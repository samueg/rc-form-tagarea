/*
---

name: Core

description: The heart of MooTools.

license: MIT-style license.

copyright: Copyright (c) 2006-2014 [Valerio Proietti](http://mad4milk.net/).

authors: The MooTools production team (http://mootools.net/developers/)

inspiration:
  - Class implementation inspired by [Base.js](http://dean.edwards.name/weblog/2006/03/base/) Copyright (c) 2006 Dean Edwards, [GNU Lesser General Public License](http://opensource.org/licenses/lgpl-license.php)
  - Some functionality inspired by [Prototype.js](http://prototypejs.org) Copyright (c) 2005-2007 Sam Stephenson, [MIT License](http://opensource.org/licenses/mit-license.php)

provides: [Core, MooTools, Type, typeOf, instanceOf, Native]

...
*/
/*! MooTools: the javascript framework. license: MIT-style license. copyright: Copyright (c) 2006-2014 [Valerio Proietti](http://mad4milk.net/).*/
(function(){

this.MooTools = {
	version: '1.5.1',
	build: '0542c135fdeb7feed7d9917e01447a408f22c876'
};

// typeOf, instanceOf

var typeOf = this.typeOf = function(item){
	if (item == null) return 'null';
	if (item.$family != null) return item.$family();

	if (item.nodeName){
		if (item.nodeType == 1) return 'element';
		if (item.nodeType == 3) return (/\S/).test(item.nodeValue) ? 'textnode' : 'whitespace';
	} else if (typeof item.length == 'number'){
		if ('callee' in item) return 'arguments';
		if ('item' in item) return 'collection';
	}

	return typeof item;
};

var instanceOf = this.instanceOf = function(item, object){
	if (item == null) return false;
	var constructor = item.$constructor || item.constructor;
	while (constructor){
		if (constructor === object) return true;
		constructor = constructor.parent;
	}
	/*<ltIE8>*/
	if (!item.hasOwnProperty) return false;
	/*</ltIE8>*/
	return item instanceof object;
};

// Function overloading

var Function = this.Function;

var enumerables = true;
for (var i in {toString: 1}) enumerables = null;
if (enumerables) enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];

Function.prototype.overloadSetter = function(usePlural){
	var self = this;
	return function(a, b){
		if (a == null) return this;
		if (usePlural || typeof a != 'string'){
			for (var k in a) self.call(this, k, a[k]);
			if (enumerables) for (var i = enumerables.length; i--;){
				k = enumerables[i];
				if (a.hasOwnProperty(k)) self.call(this, k, a[k]);
			}
		} else {
			self.call(this, a, b);
		}
		return this;
	};
};

Function.prototype.overloadGetter = function(usePlural){
	var self = this;
	return function(a){
		var args, result;
		if (typeof a != 'string') args = a;
		else if (arguments.length > 1) args = arguments;
		else if (usePlural) args = [a];
		if (args){
			result = {};
			for (var i = 0; i < args.length; i++) result[args[i]] = self.call(this, args[i]);
		} else {
			result = self.call(this, a);
		}
		return result;
	};
};

Function.prototype.extend = function(key, value){
	this[key] = value;
}.overloadSetter();

Function.prototype.implement = function(key, value){
	this.prototype[key] = value;
}.overloadSetter();

// From

var slice = Array.prototype.slice;

Function.from = function(item){
	return (typeOf(item) == 'function') ? item : function(){
		return item;
	};
};

Array.from = function(item){
	if (item == null) return [];
	return (Type.isEnumerable(item) && typeof item != 'string') ? (typeOf(item) == 'array') ? item : slice.call(item) : [item];
};

Number.from = function(item){
	var number = parseFloat(item);
	return isFinite(number) ? number : null;
};

String.from = function(item){
	return item + '';
};

// hide, protect

Function.implement({

	hide: function(){
		this.$hidden = true;
		return this;
	},

	protect: function(){
		this.$protected = true;
		return this;
	}

});

// Type

var Type = this.Type = function(name, object){
	if (name){
		var lower = name.toLowerCase();
		var typeCheck = function(item){
			return (typeOf(item) == lower);
		};

		Type['is' + name] = typeCheck;
		if (object != null){
			object.prototype.$family = (function(){
				return lower;
			}).hide();
			//<1.2compat>
			object.type = typeCheck;
			//</1.2compat>
		}
	}

	if (object == null) return null;

	object.extend(this);
	object.$constructor = Type;
	object.prototype.$constructor = object;

	return object;
};

var toString = Object.prototype.toString;

Type.isEnumerable = function(item){
	return (item != null && typeof item.length == 'number' && toString.call(item) != '[object Function]' );
};

var hooks = {};

var hooksOf = function(object){
	var type = typeOf(object.prototype);
	return hooks[type] || (hooks[type] = []);
};

var implement = function(name, method){
	if (method && method.$hidden) return;

	var hooks = hooksOf(this);

	for (var i = 0; i < hooks.length; i++){
		var hook = hooks[i];
		if (typeOf(hook) == 'type') implement.call(hook, name, method);
		else hook.call(this, name, method);
	}

	var previous = this.prototype[name];
	if (previous == null || !previous.$protected) this.prototype[name] = method;

	if (this[name] == null && typeOf(method) == 'function') extend.call(this, name, function(item){
		return method.apply(item, slice.call(arguments, 1));
	});
};

var extend = function(name, method){
	if (method && method.$hidden) return;
	var previous = this[name];
	if (previous == null || !previous.$protected) this[name] = method;
};

Type.implement({

	implement: implement.overloadSetter(),

	extend: extend.overloadSetter(),

	alias: function(name, existing){
		implement.call(this, name, this.prototype[existing]);
	}.overloadSetter(),

	mirror: function(hook){
		hooksOf(this).push(hook);
		return this;
	}

});

new Type('Type', Type);

// Default Types

var force = function(name, object, methods){
	var isType = (object != Object),
		prototype = object.prototype;

	if (isType) object = new Type(name, object);

	for (var i = 0, l = methods.length; i < l; i++){
		var key = methods[i],
			generic = object[key],
			proto = prototype[key];

		if (generic) generic.protect();
		if (isType && proto) object.implement(key, proto.protect());
	}

	if (isType){
		var methodsEnumerable = prototype.propertyIsEnumerable(methods[0]);
		object.forEachMethod = function(fn){
			if (!methodsEnumerable) for (var i = 0, l = methods.length; i < l; i++){
				fn.call(prototype, prototype[methods[i]], methods[i]);
			}
			for (var key in prototype) fn.call(prototype, prototype[key], key);
		};
	}

	return force;
};

force('String', String, [
	'charAt', 'charCodeAt', 'concat', 'contains', 'indexOf', 'lastIndexOf', 'match', 'quote', 'replace', 'search',
	'slice', 'split', 'substr', 'substring', 'trim', 'toLowerCase', 'toUpperCase'
])('Array', Array, [
	'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift', 'concat', 'join', 'slice',
	'indexOf', 'lastIndexOf', 'filter', 'forEach', 'every', 'map', 'some', 'reduce', 'reduceRight'
])('Number', Number, [
	'toExponential', 'toFixed', 'toLocaleString', 'toPrecision'
])('Function', Function, [
	'apply', 'call', 'bind'
])('RegExp', RegExp, [
	'exec', 'test'
])('Object', Object, [
	'create', 'defineProperty', 'defineProperties', 'keys',
	'getPrototypeOf', 'getOwnPropertyDescriptor', 'getOwnPropertyNames',
	'preventExtensions', 'isExtensible', 'seal', 'isSealed', 'freeze', 'isFrozen'
])('Date', Date, ['now']);

Object.extend = extend.overloadSetter();

Date.extend('now', function(){
	return +(new Date);
});

new Type('Boolean', Boolean);

// fixes NaN returning as Number

Number.prototype.$family = function(){
	return isFinite(this) ? 'number' : 'null';
}.hide();

// Number.random

Number.extend('random', function(min, max){
	return Math.floor(Math.random() * (max - min + 1) + min);
});

// forEach, each

var hasOwnProperty = Object.prototype.hasOwnProperty;
Object.extend('forEach', function(object, fn, bind){
	for (var key in object){
		if (hasOwnProperty.call(object, key)) fn.call(bind, object[key], key, object);
	}
});

Object.each = Object.forEach;

Array.implement({

	/*<!ES5>*/
	forEach: function(fn, bind){
		for (var i = 0, l = this.length; i < l; i++){
			if (i in this) fn.call(bind, this[i], i, this);
		}
	},
	/*</!ES5>*/

	each: function(fn, bind){
		Array.forEach(this, fn, bind);
		return this;
	}

});

// Array & Object cloning, Object merging and appending

var cloneOf = function(item){
	switch (typeOf(item)){
		case 'array': return item.clone();
		case 'object': return Object.clone(item);
		default: return item;
	}
};

Array.implement('clone', function(){
	var i = this.length, clone = new Array(i);
	while (i--) clone[i] = cloneOf(this[i]);
	return clone;
});

var mergeOne = function(source, key, current){
	switch (typeOf(current)){
		case 'object':
			if (typeOf(source[key]) == 'object') Object.merge(source[key], current);
			else source[key] = Object.clone(current);
		break;
		case 'array': source[key] = current.clone(); break;
		default: source[key] = current;
	}
	return source;
};

Object.extend({

	merge: function(source, k, v){
		if (typeOf(k) == 'string') return mergeOne(source, k, v);
		for (var i = 1, l = arguments.length; i < l; i++){
			var object = arguments[i];
			for (var key in object) mergeOne(source, key, object[key]);
		}
		return source;
	},

	clone: function(object){
		var clone = {};
		for (var key in object) clone[key] = cloneOf(object[key]);
		return clone;
	},

	append: function(original){
		for (var i = 1, l = arguments.length; i < l; i++){
			var extended = arguments[i] || {};
			for (var key in extended) original[key] = extended[key];
		}
		return original;
	}

});

// Object-less types

['Object', 'WhiteSpace', 'TextNode', 'Collection', 'Arguments'].each(function(name){
	new Type(name);
});

// Unique ID

var UID = Date.now();

String.extend('uniqueID', function(){
	return (UID++).toString(36);
});

//<1.2compat>

var Hash = this.Hash = new Type('Hash', function(object){
	if (typeOf(object) == 'hash') object = Object.clone(object.getClean());
	for (var key in object) this[key] = object[key];
	return this;
});

Hash.implement({

	forEach: function(fn, bind){
		Object.forEach(this, fn, bind);
	},

	getClean: function(){
		var clean = {};
		for (var key in this){
			if (this.hasOwnProperty(key)) clean[key] = this[key];
		}
		return clean;
	},

	getLength: function(){
		var length = 0;
		for (var key in this){
			if (this.hasOwnProperty(key)) length++;
		}
		return length;
	}

});

Hash.alias('each', 'forEach');

Object.type = Type.isObject;

var Native = this.Native = function(properties){
	return new Type(properties.name, properties.initialize);
};

Native.type = Type.type;

Native.implement = function(objects, methods){
	for (var i = 0; i < objects.length; i++) objects[i].implement(methods);
	return Native;
};

var arrayType = Array.type;
Array.type = function(item){
	return instanceOf(item, Array) || arrayType(item);
};

this.$A = function(item){
	return Array.from(item).slice();
};

this.$arguments = function(i){
	return function(){
		return arguments[i];
	};
};

this.$chk = function(obj){
	return !!(obj || obj === 0);
};

this.$clear = function(timer){
	clearTimeout(timer);
	clearInterval(timer);
	return null;
};

this.$defined = function(obj){
	return (obj != null);
};

this.$each = function(iterable, fn, bind){
	var type = typeOf(iterable);
	((type == 'arguments' || type == 'collection' || type == 'array' || type == 'elements') ? Array : Object).each(iterable, fn, bind);
};

this.$empty = function(){};

this.$extend = function(original, extended){
	return Object.append(original, extended);
};

this.$H = function(object){
	return new Hash(object);
};

this.$merge = function(){
	var args = Array.slice(arguments);
	args.unshift({});
	return Object.merge.apply(null, args);
};

this.$lambda = Function.from;
this.$mixin = Object.merge;
this.$random = Number.random;
this.$splat = Array.from;
this.$time = Date.now;

this.$type = function(object){
	var type = typeOf(object);
	if (type == 'elements') return 'array';
	return (type == 'null') ? false : type;
};

this.$unlink = function(object){
	switch (typeOf(object)){
		case 'object': return Object.clone(object);
		case 'array': return Array.clone(object);
		case 'hash': return new Hash(object);
		default: return object;
	}
};

//</1.2compat>

})();

/*
---

name: Array

description: Contains Array Prototypes like each, contains, and erase.

license: MIT-style license.

requires: [Type]

provides: Array

...
*/

Array.implement({

	/*<!ES5>*/
	every: function(fn, bind){
		for (var i = 0, l = this.length >>> 0; i < l; i++){
			if ((i in this) && !fn.call(bind, this[i], i, this)) return false;
		}
		return true;
	},

	filter: function(fn, bind){
		var results = [];
		for (var value, i = 0, l = this.length >>> 0; i < l; i++) if (i in this){
			value = this[i];
			if (fn.call(bind, value, i, this)) results.push(value);
		}
		return results;
	},

	indexOf: function(item, from){
		var length = this.length >>> 0;
		for (var i = (from < 0) ? Math.max(0, length + from) : from || 0; i < length; i++){
			if (this[i] === item) return i;
		}
		return -1;
	},

	map: function(fn, bind){
		var length = this.length >>> 0, results = Array(length);
		for (var i = 0; i < length; i++){
			if (i in this) results[i] = fn.call(bind, this[i], i, this);
		}
		return results;
	},

	some: function(fn, bind){
		for (var i = 0, l = this.length >>> 0; i < l; i++){
			if ((i in this) && fn.call(bind, this[i], i, this)) return true;
		}
		return false;
	},
	/*</!ES5>*/

	clean: function(){
		return this.filter(function(item){
			return item != null;
		});
	},

	invoke: function(methodName){
		var args = Array.slice(arguments, 1);
		return this.map(function(item){
			return item[methodName].apply(item, args);
		});
	},

	associate: function(keys){
		var obj = {}, length = Math.min(this.length, keys.length);
		for (var i = 0; i < length; i++) obj[keys[i]] = this[i];
		return obj;
	},

	link: function(object){
		var result = {};
		for (var i = 0, l = this.length; i < l; i++){
			for (var key in object){
				if (object[key](this[i])){
					result[key] = this[i];
					delete object[key];
					break;
				}
			}
		}
		return result;
	},

	contains: function(item, from){
		return this.indexOf(item, from) != -1;
	},

	append: function(array){
		this.push.apply(this, array);
		return this;
	},

	getLast: function(){
		return (this.length) ? this[this.length - 1] : null;
	},

	getRandom: function(){
		return (this.length) ? this[Number.random(0, this.length - 1)] : null;
	},

	include: function(item){
		if (!this.contains(item)) this.push(item);
		return this;
	},

	combine: function(array){
		for (var i = 0, l = array.length; i < l; i++) this.include(array[i]);
		return this;
	},

	erase: function(item){
		for (var i = this.length; i--;){
			if (this[i] === item) this.splice(i, 1);
		}
		return this;
	},

	empty: function(){
		this.length = 0;
		return this;
	},

	flatten: function(){
		var array = [];
		for (var i = 0, l = this.length; i < l; i++){
			var type = typeOf(this[i]);
			if (type == 'null') continue;
			array = array.concat((type == 'array' || type == 'collection' || type == 'arguments' || instanceOf(this[i], Array)) ? Array.flatten(this[i]) : this[i]);
		}
		return array;
	},

	pick: function(){
		for (var i = 0, l = this.length; i < l; i++){
			if (this[i] != null) return this[i];
		}
		return null;
	},

	hexToRgb: function(array){
		if (this.length != 3) return null;
		var rgb = this.map(function(value){
			if (value.length == 1) value += value;
			return parseInt(value, 16);
		});
		return (array) ? rgb : 'rgb(' + rgb + ')';
	},

	rgbToHex: function(array){
		if (this.length < 3) return null;
		if (this.length == 4 && this[3] == 0 && !array) return 'transparent';
		var hex = [];
		for (var i = 0; i < 3; i++){
			var bit = (this[i] - 0).toString(16);
			hex.push((bit.length == 1) ? '0' + bit : bit);
		}
		return (array) ? hex : '#' + hex.join('');
	}

});

//<1.2compat>

Array.alias('extend', 'append');

var $pick = function(){
	return Array.from(arguments).pick();
};

//</1.2compat>

/*
---

name: Function

description: Contains Function Prototypes like create, bind, pass, and delay.

license: MIT-style license.

requires: Type

provides: Function

...
*/

Function.extend({

	attempt: function(){
		for (var i = 0, l = arguments.length; i < l; i++){
			try {
				return arguments[i]();
			} catch (e){}
		}
		return null;
	}

});

Function.implement({

	attempt: function(args, bind){
		try {
			return this.apply(bind, Array.from(args));
		} catch (e){}

		return null;
	},

	/*<!ES5-bind>*/
	bind: function(that){
		var self = this,
			args = arguments.length > 1 ? Array.slice(arguments, 1) : null,
			F = function(){};

		var bound = function(){
			var context = that, length = arguments.length;
			if (this instanceof bound){
				F.prototype = self.prototype;
				context = new F;
			}
			var result = (!args && !length)
				? self.call(context)
				: self.apply(context, args && length ? args.concat(Array.slice(arguments)) : args || arguments);
			return context == that ? result : context;
		};
		return bound;
	},
	/*</!ES5-bind>*/

	pass: function(args, bind){
		var self = this;
		if (args != null) args = Array.from(args);
		return function(){
			return self.apply(bind, args || arguments);
		};
	},

	delay: function(delay, bind, args){
		return setTimeout(this.pass((args == null ? [] : args), bind), delay);
	},

	periodical: function(periodical, bind, args){
		return setInterval(this.pass((args == null ? [] : args), bind), periodical);
	}

});

//<1.2compat>

delete Function.prototype.bind;

Function.implement({

	create: function(options){
		var self = this;
		options = options || {};
		return function(event){
			var args = options.arguments;
			args = (args != null) ? Array.from(args) : Array.slice(arguments, (options.event) ? 1 : 0);
			if (options.event) args = [event || window.event].extend(args);
			var returns = function(){
				return self.apply(options.bind || null, args);
			};
			if (options.delay) return setTimeout(returns, options.delay);
			if (options.periodical) return setInterval(returns, options.periodical);
			if (options.attempt) return Function.attempt(returns);
			return returns();
		};
	},

	bind: function(bind, args){
		var self = this;
		if (args != null) args = Array.from(args);
		return function(){
			return self.apply(bind, args || arguments);
		};
	},

	bindWithEvent: function(bind, args){
		var self = this;
		if (args != null) args = Array.from(args);
		return function(event){
			return self.apply(bind, (args == null) ? arguments : [event].concat(args));
		};
	},

	run: function(args, bind){
		return this.apply(bind, Array.from(args));
	}

});

if (Object.create == Function.prototype.create) Object.create = null;

var $try = Function.attempt;

//</1.2compat>

/*
---

name: Number

description: Contains Number Prototypes like limit, round, times, and ceil.

license: MIT-style license.

requires: Type

provides: Number

...
*/

Number.implement({

	limit: function(min, max){
		return Math.min(max, Math.max(min, this));
	},

	round: function(precision){
		precision = Math.pow(10, precision || 0).toFixed(precision < 0 ? -precision : 0);
		return Math.round(this * precision) / precision;
	},

	times: function(fn, bind){
		for (var i = 0; i < this; i++) fn.call(bind, i, this);
	},

	toFloat: function(){
		return parseFloat(this);
	},

	toInt: function(base){
		return parseInt(this, base || 10);
	}

});

Number.alias('each', 'times');

(function(math){
	var methods = {};
	math.each(function(name){
		if (!Number[name]) methods[name] = function(){
			return Math[name].apply(null, [this].concat(Array.from(arguments)));
		};
	});
	Number.implement(methods);
})(['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'max', 'min', 'pow', 'sin', 'sqrt', 'tan']);

/*
---

name: String

description: Contains String Prototypes like camelCase, capitalize, test, and toInt.

license: MIT-style license.

requires: [Type, Array]

provides: String

...
*/

String.implement({

	//<!ES6>
	contains: function(string, index){
		return (index ? String(this).slice(index) : String(this)).indexOf(string) > -1;
	},
	//</!ES6>

	test: function(regex, params){
		return ((typeOf(regex) == 'regexp') ? regex : new RegExp('' + regex, params)).test(this);
	},

	trim: function(){
		return String(this).replace(/^\s+|\s+$/g, '');
	},

	clean: function(){
		return String(this).replace(/\s+/g, ' ').trim();
	},

	camelCase: function(){
		return String(this).replace(/-\D/g, function(match){
			return match.charAt(1).toUpperCase();
		});
	},

	hyphenate: function(){
		return String(this).replace(/[A-Z]/g, function(match){
			return ('-' + match.charAt(0).toLowerCase());
		});
	},

	capitalize: function(){
		return String(this).replace(/\b[a-z]/g, function(match){
			return match.toUpperCase();
		});
	},

	escapeRegExp: function(){
		return String(this).replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');
	},

	toInt: function(base){
		return parseInt(this, base || 10);
	},

	toFloat: function(){
		return parseFloat(this);
	},

	hexToRgb: function(array){
		var hex = String(this).match(/^#?(\w{1,2})(\w{1,2})(\w{1,2})$/);
		return (hex) ? hex.slice(1).hexToRgb(array) : null;
	},

	rgbToHex: function(array){
		var rgb = String(this).match(/\d{1,3}/g);
		return (rgb) ? rgb.rgbToHex(array) : null;
	},

	substitute: function(object, regexp){
		return String(this).replace(regexp || (/\\?\{([^{}]+)\}/g), function(match, name){
			if (match.charAt(0) == '\\') return match.slice(1);
			return (object[name] != null) ? object[name] : '';
		});
	}

});

//<1.4compat>
String.prototype.contains = function(string, separator){
	return (separator) ? (separator + this + separator).indexOf(separator + string + separator) > -1 : String(this).indexOf(string) > -1;
};
//</1.4compat>

/*
---

name: Browser

description: The Browser Object. Contains Browser initialization, Window and Document, and the Browser Hash.

license: MIT-style license.

requires: [Array, Function, Number, String]

provides: [Browser, Window, Document]

...
*/

(function(){

var document = this.document;
var window = document.window = this;

var parse = function(ua, platform){
	ua = ua.toLowerCase();
	platform = (platform ? platform.toLowerCase() : '');

	var UA = ua.match(/(opera|ie|firefox|chrome|trident|crios|version)[\s\/:]([\w\d\.]+)?.*?(safari|(?:rv[\s\/:]|version[\s\/:])([\w\d\.]+)|$)/) || [null, 'unknown', 0];

	if (UA[1] == 'trident'){
		UA[1] = 'ie';
		if (UA[4]) UA[2] = UA[4];
	} else if (UA[1] == 'crios'){
		UA[1] = 'chrome';
	}

	platform = ua.match(/ip(?:ad|od|hone)/) ? 'ios' : (ua.match(/(?:webos|android)/) || platform.match(/mac|win|linux/) || ['other'])[0];
	if (platform == 'win') platform = 'windows';

	return {
		extend: Function.prototype.extend,
		name: (UA[1] == 'version') ? UA[3] : UA[1],
		version: parseFloat((UA[1] == 'opera' && UA[4]) ? UA[4] : UA[2]),
		platform: platform
	};
};

var Browser = this.Browser = parse(navigator.userAgent, navigator.platform);

if (Browser.name == 'ie'){
	Browser.version = document.documentMode;
}

Browser.extend({
	Features: {
		xpath: !!(document.evaluate),
		air: !!(window.runtime),
		query: !!(document.querySelector),
		json: !!(window.JSON)
	},
	parseUA: parse
});

//<1.4compat>
Browser[Browser.name] = true;
Browser[Browser.name + parseInt(Browser.version, 10)] = true;

if (Browser.name == 'ie' && Browser.version >= '11'){
	delete Browser.ie;
}

var platform = Browser.platform;
if (platform == 'windows'){
	platform = 'win';
}
Browser.Platform = {
	name: platform
};
Browser.Platform[platform] = true;
//</1.4compat>

// Request

Browser.Request = (function(){

	var XMLHTTP = function(){
		return new XMLHttpRequest();
	};

	var MSXML2 = function(){
		return new ActiveXObject('MSXML2.XMLHTTP');
	};

	var MSXML = function(){
		return new ActiveXObject('Microsoft.XMLHTTP');
	};

	return Function.attempt(function(){
		XMLHTTP();
		return XMLHTTP;
	}, function(){
		MSXML2();
		return MSXML2;
	}, function(){
		MSXML();
		return MSXML;
	});

})();

Browser.Features.xhr = !!(Browser.Request);

//<1.4compat>

// Flash detection

var version = (Function.attempt(function(){
	return navigator.plugins['Shockwave Flash'].description;
}, function(){
	return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
}) || '0 r0').match(/\d+/g);

Browser.Plugins = {
	Flash: {
		version: Number(version[0] || '0.' + version[1]) || 0,
		build: Number(version[2]) || 0
	}
};

//</1.4compat>

// String scripts

Browser.exec = function(text){
	if (!text) return text;
	if (window.execScript){
		window.execScript(text);
	} else {
		var script = document.createElement('script');
		script.setAttribute('type', 'text/javascript');
		script.text = text;
		document.head.appendChild(script);
		document.head.removeChild(script);
	}
	return text;
};

String.implement('stripScripts', function(exec){
	var scripts = '';
	var text = this.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function(all, code){
		scripts += code + '\n';
		return '';
	});
	if (exec === true) Browser.exec(scripts);
	else if (typeOf(exec) == 'function') exec(scripts, text);
	return text;
});

// Window, Document

Browser.extend({
	Document: this.Document,
	Window: this.Window,
	Element: this.Element,
	Event: this.Event
});

this.Window = this.$constructor = new Type('Window', function(){});

this.$family = Function.from('window').hide();

Window.mirror(function(name, method){
	window[name] = method;
});

this.Document = document.$constructor = new Type('Document', function(){});

document.$family = Function.from('document').hide();

Document.mirror(function(name, method){
	document[name] = method;
});

document.html = document.documentElement;
if (!document.head) document.head = document.getElementsByTagName('head')[0];

if (document.execCommand) try {
	document.execCommand("BackgroundImageCache", false, true);
} catch (e){}

/*<ltIE9>*/
if (this.attachEvent && !this.addEventListener){
	var unloadEvent = function(){
		this.detachEvent('onunload', unloadEvent);
		document.head = document.html = document.window = null;
		window = this.Window = document = null;
	};
	this.attachEvent('onunload', unloadEvent);
}

// IE fails on collections and <select>.options (refers to <select>)
var arrayFrom = Array.from;
try {
	arrayFrom(document.html.childNodes);
} catch(e){
	Array.from = function(item){
		if (typeof item != 'string' && Type.isEnumerable(item) && typeOf(item) != 'array'){
			var i = item.length, array = new Array(i);
			while (i--) array[i] = item[i];
			return array;
		}
		return arrayFrom(item);
	};

	var prototype = Array.prototype,
		slice = prototype.slice;
	['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift', 'concat', 'join', 'slice'].each(function(name){
		var method = prototype[name];
		Array[name] = function(item){
			return method.apply(Array.from(item), slice.call(arguments, 1));
		};
	});
}
/*</ltIE9>*/

//<1.2compat>

if (Browser.Platform.ios) Browser.Platform.ipod = true;

Browser.Engine = {};

var setEngine = function(name, version){
	Browser.Engine.name = name;
	Browser.Engine[name + version] = true;
	Browser.Engine.version = version;
};

if (Browser.ie){
	Browser.Engine.trident = true;

	switch (Browser.version){
		case 6: setEngine('trident', 4); break;
		case 7: setEngine('trident', 5); break;
		case 8: setEngine('trident', 6);
	}
}

if (Browser.firefox){
	Browser.Engine.gecko = true;

	if (Browser.version >= 3) setEngine('gecko', 19);
	else setEngine('gecko', 18);
}

if (Browser.safari || Browser.chrome){
	Browser.Engine.webkit = true;

	switch (Browser.version){
		case 2: setEngine('webkit', 419); break;
		case 3: setEngine('webkit', 420); break;
		case 4: setEngine('webkit', 525);
	}
}

if (Browser.opera){
	Browser.Engine.presto = true;

	if (Browser.version >= 9.6) setEngine('presto', 960);
	else if (Browser.version >= 9.5) setEngine('presto', 950);
	else setEngine('presto', 925);
}

if (Browser.name == 'unknown'){
	switch ((navigator.userAgent.toLowerCase().match(/(?:webkit|khtml|gecko)/) || [])[0]){
		case 'webkit':
		case 'khtml':
			Browser.Engine.webkit = true;
		break;
		case 'gecko':
			Browser.Engine.gecko = true;
	}
}

this.$exec = Browser.exec;

//</1.2compat>

})();

/*
---

name: Class

description: Contains the Class Function for easily creating, extending, and implementing reusable Classes.

license: MIT-style license.

requires: [Array, String, Function, Number]

provides: Class

...
*/

(function(){

var Class = this.Class = new Type('Class', function(params){
	if (instanceOf(params, Function)) params = {initialize: params};

	var newClass = function(){
		reset(this);
		if (newClass.$prototyping) return this;
		this.$caller = null;
		var value = (this.initialize) ? this.initialize.apply(this, arguments) : this;
		this.$caller = this.caller = null;
		return value;
	}.extend(this).implement(params);

	newClass.$constructor = Class;
	newClass.prototype.$constructor = newClass;
	newClass.prototype.parent = parent;

	return newClass;
});

var parent = function(){
	if (!this.$caller) throw new Error('The method "parent" cannot be called.');
	var name = this.$caller.$name,
		parent = this.$caller.$owner.parent,
		previous = (parent) ? parent.prototype[name] : null;
	if (!previous) throw new Error('The method "' + name + '" has no parent.');
	return previous.apply(this, arguments);
};

var reset = function(object){
	for (var key in object){
		var value = object[key];
		switch (typeOf(value)){
			case 'object':
				var F = function(){};
				F.prototype = value;
				object[key] = reset(new F);
			break;
			case 'array': object[key] = value.clone(); break;
		}
	}
	return object;
};

var wrap = function(self, key, method){
	if (method.$origin) method = method.$origin;
	var wrapper = function(){
		if (method.$protected && this.$caller == null) throw new Error('The method "' + key + '" cannot be called.');
		var caller = this.caller, current = this.$caller;
		this.caller = current; this.$caller = wrapper;
		var result = method.apply(this, arguments);
		this.$caller = current; this.caller = caller;
		return result;
	}.extend({$owner: self, $origin: method, $name: key});
	return wrapper;
};

var implement = function(key, value, retain){
	if (Class.Mutators.hasOwnProperty(key)){
		value = Class.Mutators[key].call(this, value);
		if (value == null) return this;
	}

	if (typeOf(value) == 'function'){
		if (value.$hidden) return this;
		this.prototype[key] = (retain) ? value : wrap(this, key, value);
	} else {
		Object.merge(this.prototype, key, value);
	}

	return this;
};

var getInstance = function(klass){
	klass.$prototyping = true;
	var proto = new klass;
	delete klass.$prototyping;
	return proto;
};

Class.implement('implement', implement.overloadSetter());

Class.Mutators = {

	Extends: function(parent){
		this.parent = parent;
		this.prototype = getInstance(parent);
	},

	Implements: function(items){
		Array.from(items).each(function(item){
			var instance = new item;
			for (var key in instance) implement.call(this, key, instance[key], true);
		}, this);
	}
};

})();

/*
---

name: Class.Extras

description: Contains Utility Classes that can be implemented into your own Classes to ease the execution of many common tasks.

license: MIT-style license.

requires: Class

provides: [Class.Extras, Chain, Events, Options]

...
*/

(function(){

this.Chain = new Class({

	$chain: [],

	chain: function(){
		this.$chain.append(Array.flatten(arguments));
		return this;
	},

	callChain: function(){
		return (this.$chain.length) ? this.$chain.shift().apply(this, arguments) : false;
	},

	clearChain: function(){
		this.$chain.empty();
		return this;
	}

});

var removeOn = function(string){
	return string.replace(/^on([A-Z])/, function(full, first){
		return first.toLowerCase();
	});
};

this.Events = new Class({

	$events: {},

	addEvent: function(type, fn, internal){
		type = removeOn(type);

		/*<1.2compat>*/
		if (fn == $empty) return this;
		/*</1.2compat>*/

		this.$events[type] = (this.$events[type] || []).include(fn);
		if (internal) fn.internal = true;
		return this;
	},

	addEvents: function(events){
		for (var type in events) this.addEvent(type, events[type]);
		return this;
	},

	fireEvent: function(type, args, delay){
		type = removeOn(type);
		var events = this.$events[type];
		if (!events) return this;
		args = Array.from(args);
		events.each(function(fn){
			if (delay) fn.delay(delay, this, args);
			else fn.apply(this, args);
		}, this);
		return this;
	},

	removeEvent: function(type, fn){
		type = removeOn(type);
		var events = this.$events[type];
		if (events && !fn.internal){
			var index = events.indexOf(fn);
			if (index != -1) delete events[index];
		}
		return this;
	},

	removeEvents: function(events){
		var type;
		if (typeOf(events) == 'object'){
			for (type in events) this.removeEvent(type, events[type]);
			return this;
		}
		if (events) events = removeOn(events);
		for (type in this.$events){
			if (events && events != type) continue;
			var fns = this.$events[type];
			for (var i = fns.length; i--;) if (i in fns){
				this.removeEvent(type, fns[i]);
			}
		}
		return this;
	}

});

this.Options = new Class({

	setOptions: function(){
		var options = this.options = Object.merge.apply(null, [{}, this.options].append(arguments));
		if (this.addEvent) for (var option in options){
			if (typeOf(options[option]) != 'function' || !(/^on[A-Z]/).test(option)) continue;
			this.addEvent(option, options[option]);
			delete options[option];
		}
		return this;
	}

});

})();

/*
---

name: Object

description: Object generic methods

license: MIT-style license.

requires: Type

provides: [Object, Hash]

...
*/

(function(){

var hasOwnProperty = Object.prototype.hasOwnProperty;

Object.extend({

	subset: function(object, keys){
		var results = {};
		for (var i = 0, l = keys.length; i < l; i++){
			var k = keys[i];
			if (k in object) results[k] = object[k];
		}
		return results;
	},

	map: function(object, fn, bind){
		var results = {};
		for (var key in object){
			if (hasOwnProperty.call(object, key)) results[key] = fn.call(bind, object[key], key, object);
		}
		return results;
	},

	filter: function(object, fn, bind){
		var results = {};
		for (var key in object){
			var value = object[key];
			if (hasOwnProperty.call(object, key) && fn.call(bind, value, key, object)) results[key] = value;
		}
		return results;
	},

	every: function(object, fn, bind){
		for (var key in object){
			if (hasOwnProperty.call(object, key) && !fn.call(bind, object[key], key)) return false;
		}
		return true;
	},

	some: function(object, fn, bind){
		for (var key in object){
			if (hasOwnProperty.call(object, key) && fn.call(bind, object[key], key)) return true;
		}
		return false;
	},

	keys: function(object){
		var keys = [];
		for (var key in object){
			if (hasOwnProperty.call(object, key)) keys.push(key);
		}
		return keys;
	},

	values: function(object){
		var values = [];
		for (var key in object){
			if (hasOwnProperty.call(object, key)) values.push(object[key]);
		}
		return values;
	},

	getLength: function(object){
		return Object.keys(object).length;
	},

	keyOf: function(object, value){
		for (var key in object){
			if (hasOwnProperty.call(object, key) && object[key] === value) return key;
		}
		return null;
	},

	contains: function(object, value){
		return Object.keyOf(object, value) != null;
	},

	toQueryString: function(object, base){
		var queryString = [];

		Object.each(object, function(value, key){
			if (base) key = base + '[' + key + ']';
			var result;
			switch (typeOf(value)){
				case 'object': result = Object.toQueryString(value, key); break;
				case 'array':
					var qs = {};
					value.each(function(val, i){
						qs[i] = val;
					});
					result = Object.toQueryString(qs, key);
				break;
				default: result = key + '=' + encodeURIComponent(value);
			}
			if (value != null) queryString.push(result);
		});

		return queryString.join('&');
	}

});

})();

//<1.2compat>

Hash.implement({

	has: Object.prototype.hasOwnProperty,

	keyOf: function(value){
		return Object.keyOf(this, value);
	},

	hasValue: function(value){
		return Object.contains(this, value);
	},

	extend: function(properties){
		Hash.each(properties || {}, function(value, key){
			Hash.set(this, key, value);
		}, this);
		return this;
	},

	combine: function(properties){
		Hash.each(properties || {}, function(value, key){
			Hash.include(this, key, value);
		}, this);
		return this;
	},

	erase: function(key){
		if (this.hasOwnProperty(key)) delete this[key];
		return this;
	},

	get: function(key){
		return (this.hasOwnProperty(key)) ? this[key] : null;
	},

	set: function(key, value){
		if (!this[key] || this.hasOwnProperty(key)) this[key] = value;
		return this;
	},

	empty: function(){
		Hash.each(this, function(value, key){
			delete this[key];
		}, this);
		return this;
	},

	include: function(key, value){
		if (this[key] == null) this[key] = value;
		return this;
	},

	map: function(fn, bind){
		return new Hash(Object.map(this, fn, bind));
	},

	filter: function(fn, bind){
		return new Hash(Object.filter(this, fn, bind));
	},

	every: function(fn, bind){
		return Object.every(this, fn, bind);
	},

	some: function(fn, bind){
		return Object.some(this, fn, bind);
	},

	getKeys: function(){
		return Object.keys(this);
	},

	getValues: function(){
		return Object.values(this);
	},

	toQueryString: function(base){
		return Object.toQueryString(this, base);
	}

});

Hash.extend = Object.append;

Hash.alias({indexOf: 'keyOf', contains: 'hasValue'});

//</1.2compat>

/*
---
name: Slick.Parser
description: Standalone CSS3 Selector parser
provides: Slick.Parser
...
*/

;(function(){

var parsed,
	separatorIndex,
	combinatorIndex,
	reversed,
	cache = {},
	reverseCache = {},
	reUnescape = /\\/g;

var parse = function(expression, isReversed){
	if (expression == null) return null;
	if (expression.Slick === true) return expression;
	expression = ('' + expression).replace(/^\s+|\s+$/g, '');
	reversed = !!isReversed;
	var currentCache = (reversed) ? reverseCache : cache;
	if (currentCache[expression]) return currentCache[expression];
	parsed = {
		Slick: true,
		expressions: [],
		raw: expression,
		reverse: function(){
			return parse(this.raw, true);
		}
	};
	separatorIndex = -1;
	while (expression != (expression = expression.replace(regexp, parser)));
	parsed.length = parsed.expressions.length;
	return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;
};

var reverseCombinator = function(combinator){
	if (combinator === '!') return ' ';
	else if (combinator === ' ') return '!';
	else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
	else return '!' + combinator;
};

var reverse = function(expression){
	var expressions = expression.expressions;
	for (var i = 0; i < expressions.length; i++){
		var exp = expressions[i];
		var last = {parts: [], tag: '*', combinator: reverseCombinator(exp[0].combinator)};

		for (var j = 0; j < exp.length; j++){
			var cexp = exp[j];
			if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
			cexp.combinator = cexp.reverseCombinator;
			delete cexp.reverseCombinator;
		}

		exp.reverse().push(last);
	}
	return expression;
};

var escapeRegExp = function(string){// Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
	return string.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, function(match){
		return '\\' + match;
	});
};

var regexp = new RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
	"(?x)^(?:\
	  \\s* ( , ) \\s*               # Separator          \n\
	| \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
	|      ( \\s+ )                 # CombinatorChildren \n\
	|      ( <unicode>+ | \\* )     # Tag                \n\
	| \\#  ( <unicode>+       )     # ID                 \n\
	| \\.  ( <unicode>+       )     # ClassName          \n\
	|                               # Attribute          \n\
	\\[  \
		\\s* (<unicode1>+)  (?:  \
			\\s* ([*^$!~|]?=)  (?:  \
				\\s* (?:\
					([\"']?)(.*?)\\9 \
				)\
			)  \
		)?  \\s*  \
	\\](?!\\]) \n\
	|   :+ ( <unicode>+ )(?:\
	\\( (?:\
		(?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
	) \\)\
	)?\
	)"
*/
	"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
	.replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
	.replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
	.replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
);

function parser(
	rawMatch,

	separator,
	combinator,
	combinatorChildren,

	tagName,
	id,
	className,

	attributeKey,
	attributeOperator,
	attributeQuote,
	attributeValue,

	pseudoMarker,
	pseudoClass,
	pseudoQuote,
	pseudoClassQuotedValue,
	pseudoClassValue
){
	if (separator || separatorIndex === -1){
		parsed.expressions[++separatorIndex] = [];
		combinatorIndex = -1;
		if (separator) return '';
	}

	if (combinator || combinatorChildren || combinatorIndex === -1){
		combinator = combinator || ' ';
		var currentSeparator = parsed.expressions[separatorIndex];
		if (reversed && currentSeparator[combinatorIndex])
			currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
		currentSeparator[++combinatorIndex] = {combinator: combinator, tag: '*'};
	}

	var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

	if (tagName){
		currentParsed.tag = tagName.replace(reUnescape, '');

	} else if (id){
		currentParsed.id = id.replace(reUnescape, '');

	} else if (className){
		className = className.replace(reUnescape, '');

		if (!currentParsed.classList) currentParsed.classList = [];
		if (!currentParsed.classes) currentParsed.classes = [];
		currentParsed.classList.push(className);
		currentParsed.classes.push({
			value: className,
			regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
		});

	} else if (pseudoClass){
		pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
		pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;

		if (!currentParsed.pseudos) currentParsed.pseudos = [];
		currentParsed.pseudos.push({
			key: pseudoClass.replace(reUnescape, ''),
			value: pseudoClassValue,
			type: pseudoMarker.length == 1 ? 'class' : 'element'
		});

	} else if (attributeKey){
		attributeKey = attributeKey.replace(reUnescape, '');
		attributeValue = (attributeValue || '').replace(reUnescape, '');

		var test, regexp;

		switch (attributeOperator){
			case '^=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue)            ); break;
			case '$=' : regexp = new RegExp(            escapeRegExp(attributeValue) +'$'       ); break;
			case '~=' : regexp = new RegExp( '(^|\\s)'+ escapeRegExp(attributeValue) +'(\\s|$)' ); break;
			case '|=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue) +'(-|$)'   ); break;
			case  '=' : test = function(value){
				return attributeValue == value;
			}; break;
			case '*=' : test = function(value){
				return value && value.indexOf(attributeValue) > -1;
			}; break;
			case '!=' : test = function(value){
				return attributeValue != value;
			}; break;
			default   : test = function(value){
				return !!value;
			};
		}

		if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function(){
			return false;
		};

		if (!test) test = function(value){
			return value && regexp.test(value);
		};

		if (!currentParsed.attributes) currentParsed.attributes = [];
		currentParsed.attributes.push({
			key: attributeKey,
			operator: attributeOperator,
			value: attributeValue,
			test: test
		});

	}

	return '';
};

// Slick NS

var Slick = (this.Slick || {});

Slick.parse = function(expression){
	return parse(expression);
};

Slick.escapeRegExp = escapeRegExp;

if (!this.Slick) this.Slick = Slick;

}).apply(/*<CommonJS>*/(typeof exports != 'undefined') ? exports : /*</CommonJS>*/this);

/*
---
name: Slick.Finder
description: The new, superfast css selector engine.
provides: Slick.Finder
requires: Slick.Parser
...
*/

;(function(){

var local = {},
	featuresCache = {},
	toString = Object.prototype.toString;

// Feature / Bug detection

local.isNativeCode = function(fn){
	return (/\{\s*\[native code\]\s*\}/).test('' + fn);
};

local.isXML = function(document){
	return (!!document.xmlVersion) || (!!document.xml) || (toString.call(document) == '[object XMLDocument]') ||
	(document.nodeType == 9 && document.documentElement.nodeName != 'HTML');
};

local.setDocument = function(document){

	// convert elements / window arguments to document. if document cannot be extrapolated, the function returns.
	var nodeType = document.nodeType;
	if (nodeType == 9); // document
	else if (nodeType) document = document.ownerDocument; // node
	else if (document.navigator) document = document.document; // window
	else return;

	// check if it's the old document

	if (this.document === document) return;
	this.document = document;

	// check if we have done feature detection on this document before

	var root = document.documentElement,
		rootUid = this.getUIDXML(root),
		features = featuresCache[rootUid],
		feature;

	if (features){
		for (feature in features){
			this[feature] = features[feature];
		}
		return;
	}

	features = featuresCache[rootUid] = {};

	features.root = root;
	features.isXMLDocument = this.isXML(document);

	features.brokenStarGEBTN
	= features.starSelectsClosedQSA
	= features.idGetsName
	= features.brokenMixedCaseQSA
	= features.brokenGEBCN
	= features.brokenCheckedQSA
	= features.brokenEmptyAttributeQSA
	= features.isHTMLDocument
	= features.nativeMatchesSelector
	= false;

	var starSelectsClosed, starSelectsComments,
		brokenSecondClassNameGEBCN, cachedGetElementsByClassName,
		brokenFormAttributeGetter;

	var selected, id = 'slick_uniqueid';
	var testNode = document.createElement('div');

	var testRoot = document.body || document.getElementsByTagName('body')[0] || root;
	testRoot.appendChild(testNode);

	// on non-HTML documents innerHTML and getElementsById doesnt work properly
	try {
		testNode.innerHTML = '<a id="'+id+'"></a>';
		features.isHTMLDocument = !!document.getElementById(id);
	} catch(e){};

	if (features.isHTMLDocument){

		testNode.style.display = 'none';

		// IE returns comment nodes for getElementsByTagName('*') for some documents
		testNode.appendChild(document.createComment(''));
		starSelectsComments = (testNode.getElementsByTagName('*').length > 1);

		// IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
		try {
			testNode.innerHTML = 'foo</foo>';
			selected = testNode.getElementsByTagName('*');
			starSelectsClosed = (selected && !!selected.length && selected[0].nodeName.charAt(0) == '/');
		} catch(e){};

		features.brokenStarGEBTN = starSelectsComments || starSelectsClosed;

		// IE returns elements with the name instead of just id for getElementsById for some documents
		try {
			testNode.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>';
			features.idGetsName = document.getElementById(id) === testNode.firstChild;
		} catch(e){};

		if (testNode.getElementsByClassName){

			// Safari 3.2 getElementsByClassName caches results
			try {
				testNode.innerHTML = '<a class="f"></a><a class="b"></a>';
				testNode.getElementsByClassName('b').length;
				testNode.firstChild.className = 'b';
				cachedGetElementsByClassName = (testNode.getElementsByClassName('b').length != 2);
			} catch(e){};

			// Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
			try {
				testNode.innerHTML = '<a class="a"></a><a class="f b a"></a>';
				brokenSecondClassNameGEBCN = (testNode.getElementsByClassName('a').length != 2);
			} catch(e){};

			features.brokenGEBCN = cachedGetElementsByClassName || brokenSecondClassNameGEBCN;
		}

		if (testNode.querySelectorAll){
			// IE 8 returns closed nodes (EG:"</foo>") for querySelectorAll('*') for some documents
			try {
				testNode.innerHTML = 'foo</foo>';
				selected = testNode.querySelectorAll('*');
				features.starSelectsClosedQSA = (selected && !!selected.length && selected[0].nodeName.charAt(0) == '/');
			} catch(e){};

			// Safari 3.2 querySelectorAll doesnt work with mixedcase on quirksmode
			try {
				testNode.innerHTML = '<a class="MiX"></a>';
				features.brokenMixedCaseQSA = !testNode.querySelectorAll('.MiX').length;
			} catch(e){};

			// Webkit and Opera dont return selected options on querySelectorAll
			try {
				testNode.innerHTML = '<select><option selected="selected">a</option></select>';
				features.brokenCheckedQSA = (testNode.querySelectorAll(':checked').length == 0);
			} catch(e){};

			// IE returns incorrect results for attr[*^$]="" selectors on querySelectorAll
			try {
				testNode.innerHTML = '<a class=""></a>';
				features.brokenEmptyAttributeQSA = (testNode.querySelectorAll('[class*=""]').length != 0);
			} catch(e){};

		}

		// IE6-7, if a form has an input of id x, form.getAttribute(x) returns a reference to the input
		try {
			testNode.innerHTML = '<form action="s"><input id="action"/></form>';
			brokenFormAttributeGetter = (testNode.firstChild.getAttribute('action') != 's');
		} catch(e){};

		// native matchesSelector function

		features.nativeMatchesSelector = root.matches || /*root.msMatchesSelector ||*/ root.mozMatchesSelector || root.webkitMatchesSelector;
		if (features.nativeMatchesSelector) try {
			// if matchesSelector trows errors on incorrect sintaxes we can use it
			features.nativeMatchesSelector.call(root, ':slick');
			features.nativeMatchesSelector = null;
		} catch(e){};

	}

	try {
		root.slick_expando = 1;
		delete root.slick_expando;
		features.getUID = this.getUIDHTML;
	} catch(e){
		features.getUID = this.getUIDXML;
	}

	testRoot.removeChild(testNode);
	testNode = selected = testRoot = null;

	// getAttribute

	features.getAttribute = (features.isHTMLDocument && brokenFormAttributeGetter) ? function(node, name){
		var method = this.attributeGetters[name];
		if (method) return method.call(node);
		var attributeNode = node.getAttributeNode(name);
		return (attributeNode) ? attributeNode.nodeValue : null;
	} : function(node, name){
		var method = this.attributeGetters[name];
		return (method) ? method.call(node) : node.getAttribute(name);
	};

	// hasAttribute

	features.hasAttribute = (root && this.isNativeCode(root.hasAttribute)) ? function(node, attribute){
		return node.hasAttribute(attribute);
	} : function(node, attribute){
		node = node.getAttributeNode(attribute);
		return !!(node && (node.specified || node.nodeValue));
	};

	// contains
	// FIXME: Add specs: local.contains should be different for xml and html documents?
	var nativeRootContains = root && this.isNativeCode(root.contains),
		nativeDocumentContains = document && this.isNativeCode(document.contains);

	features.contains = (nativeRootContains && nativeDocumentContains) ? function(context, node){
		return context.contains(node);
	} : (nativeRootContains && !nativeDocumentContains) ? function(context, node){
		// IE8 does not have .contains on document.
		return context === node || ((context === document) ? document.documentElement : context).contains(node);
	} : (root && root.compareDocumentPosition) ? function(context, node){
		return context === node || !!(context.compareDocumentPosition(node) & 16);
	} : function(context, node){
		if (node) do {
			if (node === context) return true;
		} while ((node = node.parentNode));
		return false;
	};

	// document order sorting
	// credits to Sizzle (http://sizzlejs.com/)

	features.documentSorter = (root.compareDocumentPosition) ? function(a, b){
		if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0;
		return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;
	} : ('sourceIndex' in root) ? function(a, b){
		if (!a.sourceIndex || !b.sourceIndex) return 0;
		return a.sourceIndex - b.sourceIndex;
	} : (document.createRange) ? function(a, b){
		if (!a.ownerDocument || !b.ownerDocument) return 0;
		var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();
		aRange.setStart(a, 0);
		aRange.setEnd(a, 0);
		bRange.setStart(b, 0);
		bRange.setEnd(b, 0);
		return aRange.compareBoundaryPoints(Range.START_TO_END, bRange);
	} : null ;

	root = null;

	for (feature in features){
		this[feature] = features[feature];
	}
};

// Main Method

var reSimpleSelector = /^([#.]?)((?:[\w-]+|\*))$/,
	reEmptyAttribute = /\[.+[*$^]=(?:""|'')?\]/,
	qsaFailExpCache = {};

local.search = function(context, expression, append, first){

	var found = this.found = (first) ? null : (append || []);

	if (!context) return found;
	else if (context.navigator) context = context.document; // Convert the node from a window to a document
	else if (!context.nodeType) return found;

	// setup

	var parsed, i,
		uniques = this.uniques = {},
		hasOthers = !!(append && append.length),
		contextIsDocument = (context.nodeType == 9);

	if (this.document !== (contextIsDocument ? context : context.ownerDocument)) this.setDocument(context);

	// avoid duplicating items already in the append array
	if (hasOthers) for (i = found.length; i--;) uniques[this.getUID(found[i])] = true;

	// expression checks

	if (typeof expression == 'string'){ // expression is a string

		/*<simple-selectors-override>*/
		var simpleSelector = expression.match(reSimpleSelector);
		simpleSelectors: if (simpleSelector){

			var symbol = simpleSelector[1],
				name = simpleSelector[2],
				node, nodes;

			if (!symbol){

				if (name == '*' && this.brokenStarGEBTN) break simpleSelectors;
				nodes = context.getElementsByTagName(name);
				if (first) return nodes[0] || null;
				for (i = 0; node = nodes[i++];){
					if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
				}

			} else if (symbol == '#'){

				if (!this.isHTMLDocument || !contextIsDocument) break simpleSelectors;
				node = context.getElementById(name);
				if (!node) return found;
				if (this.idGetsName && node.getAttributeNode('id').nodeValue != name) break simpleSelectors;
				if (first) return node || null;
				if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);

			} else if (symbol == '.'){

				if (!this.isHTMLDocument || ((!context.getElementsByClassName || this.brokenGEBCN) && context.querySelectorAll)) break simpleSelectors;
				if (context.getElementsByClassName && !this.brokenGEBCN){
					nodes = context.getElementsByClassName(name);
					if (first) return nodes[0] || null;
					for (i = 0; node = nodes[i++];){
						if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
					}
				} else {
					var matchClass = new RegExp('(^|\\s)'+ Slick.escapeRegExp(name) +'(\\s|$)');
					nodes = context.getElementsByTagName('*');
					for (i = 0; node = nodes[i++];){
						className = node.className;
						if (!(className && matchClass.test(className))) continue;
						if (first) return node;
						if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
					}
				}

			}

			if (hasOthers) this.sort(found);
			return (first) ? null : found;

		}
		/*</simple-selectors-override>*/

		/*<query-selector-override>*/
		querySelector: if (context.querySelectorAll){

			if (!this.isHTMLDocument
				|| qsaFailExpCache[expression]
				//TODO: only skip when expression is actually mixed case
				|| this.brokenMixedCaseQSA
				|| (this.brokenCheckedQSA && expression.indexOf(':checked') > -1)
				|| (this.brokenEmptyAttributeQSA && reEmptyAttribute.test(expression))
				|| (!contextIsDocument //Abort when !contextIsDocument and...
					//  there are multiple expressions in the selector
					//  since we currently only fix non-document rooted QSA for single expression selectors
					&& expression.indexOf(',') > -1
				)
				|| Slick.disableQSA
			) break querySelector;

			var _expression = expression, _context = context;
			if (!contextIsDocument){
				// non-document rooted QSA
				// credits to Andrew Dupont
				var currentId = _context.getAttribute('id'), slickid = 'slickid__';
				_context.setAttribute('id', slickid);
				_expression = '#' + slickid + ' ' + _expression;
				context = _context.parentNode;
			}

			try {
				if (first) return context.querySelector(_expression) || null;
				else nodes = context.querySelectorAll(_expression);
			} catch(e){
				qsaFailExpCache[expression] = 1;
				break querySelector;
			} finally {
				if (!contextIsDocument){
					if (currentId) _context.setAttribute('id', currentId);
					else _context.removeAttribute('id');
					context = _context;
				}
			}

			if (this.starSelectsClosedQSA) for (i = 0; node = nodes[i++];){
				if (node.nodeName > '@' && !(hasOthers && uniques[this.getUID(node)])) found.push(node);
			} else for (i = 0; node = nodes[i++];){
				if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
			}

			if (hasOthers) this.sort(found);
			return found;

		}
		/*</query-selector-override>*/

		parsed = this.Slick.parse(expression);
		if (!parsed.length) return found;
	} else if (expression == null){ // there is no expression
		return found;
	} else if (expression.Slick){ // expression is a parsed Slick object
		parsed = expression;
	} else if (this.contains(context.documentElement || context, expression)){ // expression is a node
		(found) ? found.push(expression) : found = expression;
		return found;
	} else { // other junk
		return found;
	}

	/*<pseudo-selectors>*//*<nth-pseudo-selectors>*/

	// cache elements for the nth selectors

	this.posNTH = {};
	this.posNTHLast = {};
	this.posNTHType = {};
	this.posNTHTypeLast = {};

	/*</nth-pseudo-selectors>*//*</pseudo-selectors>*/

	// if append is null and there is only a single selector with one expression use pushArray, else use pushUID
	this.push = (!hasOthers && (first || (parsed.length == 1 && parsed.expressions[0].length == 1))) ? this.pushArray : this.pushUID;

	if (found == null) found = [];

	// default engine

	var j, m, n;
	var combinator, tag, id, classList, classes, attributes, pseudos;
	var currentItems, currentExpression, currentBit, lastBit, expressions = parsed.expressions;

	search: for (i = 0; (currentExpression = expressions[i]); i++) for (j = 0; (currentBit = currentExpression[j]); j++){

		combinator = 'combinator:' + currentBit.combinator;
		if (!this[combinator]) continue search;

		tag        = (this.isXMLDocument) ? currentBit.tag : currentBit.tag.toUpperCase();
		id         = currentBit.id;
		classList  = currentBit.classList;
		classes    = currentBit.classes;
		attributes = currentBit.attributes;
		pseudos    = currentBit.pseudos;
		lastBit    = (j === (currentExpression.length - 1));

		this.bitUniques = {};

		if (lastBit){
			this.uniques = uniques;
			this.found = found;
		} else {
			this.uniques = {};
			this.found = [];
		}

		if (j === 0){
			this[combinator](context, tag, id, classes, attributes, pseudos, classList);
			if (first && lastBit && found.length) break search;
		} else {
			if (first && lastBit) for (m = 0, n = currentItems.length; m < n; m++){
				this[combinator](currentItems[m], tag, id, classes, attributes, pseudos, classList);
				if (found.length) break search;
			} else for (m = 0, n = currentItems.length; m < n; m++) this[combinator](currentItems[m], tag, id, classes, attributes, pseudos, classList);
		}

		currentItems = this.found;
	}

	// should sort if there are nodes in append and if you pass multiple expressions.
	if (hasOthers || (parsed.expressions.length > 1)) this.sort(found);

	return (first) ? (found[0] || null) : found;
};

// Utils

local.uidx = 1;
local.uidk = 'slick-uniqueid';

local.getUIDXML = function(node){
	var uid = node.getAttribute(this.uidk);
	if (!uid){
		uid = this.uidx++;
		node.setAttribute(this.uidk, uid);
	}
	return uid;
};

local.getUIDHTML = function(node){
	return node.uniqueNumber || (node.uniqueNumber = this.uidx++);
};

// sort based on the setDocument documentSorter method.

local.sort = function(results){
	if (!this.documentSorter) return results;
	results.sort(this.documentSorter);
	return results;
};

/*<pseudo-selectors>*//*<nth-pseudo-selectors>*/

local.cacheNTH = {};

local.matchNTH = /^([+-]?\d*)?([a-z]+)?([+-]\d+)?$/;

local.parseNTHArgument = function(argument){
	var parsed = argument.match(this.matchNTH);
	if (!parsed) return false;
	var special = parsed[2] || false;
	var a = parsed[1] || 1;
	if (a == '-') a = -1;
	var b = +parsed[3] || 0;
	parsed =
		(special == 'n')	? {a: a, b: b} :
		(special == 'odd')	? {a: 2, b: 1} :
		(special == 'even')	? {a: 2, b: 0} : {a: 0, b: a};

	return (this.cacheNTH[argument] = parsed);
};

local.createNTHPseudo = function(child, sibling, positions, ofType){
	return function(node, argument){
		var uid = this.getUID(node);
		if (!this[positions][uid]){
			var parent = node.parentNode;
			if (!parent) return false;
			var el = parent[child], count = 1;
			if (ofType){
				var nodeName = node.nodeName;
				do {
					if (el.nodeName != nodeName) continue;
					this[positions][this.getUID(el)] = count++;
				} while ((el = el[sibling]));
			} else {
				do {
					if (el.nodeType != 1) continue;
					this[positions][this.getUID(el)] = count++;
				} while ((el = el[sibling]));
			}
		}
		argument = argument || 'n';
		var parsed = this.cacheNTH[argument] || this.parseNTHArgument(argument);
		if (!parsed) return false;
		var a = parsed.a, b = parsed.b, pos = this[positions][uid];
		if (a == 0) return b == pos;
		if (a > 0){
			if (pos < b) return false;
		} else {
			if (b < pos) return false;
		}
		return ((pos - b) % a) == 0;
	};
};

/*</nth-pseudo-selectors>*//*</pseudo-selectors>*/

local.pushArray = function(node, tag, id, classes, attributes, pseudos){
	if (this.matchSelector(node, tag, id, classes, attributes, pseudos)) this.found.push(node);
};

local.pushUID = function(node, tag, id, classes, attributes, pseudos){
	var uid = this.getUID(node);
	if (!this.uniques[uid] && this.matchSelector(node, tag, id, classes, attributes, pseudos)){
		this.uniques[uid] = true;
		this.found.push(node);
	}
};

local.matchNode = function(node, selector){
	if (this.isHTMLDocument && this.nativeMatchesSelector){
		try {
			return this.nativeMatchesSelector.call(node, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
		} catch(matchError){}
	}

	var parsed = this.Slick.parse(selector);
	if (!parsed) return true;

	// simple (single) selectors
	var expressions = parsed.expressions, simpleExpCounter = 0, i, currentExpression;
	for (i = 0; (currentExpression = expressions[i]); i++){
		if (currentExpression.length == 1){
			var exp = currentExpression[0];
			if (this.matchSelector(node, (this.isXMLDocument) ? exp.tag : exp.tag.toUpperCase(), exp.id, exp.classes, exp.attributes, exp.pseudos)) return true;
			simpleExpCounter++;
		}
	}

	if (simpleExpCounter == parsed.length) return false;

	var nodes = this.search(this.document, parsed), item;
	for (i = 0; item = nodes[i++];){
		if (item === node) return true;
	}
	return false;
};

local.matchPseudo = function(node, name, argument){
	var pseudoName = 'pseudo:' + name;
	if (this[pseudoName]) return this[pseudoName](node, argument);
	var attribute = this.getAttribute(node, name);
	return (argument) ? argument == attribute : !!attribute;
};

local.matchSelector = function(node, tag, id, classes, attributes, pseudos){
	if (tag){
		var nodeName = (this.isXMLDocument) ? node.nodeName : node.nodeName.toUpperCase();
		if (tag == '*'){
			if (nodeName < '@') return false; // Fix for comment nodes and closed nodes
		} else {
			if (nodeName != tag) return false;
		}
	}

	if (id && node.getAttribute('id') != id) return false;

	var i, part, cls;
	if (classes) for (i = classes.length; i--;){
		cls = this.getAttribute(node, 'class');
		if (!(cls && classes[i].regexp.test(cls))) return false;
	}
	if (attributes) for (i = attributes.length; i--;){
		part = attributes[i];
		if (part.operator ? !part.test(this.getAttribute(node, part.key)) : !this.hasAttribute(node, part.key)) return false;
	}
	if (pseudos) for (i = pseudos.length; i--;){
		part = pseudos[i];
		if (!this.matchPseudo(node, part.key, part.value)) return false;
	}
	return true;
};

var combinators = {

	' ': function(node, tag, id, classes, attributes, pseudos, classList){ // all child nodes, any level

		var i, item, children;

		if (this.isHTMLDocument){
			getById: if (id){
				item = this.document.getElementById(id);
				if ((!item && node.all) || (this.idGetsName && item && item.getAttributeNode('id').nodeValue != id)){
					// all[id] returns all the elements with that name or id inside node
					// if theres just one it will return the element, else it will be a collection
					children = node.all[id];
					if (!children) return;
					if (!children[0]) children = [children];
					for (i = 0; item = children[i++];){
						var idNode = item.getAttributeNode('id');
						if (idNode && idNode.nodeValue == id){
							this.push(item, tag, null, classes, attributes, pseudos);
							break;
						}
					}
					return;
				}
				if (!item){
					// if the context is in the dom we return, else we will try GEBTN, breaking the getById label
					if (this.contains(this.root, node)) return;
					else break getById;
				} else if (this.document !== node && !this.contains(node, item)) return;
				this.push(item, tag, null, classes, attributes, pseudos);
				return;
			}
			getByClass: if (classes && node.getElementsByClassName && !this.brokenGEBCN){
				children = node.getElementsByClassName(classList.join(' '));
				if (!(children && children.length)) break getByClass;
				for (i = 0; item = children[i++];) this.push(item, tag, id, null, attributes, pseudos);
				return;
			}
		}
		getByTag: {
			children = node.getElementsByTagName(tag);
			if (!(children && children.length)) break getByTag;
			if (!this.brokenStarGEBTN) tag = null;
			for (i = 0; item = children[i++];) this.push(item, tag, id, classes, attributes, pseudos);
		}
	},

	'>': function(node, tag, id, classes, attributes, pseudos){ // direct children
		if ((node = node.firstChild)) do {
			if (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);
		} while ((node = node.nextSibling));
	},

	'+': function(node, tag, id, classes, attributes, pseudos){ // next sibling
		while ((node = node.nextSibling)) if (node.nodeType == 1){
			this.push(node, tag, id, classes, attributes, pseudos);
			break;
		}
	},

	'^': function(node, tag, id, classes, attributes, pseudos){ // first child
		node = node.firstChild;
		if (node){
			if (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);
			else this['combinator:+'](node, tag, id, classes, attributes, pseudos);
		}
	},

	'~': function(node, tag, id, classes, attributes, pseudos){ // next siblings
		while ((node = node.nextSibling)){
			if (node.nodeType != 1) continue;
			var uid = this.getUID(node);
			if (this.bitUniques[uid]) break;
			this.bitUniques[uid] = true;
			this.push(node, tag, id, classes, attributes, pseudos);
		}
	},

	'++': function(node, tag, id, classes, attributes, pseudos){ // next sibling and previous sibling
		this['combinator:+'](node, tag, id, classes, attributes, pseudos);
		this['combinator:!+'](node, tag, id, classes, attributes, pseudos);
	},

	'~~': function(node, tag, id, classes, attributes, pseudos){ // next siblings and previous siblings
		this['combinator:~'](node, tag, id, classes, attributes, pseudos);
		this['combinator:!~'](node, tag, id, classes, attributes, pseudos);
	},

	'!': function(node, tag, id, classes, attributes, pseudos){ // all parent nodes up to document
		while ((node = node.parentNode)) if (node !== this.document) this.push(node, tag, id, classes, attributes, pseudos);
	},

	'!>': function(node, tag, id, classes, attributes, pseudos){ // direct parent (one level)
		node = node.parentNode;
		if (node !== this.document) this.push(node, tag, id, classes, attributes, pseudos);
	},

	'!+': function(node, tag, id, classes, attributes, pseudos){ // previous sibling
		while ((node = node.previousSibling)) if (node.nodeType == 1){
			this.push(node, tag, id, classes, attributes, pseudos);
			break;
		}
	},

	'!^': function(node, tag, id, classes, attributes, pseudos){ // last child
		node = node.lastChild;
		if (node){
			if (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);
			else this['combinator:!+'](node, tag, id, classes, attributes, pseudos);
		}
	},

	'!~': function(node, tag, id, classes, attributes, pseudos){ // previous siblings
		while ((node = node.previousSibling)){
			if (node.nodeType != 1) continue;
			var uid = this.getUID(node);
			if (this.bitUniques[uid]) break;
			this.bitUniques[uid] = true;
			this.push(node, tag, id, classes, attributes, pseudos);
		}
	}

};

for (var c in combinators) local['combinator:' + c] = combinators[c];

var pseudos = {

	/*<pseudo-selectors>*/

	'empty': function(node){
		var child = node.firstChild;
		return !(child && child.nodeType == 1) && !(node.innerText || node.textContent || '').length;
	},

	'not': function(node, expression){
		return !this.matchNode(node, expression);
	},

	'contains': function(node, text){
		return (node.innerText || node.textContent || '').indexOf(text) > -1;
	},

	'first-child': function(node){
		while ((node = node.previousSibling)) if (node.nodeType == 1) return false;
		return true;
	},

	'last-child': function(node){
		while ((node = node.nextSibling)) if (node.nodeType == 1) return false;
		return true;
	},

	'only-child': function(node){
		var prev = node;
		while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false;
		var next = node;
		while ((next = next.nextSibling)) if (next.nodeType == 1) return false;
		return true;
	},

	/*<nth-pseudo-selectors>*/

	'nth-child': local.createNTHPseudo('firstChild', 'nextSibling', 'posNTH'),

	'nth-last-child': local.createNTHPseudo('lastChild', 'previousSibling', 'posNTHLast'),

	'nth-of-type': local.createNTHPseudo('firstChild', 'nextSibling', 'posNTHType', true),

	'nth-last-of-type': local.createNTHPseudo('lastChild', 'previousSibling', 'posNTHTypeLast', true),

	'index': function(node, index){
		return this['pseudo:nth-child'](node, '' + (index + 1));
	},

	'even': function(node){
		return this['pseudo:nth-child'](node, '2n');
	},

	'odd': function(node){
		return this['pseudo:nth-child'](node, '2n+1');
	},

	/*</nth-pseudo-selectors>*/

	/*<of-type-pseudo-selectors>*/

	'first-of-type': function(node){
		var nodeName = node.nodeName;
		while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false;
		return true;
	},

	'last-of-type': function(node){
		var nodeName = node.nodeName;
		while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false;
		return true;
	},

	'only-of-type': function(node){
		var prev = node, nodeName = node.nodeName;
		while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false;
		var next = node;
		while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false;
		return true;
	},

	/*</of-type-pseudo-selectors>*/

	// custom pseudos

	'enabled': function(node){
		return !node.disabled;
	},

	'disabled': function(node){
		return node.disabled;
	},

	'checked': function(node){
		return node.checked || node.selected;
	},

	'focus': function(node){
		return this.isHTMLDocument && this.document.activeElement === node && (node.href || node.type || this.hasAttribute(node, 'tabindex'));
	},

	'root': function(node){
		return (node === this.root);
	},

	'selected': function(node){
		return node.selected;
	}

	/*</pseudo-selectors>*/
};

for (var p in pseudos) local['pseudo:' + p] = pseudos[p];

// attributes methods

var attributeGetters = local.attributeGetters = {

	'for': function(){
		return ('htmlFor' in this) ? this.htmlFor : this.getAttribute('for');
	},

	'href': function(){
		return ('href' in this) ? this.getAttribute('href', 2) : this.getAttribute('href');
	},

	'style': function(){
		return (this.style) ? this.style.cssText : this.getAttribute('style');
	},

	'tabindex': function(){
		var attributeNode = this.getAttributeNode('tabindex');
		return (attributeNode && attributeNode.specified) ? attributeNode.nodeValue : null;
	},

	'type': function(){
		return this.getAttribute('type');
	},

	'maxlength': function(){
		var attributeNode = this.getAttributeNode('maxLength');
		return (attributeNode && attributeNode.specified) ? attributeNode.nodeValue : null;
	}

};

attributeGetters.MAXLENGTH = attributeGetters.maxLength = attributeGetters.maxlength;

// Slick

var Slick = local.Slick = (this.Slick || {});

Slick.version = '1.1.7';

// Slick finder

Slick.search = function(context, expression, append){
	return local.search(context, expression, append);
};

Slick.find = function(context, expression){
	return local.search(context, expression, null, true);
};

// Slick containment checker

Slick.contains = function(container, node){
	local.setDocument(container);
	return local.contains(container, node);
};

// Slick attribute getter

Slick.getAttribute = function(node, name){
	local.setDocument(node);
	return local.getAttribute(node, name);
};

Slick.hasAttribute = function(node, name){
	local.setDocument(node);
	return local.hasAttribute(node, name);
};

// Slick matcher

Slick.match = function(node, selector){
	if (!(node && selector)) return false;
	if (!selector || selector === node) return true;
	local.setDocument(node);
	return local.matchNode(node, selector);
};

// Slick attribute accessor

Slick.defineAttributeGetter = function(name, fn){
	local.attributeGetters[name] = fn;
	return this;
};

Slick.lookupAttributeGetter = function(name){
	return local.attributeGetters[name];
};

// Slick pseudo accessor

Slick.definePseudo = function(name, fn){
	local['pseudo:' + name] = function(node, argument){
		return fn.call(node, argument);
	};
	return this;
};

Slick.lookupPseudo = function(name){
	var pseudo = local['pseudo:' + name];
	if (pseudo) return function(argument){
		return pseudo.call(this, argument);
	};
	return null;
};

// Slick overrides accessor

Slick.override = function(regexp, fn){
	local.override(regexp, fn);
	return this;
};

Slick.isXML = local.isXML;

Slick.uidOf = function(node){
	return local.getUIDHTML(node);
};

if (!this.Slick) this.Slick = Slick;

}).apply(/*<CommonJS>*/(typeof exports != 'undefined') ? exports : /*</CommonJS>*/this);

/*
---

name: Element

description: One of the most important items in MooTools. Contains the dollar function, the dollars function, and an handful of cross-browser, time-saver methods to let you easily work with HTML Elements.

license: MIT-style license.

requires: [Window, Document, Array, String, Function, Object, Number, Slick.Parser, Slick.Finder]

provides: [Element, Elements, $, $$, IFrame, Selectors]

...
*/

var Element = this.Element = function(tag, props){
	var konstructor = Element.Constructors[tag];
	if (konstructor) return konstructor(props);
	if (typeof tag != 'string') return document.id(tag).set(props);

	if (!props) props = {};

	if (!(/^[\w-]+$/).test(tag)){
		var parsed = Slick.parse(tag).expressions[0][0];
		tag = (parsed.tag == '*') ? 'div' : parsed.tag;
		if (parsed.id && props.id == null) props.id = parsed.id;

		var attributes = parsed.attributes;
		if (attributes) for (var attr, i = 0, l = attributes.length; i < l; i++){
			attr = attributes[i];
			if (props[attr.key] != null) continue;

			if (attr.value != null && attr.operator == '=') props[attr.key] = attr.value;
			else if (!attr.value && !attr.operator) props[attr.key] = true;
		}

		if (parsed.classList && props['class'] == null) props['class'] = parsed.classList.join(' ');
	}

	return document.newElement(tag, props);
};


if (Browser.Element){
	Element.prototype = Browser.Element.prototype;
	// IE8 and IE9 require the wrapping.
	Element.prototype._fireEvent = (function(fireEvent){
		return function(type, event){
			return fireEvent.call(this, type, event);
		};
	})(Element.prototype.fireEvent);
}

new Type('Element', Element).mirror(function(name){
	if (Array.prototype[name]) return;

	var obj = {};
	obj[name] = function(){
		var results = [], args = arguments, elements = true;
		for (var i = 0, l = this.length; i < l; i++){
			var element = this[i], result = results[i] = element[name].apply(element, args);
			elements = (elements && typeOf(result) == 'element');
		}
		return (elements) ? new Elements(results) : results;
	};

	Elements.implement(obj);
});

if (!Browser.Element){
	Element.parent = Object;

	Element.Prototype = {
		'$constructor': Element,
		'$family': Function.from('element').hide()
	};

	Element.mirror(function(name, method){
		Element.Prototype[name] = method;
	});
}

Element.Constructors = {};

//<1.2compat>

Element.Constructors = new Hash;

//</1.2compat>

var IFrame = new Type('IFrame', function(){
	var params = Array.link(arguments, {
		properties: Type.isObject,
		iframe: function(obj){
			return (obj != null);
		}
	});

	var props = params.properties || {}, iframe;
	if (params.iframe) iframe = document.id(params.iframe);
	var onload = props.onload || function(){};
	delete props.onload;
	props.id = props.name = [props.id, props.name, iframe ? (iframe.id || iframe.name) : 'IFrame_' + String.uniqueID()].pick();
	iframe = new Element(iframe || 'iframe', props);

	var onLoad = function(){
		onload.call(iframe.contentWindow);
	};

	if (window.frames[props.id]) onLoad();
	else iframe.addListener('load', onLoad);
	return iframe;
});

var Elements = this.Elements = function(nodes){
	if (nodes && nodes.length){
		var uniques = {}, node;
		for (var i = 0; node = nodes[i++];){
			var uid = Slick.uidOf(node);
			if (!uniques[uid]){
				uniques[uid] = true;
				this.push(node);
			}
		}
	}
};

Elements.prototype = {length: 0};
Elements.parent = Array;

new Type('Elements', Elements).implement({

	filter: function(filter, bind){
		if (!filter) return this;
		return new Elements(Array.filter(this, (typeOf(filter) == 'string') ? function(item){
			return item.match(filter);
		} : filter, bind));
	}.protect(),

	push: function(){
		var length = this.length;
		for (var i = 0, l = arguments.length; i < l; i++){
			var item = document.id(arguments[i]);
			if (item) this[length++] = item;
		}
		return (this.length = length);
	}.protect(),

	unshift: function(){
		var items = [];
		for (var i = 0, l = arguments.length; i < l; i++){
			var item = document.id(arguments[i]);
			if (item) items.push(item);
		}
		return Array.prototype.unshift.apply(this, items);
	}.protect(),

	concat: function(){
		var newElements = new Elements(this);
		for (var i = 0, l = arguments.length; i < l; i++){
			var item = arguments[i];
			if (Type.isEnumerable(item)) newElements.append(item);
			else newElements.push(item);
		}
		return newElements;
	}.protect(),

	append: function(collection){
		for (var i = 0, l = collection.length; i < l; i++) this.push(collection[i]);
		return this;
	}.protect(),

	empty: function(){
		while (this.length) delete this[--this.length];
		return this;
	}.protect()

});

//<1.2compat>

Elements.alias('extend', 'append');

//</1.2compat>

(function(){

// FF, IE
var splice = Array.prototype.splice, object = {'0': 0, '1': 1, length: 2};

splice.call(object, 1, 1);
if (object[1] == 1) Elements.implement('splice', function(){
	var length = this.length;
	var result = splice.apply(this, arguments);
	while (length >= this.length) delete this[length--];
	return result;
}.protect());

Array.forEachMethod(function(method, name){
	Elements.implement(name, method);
});

Array.mirror(Elements);

/*<ltIE8>*/
var createElementAcceptsHTML;
try {
	createElementAcceptsHTML = (document.createElement('<input name=x>').name == 'x');
} catch (e){}

var escapeQuotes = function(html){
	return ('' + html).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
};
/*</ltIE8>*/

/*<ltIE9>*/
// #2479 - IE8 Cannot set HTML of style element
var canChangeStyleHTML = (function(){
    var div = document.createElement('style'),
        flag = false;
    try {
        div.innerHTML = '#justTesing{margin: 0px;}';
        flag = !!div.innerHTML;
    } catch(e){}
    return flag;
})();
/*</ltIE9>*/

Document.implement({

	newElement: function(tag, props){
		if (props){
			if (props.checked != null) props.defaultChecked = props.checked;
			if ((props.type == 'checkbox' || props.type == 'radio') && props.value == null) props.value = 'on'; 
			/*<ltIE9>*/ // IE needs the type to be set before changing content of style element
			if (!canChangeStyleHTML && tag == 'style'){
				var styleElement = document.createElement('style');
				styleElement.setAttribute('type', 'text/css');
				if (props.type) delete props.type;
				return this.id(styleElement).set(props);
			}
			/*</ltIE9>*/
			/*<ltIE8>*/// Fix for readonly name and type properties in IE < 8
			if (createElementAcceptsHTML){
				tag = '<' + tag;
				if (props.name) tag += ' name="' + escapeQuotes(props.name) + '"';
				if (props.type) tag += ' type="' + escapeQuotes(props.type) + '"';
				tag += '>';
				delete props.name;
				delete props.type;
			}
			/*</ltIE8>*/
		}
		return this.id(this.createElement(tag)).set(props);
	}

});

})();

(function(){

Slick.uidOf(window);
Slick.uidOf(document);

Document.implement({

	newTextNode: function(text){
		return this.createTextNode(text);
	},

	getDocument: function(){
		return this;
	},

	getWindow: function(){
		return this.window;
	},

	id: (function(){

		var types = {

			string: function(id, nocash, doc){
				id = Slick.find(doc, '#' + id.replace(/(\W)/g, '\\$1'));
				return (id) ? types.element(id, nocash) : null;
			},

			element: function(el, nocash){
				Slick.uidOf(el);
				if (!nocash && !el.$family && !(/^(?:object|embed)$/i).test(el.tagName)){
					var fireEvent = el.fireEvent;
					// wrapping needed in IE7, or else crash
					el._fireEvent = function(type, event){
						return fireEvent(type, event);
					};
					Object.append(el, Element.Prototype);
				}
				return el;
			},

			object: function(obj, nocash, doc){
				if (obj.toElement) return types.element(obj.toElement(doc), nocash);
				return null;
			}

		};

		types.textnode = types.whitespace = types.window = types.document = function(zero){
			return zero;
		};

		return function(el, nocash, doc){
			if (el && el.$family && el.uniqueNumber) return el;
			var type = typeOf(el);
			return (types[type]) ? types[type](el, nocash, doc || document) : null;
		};

	})()

});

if (window.$ == null) Window.implement('$', function(el, nc){
	return document.id(el, nc, this.document);
});

Window.implement({

	getDocument: function(){
		return this.document;
	},

	getWindow: function(){
		return this;
	}

});

[Document, Element].invoke('implement', {

	getElements: function(expression){
		return Slick.search(this, expression, new Elements);
	},

	getElement: function(expression){
		return document.id(Slick.find(this, expression));
	}

});

var contains = {contains: function(element){
	return Slick.contains(this, element);
}};

if (!document.contains) Document.implement(contains);
if (!document.createElement('div').contains) Element.implement(contains);

//<1.2compat>

Element.implement('hasChild', function(element){
	return this !== element && this.contains(element);
});

(function(search, find, match){

	this.Selectors = {};
	var pseudos = this.Selectors.Pseudo = new Hash();

	var addSlickPseudos = function(){
		for (var name in pseudos) if (pseudos.hasOwnProperty(name)){
			Slick.definePseudo(name, pseudos[name]);
			delete pseudos[name];
		}
	};

	Slick.search = function(context, expression, append){
		addSlickPseudos();
		return search.call(this, context, expression, append);
	};

	Slick.find = function(context, expression){
		addSlickPseudos();
		return find.call(this, context, expression);
	};

	Slick.match = function(node, selector){
		addSlickPseudos();
		return match.call(this, node, selector);
	};

})(Slick.search, Slick.find, Slick.match);

//</1.2compat>

// tree walking

var injectCombinator = function(expression, combinator){
	if (!expression) return combinator;

	expression = Object.clone(Slick.parse(expression));

	var expressions = expression.expressions;
	for (var i = expressions.length; i--;)
		expressions[i][0].combinator = combinator;

	return expression;
};

Object.forEach({
	getNext: '~',
	getPrevious: '!~',
	getParent: '!'
}, function(combinator, method){
	Element.implement(method, function(expression){
		return this.getElement(injectCombinator(expression, combinator));
	});
});

Object.forEach({
	getAllNext: '~',
	getAllPrevious: '!~',
	getSiblings: '~~',
	getChildren: '>',
	getParents: '!'
}, function(combinator, method){
	Element.implement(method, function(expression){
		return this.getElements(injectCombinator(expression, combinator));
	});
});

Element.implement({

	getFirst: function(expression){
		return document.id(Slick.search(this, injectCombinator(expression, '>'))[0]);
	},

	getLast: function(expression){
		return document.id(Slick.search(this, injectCombinator(expression, '>')).getLast());
	},

	getWindow: function(){
		return this.ownerDocument.window;
	},

	getDocument: function(){
		return this.ownerDocument;
	},

	getElementById: function(id){
		return document.id(Slick.find(this, '#' + ('' + id).replace(/(\W)/g, '\\$1')));
	},

	match: function(expression){
		return !expression || Slick.match(this, expression);
	}

});

//<1.2compat>

if (window.$$ == null) Window.implement('$$', function(selector){
	var elements = new Elements;
	if (arguments.length == 1 && typeof selector == 'string') return Slick.search(this.document, selector, elements);
	var args = Array.flatten(arguments);
	for (var i = 0, l = args.length; i < l; i++){
		var item = args[i];
		switch (typeOf(item)){
			case 'element': elements.push(item); break;
			case 'string': Slick.search(this.document, item, elements);
		}
	}
	return elements;
});

//</1.2compat>

if (window.$$ == null) Window.implement('$$', function(selector){
	if (arguments.length == 1){
		if (typeof selector == 'string') return Slick.search(this.document, selector, new Elements);
		else if (Type.isEnumerable(selector)) return new Elements(selector);
	}
	return new Elements(arguments);
});

// Inserters

var inserters = {

	before: function(context, element){
		var parent = element.parentNode;
		if (parent) parent.insertBefore(context, element);
	},

	after: function(context, element){
		var parent = element.parentNode;
		if (parent) parent.insertBefore(context, element.nextSibling);
	},

	bottom: function(context, element){
		element.appendChild(context);
	},

	top: function(context, element){
		element.insertBefore(context, element.firstChild);
	}

};

inserters.inside = inserters.bottom;

//<1.2compat>

Object.each(inserters, function(inserter, where){

	where = where.capitalize();

	var methods = {};

	methods['inject' + where] = function(el){
		inserter(this, document.id(el, true));
		return this;
	};

	methods['grab' + where] = function(el){
		inserter(document.id(el, true), this);
		return this;
	};

	Element.implement(methods);

});

//</1.2compat>

// getProperty / setProperty

var propertyGetters = {}, propertySetters = {};

// properties

var properties = {};
Array.forEach([
	'type', 'value', 'defaultValue', 'accessKey', 'cellPadding', 'cellSpacing', 'colSpan',
	'frameBorder', 'rowSpan', 'tabIndex', 'useMap'
], function(property){
	properties[property.toLowerCase()] = property;
});

properties.html = 'innerHTML';
properties.text = (document.createElement('div').textContent == null) ? 'innerText': 'textContent';

Object.forEach(properties, function(real, key){
	propertySetters[key] = function(node, value){
		node[real] = value;
	};
	propertyGetters[key] = function(node){
		return node[real];
	};
});

/*<ltIE9>*/
propertySetters.text = (function(setter){
	return function(node, value){
		if (node.get('tag') == 'style') node.set('html', value);
		else node[properties.text] = value;
	};
})(propertySetters.text);

propertyGetters.text = (function(getter){
	return function(node){
		return (node.get('tag') == 'style') ? node.innerHTML : getter(node);
	};
})(propertyGetters.text);
/*</ltIE9>*/

// Booleans

var bools = [
	'compact', 'nowrap', 'ismap', 'declare', 'noshade', 'checked',
	'disabled', 'readOnly', 'multiple', 'selected', 'noresize',
	'defer', 'defaultChecked', 'autofocus', 'controls', 'autoplay',
	'loop'
];

var booleans = {};
Array.forEach(bools, function(bool){
	var lower = bool.toLowerCase();
	booleans[lower] = bool;
	propertySetters[lower] = function(node, value){
		node[bool] = !!value;
	};
	propertyGetters[lower] = function(node){
		return !!node[bool];
	};
});

// Special cases

Object.append(propertySetters, {

	'class': function(node, value){
		('className' in node) ? node.className = (value || '') : node.setAttribute('class', value);
	},

	'for': function(node, value){
		('htmlFor' in node) ? node.htmlFor = value : node.setAttribute('for', value);
	},

	'style': function(node, value){
		(node.style) ? node.style.cssText = value : node.setAttribute('style', value);
	},

	'value': function(node, value){
		node.value = (value != null) ? value : '';
	}

});

propertyGetters['class'] = function(node){
	return ('className' in node) ? node.className || null : node.getAttribute('class');
};

/* <webkit> */
var el = document.createElement('button');
// IE sets type as readonly and throws
try { el.type = 'button'; } catch(e){}
if (el.type != 'button') propertySetters.type = function(node, value){
	node.setAttribute('type', value);
};
el = null;
/* </webkit> */

/*<IE>*/

/*<ltIE9>*/
// #2479 - IE8 Cannot set HTML of style element
var canChangeStyleHTML = (function(){
    var div = document.createElement('style'),
        flag = false;
    try {
        div.innerHTML = '#justTesing{margin: 0px;}';
        flag = !!div.innerHTML;
    } catch(e){}
    return flag;
})();
/*</ltIE9>*/

var input = document.createElement('input'), volatileInputValue, html5InputSupport;

// #2178
input.value = 't';
input.type = 'submit';
volatileInputValue = input.value != 't';

// #2443 - IE throws "Invalid Argument" when trying to use html5 input types
try {
	input.type = 'email';
	html5InputSupport = input.type == 'email';
} catch(e){}

input = null;

if (volatileInputValue || !html5InputSupport) propertySetters.type = function(node, type){
	try {
		var value = node.value;
		node.type = type;
		node.value = value;
	} catch (e){}
};
/*</IE>*/

/* getProperty, setProperty */

/* <ltIE9> */
var pollutesGetAttribute = (function(div){
	div.random = 'attribute';
	return (div.getAttribute('random') == 'attribute');
})(document.createElement('div'));

var hasCloneBug = (function(test){
	test.innerHTML = '<object><param name="should_fix" value="the unknown" /></object>';
	return test.cloneNode(true).firstChild.childNodes.length != 1;
})(document.createElement('div'));
/* </ltIE9> */

var hasClassList = !!document.createElement('div').classList;

var classes = function(className){
	var classNames = (className || '').clean().split(" "), uniques = {};
	return classNames.filter(function(className){
		if (className !== "" && !uniques[className]) return uniques[className] = className;
	});
};

var addToClassList = function(name){
	this.classList.add(name);
};

var removeFromClassList = function(name){
	this.classList.remove(name);
};

Element.implement({

	setProperty: function(name, value){
		var setter = propertySetters[name.toLowerCase()];
		if (setter){
			setter(this, value);
		} else {
			/* <ltIE9> */
			var attributeWhiteList;
			if (pollutesGetAttribute) attributeWhiteList = this.retrieve('$attributeWhiteList', {});
			/* </ltIE9> */

			if (value == null){
				this.removeAttribute(name);
				/* <ltIE9> */
				if (pollutesGetAttribute) delete attributeWhiteList[name];
				/* </ltIE9> */
			} else {
				this.setAttribute(name, '' + value);
				/* <ltIE9> */
				if (pollutesGetAttribute) attributeWhiteList[name] = true;
				/* </ltIE9> */
			}
		}
		return this;
	},

	setProperties: function(attributes){
		for (var attribute in attributes) this.setProperty(attribute, attributes[attribute]);
		return this;
	},

	getProperty: function(name){
		var getter = propertyGetters[name.toLowerCase()];
		if (getter) return getter(this);
		/* <ltIE9> */
		if (pollutesGetAttribute){
			var attr = this.getAttributeNode(name), attributeWhiteList = this.retrieve('$attributeWhiteList', {});
			if (!attr) return null;
			if (attr.expando && !attributeWhiteList[name]){
				var outer = this.outerHTML;
				// segment by the opening tag and find mention of attribute name
				if (outer.substr(0, outer.search(/\/?['"]?>(?![^<]*<['"])/)).indexOf(name) < 0) return null;
				attributeWhiteList[name] = true;
			}
		}
		/* </ltIE9> */
		var result = Slick.getAttribute(this, name);
		return (!result && !Slick.hasAttribute(this, name)) ? null : result;
	},

	getProperties: function(){
		var args = Array.from(arguments);
		return args.map(this.getProperty, this).associate(args);
	},

	removeProperty: function(name){
		return this.setProperty(name, null);
	},

	removeProperties: function(){
		Array.each(arguments, this.removeProperty, this);
		return this;
	},

	set: function(prop, value){
		var property = Element.Properties[prop];
		(property && property.set) ? property.set.call(this, value) : this.setProperty(prop, value);
	}.overloadSetter(),

	get: function(prop){
		var property = Element.Properties[prop];
		return (property && property.get) ? property.get.apply(this) : this.getProperty(prop);
	}.overloadGetter(),

	erase: function(prop){
		var property = Element.Properties[prop];
		(property && property.erase) ? property.erase.apply(this) : this.removeProperty(prop);
		return this;
	},

	hasClass: hasClassList ? function(className){
		return this.classList.contains(className);
	} : function(className){
		return classes(this.className).contains(className);
	},

	addClass: hasClassList ? function(className){
		classes(className).forEach(addToClassList, this);
		return this;
	} : function(className){
		this.className = classes(className + ' ' + this.className).join(' ');
		return this;
	},

	removeClass: hasClassList ? function(className){
		classes(className).forEach(removeFromClassList, this);
		return this;
	} : function(className){
		var classNames = classes(this.className);
		classes(className).forEach(classNames.erase, classNames);
		this.className = classNames.join(' ');
		return this;
	},

	toggleClass: function(className, force){
		if (force == null) force = !this.hasClass(className);
		return (force) ? this.addClass(className) : this.removeClass(className);
	},

	adopt: function(){
		var parent = this, fragment, elements = Array.flatten(arguments), length = elements.length;
		if (length > 1) parent = fragment = document.createDocumentFragment();

		for (var i = 0; i < length; i++){
			var element = document.id(elements[i], true);
			if (element) parent.appendChild(element);
		}

		if (fragment) this.appendChild(fragment);

		return this;
	},

	appendText: function(text, where){
		return this.grab(this.getDocument().newTextNode(text), where);
	},

	grab: function(el, where){
		inserters[where || 'bottom'](document.id(el, true), this);
		return this;
	},

	inject: function(el, where){
		inserters[where || 'bottom'](this, document.id(el, true));
		return this;
	},

	replaces: function(el){
		el = document.id(el, true);
		el.parentNode.replaceChild(this, el);
		return this;
	},

	wraps: function(el, where){
		el = document.id(el, true);
		return this.replaces(el).grab(el, where);
	},

	getSelected: function(){
		this.selectedIndex; // Safari 3.2.1
		return new Elements(Array.from(this.options).filter(function(option){
			return option.selected;
		}));
	},

	toQueryString: function(){
		var queryString = [];
		this.getElements('input, select, textarea').each(function(el){
			var type = el.type;
			if (!el.name || el.disabled || type == 'submit' || type == 'reset' || type == 'file' || type == 'image') return;

			var value = (el.get('tag') == 'select') ? el.getSelected().map(function(opt){
				// IE
				return document.id(opt).get('value');
			}) : ((type == 'radio' || type == 'checkbox') && !el.checked) ? null : el.get('value');

			Array.from(value).each(function(val){
				if (typeof val != 'undefined') queryString.push(encodeURIComponent(el.name) + '=' + encodeURIComponent(val));
			});
		});
		return queryString.join('&');
	}

});


// appendHTML

var appendInserters = {
	before: 'beforeBegin',
	after: 'afterEnd',
	bottom: 'beforeEnd',
	top: 'afterBegin',
	inside: 'beforeEnd'
};

Element.implement('appendHTML', ('insertAdjacentHTML' in document.createElement('div')) ? function(html, where){
	this.insertAdjacentHTML(appendInserters[where || 'bottom'], html);
	return this;
} : function(html, where){
	var temp = new Element('div', {html: html}),
		children = temp.childNodes,
		fragment = temp.firstChild;

	if (!fragment) return this;
	if (children.length > 1){
		fragment = document.createDocumentFragment();
		for (var i = 0, l = children.length; i < l; i++){
			fragment.appendChild(children[i]);
		}
	}

	inserters[where || 'bottom'](fragment, this);
	return this;
});

var collected = {}, storage = {};

var get = function(uid){
	return (storage[uid] || (storage[uid] = {}));
};

var clean = function(item){
	var uid = item.uniqueNumber;
	if (item.removeEvents) item.removeEvents();
	if (item.clearAttributes) item.clearAttributes();
	if (uid != null){
		delete collected[uid];
		delete storage[uid];
	}
	return item;
};

var formProps = {input: 'checked', option: 'selected', textarea: 'value'};

Element.implement({

	destroy: function(){
		var children = clean(this).getElementsByTagName('*');
		Array.each(children, clean);
		Element.dispose(this);
		return null;
	},

	empty: function(){
		Array.from(this.childNodes).each(Element.dispose);
		return this;
	},

	dispose: function(){
		return (this.parentNode) ? this.parentNode.removeChild(this) : this;
	},

	clone: function(contents, keepid){
		contents = contents !== false;
		var clone = this.cloneNode(contents), ce = [clone], te = [this], i;

		if (contents){
			ce.append(Array.from(clone.getElementsByTagName('*')));
			te.append(Array.from(this.getElementsByTagName('*')));
		}

		for (i = ce.length; i--;){
			var node = ce[i], element = te[i];
			if (!keepid) node.removeAttribute('id');
			/*<ltIE9>*/
			if (node.clearAttributes){
				node.clearAttributes();
				node.mergeAttributes(element);
				node.removeAttribute('uniqueNumber');
				if (node.options){
					var no = node.options, eo = element.options;
					for (var j = no.length; j--;) no[j].selected = eo[j].selected;
				}
			}
			/*</ltIE9>*/
			var prop = formProps[element.tagName.toLowerCase()];
			if (prop && element[prop]) node[prop] = element[prop];
		}

		/*<ltIE9>*/
		if (hasCloneBug){
			var co = clone.getElementsByTagName('object'), to = this.getElementsByTagName('object');
			for (i = co.length; i--;) co[i].outerHTML = to[i].outerHTML;
		}
		/*</ltIE9>*/
		return document.id(clone);
	}

});

[Element, Window, Document].invoke('implement', {

	addListener: function(type, fn){
		if (window.attachEvent && !window.addEventListener){
			collected[Slick.uidOf(this)] = this;
		}
		if (this.addEventListener) this.addEventListener(type, fn, !!arguments[2]);
		else this.attachEvent('on' + type, fn);
		return this;
	},

	removeListener: function(type, fn){
		if (this.removeEventListener) this.removeEventListener(type, fn, !!arguments[2]);
		else this.detachEvent('on' + type, fn);
		return this;
	},

	retrieve: function(property, dflt){
		var storage = get(Slick.uidOf(this)), prop = storage[property];
		if (dflt != null && prop == null) prop = storage[property] = dflt;
		return prop != null ? prop : null;
	},

	store: function(property, value){
		var storage = get(Slick.uidOf(this));
		storage[property] = value;
		return this;
	},

	eliminate: function(property){
		var storage = get(Slick.uidOf(this));
		delete storage[property];
		return this;
	}

});

/*<ltIE9>*/
if (window.attachEvent && !window.addEventListener){
	var gc = function(){
		Object.each(collected, clean);
		if (window.CollectGarbage) CollectGarbage();
		window.removeListener('unload', gc);
	}
	window.addListener('unload', gc);
}
/*</ltIE9>*/

Element.Properties = {};

//<1.2compat>

Element.Properties = new Hash;

//</1.2compat>

Element.Properties.style = {

	set: function(style){
		this.style.cssText = style;
	},

	get: function(){
		return this.style.cssText;
	},

	erase: function(){
		this.style.cssText = '';
	}

};

Element.Properties.tag = {

	get: function(){
		return this.tagName.toLowerCase();
	}

};

Element.Properties.html = {

	set: function(html){
		if (html == null) html = '';
		else if (typeOf(html) == 'array') html = html.join('');

		/*<ltIE9>*/
		if (this.styleSheet && !canChangeStyleHTML) this.styleSheet.cssText = html;
		else /*</ltIE9>*/this.innerHTML = html;
	},
	erase: function(){
		this.set('html', '');
	}

};

var supportsHTML5Elements = true, supportsTableInnerHTML = true, supportsTRInnerHTML = true;

/*<ltIE9>*/
// technique by jdbarlett - http://jdbartlett.com/innershiv/
var div = document.createElement('div');
div.innerHTML = '<nav></nav>';
supportsHTML5Elements = (div.childNodes.length == 1);
if (!supportsHTML5Elements){
	var tags = 'abbr article aside audio canvas datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video'.split(' '),
		fragment = document.createDocumentFragment(), l = tags.length;
	while (l--) fragment.createElement(tags[l]);
}
div = null;
/*</ltIE9>*/

/*<IE>*/
supportsTableInnerHTML = Function.attempt(function(){
	var table = document.createElement('table');
	table.innerHTML = '<tr><td></td></tr>';
	return true;
});

/*<ltFF4>*/
var tr = document.createElement('tr'), html = '<td></td>';
tr.innerHTML = html;
supportsTRInnerHTML = (tr.innerHTML == html);
tr = null;
/*</ltFF4>*/

if (!supportsTableInnerHTML || !supportsTRInnerHTML || !supportsHTML5Elements){

	Element.Properties.html.set = (function(set){

		var translations = {
			table: [1, '<table>', '</table>'],
			select: [1, '<select>', '</select>'],
			tbody: [2, '<table><tbody>', '</tbody></table>'],
			tr: [3, '<table><tbody><tr>', '</tr></tbody></table>']
		};

		translations.thead = translations.tfoot = translations.tbody;

		return function(html){

			/*<ltIE9>*/
			if (this.styleSheet) return set.call(this, html);
			/*</ltIE9>*/
			var wrap = translations[this.get('tag')];
			if (!wrap && !supportsHTML5Elements) wrap = [0, '', ''];
			if (!wrap) return set.call(this, html);

			var level = wrap[0], wrapper = document.createElement('div'), target = wrapper;
			if (!supportsHTML5Elements) fragment.appendChild(wrapper);
			wrapper.innerHTML = [wrap[1], html, wrap[2]].flatten().join('');
			while (level--) target = target.firstChild;
			this.empty().adopt(target.childNodes);
			if (!supportsHTML5Elements) fragment.removeChild(wrapper);
			wrapper = null;
		};

	})(Element.Properties.html.set);
}
/*</IE>*/

/*<ltIE9>*/
var testForm = document.createElement('form');
testForm.innerHTML = '<select><option>s</option></select>';

if (testForm.firstChild.value != 's') Element.Properties.value = {

	set: function(value){
		var tag = this.get('tag');
		if (tag != 'select') return this.setProperty('value', value);
		var options = this.getElements('option');
		value = String(value);
		for (var i = 0; i < options.length; i++){
			var option = options[i],
				attr = option.getAttributeNode('value'),
				optionValue = (attr && attr.specified) ? option.value : option.get('text');
			if (optionValue === value) return option.selected = true;
		}
	},

	get: function(){
		var option = this, tag = option.get('tag');

		if (tag != 'select' && tag != 'option') return this.getProperty('value');

		if (tag == 'select' && !(option = option.getSelected()[0])) return '';

		var attr = option.getAttributeNode('value');
		return (attr && attr.specified) ? option.value : option.get('text');
	}

};
testForm = null;
/*</ltIE9>*/

/*<IE>*/
if (document.createElement('div').getAttributeNode('id')) Element.Properties.id = {
	set: function(id){
		this.id = this.getAttributeNode('id').value = id;
	},
	get: function(){
		return this.id || null;
	},
	erase: function(){
		this.id = this.getAttributeNode('id').value = '';
	}
};
/*</IE>*/

})();

/*
---

name: Event

description: Contains the Event Type, to make the event object cross-browser.

license: MIT-style license.

requires: [Window, Document, Array, Function, String, Object]

provides: Event

...
*/

(function(){

var _keys = {};
var normalizeWheelSpeed = function(event){
    var normalized;
    if (event.wheelDelta){
        normalized = event.wheelDelta % 120 == 0 ? event.wheelDelta / 120 : event.wheelDelta / 12;
    } else {
        var rawAmount = event.deltaY || event.detail || 0;
        normalized = -(rawAmount % 3 == 0 ? rawAmount / 3 : rawAmount * 10);
    }
    return normalized;
}

var DOMEvent = this.DOMEvent = new Type('DOMEvent', function(event, win){
	if (!win) win = window;
	event = event || win.event;
	if (event.$extended) return event;
	this.event = event;
	this.$extended = true;
	this.shift = event.shiftKey;
	this.control = event.ctrlKey;
	this.alt = event.altKey;
	this.meta = event.metaKey;
	var type = this.type = event.type;
	var target = event.target || event.srcElement;
	while (target && target.nodeType == 3) target = target.parentNode;
	this.target = document.id(target);

	if (type.indexOf('key') == 0){
		var code = this.code = (event.which || event.keyCode);
		this.key = _keys[code]/*<1.3compat>*/ || Object.keyOf(Event.Keys, code)/*</1.3compat>*/;
		if (type == 'keydown' || type == 'keyup'){
			if (code > 111 && code < 124) this.key = 'f' + (code - 111);
			else if (code > 95 && code < 106) this.key = code - 96;
		}
		if (this.key == null) this.key = String.fromCharCode(code).toLowerCase();
	} else if (type == 'click' || type == 'dblclick' || type == 'contextmenu' || type == 'wheel' || type == 'DOMMouseScroll' || type.indexOf('mouse') == 0){
		var doc = win.document;
		doc = (!doc.compatMode || doc.compatMode == 'CSS1Compat') ? doc.html : doc.body;
		this.page = {
			x: (event.pageX != null) ? event.pageX : event.clientX + doc.scrollLeft,
			y: (event.pageY != null) ? event.pageY : event.clientY + doc.scrollTop
		};
		this.client = {
			x: (event.pageX != null) ? event.pageX - win.pageXOffset : event.clientX,
			y: (event.pageY != null) ? event.pageY - win.pageYOffset : event.clientY
		};
		if (type == 'DOMMouseScroll' || type == 'wheel' || type == 'mousewheel') this.wheel = normalizeWheelSpeed(event);
		this.rightClick = (event.which == 3 || event.button == 2);
		if (type == 'mouseover' || type == 'mouseout'){
			var related = event.relatedTarget || event[(type == 'mouseover' ? 'from' : 'to') + 'Element'];
			while (related && related.nodeType == 3) related = related.parentNode;
			this.relatedTarget = document.id(related);
		}
	} else if (type.indexOf('touch') == 0 || type.indexOf('gesture') == 0){
		this.rotation = event.rotation;
		this.scale = event.scale;
		this.targetTouches = event.targetTouches;
		this.changedTouches = event.changedTouches;
		var touches = this.touches = event.touches;
		if (touches && touches[0]){
			var touch = touches[0];
			this.page = {x: touch.pageX, y: touch.pageY};
			this.client = {x: touch.clientX, y: touch.clientY};
		}
	}

	if (!this.client) this.client = {};
	if (!this.page) this.page = {};
});

DOMEvent.implement({

	stop: function(){
		return this.preventDefault().stopPropagation();
	},

	stopPropagation: function(){
		if (this.event.stopPropagation) this.event.stopPropagation();
		else this.event.cancelBubble = true;
		return this;
	},

	preventDefault: function(){
		if (this.event.preventDefault) this.event.preventDefault();
		else this.event.returnValue = false;
		return this;
	}

});

DOMEvent.defineKey = function(code, key){
	_keys[code] = key;
	return this;
};

DOMEvent.defineKeys = DOMEvent.defineKey.overloadSetter(true);

DOMEvent.defineKeys({
	'38': 'up', '40': 'down', '37': 'left', '39': 'right',
	'27': 'esc', '32': 'space', '8': 'backspace', '9': 'tab',
	'46': 'delete', '13': 'enter'
});

})();

/*<1.3compat>*/
var Event = DOMEvent;
Event.Keys = {};
/*</1.3compat>*/

/*<1.2compat>*/

Event.Keys = new Hash(Event.Keys);

/*</1.2compat>*/

/*
---

name: Element.Event

description: Contains Element methods for dealing with events. This file also includes mouseenter and mouseleave custom Element Events, if necessary.

license: MIT-style license.

requires: [Element, Event]

provides: Element.Event

...
*/

(function(){

Element.Properties.events = {set: function(events){
	this.addEvents(events);
}};

[Element, Window, Document].invoke('implement', {

	addEvent: function(type, fn){
		var events = this.retrieve('events', {});
		if (!events[type]) events[type] = {keys: [], values: []};
		if (events[type].keys.contains(fn)) return this;
		events[type].keys.push(fn);
		var realType = type,
			custom = Element.Events[type],
			condition = fn,
			self = this;
		if (custom){
			if (custom.onAdd) custom.onAdd.call(this, fn, type);
			if (custom.condition){
				condition = function(event){
					if (custom.condition.call(this, event, type)) return fn.call(this, event);
					return true;
				};
			}
			if (custom.base) realType = Function.from(custom.base).call(this, type);
		}
		var defn = function(){
			return fn.call(self);
		};
		var nativeEvent = Element.NativeEvents[realType];
		if (nativeEvent){
			if (nativeEvent == 2){
				defn = function(event){
					event = new DOMEvent(event, self.getWindow());
					if (condition.call(self, event) === false) event.stop();
				};
			}
			this.addListener(realType, defn, arguments[2]);
		}
		events[type].values.push(defn);
		return this;
	},

	removeEvent: function(type, fn){
		var events = this.retrieve('events');
		if (!events || !events[type]) return this;
		var list = events[type];
		var index = list.keys.indexOf(fn);
		if (index == -1) return this;
		var value = list.values[index];
		delete list.keys[index];
		delete list.values[index];
		var custom = Element.Events[type];
		if (custom){
			if (custom.onRemove) custom.onRemove.call(this, fn, type);
			if (custom.base) type = Function.from(custom.base).call(this, type);
		}
		return (Element.NativeEvents[type]) ? this.removeListener(type, value, arguments[2]) : this;
	},

	addEvents: function(events){
		for (var event in events) this.addEvent(event, events[event]);
		return this;
	},

	removeEvents: function(events){
		var type;
		if (typeOf(events) == 'object'){
			for (type in events) this.removeEvent(type, events[type]);
			return this;
		}
		var attached = this.retrieve('events');
		if (!attached) return this;
		if (!events){
			for (type in attached) this.removeEvents(type);
			this.eliminate('events');
		} else if (attached[events]){
			attached[events].keys.each(function(fn){
				this.removeEvent(events, fn);
			}, this);
			delete attached[events];
		}
		return this;
	},

	fireEvent: function(type, args, delay){
		var events = this.retrieve('events');
		if (!events || !events[type]) return this;
		args = Array.from(args);

		events[type].keys.each(function(fn){
			if (delay) fn.delay(delay, this, args);
			else fn.apply(this, args);
		}, this);
		return this;
	},

	cloneEvents: function(from, type){
		from = document.id(from);
		var events = from.retrieve('events');
		if (!events) return this;
		if (!type){
			for (var eventType in events) this.cloneEvents(from, eventType);
		} else if (events[type]){
			events[type].keys.each(function(fn){
				this.addEvent(type, fn);
			}, this);
		}
		return this;
	}

});

Element.NativeEvents = {
	click: 2, dblclick: 2, mouseup: 2, mousedown: 2, contextmenu: 2, //mouse buttons
	wheel: 2, mousewheel: 2, DOMMouseScroll: 2, //mouse wheel
	mouseover: 2, mouseout: 2, mousemove: 2, selectstart: 2, selectend: 2, //mouse movement
	keydown: 2, keypress: 2, keyup: 2, //keyboard
	orientationchange: 2, // mobile
	touchstart: 2, touchmove: 2, touchend: 2, touchcancel: 2, // touch
	gesturestart: 2, gesturechange: 2, gestureend: 2, // gesture
	focus: 2, blur: 2, change: 2, reset: 2, select: 2, submit: 2, paste: 2, input: 2, //form elements
	load: 2, unload: 1, beforeunload: 2, resize: 1, move: 1, DOMContentLoaded: 1, readystatechange: 1, //window
	hashchange: 1, popstate: 2, // history
	error: 1, abort: 1, scroll: 1, message: 2 //misc
};

Element.Events = {
	mousewheel: {
		base: 'onwheel' in document ? 'wheel' : 'onmousewheel' in document ? 'mousewheel' : 'DOMMouseScroll'
	}
};

var check = function(event){
	var related = event.relatedTarget;
	if (related == null) return true;
	if (!related) return false;
	return (related != this && related.prefix != 'xul' && typeOf(this) != 'document' && !this.contains(related));
};

if ('onmouseenter' in document.documentElement){
	Element.NativeEvents.mouseenter = Element.NativeEvents.mouseleave = 2;
	Element.MouseenterCheck = check;
} else {
	Element.Events.mouseenter = {
		base: 'mouseover',
		condition: check
	};

	Element.Events.mouseleave = {
		base: 'mouseout',
		condition: check
	};
}

/*<ltIE9>*/
if (!window.addEventListener){
	Element.NativeEvents.propertychange = 2;
	Element.Events.change = {
		base: function(){
			var type = this.type;
			return (this.get('tag') == 'input' && (type == 'radio' || type == 'checkbox')) ? 'propertychange' : 'change';
		},
		condition: function(event){
			return event.type != 'propertychange' || event.event.propertyName == 'checked';
		}
	};
}
/*</ltIE9>*/

//<1.2compat>

Element.Events = new Hash(Element.Events);

//</1.2compat>

})();

/*
---

name: Element.Delegation

description: Extends the Element native object to include the delegate method for more efficient event management.

license: MIT-style license.

requires: [Element.Event]

provides: [Element.Delegation]

...
*/

(function(){

var eventListenerSupport = !!window.addEventListener;

Element.NativeEvents.focusin = Element.NativeEvents.focusout = 2;

var bubbleUp = function(self, match, fn, event, target){
	while (target && target != self){
		if (match(target, event)) return fn.call(target, event, target);
		target = document.id(target.parentNode);
	}
};

var map = {
	mouseenter: {
		base: 'mouseover',
		condition: Element.MouseenterCheck
	},
	mouseleave: {
		base: 'mouseout',
		condition: Element.MouseenterCheck
	},
	focus: {
		base: 'focus' + (eventListenerSupport ? '' : 'in'),
		capture: true
	},
	blur: {
		base: eventListenerSupport ? 'blur' : 'focusout',
		capture: true
	}
};

/*<ltIE9>*/
var _key = '$delegation:';
var formObserver = function(type){

	return {

		base: 'focusin',

		remove: function(self, uid){
			var list = self.retrieve(_key + type + 'listeners', {})[uid];
			if (list && list.forms) for (var i = list.forms.length; i--;){
				// the form may have been destroyed, so it won't have the
				// removeEvent method anymore. In that case the event was
				// removed as well.
				if (list.forms[i].removeEvent) list.forms[i].removeEvent(type, list.fns[i]);
			}
		},

		listen: function(self, match, fn, event, target, uid){
			var form = (target.get('tag') == 'form') ? target : event.target.getParent('form');
			if (!form) return;

			var listeners = self.retrieve(_key + type + 'listeners', {}),
				listener = listeners[uid] || {forms: [], fns: []},
				forms = listener.forms, fns = listener.fns;

			if (forms.indexOf(form) != -1) return;
			forms.push(form);

			var _fn = function(event){
				bubbleUp(self, match, fn, event, target);
			};
			form.addEvent(type, _fn);
			fns.push(_fn);

			listeners[uid] = listener;
			self.store(_key + type + 'listeners', listeners);
		}
	};
};

var inputObserver = function(type){
	return {
		base: 'focusin',
		listen: function(self, match, fn, event, target){
			var events = {blur: function(){
				this.removeEvents(events);
			}};
			events[type] = function(event){
				bubbleUp(self, match, fn, event, target);
			};
			event.target.addEvents(events);
		}
	};
};

if (!eventListenerSupport) Object.append(map, {
	submit: formObserver('submit'),
	reset: formObserver('reset'),
	change: inputObserver('change'),
	select: inputObserver('select')
});
/*</ltIE9>*/

var proto = Element.prototype,
	addEvent = proto.addEvent,
	removeEvent = proto.removeEvent;

var relay = function(old, method){
	return function(type, fn, useCapture){
		if (type.indexOf(':relay') == -1) return old.call(this, type, fn, useCapture);
		var parsed = Slick.parse(type).expressions[0][0];
		if (parsed.pseudos[0].key != 'relay') return old.call(this, type, fn, useCapture);
		var newType = parsed.tag;
		parsed.pseudos.slice(1).each(function(pseudo){
			newType += ':' + pseudo.key + (pseudo.value ? '(' + pseudo.value + ')' : '');
		});
		old.call(this, type, fn);
		return method.call(this, newType, parsed.pseudos[0].value, fn);
	};
};

var delegation = {

	addEvent: function(type, match, fn){
		var storage = this.retrieve('$delegates', {}), stored = storage[type];
		if (stored) for (var _uid in stored){
			if (stored[_uid].fn == fn && stored[_uid].match == match) return this;
		}

		var _type = type, _match = match, _fn = fn, _map = map[type] || {};
		type = _map.base || _type;

		match = function(target){
			return Slick.match(target, _match);
		};

		var elementEvent = Element.Events[_type];
		if (_map.condition || elementEvent && elementEvent.condition){
			var __match = match, condition = _map.condition || elementEvent.condition;
			match = function(target, event){
				return __match(target, event) && condition.call(target, event, type);
			};
		}

		var self = this, uid = String.uniqueID();
		var delegator = _map.listen ? function(event, target){
			if (!target && event && event.target) target = event.target;
			if (target) _map.listen(self, match, fn, event, target, uid);
		} : function(event, target){
			if (!target && event && event.target) target = event.target;
			if (target) bubbleUp(self, match, fn, event, target);
		};

		if (!stored) stored = {};
		stored[uid] = {
			match: _match,
			fn: _fn,
			delegator: delegator
		};
		storage[_type] = stored;
		return addEvent.call(this, type, delegator, _map.capture);
	},

	removeEvent: function(type, match, fn, _uid){
		var storage = this.retrieve('$delegates', {}), stored = storage[type];
		if (!stored) return this;

		if (_uid){
			var _type = type, delegator = stored[_uid].delegator, _map = map[type] || {};
			type = _map.base || _type;
			if (_map.remove) _map.remove(this, _uid);
			delete stored[_uid];
			storage[_type] = stored;
			return removeEvent.call(this, type, delegator, _map.capture);
		}

		var __uid, s;
		if (fn) for (__uid in stored){
			s = stored[__uid];
			if (s.match == match && s.fn == fn) return delegation.removeEvent.call(this, type, match, fn, __uid);
		} else for (__uid in stored){
			s = stored[__uid];
			if (s.match == match) delegation.removeEvent.call(this, type, match, s.fn, __uid);
		}
		return this;
	}

};

[Element, Window, Document].invoke('implement', {
	addEvent: relay(addEvent, delegation.addEvent),
	removeEvent: relay(removeEvent, delegation.removeEvent)
});

})();

/*
---

name: Element.Style

description: Contains methods for interacting with the styles of Elements in a fashionable way.

license: MIT-style license.

requires: Element

provides: Element.Style

...
*/

(function(){

var html = document.html, el;

//<ltIE9>
// Check for oldIE, which does not remove styles when they're set to null
el = document.createElement('div');
el.style.color = 'red';
el.style.color = null;
var doesNotRemoveStyles = el.style.color == 'red';

// check for oldIE, which returns border* shorthand styles in the wrong order (color-width-style instead of width-style-color)
var border = '1px solid #123abc';
el.style.border = border;
var returnsBordersInWrongOrder = el.style.border != border;
el = null;
//</ltIE9>

var hasGetComputedStyle = !!window.getComputedStyle,
	supportBorderRadius = document.createElement('div').style.borderRadius != null;

Element.Properties.styles = {set: function(styles){
	this.setStyles(styles);
}};

var hasOpacity = (html.style.opacity != null),
	hasFilter = (html.style.filter != null),
	reAlpha = /alpha\(opacity=([\d.]+)\)/i;

var setVisibility = function(element, opacity){
	element.store('$opacity', opacity);
	element.style.visibility = opacity > 0 || opacity == null ? 'visible' : 'hidden';
};

//<ltIE9>
var setFilter = function(element, regexp, value){
	var style = element.style,
		filter = style.filter || element.getComputedStyle('filter') || '';
	style.filter = (regexp.test(filter) ? filter.replace(regexp, value) : filter + ' ' + value).trim();
	if (!style.filter) style.removeAttribute('filter');
};
//</ltIE9>

var setOpacity = (hasOpacity ? function(element, opacity){
	element.style.opacity = opacity;
} : (hasFilter ? function(element, opacity){
	if (!element.currentStyle || !element.currentStyle.hasLayout) element.style.zoom = 1;
	if (opacity == null || opacity == 1){
		setFilter(element, reAlpha, '');
		if (opacity == 1 && getOpacity(element) != 1) setFilter(element, reAlpha, 'alpha(opacity=100)');
	} else {
		setFilter(element, reAlpha, 'alpha(opacity=' + (opacity * 100).limit(0, 100).round() + ')');
	}
} : setVisibility));

var getOpacity = (hasOpacity ? function(element){
	var opacity = element.style.opacity || element.getComputedStyle('opacity');
	return (opacity == '') ? 1 : opacity.toFloat();
} : (hasFilter ? function(element){
	var filter = (element.style.filter || element.getComputedStyle('filter')),
		opacity;
	if (filter) opacity = filter.match(reAlpha);
	return (opacity == null || filter == null) ? 1 : (opacity[1] / 100);
} : function(element){
	var opacity = element.retrieve('$opacity');
	if (opacity == null) opacity = (element.style.visibility == 'hidden' ? 0 : 1);
	return opacity;
}));

var floatName = (html.style.cssFloat == null) ? 'styleFloat' : 'cssFloat',
	namedPositions = {left: '0%', top: '0%', center: '50%', right: '100%', bottom: '100%'},
	hasBackgroundPositionXY = (html.style.backgroundPositionX != null);

//<ltIE9>
var removeStyle = function(style, property){
	if (property == 'backgroundPosition'){
		style.removeAttribute(property + 'X');
		property += 'Y';
	}
	style.removeAttribute(property);
};
//</ltIE9>

Element.implement({

	getComputedStyle: function(property){
		if (!hasGetComputedStyle && this.currentStyle) return this.currentStyle[property.camelCase()];
		var defaultView = Element.getDocument(this).defaultView,
			computed = defaultView ? defaultView.getComputedStyle(this, null) : null;
		return (computed) ? computed.getPropertyValue((property == floatName) ? 'float' : property.hyphenate()) : '';
	},

	setStyle: function(property, value){
		if (property == 'opacity'){
			if (value != null) value = parseFloat(value);
			setOpacity(this, value);
			return this;
		}
		property = (property == 'float' ? floatName : property).camelCase();
		if (typeOf(value) != 'string'){
			var map = (Element.Styles[property] || '@').split(' ');
			value = Array.from(value).map(function(val, i){
				if (!map[i]) return '';
				return (typeOf(val) == 'number') ? map[i].replace('@', Math.round(val)) : val;
			}).join(' ');
		} else if (value == String(Number(value))){
			value = Math.round(value);
		}
		this.style[property] = value;
		//<ltIE9>
		if ((value == '' || value == null) && doesNotRemoveStyles && this.style.removeAttribute){
			removeStyle(this.style, property);
		}
		//</ltIE9>
		return this;
	},

	getStyle: function(property){
		if (property == 'opacity') return getOpacity(this);
		property = (property == 'float' ? floatName : property).camelCase();
		if (supportBorderRadius && property.indexOf('borderRadius') != -1){
			return ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'].map(function(corner){
				return this.style[corner] || '0px';
			}, this).join(' ');
		}
		var result = this.style[property];
		if (!result || property == 'zIndex'){
			if (Element.ShortStyles.hasOwnProperty(property)){
				result = [];
				for (var s in Element.ShortStyles[property]) result.push(this.getStyle(s));
				return result.join(' ');
			}
			result = this.getComputedStyle(property);
		}
		if (hasBackgroundPositionXY && /^backgroundPosition[XY]?$/.test(property)){
			return result.replace(/(top|right|bottom|left)/g, function(position){
				return namedPositions[position];
			}) || '0px';
		}
		if (!result && property == 'backgroundPosition') return '0px 0px';
		if (result){
			result = String(result);
			var color = result.match(/rgba?\([\d\s,]+\)/);
			if (color) result = result.replace(color[0], color[0].rgbToHex());
		}
		if (!hasGetComputedStyle && !this.style[property]){
			if ((/^(height|width)$/).test(property) && !(/px$/.test(result))){
				var values = (property == 'width') ? ['left', 'right'] : ['top', 'bottom'], size = 0;
				values.each(function(value){
					size += this.getStyle('border-' + value + '-width').toInt() + this.getStyle('padding-' + value).toInt();
				}, this);
				return this['offset' + property.capitalize()] - size + 'px';
			}
			if ((/^border(.+)Width|margin|padding/).test(property) && isNaN(parseFloat(result))){
				return '0px';
			}
		}
		//<ltIE9>
		if (returnsBordersInWrongOrder && /^border(Top|Right|Bottom|Left)?$/.test(property) && /^#/.test(result)){
			return result.replace(/^(.+)\s(.+)\s(.+)$/, '$2 $3 $1');
		}
		//</ltIE9>

		return result;
	},

	setStyles: function(styles){
		for (var style in styles) this.setStyle(style, styles[style]);
		return this;
	},

	getStyles: function(){
		var result = {};
		Array.flatten(arguments).each(function(key){
			result[key] = this.getStyle(key);
		}, this);
		return result;
	}

});

Element.Styles = {
	left: '@px', top: '@px', bottom: '@px', right: '@px',
	width: '@px', height: '@px', maxWidth: '@px', maxHeight: '@px', minWidth: '@px', minHeight: '@px',
	backgroundColor: 'rgb(@, @, @)', backgroundSize: '@px', backgroundPosition: '@px @px', color: 'rgb(@, @, @)',
	fontSize: '@px', letterSpacing: '@px', lineHeight: '@px', clip: 'rect(@px @px @px @px)',
	margin: '@px @px @px @px', padding: '@px @px @px @px', border: '@px @ rgb(@, @, @) @px @ rgb(@, @, @) @px @ rgb(@, @, @)',
	borderWidth: '@px @px @px @px', borderStyle: '@ @ @ @', borderColor: 'rgb(@, @, @) rgb(@, @, @) rgb(@, @, @) rgb(@, @, @)',
	zIndex: '@', 'zoom': '@', fontWeight: '@', textIndent: '@px', opacity: '@', borderRadius: '@px @px @px @px'
};

//<1.3compat>

Element.implement({

	setOpacity: function(value){
		setOpacity(this, value);
		return this;
	},

	getOpacity: function(){
		return getOpacity(this);
	}

});

Element.Properties.opacity = {

	set: function(opacity){
		setOpacity(this, opacity);
		setVisibility(this, opacity);
	},

	get: function(){
		return getOpacity(this);
	}

};

//</1.3compat>

//<1.2compat>

Element.Styles = new Hash(Element.Styles);

//</1.2compat>

Element.ShortStyles = {margin: {}, padding: {}, border: {}, borderWidth: {}, borderStyle: {}, borderColor: {}};

['Top', 'Right', 'Bottom', 'Left'].each(function(direction){
	var Short = Element.ShortStyles;
	var All = Element.Styles;
	['margin', 'padding'].each(function(style){
		var sd = style + direction;
		Short[style][sd] = All[sd] = '@px';
	});
	var bd = 'border' + direction;
	Short.border[bd] = All[bd] = '@px @ rgb(@, @, @)';
	var bdw = bd + 'Width', bds = bd + 'Style', bdc = bd + 'Color';
	Short[bd] = {};
	Short.borderWidth[bdw] = Short[bd][bdw] = All[bdw] = '@px';
	Short.borderStyle[bds] = Short[bd][bds] = All[bds] = '@';
	Short.borderColor[bdc] = Short[bd][bdc] = All[bdc] = 'rgb(@, @, @)';
});

if (hasBackgroundPositionXY) Element.ShortStyles.backgroundPosition = {backgroundPositionX: '@', backgroundPositionY: '@'};
})();

/*
---

name: Element.Dimensions

description: Contains methods to work with size, scroll, or positioning of Elements and the window object.

license: MIT-style license.

credits:
  - Element positioning based on the [qooxdoo](http://qooxdoo.org/) code and smart browser fixes, [LGPL License](http://www.gnu.org/licenses/lgpl.html).
  - Viewport dimensions based on [YUI](http://developer.yahoo.com/yui/) code, [BSD License](http://developer.yahoo.com/yui/license.html).

requires: [Element, Element.Style]

provides: [Element.Dimensions]

...
*/

(function(){

var element = document.createElement('div'),
	child = document.createElement('div');
element.style.height = '0';
element.appendChild(child);
var brokenOffsetParent = (child.offsetParent === element);
element = child = null;

var heightComponents = ['height', 'paddingTop', 'paddingBottom', 'borderTopWidth', 'borderBottomWidth'],
	widthComponents = ['width', 'paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'];

var svgCalculateSize = function(el){

	var gCS = window.getComputedStyle(el),
		bounds = {x: 0, y: 0};

	heightComponents.each(function(css){
		bounds.y += parseFloat(gCS[css]);
	});
	widthComponents.each(function(css){
		bounds.x += parseFloat(gCS[css]);
	});
	return bounds;
};

var isOffset = function(el){
	return styleString(el, 'position') != 'static' || isBody(el);
};

var isOffsetStatic = function(el){
	return isOffset(el) || (/^(?:table|td|th)$/i).test(el.tagName);
};

Element.implement({

	scrollTo: function(x, y){
		if (isBody(this)){
			this.getWindow().scrollTo(x, y);
		} else {
			this.scrollLeft = x;
			this.scrollTop = y;
		}
		return this;
	},

	getSize: function(){
		if (isBody(this)) return this.getWindow().getSize();

		//<ltIE9>
		// This if clause is because IE8- cannot calculate getBoundingClientRect of elements with visibility hidden.
		if (!window.getComputedStyle) return {x: this.offsetWidth, y: this.offsetHeight};
		//</ltIE9>

		// This svg section under, calling `svgCalculateSize()`, can be removed when FF fixed the svg size bug.
		// Bug info: https://bugzilla.mozilla.org/show_bug.cgi?id=530985
		if (this.get('tag') == 'svg') return svgCalculateSize(this);
		
		var bounds = this.getBoundingClientRect();
		return {x: bounds.width, y: bounds.height};
	},

	getScrollSize: function(){
		if (isBody(this)) return this.getWindow().getScrollSize();
		return {x: this.scrollWidth, y: this.scrollHeight};
	},

	getScroll: function(){
		if (isBody(this)) return this.getWindow().getScroll();
		return {x: this.scrollLeft, y: this.scrollTop};
	},

	getScrolls: function(){
		var element = this.parentNode, position = {x: 0, y: 0};
		while (element && !isBody(element)){
			position.x += element.scrollLeft;
			position.y += element.scrollTop;
			element = element.parentNode;
		}
		return position;
	},

	getOffsetParent: brokenOffsetParent ? function(){
		var element = this;
		if (isBody(element) || styleString(element, 'position') == 'fixed') return null;

		var isOffsetCheck = (styleString(element, 'position') == 'static') ? isOffsetStatic : isOffset;
		while ((element = element.parentNode)){
			if (isOffsetCheck(element)) return element;
		}
		return null;
	} : function(){
		var element = this;
		if (isBody(element) || styleString(element, 'position') == 'fixed') return null;

		try {
			return element.offsetParent;
		} catch(e){}
		return null;
	},

	getOffsets: function(){
		var hasGetBoundingClientRect = this.getBoundingClientRect;
//<1.4compat>
		hasGetBoundingClientRect = hasGetBoundingClientRect && !Browser.Platform.ios
//</1.4compat>
		if (hasGetBoundingClientRect){
			var bound = this.getBoundingClientRect(),
				html = document.id(this.getDocument().documentElement),
				htmlScroll = html.getScroll(),
				elemScrolls = this.getScrolls(),
				isFixed = (styleString(this, 'position') == 'fixed');

			return {
				x: bound.left.toInt() + elemScrolls.x + ((isFixed) ? 0 : htmlScroll.x) - html.clientLeft,
				y: bound.top.toInt() + elemScrolls.y + ((isFixed) ? 0 : htmlScroll.y) - html.clientTop
			};
		}

		var element = this, position = {x: 0, y: 0};
		if (isBody(this)) return position;

		while (element && !isBody(element)){
			position.x += element.offsetLeft;
			position.y += element.offsetTop;
//<1.4compat>
			if (Browser.firefox){
				if (!borderBox(element)){
					position.x += leftBorder(element);
					position.y += topBorder(element);
				}
				var parent = element.parentNode;
				if (parent && styleString(parent, 'overflow') != 'visible'){
					position.x += leftBorder(parent);
					position.y += topBorder(parent);
				}
			} else if (element != this && Browser.safari){
				position.x += leftBorder(element);
				position.y += topBorder(element);
			}
//</1.4compat>
			element = element.offsetParent;
		}
//<1.4compat>
		if (Browser.firefox && !borderBox(this)){
			position.x -= leftBorder(this);
			position.y -= topBorder(this);
		}
//</1.4compat>
		return position;
	},

	getPosition: function(relative){
		var offset = this.getOffsets(),
			scroll = this.getScrolls();
		var position = {
			x: offset.x - scroll.x,
			y: offset.y - scroll.y
		};

		if (relative && (relative = document.id(relative))){
			var relativePosition = relative.getPosition();
			return {x: position.x - relativePosition.x - leftBorder(relative), y: position.y - relativePosition.y - topBorder(relative)};
		}
		return position;
	},

	getCoordinates: function(element){
		if (isBody(this)) return this.getWindow().getCoordinates();
		var position = this.getPosition(element),
			size = this.getSize();
		var obj = {
			left: position.x,
			top: position.y,
			width: size.x,
			height: size.y
		};
		obj.right = obj.left + obj.width;
		obj.bottom = obj.top + obj.height;
		return obj;
	},

	computePosition: function(obj){
		return {
			left: obj.x - styleNumber(this, 'margin-left'),
			top: obj.y - styleNumber(this, 'margin-top')
		};
	},

	setPosition: function(obj){
		return this.setStyles(this.computePosition(obj));
	}

});


[Document, Window].invoke('implement', {

	getSize: function(){
		var doc = getCompatElement(this);
		return {x: doc.clientWidth, y: doc.clientHeight};
	},

	getScroll: function(){
		var win = this.getWindow(), doc = getCompatElement(this);
		return {x: win.pageXOffset || doc.scrollLeft, y: win.pageYOffset || doc.scrollTop};
	},

	getScrollSize: function(){
		var doc = getCompatElement(this),
			min = this.getSize(),
			body = this.getDocument().body;

		return {x: Math.max(doc.scrollWidth, body.scrollWidth, min.x), y: Math.max(doc.scrollHeight, body.scrollHeight, min.y)};
	},

	getPosition: function(){
		return {x: 0, y: 0};
	},

	getCoordinates: function(){
		var size = this.getSize();
		return {top: 0, left: 0, bottom: size.y, right: size.x, height: size.y, width: size.x};
	}

});

// private methods

var styleString = Element.getComputedStyle;

function styleNumber(element, style){
	return styleString(element, style).toInt() || 0;
}

function borderBox(element){
	return styleString(element, '-moz-box-sizing') == 'border-box';
}

function topBorder(element){
	return styleNumber(element, 'border-top-width');
}

function leftBorder(element){
	return styleNumber(element, 'border-left-width');
}

function isBody(element){
	return (/^(?:body|html)$/i).test(element.tagName);
}

function getCompatElement(element){
	var doc = element.getDocument();
	return (!doc.compatMode || doc.compatMode == 'CSS1Compat') ? doc.html : doc.body;
}

})();

//aliases
Element.alias({position: 'setPosition'}); //compatability

[Window, Document, Element].invoke('implement', {

	getHeight: function(){
		return this.getSize().y;
	},

	getWidth: function(){
		return this.getSize().x;
	},

	getScrollTop: function(){
		return this.getScroll().y;
	},

	getScrollLeft: function(){
		return this.getScroll().x;
	},

	getScrollHeight: function(){
		return this.getScrollSize().y;
	},

	getScrollWidth: function(){
		return this.getScrollSize().x;
	},

	getTop: function(){
		return this.getPosition().y;
	},

	getLeft: function(){
		return this.getPosition().x;
	}

});

/*
---

name: Fx

description: Contains the basic animation logic to be extended by all other Fx Classes.

license: MIT-style license.

requires: [Chain, Events, Options]

provides: Fx

...
*/

(function(){

var Fx = this.Fx = new Class({

	Implements: [Chain, Events, Options],

	options: {
		/*
		onStart: nil,
		onCancel: nil,
		onComplete: nil,
		*/
		fps: 60,
		unit: false,
		duration: 500,
		frames: null,
		frameSkip: true,
		link: 'ignore'
	},

	initialize: function(options){
		this.subject = this.subject || this;
		this.setOptions(options);
	},

	getTransition: function(){
		return function(p){
			return -(Math.cos(Math.PI * p) - 1) / 2;
		};
	},

	step: function(now){
		if (this.options.frameSkip){
			var diff = (this.time != null) ? (now - this.time) : 0, frames = diff / this.frameInterval;
			this.time = now;
			this.frame += frames;
		} else {
			this.frame++;
		}

		if (this.frame < this.frames){
			var delta = this.transition(this.frame / this.frames);
			this.set(this.compute(this.from, this.to, delta));
		} else {
			this.frame = this.frames;
			this.set(this.compute(this.from, this.to, 1));
			this.stop();
		}
	},

	set: function(now){
		return now;
	},

	compute: function(from, to, delta){
		return Fx.compute(from, to, delta);
	},

	check: function(){
		if (!this.isRunning()) return true;
		switch (this.options.link){
			case 'cancel': this.cancel(); return true;
			case 'chain': this.chain(this.caller.pass(arguments, this)); return false;
		}
		return false;
	},

	start: function(from, to){
		if (!this.check(from, to)) return this;
		this.from = from;
		this.to = to;
		this.frame = (this.options.frameSkip) ? 0 : -1;
		this.time = null;
		this.transition = this.getTransition();
		var frames = this.options.frames, fps = this.options.fps, duration = this.options.duration;
		this.duration = Fx.Durations[duration] || duration.toInt();
		this.frameInterval = 1000 / fps;
		this.frames = frames || Math.round(this.duration / this.frameInterval);
		this.fireEvent('start', this.subject);
		pushInstance.call(this, fps);
		return this;
	},

	stop: function(){
		if (this.isRunning()){
			this.time = null;
			pullInstance.call(this, this.options.fps);
			if (this.frames == this.frame){
				this.fireEvent('complete', this.subject);
				if (!this.callChain()) this.fireEvent('chainComplete', this.subject);
			} else {
				this.fireEvent('stop', this.subject);
			}
		}
		return this;
	},

	cancel: function(){
		if (this.isRunning()){
			this.time = null;
			pullInstance.call(this, this.options.fps);
			this.frame = this.frames;
			this.fireEvent('cancel', this.subject).clearChain();
		}
		return this;
	},

	pause: function(){
		if (this.isRunning()){
			this.time = null;
			pullInstance.call(this, this.options.fps);
		}
		return this;
	},

	resume: function(){
		if (this.isPaused()) pushInstance.call(this, this.options.fps);
		return this;
	},

	isRunning: function(){
		var list = instances[this.options.fps];
		return list && list.contains(this);
	},

	isPaused: function(){
		return (this.frame < this.frames) && !this.isRunning();
	}

});

Fx.compute = function(from, to, delta){
	return (to - from) * delta + from;
};

Fx.Durations = {'short': 250, 'normal': 500, 'long': 1000};

// global timers

var instances = {}, timers = {};

var loop = function(){
	var now = Date.now();
	for (var i = this.length; i--;){
		var instance = this[i];
		if (instance) instance.step(now);
	}
};

var pushInstance = function(fps){
	var list = instances[fps] || (instances[fps] = []);
	list.push(this);
	if (!timers[fps]) timers[fps] = loop.periodical(Math.round(1000 / fps), list);
};

var pullInstance = function(fps){
	var list = instances[fps];
	if (list){
		list.erase(this);
		if (!list.length && timers[fps]){
			delete instances[fps];
			timers[fps] = clearInterval(timers[fps]);
		}
	}
};

})();

/*
---

name: Fx.CSS

description: Contains the CSS animation logic. Used by Fx.Tween, Fx.Morph, Fx.Elements.

license: MIT-style license.

requires: [Fx, Element.Style]

provides: Fx.CSS

...
*/

Fx.CSS = new Class({

	Extends: Fx,

	//prepares the base from/to object

	prepare: function(element, property, values){
		values = Array.from(values);
		var from = values[0], to = values[1];
		if (to == null){
			to = from;
			from = element.getStyle(property);
			var unit = this.options.unit;
			// adapted from: https://github.com/ryanmorr/fx/blob/master/fx.js#L299
			if (unit && from && typeof from == 'string' && from.slice(-unit.length) != unit && parseFloat(from) != 0){
				element.setStyle(property, to + unit);
				var value = element.getComputedStyle(property);
				// IE and Opera support pixelLeft or pixelWidth
				if (!(/px$/.test(value))){
					value = element.style[('pixel-' + property).camelCase()];
					if (value == null){
						// adapted from Dean Edwards' http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
						var left = element.style.left;
						element.style.left = to + unit;
						value = element.style.pixelLeft;
						element.style.left = left;
					}
				}
				from = (to || 1) / (parseFloat(value) || 1) * (parseFloat(from) || 0);
				element.setStyle(property, from + unit);
			}
		}
		return {from: this.parse(from), to: this.parse(to)};
	},

	//parses a value into an array

	parse: function(value){
		value = Function.from(value)();
		value = (typeof value == 'string') ? value.split(' ') : Array.from(value);
		return value.map(function(val){
			val = String(val);
			var found = false;
			Object.each(Fx.CSS.Parsers, function(parser, key){
				if (found) return;
				var parsed = parser.parse(val);
				if (parsed || parsed === 0) found = {value: parsed, parser: parser};
			});
			found = found || {value: val, parser: Fx.CSS.Parsers.String};
			return found;
		});
	},

	//computes by a from and to prepared objects, using their parsers.

	compute: function(from, to, delta){
		var computed = [];
		(Math.min(from.length, to.length)).times(function(i){
			computed.push({value: from[i].parser.compute(from[i].value, to[i].value, delta), parser: from[i].parser});
		});
		computed.$family = Function.from('fx:css:value');
		return computed;
	},

	//serves the value as settable

	serve: function(value, unit){
		if (typeOf(value) != 'fx:css:value') value = this.parse(value);
		var returned = [];
		value.each(function(bit){
			returned = returned.concat(bit.parser.serve(bit.value, unit));
		});
		return returned;
	},

	//renders the change to an element

	render: function(element, property, value, unit){
		element.setStyle(property, this.serve(value, unit));
	},

	//searches inside the page css to find the values for a selector

	search: function(selector){
		if (Fx.CSS.Cache[selector]) return Fx.CSS.Cache[selector];
		var to = {}, selectorTest = new RegExp('^' + selector.escapeRegExp() + '$');

		var searchStyles = function(rules){
			Array.each(rules, function(rule, i){
				if (rule.media){
					searchStyles(rule.rules || rule.cssRules);
					return;
				}
				if (!rule.style) return;
				var selectorText = (rule.selectorText) ? rule.selectorText.replace(/^\w+/, function(m){
					return m.toLowerCase();
				}) : null;
				if (!selectorText || !selectorTest.test(selectorText)) return;
				Object.each(Element.Styles, function(value, style){
					if (!rule.style[style] || Element.ShortStyles[style]) return;
					value = String(rule.style[style]);
					to[style] = ((/^rgb/).test(value)) ? value.rgbToHex() : value;
				});
			});
		};

		Array.each(document.styleSheets, function(sheet, j){
			var href = sheet.href;
			if (href && href.indexOf('://') > -1 && href.indexOf(document.domain) == -1) return;
			var rules = sheet.rules || sheet.cssRules;
			searchStyles(rules);
		});
		return Fx.CSS.Cache[selector] = to;
	}

});

Fx.CSS.Cache = {};

Fx.CSS.Parsers = {

	Color: {
		parse: function(value){
			if (value.match(/^#[0-9a-f]{3,6}$/i)) return value.hexToRgb(true);
			return ((value = value.match(/(\d+),\s*(\d+),\s*(\d+)/))) ? [value[1], value[2], value[3]] : false;
		},
		compute: function(from, to, delta){
			return from.map(function(value, i){
				return Math.round(Fx.compute(from[i], to[i], delta));
			});
		},
		serve: function(value){
			return value.map(Number);
		}
	},

	Number: {
		parse: parseFloat,
		compute: Fx.compute,
		serve: function(value, unit){
			return (unit) ? value + unit : value;
		}
	},

	String: {
		parse: Function.from(false),
		compute: function(zero, one){
			return one;
		},
		serve: function(zero){
			return zero;
		}
	}

};

//<1.2compat>

Fx.CSS.Parsers = new Hash(Fx.CSS.Parsers);

//</1.2compat>

/*
---

name: Fx.Morph

description: Formerly Fx.Styles, effect to transition any number of CSS properties for an element using an object of rules, or CSS based selector rules.

license: MIT-style license.

requires: Fx.CSS

provides: Fx.Morph

...
*/

Fx.Morph = new Class({

	Extends: Fx.CSS,

	initialize: function(element, options){
		this.element = this.subject = document.id(element);
		this.parent(options);
	},

	set: function(now){
		if (typeof now == 'string') now = this.search(now);
		for (var p in now) this.render(this.element, p, now[p], this.options.unit);
		return this;
	},

	compute: function(from, to, delta){
		var now = {};
		for (var p in from) now[p] = this.parent(from[p], to[p], delta);
		return now;
	},

	start: function(properties){
		if (!this.check(properties)) return this;
		if (typeof properties == 'string') properties = this.search(properties);
		var from = {}, to = {};
		for (var p in properties){
			var parsed = this.prepare(this.element, p, properties[p]);
			from[p] = parsed.from;
			to[p] = parsed.to;
		}
		return this.parent(from, to);
	}

});

Element.Properties.morph = {

	set: function(options){
		this.get('morph').cancel().setOptions(options);
		return this;
	},

	get: function(){
		var morph = this.retrieve('morph');
		if (!morph){
			morph = new Fx.Morph(this, {link: 'cancel'});
			this.store('morph', morph);
		}
		return morph;
	}

};

Element.implement({

	morph: function(props){
		this.get('morph').start(props);
		return this;
	}

});

/*
---

name: Fx.Transitions

description: Contains a set of advanced transitions to be used with any of the Fx Classes.

license: MIT-style license.

credits:
  - Easing Equations by Robert Penner, <http://www.robertpenner.com/easing/>, modified and optimized to be used with MooTools.

requires: Fx

provides: Fx.Transitions

...
*/

Fx.implement({

	getTransition: function(){
		var trans = this.options.transition || Fx.Transitions.Sine.easeInOut;
		if (typeof trans == 'string'){
			var data = trans.split(':');
			trans = Fx.Transitions;
			trans = trans[data[0]] || trans[data[0].capitalize()];
			if (data[1]) trans = trans['ease' + data[1].capitalize() + (data[2] ? data[2].capitalize() : '')];
		}
		return trans;
	}

});

Fx.Transition = function(transition, params){
	params = Array.from(params);
	var easeIn = function(pos){
		return transition(pos, params);
	};
	return Object.append(easeIn, {
		easeIn: easeIn,
		easeOut: function(pos){
			return 1 - transition(1 - pos, params);
		},
		easeInOut: function(pos){
			return (pos <= 0.5 ? transition(2 * pos, params) : (2 - transition(2 * (1 - pos), params))) / 2;
		}
	});
};

Fx.Transitions = {

	linear: function(zero){
		return zero;
	}

};

//<1.2compat>

Fx.Transitions = new Hash(Fx.Transitions);

//</1.2compat>

Fx.Transitions.extend = function(transitions){
	for (var transition in transitions) Fx.Transitions[transition] = new Fx.Transition(transitions[transition]);
};

Fx.Transitions.extend({

	Pow: function(p, x){
		return Math.pow(p, x && x[0] || 6);
	},

	Expo: function(p){
		return Math.pow(2, 8 * (p - 1));
	},

	Circ: function(p){
		return 1 - Math.sin(Math.acos(p));
	},

	Sine: function(p){
		return 1 - Math.cos(p * Math.PI / 2);
	},

	Back: function(p, x){
		x = x && x[0] || 1.618;
		return Math.pow(p, 2) * ((x + 1) * p - x);
	},

	Bounce: function(p){
		var value;
		for (var a = 0, b = 1; 1; a += b, b /= 2){
			if (p >= (7 - 4 * a) / 11){
				value = b * b - Math.pow((11 - 6 * a - 11 * p) / 4, 2);
				break;
			}
		}
		return value;
	},

	Elastic: function(p, x){
		return Math.pow(2, 10 * --p) * Math.cos(20 * p * Math.PI * (x && x[0] || 1) / 3);
	}

});

['Quad', 'Cubic', 'Quart', 'Quint'].each(function(transition, i){
	Fx.Transitions[transition] = new Fx.Transition(function(p){
		return Math.pow(p, i + 2);
	});
});

/*
---

name: Fx.Tween

description: Formerly Fx.Style, effect to transition any CSS property for an element.

license: MIT-style license.

requires: Fx.CSS

provides: [Fx.Tween, Element.fade, Element.highlight]

...
*/

Fx.Tween = new Class({

	Extends: Fx.CSS,

	initialize: function(element, options){
		this.element = this.subject = document.id(element);
		this.parent(options);
	},

	set: function(property, now){
		if (arguments.length == 1){
			now = property;
			property = this.property || this.options.property;
		}
		this.render(this.element, property, now, this.options.unit);
		return this;
	},

	start: function(property, from, to){
		if (!this.check(property, from, to)) return this;
		var args = Array.flatten(arguments);
		this.property = this.options.property || args.shift();
		var parsed = this.prepare(this.element, this.property, args);
		return this.parent(parsed.from, parsed.to);
	}

});

Element.Properties.tween = {

	set: function(options){
		this.get('tween').cancel().setOptions(options);
		return this;
	},

	get: function(){
		var tween = this.retrieve('tween');
		if (!tween){
			tween = new Fx.Tween(this, {link: 'cancel'});
			this.store('tween', tween);
		}
		return tween;
	}

};

Element.implement({

	tween: function(property, from, to){
		this.get('tween').start(property, from, to);
		return this;
	},

	fade: function(how){
		var fade = this.get('tween'), method, args = ['opacity'].append(arguments), toggle;
		if (args[1] == null) args[1] = 'toggle';
		switch (args[1]){
			case 'in': method = 'start'; args[1] = 1; break;
			case 'out': method = 'start'; args[1] = 0; break;
			case 'show': method = 'set'; args[1] = 1; break;
			case 'hide': method = 'set'; args[1] = 0; break;
			case 'toggle':
				var flag = this.retrieve('fade:flag', this.getStyle('opacity') == 1);
				method = 'start';
				args[1] = flag ? 0 : 1;
				this.store('fade:flag', !flag);
				toggle = true;
			break;
			default: method = 'start';
		}
		if (!toggle) this.eliminate('fade:flag');
		fade[method].apply(fade, args);
		var to = args[args.length - 1];
		if (method == 'set' || to != 0) this.setStyle('visibility', to == 0 ? 'hidden' : 'visible');
		else fade.chain(function(){
			this.element.setStyle('visibility', 'hidden');
			this.callChain();
		});
		return this;
	},

	highlight: function(start, end){
		if (!end){
			end = this.retrieve('highlight:original', this.getStyle('background-color'));
			end = (end == 'transparent') ? '#fff' : end;
		}
		var tween = this.get('tween');
		tween.start('background-color', start || '#ffff88', end).chain(function(){
			this.setStyle('background-color', this.retrieve('highlight:original'));
			tween.callChain();
		}.bind(this));
		return this;
	}

});

/*
---

name: Request

description: Powerful all purpose Request Class. Uses XMLHTTPRequest.

license: MIT-style license.

requires: [Object, Element, Chain, Events, Options, Browser]

provides: Request

...
*/

(function(){

var empty = function(){},
	progressSupport = ('onprogress' in new Browser.Request);

var Request = this.Request = new Class({

	Implements: [Chain, Events, Options],

	options: {/*
		onRequest: function(){},
		onLoadstart: function(event, xhr){},
		onProgress: function(event, xhr){},
		onComplete: function(){},
		onCancel: function(){},
		onSuccess: function(responseText, responseXML){},
		onFailure: function(xhr){},
		onException: function(headerName, value){},
		onTimeout: function(){},
		user: '',
		password: '',
		withCredentials: false,*/
		url: '',
		data: '',
		headers: {
			'X-Requested-With': 'XMLHttpRequest',
			'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
		},
		async: true,
		format: false,
		method: 'post',
		link: 'ignore',
		isSuccess: null,
		emulation: true,
		urlEncoded: true,
		encoding: 'utf-8',
		evalScripts: false,
		evalResponse: false,
		timeout: 0,
		noCache: false
	},

	initialize: function(options){
		this.xhr = new Browser.Request();
		this.setOptions(options);
		this.headers = this.options.headers;
	},

	onStateChange: function(){
		var xhr = this.xhr;
		if (xhr.readyState != 4 || !this.running) return;
		this.running = false;
		this.status = 0;
		Function.attempt(function(){
			var status = xhr.status;
			this.status = (status == 1223) ? 204 : status;
		}.bind(this));
		xhr.onreadystatechange = empty;
		if (progressSupport) xhr.onprogress = xhr.onloadstart = empty;
		if (this.timer){
			clearTimeout(this.timer);
			delete this.timer;
		}

		this.response = {text: this.xhr.responseText || '', xml: this.xhr.responseXML};
		if (this.options.isSuccess.call(this, this.status))
			this.success(this.response.text, this.response.xml);
		else
			this.failure();
	},

	isSuccess: function(){
		var status = this.status;
		return (status >= 200 && status < 300);
	},

	isRunning: function(){
		return !!this.running;
	},

	processScripts: function(text){
		if (this.options.evalResponse || (/(ecma|java)script/).test(this.getHeader('Content-type'))) return Browser.exec(text);
		return text.stripScripts(this.options.evalScripts);
	},

	success: function(text, xml){
		this.onSuccess(this.processScripts(text), xml);
	},

	onSuccess: function(){
		this.fireEvent('complete', arguments).fireEvent('success', arguments).callChain();
	},

	failure: function(){
		this.onFailure();
	},

	onFailure: function(){
		this.fireEvent('complete').fireEvent('failure', this.xhr);
	},

	loadstart: function(event){
		this.fireEvent('loadstart', [event, this.xhr]);
	},

	progress: function(event){
		this.fireEvent('progress', [event, this.xhr]);
	},

	timeout: function(){
		this.fireEvent('timeout', this.xhr);
	},

	setHeader: function(name, value){
		this.headers[name] = value;
		return this;
	},

	getHeader: function(name){
		return Function.attempt(function(){
			return this.xhr.getResponseHeader(name);
		}.bind(this));
	},

	check: function(){
		if (!this.running) return true;
		switch (this.options.link){
			case 'cancel': this.cancel(); return true;
			case 'chain': this.chain(this.caller.pass(arguments, this)); return false;
		}
		return false;
	},

	send: function(options){
		if (!this.check(options)) return this;

		this.options.isSuccess = this.options.isSuccess || this.isSuccess;
		this.running = true;

		var type = typeOf(options);
		if (type == 'string' || type == 'element') options = {data: options};

		var old = this.options;
		options = Object.append({data: old.data, url: old.url, method: old.method}, options);
		var data = options.data, url = String(options.url), method = options.method.toLowerCase();

		switch (typeOf(data)){
			case 'element': data = document.id(data).toQueryString(); break;
			case 'object': case 'hash': data = Object.toQueryString(data);
		}

		if (this.options.format){
			var format = 'format=' + this.options.format;
			data = (data) ? format + '&' + data : format;
		}

		if (this.options.emulation && !['get', 'post'].contains(method)){
			var _method = '_method=' + method;
			data = (data) ? _method + '&' + data : _method;
			method = 'post';
		}

		if (this.options.urlEncoded && ['post', 'put'].contains(method)){
			var encoding = (this.options.encoding) ? '; charset=' + this.options.encoding : '';
			this.headers['Content-type'] = 'application/x-www-form-urlencoded' + encoding;
		}

		if (!url) url = document.location.pathname;

		var trimPosition = url.lastIndexOf('/');
		if (trimPosition > -1 && (trimPosition = url.indexOf('#')) > -1) url = url.substr(0, trimPosition);

		if (this.options.noCache)
			url += (url.indexOf('?') > -1 ? '&' : '?') + String.uniqueID();

		if (data && (method == 'get' || method == 'delete')){
			url += (url.indexOf('?') > -1 ? '&' : '?') + data;
			data = null;
		}

		var xhr = this.xhr;
		if (progressSupport){
			xhr.onloadstart = this.loadstart.bind(this);
			xhr.onprogress = this.progress.bind(this);
		}

		xhr.open(method.toUpperCase(), url, this.options.async, this.options.user, this.options.password);
		if ((/*<1.4compat>*/this.options.user || /*</1.4compat>*/this.options.withCredentials) && 'withCredentials' in xhr) xhr.withCredentials = true;

		xhr.onreadystatechange = this.onStateChange.bind(this);

		Object.each(this.headers, function(value, key){
			try {
				xhr.setRequestHeader(key, value);
			} catch (e){
				this.fireEvent('exception', [key, value]);
			}
		}, this);

		this.fireEvent('request');
		xhr.send(data);
		if (!this.options.async) this.onStateChange();
		else if (this.options.timeout) this.timer = this.timeout.delay(this.options.timeout, this);
		return this;
	},

	cancel: function(){
		if (!this.running) return this;
		this.running = false;
		var xhr = this.xhr;
		xhr.abort();
		if (this.timer){
			clearTimeout(this.timer);
			delete this.timer;
		}
		xhr.onreadystatechange = empty;
		if (progressSupport) xhr.onprogress = xhr.onloadstart = empty;
		this.xhr = new Browser.Request();
		this.fireEvent('cancel');
		return this;
	}

});

var methods = {};
['get', 'post', 'put', 'delete', 'patch', 'head', 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD'].each(function(method){
	methods[method] = function(data){
		var object = {
			method: method
		};
		if (data != null) object.data = data;
		return this.send(object);
	};
});

Request.implement(methods);

Element.Properties.send = {

	set: function(options){
		var send = this.get('send').cancel();
		send.setOptions(options);
		return this;
	},

	get: function(){
		var send = this.retrieve('send');
		if (!send){
			send = new Request({
				data: this, link: 'cancel', method: this.get('method') || 'post', url: this.get('action')
			});
			this.store('send', send);
		}
		return send;
	}

};

Element.implement({

	send: function(url){
		var sender = this.get('send');
		sender.send({data: this, url: url || sender.options.url});
		return this;
	}

});

})();

/*
---

name: Request.HTML

description: Extends the basic Request Class with additional methods for interacting with HTML responses.

license: MIT-style license.

requires: [Element, Request]

provides: Request.HTML

...
*/

Request.HTML = new Class({

	Extends: Request,

	options: {
		update: false,
		append: false,
		evalScripts: true,
		filter: false,
		headers: {
			Accept: 'text/html, application/xml, text/xml, */*'
		}
	},

	success: function(text){
		var options = this.options, response = this.response;

		response.html = text.stripScripts(function(script){
			response.javascript = script;
		});

		var match = response.html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
		if (match) response.html = match[1];
		var temp = new Element('div').set('html', response.html);

		response.tree = temp.childNodes;
		response.elements = temp.getElements(options.filter || '*');

		if (options.filter) response.tree = response.elements;
		if (options.update){
			var update = document.id(options.update).empty();
			if (options.filter) update.adopt(response.elements);
			else update.set('html', response.html);
		} else if (options.append){
			var append = document.id(options.append);
			if (options.filter) response.elements.reverse().inject(append);
			else append.adopt(temp.getChildren());
		}
		if (options.evalScripts) Browser.exec(response.javascript);

		this.onSuccess(response.tree, response.elements, response.html, response.javascript);
	}

});

Element.Properties.load = {

	set: function(options){
		var load = this.get('load').cancel();
		load.setOptions(options);
		return this;
	},

	get: function(){
		var load = this.retrieve('load');
		if (!load){
			load = new Request.HTML({data: this, link: 'cancel', update: this, method: 'get'});
			this.store('load', load);
		}
		return load;
	}

};

Element.implement({

	load: function(){
		this.get('load').send(Array.link(arguments, {data: Type.isObject, url: Type.isString}));
		return this;
	}

});

/*
---

name: JSON

description: JSON encoder and decoder.

license: MIT-style license.

SeeAlso: <http://www.json.org/>

requires: [Array, String, Number, Function]

provides: JSON

...
*/

if (typeof JSON == 'undefined') this.JSON = {};

//<1.2compat>

JSON = new Hash({
	stringify: JSON.stringify,
	parse: JSON.parse
});

//</1.2compat>

(function(){

var special = {'\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"' : '\\"', '\\': '\\\\'};

var escape = function(chr){
	return special[chr] || '\\u' + ('0000' + chr.charCodeAt(0).toString(16)).slice(-4);
};

JSON.validate = function(string){
	string = string.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
					replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
					replace(/(?:^|:|,)(?:\s*\[)+/g, '');

	return (/^[\],:{}\s]*$/).test(string);
};

JSON.encode = JSON.stringify ? function(obj){
	return JSON.stringify(obj);
} : function(obj){
	if (obj && obj.toJSON) obj = obj.toJSON();

	switch (typeOf(obj)){
		case 'string':
			return '"' + obj.replace(/[\x00-\x1f\\"]/g, escape) + '"';
		case 'array':
			return '[' + obj.map(JSON.encode).clean() + ']';
		case 'object': case 'hash':
			var string = [];
			Object.each(obj, function(value, key){
				var json = JSON.encode(value);
				if (json) string.push(JSON.encode(key) + ':' + json);
			});
			return '{' + string + '}';
		case 'number': case 'boolean': return '' + obj;
		case 'null': return 'null';
	}

	return null;
};

JSON.secure = true;
//<1.4compat>
JSON.secure = false;
//</1.4compat>

JSON.decode = function(string, secure){
	if (!string || typeOf(string) != 'string') return null;
    
	if (secure == null) secure = JSON.secure; 
	if (secure){
		if (JSON.parse) return JSON.parse(string);
		if (!JSON.validate(string)) throw new Error('JSON could not decode the input; security is enabled and the value is not secure.');
	}

	return eval('(' + string + ')');
};

})();

/*
---

name: Request.JSON

description: Extends the basic Request Class with additional methods for sending and receiving JSON data.

license: MIT-style license.

requires: [Request, JSON]

provides: Request.JSON

...
*/

Request.JSON = new Class({

	Extends: Request,

	options: {
		/*onError: function(text, error){},*/
		secure: true
	},

	initialize: function(options){
		this.parent(options);
		Object.append(this.headers, {
			'Accept': 'application/json',
			'X-Request': 'JSON'
		});
	},

	success: function(text){
		var json;
		try {
			json = this.response.json = JSON.decode(text, this.options.secure);
		} catch (error){
			this.fireEvent('error', [text, error]);
			return;
		}
		if (json == null) this.onFailure();
		else this.onSuccess(json, text);
	}

});

/*
---

name: Cookie

description: Class for creating, reading, and deleting browser Cookies.

license: MIT-style license.

credits:
  - Based on the functions by Peter-Paul Koch (http://quirksmode.org).

requires: [Options, Browser]

provides: Cookie

...
*/

var Cookie = new Class({

	Implements: Options,

	options: {
		path: '/',
		domain: false,
		duration: false,
		secure: false,
		document: document,
		encode: true
	},

	initialize: function(key, options){
		this.key = key;
		this.setOptions(options);
	},

	write: function(value){
		if (this.options.encode) value = encodeURIComponent(value);
		if (this.options.domain) value += '; domain=' + this.options.domain;
		if (this.options.path) value += '; path=' + this.options.path;
		if (this.options.duration){
			var date = new Date();
			date.setTime(date.getTime() + this.options.duration * 24 * 60 * 60 * 1000);
			value += '; expires=' + date.toGMTString();
		}
		if (this.options.secure) value += '; secure';
		this.options.document.cookie = this.key + '=' + value;
		return this;
	},

	read: function(){
		var value = this.options.document.cookie.match('(?:^|;)\\s*' + this.key.escapeRegExp() + '=([^;]*)');
		return (value) ? decodeURIComponent(value[1]) : null;
	},

	dispose: function(){
		new Cookie(this.key, Object.merge({}, this.options, {duration: -1})).write('');
		return this;
	}

});

Cookie.write = function(key, value, options){
	return new Cookie(key, options).write(value);
};

Cookie.read = function(key){
	return new Cookie(key).read();
};

Cookie.dispose = function(key, options){
	return new Cookie(key, options).dispose();
};

/*
---

name: DOMReady

description: Contains the custom event domready.

license: MIT-style license.

requires: [Browser, Element, Element.Event]

provides: [DOMReady, DomReady]

...
*/

(function(window, document){

var ready,
	loaded,
	checks = [],
	shouldPoll,
	timer,
	testElement = document.createElement('div');

var domready = function(){
	clearTimeout(timer);
	if (!ready) {
		Browser.loaded = ready = true;
		document.removeListener('DOMContentLoaded', domready).removeListener('readystatechange', check);
		document.fireEvent('domready');
		window.fireEvent('domready');
	}
	// cleanup scope vars
	document = window = testElement = null;
};

var check = function(){
	for (var i = checks.length; i--;) if (checks[i]()){
		domready();
		return true;
	}
	return false;
};

var poll = function(){
	clearTimeout(timer);
	if (!check()) timer = setTimeout(poll, 10);
};

document.addListener('DOMContentLoaded', domready);

/*<ltIE8>*/
// doScroll technique by Diego Perini http://javascript.nwbox.com/IEContentLoaded/
// testElement.doScroll() throws when the DOM is not ready, only in the top window
var doScrollWorks = function(){
	try {
		testElement.doScroll();
		return true;
	} catch (e){}
	return false;
};
// If doScroll works already, it can't be used to determine domready
//   e.g. in an iframe
if (testElement.doScroll && !doScrollWorks()){
	checks.push(doScrollWorks);
	shouldPoll = true;
}
/*</ltIE8>*/

if (document.readyState) checks.push(function(){
	var state = document.readyState;
	return (state == 'loaded' || state == 'complete');
});

if ('onreadystatechange' in document) document.addListener('readystatechange', check);
else shouldPoll = true;

if (shouldPoll) poll();

Element.Events.domready = {
	onAdd: function(fn){
		if (ready) fn.call(this);
	}
};

// Make sure that domready fires before load
Element.Events.load = {
	base: 'load',
	onAdd: function(fn){
		if (loaded && this == window) fn.call(this);
	},
	condition: function(){
		if (this == window){
			domready();
			delete Element.Events.load;
		}
		return true;
	}
};

// This is based on the custom load event
window.addEvent('load', function(){
	loaded = true;
});

})(window, document);


/* MooTools: the javascript framework. license: MIT-style license. copyright: Copyright (c) 2006-2015 [Valerio Proietti](http://mad4milk.net/).*/ 
/*
Web Build: http://mootools.net/more/builder/102a070191b7c20c605add359dbfc79d
*/
/*
---

script: More.js

name: More

description: MooTools More

license: MIT-style license

authors:
  - Guillermo Rauch
  - Thomas Aylott
  - Scott Kyle
  - Arian Stolwijk
  - Tim Wienk
  - Christoph Pojer
  - Aaron Newton
  - Jacob Thornton

requires:
  - Core/MooTools

provides: [MooTools.More]

...
*/

MooTools.More = {
	version: '1.5.1',
	build: '2dd695ba957196ae4b0275a690765d6636a61ccd'
};

/*
---

script: Class.Binds.js

name: Class.Binds

description: Automagically binds specified methods in a class to the instance of the class.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Class
  - MooTools.More

provides: [Class.Binds]

...
*/

Class.Mutators.Binds = function(binds){
	if (!this.prototype.initialize) this.implement('initialize', function(){});
	return Array.from(binds).concat(this.prototype.Binds || []);
};

Class.Mutators.initialize = function(initialize){
	return function(){
		Array.from(this.Binds).each(function(name){
			var original = this[name];
			if (original) this[name] = original.bind(this);
		}, this);
		return initialize.apply(this, arguments);
	};
};

/*
---

script: Drag.js

name: Drag

description: The base Drag Class. Can be used to drag and resize Elements using mouse events.

license: MIT-style license

authors:
  - Valerio Proietti
  - Tom Occhinno
  - Jan Kassens

requires:
  - Core/Events
  - Core/Options
  - Core/Element.Event
  - Core/Element.Style
  - Core/Element.Dimensions
  - MooTools.More

provides: [Drag]
...

*/

var Drag = new Class({

	Implements: [Events, Options],

	options: {/*
		onBeforeStart: function(thisElement){},
		onStart: function(thisElement, event){},
		onSnap: function(thisElement){},
		onDrag: function(thisElement, event){},
		onCancel: function(thisElement){},
		onComplete: function(thisElement, event){},*/
		snap: 6,
		unit: 'px',
		grid: false,
		style: true,
		limit: false,
		handle: false,
		invert: false,
		preventDefault: false,
		stopPropagation: false,
		compensateScroll: false,
		modifiers: {x: 'left', y: 'top'}
	},

	initialize: function(){
		var params = Array.link(arguments, {
			'options': Type.isObject,
			'element': function(obj){
				return obj != null;
			}
		});

		this.element = document.id(params.element);
		this.document = this.element.getDocument();
		this.setOptions(params.options || {});
		var htype = typeOf(this.options.handle);
		this.handles = ((htype == 'array' || htype == 'collection') ? $$(this.options.handle) : document.id(this.options.handle)) || this.element;
		this.mouse = {'now': {}, 'pos': {}};
		this.value = {'start': {}, 'now': {}};
		this.offsetParent = (function(el){
			var offsetParent = el.getOffsetParent();
			var isBody = !offsetParent || (/^(?:body|html)$/i).test(offsetParent.tagName);
			return isBody ? window : document.id(offsetParent);
		})(this.element);
		this.selection = 'selectstart' in document ? 'selectstart' : 'mousedown';

		this.compensateScroll = {start: {}, diff: {}, last: {}};

		if ('ondragstart' in document && !('FileReader' in window) && !Drag.ondragstartFixed){
			document.ondragstart = Function.from(false);
			Drag.ondragstartFixed = true;
		}

		this.bound = {
			start: this.start.bind(this),
			check: this.check.bind(this),
			drag: this.drag.bind(this),
			stop: this.stop.bind(this),
			cancel: this.cancel.bind(this),
			eventStop: Function.from(false),
			scrollListener: this.scrollListener.bind(this)
		};
		this.attach();
	},

	attach: function(){
		this.handles.addEvent('mousedown', this.bound.start);
		if (this.options.compensateScroll) this.offsetParent.addEvent('scroll', this.bound.scrollListener);
		return this;
	},

	detach: function(){
		this.handles.removeEvent('mousedown', this.bound.start);
		if (this.options.compensateScroll) this.offsetParent.removeEvent('scroll', this.bound.scrollListener);
		return this;
	},

	scrollListener: function(){

		if (!this.mouse.start) return;
		var newScrollValue = this.offsetParent.getScroll();

		if (this.element.getStyle('position') == 'absolute'){
			var scrollDiff = this.sumValues(newScrollValue, this.compensateScroll.last, -1);
			this.mouse.now = this.sumValues(this.mouse.now, scrollDiff, 1);
		} else {
			this.compensateScroll.diff = this.sumValues(newScrollValue, this.compensateScroll.start, -1);
		}
		if (this.offsetParent != window) this.compensateScroll.diff = this.sumValues(this.compensateScroll.start, newScrollValue, -1);
		this.compensateScroll.last = newScrollValue;
		this.render(this.options);
	},

	sumValues: function(alpha, beta, op){
		var sum = {}, options = this.options;
		for (z in options.modifiers){
			if (!options.modifiers[z]) continue;
			sum[z] = alpha[z] + beta[z] * op;
		}
		return sum;
	},

	start: function(event){
		var options = this.options;

		if (event.rightClick) return;

		if (options.preventDefault) event.preventDefault();
		if (options.stopPropagation) event.stopPropagation();
		this.compensateScroll.start = this.compensateScroll.last = this.offsetParent.getScroll();
		this.compensateScroll.diff = {x: 0, y: 0};
		this.mouse.start = event.page;
		this.fireEvent('beforeStart', this.element);

		var limit = options.limit;
		this.limit = {x: [], y: []};

		var z, coordinates, offsetParent = this.offsetParent == window ? null : this.offsetParent;
		for (z in options.modifiers){
			if (!options.modifiers[z]) continue;

			var style = this.element.getStyle(options.modifiers[z]);

			// Some browsers (IE and Opera) don't always return pixels.
			if (style && !style.match(/px$/)){
				if (!coordinates) coordinates = this.element.getCoordinates(offsetParent);
				style = coordinates[options.modifiers[z]];
			}

			if (options.style) this.value.now[z] = (style || 0).toInt();
			else this.value.now[z] = this.element[options.modifiers[z]];

			if (options.invert) this.value.now[z] *= -1;

			this.mouse.pos[z] = event.page[z] - this.value.now[z];

			if (limit && limit[z]){
				var i = 2;
				while (i--){
					var limitZI = limit[z][i];
					if (limitZI || limitZI === 0) this.limit[z][i] = (typeof limitZI == 'function') ? limitZI() : limitZI;
				}
			}
		}

		if (typeOf(this.options.grid) == 'number') this.options.grid = {
			x: this.options.grid,
			y: this.options.grid
		};

		var events = {
			mousemove: this.bound.check,
			mouseup: this.bound.cancel
		};
		events[this.selection] = this.bound.eventStop;
		this.document.addEvents(events);
	},

	check: function(event){
		if (this.options.preventDefault) event.preventDefault();
		var distance = Math.round(Math.sqrt(Math.pow(event.page.x - this.mouse.start.x, 2) + Math.pow(event.page.y - this.mouse.start.y, 2)));
		if (distance > this.options.snap){
			this.cancel();
			this.document.addEvents({
				mousemove: this.bound.drag,
				mouseup: this.bound.stop
			});
			this.fireEvent('start', [this.element, event]).fireEvent('snap', this.element);
		}
	},

	drag: function(event){
		var options = this.options;
		if (options.preventDefault) event.preventDefault();
		this.mouse.now = this.sumValues(event.page, this.compensateScroll.diff, -1);

		this.render(options);
		this.fireEvent('drag', [this.element, event]);
	},  

	render: function(options){
		for (var z in options.modifiers){
			if (!options.modifiers[z]) continue;
			this.value.now[z] = this.mouse.now[z] - this.mouse.pos[z];

			if (options.invert) this.value.now[z] *= -1;
			if (options.limit && this.limit[z]){
				if ((this.limit[z][1] || this.limit[z][1] === 0) && (this.value.now[z] > this.limit[z][1])){
					this.value.now[z] = this.limit[z][1];
				} else if ((this.limit[z][0] || this.limit[z][0] === 0) && (this.value.now[z] < this.limit[z][0])){
					this.value.now[z] = this.limit[z][0];
				}
			}
			if (options.grid[z]) this.value.now[z] -= ((this.value.now[z] - (this.limit[z][0]||0)) % options.grid[z]);
			if (options.style) this.element.setStyle(options.modifiers[z], this.value.now[z] + options.unit);
			else this.element[options.modifiers[z]] = this.value.now[z];
		}
	},

	cancel: function(event){
		this.document.removeEvents({
			mousemove: this.bound.check,
			mouseup: this.bound.cancel
		});
		if (event){
			this.document.removeEvent(this.selection, this.bound.eventStop);
			this.fireEvent('cancel', this.element);
		}
	},

	stop: function(event){
		var events = {
			mousemove: this.bound.drag,
			mouseup: this.bound.stop
		};
		events[this.selection] = this.bound.eventStop;
		this.document.removeEvents(events);
		this.mouse.start = null;
		if (event) this.fireEvent('complete', [this.element, event]);
	}

});

Element.implement({

	makeResizable: function(options){
		var drag = new Drag(this, Object.merge({
			modifiers: {
				x: 'width',
				y: 'height'
			}
		}, options));

		this.store('resizer', drag);
		return drag.addEvent('drag', function(){
			this.fireEvent('resize', drag);
		}.bind(this));
	}

});

/*
---

script: Element.Measure.js

name: Element.Measure

description: Extends the Element native object to include methods useful in measuring dimensions.

credits: "Element.measure / .expose methods by Daniel Steigerwald License: MIT-style license. Copyright: Copyright (c) 2008 Daniel Steigerwald, daniel.steigerwald.cz"

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element.Style
  - Core/Element.Dimensions
  - MooTools.More

provides: [Element.Measure]

...
*/

(function(){

var getStylesList = function(styles, planes){
	var list = [];
	Object.each(planes, function(directions){
		Object.each(directions, function(edge){
			styles.each(function(style){
				list.push(style + '-' + edge + (style == 'border' ? '-width' : ''));
			});
		});
	});
	return list;
};

var calculateEdgeSize = function(edge, styles){
	var total = 0;
	Object.each(styles, function(value, style){
		if (style.test(edge)) total = total + value.toInt();
	});
	return total;
};

var isVisible = function(el){
	return !!(!el || el.offsetHeight || el.offsetWidth);
};


Element.implement({

	measure: function(fn){
		if (isVisible(this)) return fn.call(this);
		var parent = this.getParent(),
			toMeasure = [];
		while (!isVisible(parent) && parent != document.body){
			toMeasure.push(parent.expose());
			parent = parent.getParent();
		}
		var restore = this.expose(),
			result = fn.call(this);
		restore();
		toMeasure.each(function(restore){
			restore();
		});
		return result;
	},

	expose: function(){
		if (this.getStyle('display') != 'none') return function(){};
		var before = this.style.cssText;
		this.setStyles({
			display: 'block',
			position: 'absolute',
			visibility: 'hidden'
		});
		return function(){
			this.style.cssText = before;
		}.bind(this);
	},

	getDimensions: function(options){
		options = Object.merge({computeSize: false}, options);
		var dim = {x: 0, y: 0};

		var getSize = function(el, options){
			return (options.computeSize) ? el.getComputedSize(options) : el.getSize();
		};

		var parent = this.getParent('body');

		if (parent && this.getStyle('display') == 'none'){
			dim = this.measure(function(){
				return getSize(this, options);
			});
		} else if (parent){
			try { //safari sometimes crashes here, so catch it
				dim = getSize(this, options);
			}catch(e){}
		}

		return Object.append(dim, (dim.x || dim.x === 0) ? {
				width: dim.x,
				height: dim.y
			} : {
				x: dim.width,
				y: dim.height
			}
		);
	},

	getComputedSize: function(options){
		

		options = Object.merge({
			styles: ['padding','border'],
			planes: {
				height: ['top','bottom'],
				width: ['left','right']
			},
			mode: 'both'
		}, options);

		var styles = {},
			size = {width: 0, height: 0},
			dimensions;

		if (options.mode == 'vertical'){
			delete size.width;
			delete options.planes.width;
		} else if (options.mode == 'horizontal'){
			delete size.height;
			delete options.planes.height;
		}

		getStylesList(options.styles, options.planes).each(function(style){
			styles[style] = this.getStyle(style).toInt();
		}, this);

		Object.each(options.planes, function(edges, plane){

			var capitalized = plane.capitalize(),
				style = this.getStyle(plane);

			if (style == 'auto' && !dimensions) dimensions = this.getDimensions();

			style = styles[plane] = (style == 'auto') ? dimensions[plane] : style.toInt();
			size['total' + capitalized] = style;

			edges.each(function(edge){
				var edgesize = calculateEdgeSize(edge, styles);
				size['computed' + edge.capitalize()] = edgesize;
				size['total' + capitalized] += edgesize;
			});

		}, this);

		return Object.append(size, styles);
	}

});

})();

/*
---

script: Slider.js

name: Slider

description: Class for creating horizontal and vertical slider controls.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Element.Dimensions
  - Core/Number
  - Class.Binds
  - Drag
  - Element.Measure

provides: [Slider]

...
*/

var Slider = new Class({

	Implements: [Events, Options],

	Binds: ['clickedElement', 'draggedKnob', 'scrolledElement'],

	options: {/*
		onTick: function(intPosition){},
		onMove: function(){},
		onChange: function(intStep){},
		onComplete: function(strStep){},*/
		onTick: function(position){
			this.setKnobPosition(position);
		},
		initialStep: 0,
		snap: false,
		offset: 0,
		range: false,
		wheel: false,
		steps: 100,
		mode: 'horizontal'
	},

	initialize: function(element, knob, options){
		this.setOptions(options);
		options = this.options;
		this.element = document.id(element);
		knob = this.knob = document.id(knob);
		this.previousChange = this.previousEnd = this.step = options.initialStep ? options.initialStep : options.range ? options.range[0] : 0;

		var limit = {},
			modifiers = {x: false, y: false};

		switch (options.mode){
			case 'vertical':
				this.axis = 'y';
				this.property = 'top';
				this.offset = 'offsetHeight';
				break;
			case 'horizontal':
				this.axis = 'x';
				this.property = 'left';
				this.offset = 'offsetWidth';
		}

		this.setSliderDimensions();
		this.setRange(options.range, null, true);

		if (knob.getStyle('position') == 'static') knob.setStyle('position', 'relative');
		knob.setStyle(this.property, -options.offset);
		modifiers[this.axis] = this.property;
		limit[this.axis] = [-options.offset, this.full - options.offset];

		var dragOptions = {
			snap: 0,
			limit: limit,
			modifiers: modifiers,
			onDrag: this.draggedKnob,
			onStart: this.draggedKnob,
			onBeforeStart: (function(){
				this.isDragging = true;
			}).bind(this),
			onCancel: function(){
				this.isDragging = false;
			}.bind(this),
			onComplete: function(){
				this.isDragging = false;
				this.draggedKnob();
				this.end();
			}.bind(this)
		};
		if (options.snap) this.setSnap(dragOptions);

		this.drag = new Drag(knob, dragOptions);
		if (options.initialStep != null) this.set(options.initialStep, true);
		this.attach();
	},

	attach: function(){
		this.element.addEvent('mousedown', this.clickedElement);
		if (this.options.wheel) this.element.addEvent('mousewheel', this.scrolledElement);
		this.drag.attach();
		return this;
	},

	detach: function(){
		this.element.removeEvent('mousedown', this.clickedElement)
			.removeEvent('mousewheel', this.scrolledElement);
		this.drag.detach();
		return this;
	},

	autosize: function(){
		this.setSliderDimensions()
			.setKnobPosition(this.toPosition(this.step));
		this.drag.options.limit[this.axis] = [-this.options.offset, this.full - this.options.offset];
		if (this.options.snap) this.setSnap();
		return this;
	},

	setSnap: function(options){
		if (!options) options = this.drag.options;
		options.grid = Math.ceil(this.stepWidth);
		options.limit[this.axis][1] = this.element[this.offset];
		return this;
	},

	setKnobPosition: function(position){
		if (this.options.snap) position = this.toPosition(this.step);
		this.knob.setStyle(this.property, position);
		return this;
	},

	setSliderDimensions: function(){
		this.full = this.element.measure(function(){
			this.half = this.knob[this.offset] / 2;
			return this.element[this.offset] - this.knob[this.offset] + (this.options.offset * 2);
		}.bind(this));
		return this;
	},

	set: function(step, silently){
		if (!((this.range > 0) ^ (step < this.min))) step = this.min;
		if (!((this.range > 0) ^ (step > this.max))) step = this.max;

		this.step = (step).round(this.modulus.decimalLength);
		if (silently) this.checkStep().setKnobPosition(this.toPosition(this.step));
		else this.checkStep().fireEvent('tick', this.toPosition(this.step)).fireEvent('move').end();
		return this;
	},

	setRange: function(range, pos, silently){
		this.min = Array.pick([range[0], 0]);
		this.max = Array.pick([range[1], this.options.steps]);
		this.range = this.max - this.min;
		this.steps = this.options.steps || this.full;
		var stepSize = this.stepSize = Math.abs(this.range) / this.steps;
		this.stepWidth = this.stepSize * this.full / Math.abs(this.range);
		this.setModulus();

		if (range) this.set(Array.pick([pos, this.step]).limit(this.min,this.max), silently);
		return this;
	},
    
	setModulus: function(){
		var decimals = ((this.stepSize + '').split('.')[1] || []).length,
			modulus = 1 + '';
		while (decimals--) modulus += '0';
		this.modulus = {multiplier: (modulus).toInt(10), decimalLength: modulus.length - 1};
	},

	clickedElement: function(event){
		if (this.isDragging || event.target == this.knob) return;

		var dir = this.range < 0 ? -1 : 1,
			position = event.page[this.axis] - this.element.getPosition()[this.axis] - this.half;

		position = position.limit(-this.options.offset, this.full - this.options.offset);

		this.step = (this.min + dir * this.toStep(position)).round(this.modulus.decimalLength);

		this.checkStep()
			.fireEvent('tick', position)
			.fireEvent('move')
			.end();
	},

	scrolledElement: function(event){
		var mode = (this.options.mode == 'horizontal') ? (event.wheel < 0) : (event.wheel > 0);
		this.set(this.step + (mode ? -1 : 1) * this.stepSize);
		event.stop();
	},

	draggedKnob: function(){
		var dir = this.range < 0 ? -1 : 1,
			position = this.drag.value.now[this.axis];

		position = position.limit(-this.options.offset, this.full -this.options.offset);

		this.step = (this.min + dir * this.toStep(position)).round(this.modulus.decimalLength);
		this.checkStep();
		this.fireEvent('move');
	},

	checkStep: function(){
		var step = this.step;
		if (this.previousChange != step){
			this.previousChange = step;
			this.fireEvent('change', step);
		}
		return this;
	},

	end: function(){
		var step = this.step;
		if (this.previousEnd !== step){
			this.previousEnd = step;
			this.fireEvent('complete', step + '');
		}
		return this;
	},

	toStep: function(position){
		var step = (position + this.options.offset) * this.stepSize / this.full * this.steps;
		return this.options.steps ? (step - (step * this.modulus.multiplier) % (this.stepSize * this.modulus.multiplier) / this.modulus.multiplier).round(this.modulus.decimalLength) : step;
	},

	toPosition: function(step){
		return (this.full * Math.abs(this.min - step)) / (this.steps * this.stepSize) - this.options.offset || 0;
	}

});

/*
---

script: String.Extras.js

name: String.Extras

description: Extends the String native object to include methods useful in managing various kinds of strings (query strings, urls, html, etc).

license: MIT-style license

authors:
  - Aaron Newton
  - Guillermo Rauch
  - Christopher Pitt

requires:
  - Core/String
  - Core/Array
  - MooTools.More

provides: [String.Extras]

...
*/

(function(){

var special = {
	'a': /[]/g,
	'A': /[]/g,
	'c': /[]/g,
	'C': /[]/g,
	'd': /[]/g,
	'D': /[]/g,
	'e': /[]/g,
	'E': /[]/g,
	'g': /[]/g,
	'G': /[]/g,
	'i': /[]/g,
	'I': /[]/g,
	'l': /[]/g,
	'L': /[]/g,
	'n': /[]/g,
	'N': /[]/g,
	'o': /[]/g,
	'O': /[]/g,
	'r': /[]/g,
	'R': /[]/g,
	's': /[]/g,
	'S': /[]/g,
	't': /[]/g,
	'T': /[]/g,
	'u': /[]/g,
	'U': /[]/g,
	'y': /[]/g,
	'Y': /[]/g,
	'z': /[]/g,
	'Z': /[]/g,
	'th': /[]/g,
	'TH': /[]/g,
	'dh': /[]/g,
	'DH': /[]/g,
	'ss': /[]/g,
	'oe': /[]/g,
	'OE': /[]/g,
	'ae': /[]/g,
	'AE': /[]/g
},

tidy = {
	' ': /[\xa0\u2002\u2003\u2009]/g,
	'*': /[\xb7]/g,
	'\'': /[\u2018\u2019]/g,
	'"': /[\u201c\u201d]/g,
	'...': /[\u2026]/g,
	'-': /[\u2013]/g,
//	'--': /[\u2014]/g,
	'&raquo;': /[\uFFFD]/g
},

conversions = {
	ms: 1,
	s: 1000,
	m: 6e4,
	h: 36e5
},

findUnits = /(\d*.?\d+)([msh]+)/;

var walk = function(string, replacements){
	var result = string, key;
	for (key in replacements) result = result.replace(replacements[key], key);
	return result;
};

var getRegexForTag = function(tag, contents){
	tag = tag || '';
	var regstr = contents ? "<" + tag + "(?!\\w)[^>]*>([\\s\\S]*?)<\/" + tag + "(?!\\w)>" : "<\/?" + tag + "([^>]+)?>",
		reg = new RegExp(regstr, "gi");
	return reg;
};

String.implement({

	standardize: function(){
		return walk(this, special);
	},

	repeat: function(times){
		return new Array(times + 1).join(this);
	},

	pad: function(length, str, direction){
		if (this.length >= length) return this;

		var pad = (str == null ? ' ' : '' + str)
			.repeat(length - this.length)
			.substr(0, length - this.length);

		if (!direction || direction == 'right') return this + pad;
		if (direction == 'left') return pad + this;

		return pad.substr(0, (pad.length / 2).floor()) + this + pad.substr(0, (pad.length / 2).ceil());
	},

	getTags: function(tag, contents){
		return this.match(getRegexForTag(tag, contents)) || [];
	},

	stripTags: function(tag, contents){
		return this.replace(getRegexForTag(tag, contents), '');
	},

	tidy: function(){
		return walk(this, tidy);
	},

	truncate: function(max, trail, atChar){
		var string = this;
		if (trail == null && arguments.length == 1) trail = '';
		if (string.length > max){
			string = string.substring(0, max);
			if (atChar){
				var index = string.lastIndexOf(atChar);
				if (index != -1) string = string.substr(0, index);
			}
			if (trail) string += trail;
		}
		return string;
	},

	ms: function(){
	  // "Borrowed" from https://gist.github.com/1503944
		var units = findUnits.exec(this);
		if (units == null) return Number(this);
		return Number(units[1]) * conversions[units[2]];
	}

});

})();

/*
---

script: Fx.Scroll.js

name: Fx.Scroll

description: Effect to smoothly scroll any element, including the window.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Fx
  - Core/Element.Event
  - Core/Element.Dimensions
  - MooTools.More

provides: [Fx.Scroll]

...
*/

(function(){

Fx.Scroll = new Class({

	Extends: Fx,

	options: {
		offset: {x: 0, y: 0},
		wheelStops: true
	},

	initialize: function(element, options){
		this.element = this.subject = document.id(element);
		this.parent(options);

		if (typeOf(this.element) != 'element') this.element = document.id(this.element.getDocument().body);

		if (this.options.wheelStops){
			var stopper = this.element,
				cancel = this.cancel.pass(false, this);
			this.addEvent('start', function(){
				stopper.addEvent('mousewheel', cancel);
			}, true);
			this.addEvent('complete', function(){
				stopper.removeEvent('mousewheel', cancel);
			}, true);
		}
	},

	set: function(){
		var now = Array.flatten(arguments);
		this.element.scrollTo(now[0], now[1]);
		return this;
	},

	compute: function(from, to, delta){
		return [0, 1].map(function(i){
			return Fx.compute(from[i], to[i], delta);
		});
	},

	start: function(x, y){
		if (!this.check(x, y)) return this;
		var scroll = this.element.getScroll();
		return this.parent([scroll.x, scroll.y], [x, y]);
	},

	calculateScroll: function(x, y){
		var element = this.element,
			scrollSize = element.getScrollSize(),
			scroll = element.getScroll(),
			size = element.getSize(),
			offset = this.options.offset,
			values = {x: x, y: y};

		for (var z in values){
			if (!values[z] && values[z] !== 0) values[z] = scroll[z];
			if (typeOf(values[z]) != 'number') values[z] = scrollSize[z] - size[z];
			values[z] += offset[z];
		}

		return [values.x, values.y];
	},

	toTop: function(){
		return this.start.apply(this, this.calculateScroll(false, 0));
	},

	toLeft: function(){
		return this.start.apply(this, this.calculateScroll(0, false));
	},

	toRight: function(){
		return this.start.apply(this, this.calculateScroll('right', false));
	},

	toBottom: function(){
		return this.start.apply(this, this.calculateScroll(false, 'bottom'));
	},

	toElement: function(el, axes){
		axes = axes ? Array.from(axes) : ['x', 'y'];
		var scroll = isBody(this.element) ? {x: 0, y: 0} : this.element.getScroll();
		var position = Object.map(document.id(el).getPosition(this.element), function(value, axis){
			return axes.contains(axis) ? value + scroll[axis] : false;
		});
		return this.start.apply(this, this.calculateScroll(position.x, position.y));
	},

	toElementEdge: function(el, axes, offset){
		axes = axes ? Array.from(axes) : ['x', 'y'];
		el = document.id(el);
		var to = {},
			position = el.getPosition(this.element),
			size = el.getSize(),
			scroll = this.element.getScroll(),
			containerSize = this.element.getSize(),
			edge = {
				x: position.x + size.x,
				y: position.y + size.y
			};

		['x', 'y'].each(function(axis){
			if (axes.contains(axis)){
				if (edge[axis] > scroll[axis] + containerSize[axis]) to[axis] = edge[axis] - containerSize[axis];
				if (position[axis] < scroll[axis]) to[axis] = position[axis];
			}
			if (to[axis] == null) to[axis] = scroll[axis];
			if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
		}, this);

		if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
		return this;
	},

	toElementCenter: function(el, axes, offset){
		axes = axes ? Array.from(axes) : ['x', 'y'];
		el = document.id(el);
		var to = {},
			position = el.getPosition(this.element),
			size = el.getSize(),
			scroll = this.element.getScroll(),
			containerSize = this.element.getSize();

		['x', 'y'].each(function(axis){
			if (axes.contains(axis)){
				to[axis] = position[axis] - (containerSize[axis] - size[axis]) / 2;
			}
			if (to[axis] == null) to[axis] = scroll[axis];
			if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
		}, this);

		if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
		return this;
	}

});



function isBody(element){
	return (/^(?:body|html)$/i).test(element.tagName);
}

})();

/*
---

name: Events.Pseudos

description: Adds the functionality to add pseudo events

license: MIT-style license

authors:
  - Arian Stolwijk

requires: [Core/Class.Extras, Core/Slick.Parser, MooTools.More]

provides: [Events.Pseudos]

...
*/

(function(){

Events.Pseudos = function(pseudos, addEvent, removeEvent){

	var storeKey = '_monitorEvents:';

	var storageOf = function(object){
		return {
			store: object.store ? function(key, value){
				object.store(storeKey + key, value);
			} : function(key, value){
				(object._monitorEvents || (object._monitorEvents = {}))[key] = value;
			},
			retrieve: object.retrieve ? function(key, dflt){
				return object.retrieve(storeKey + key, dflt);
			} : function(key, dflt){
				if (!object._monitorEvents) return dflt;
				return object._monitorEvents[key] || dflt;
			}
		};
	};

	var splitType = function(type){
		if (type.indexOf(':') == -1 || !pseudos) return null;

		var parsed = Slick.parse(type).expressions[0][0],
			parsedPseudos = parsed.pseudos,
			l = parsedPseudos.length,
			splits = [];

		while (l--){
			var pseudo = parsedPseudos[l].key,
				listener = pseudos[pseudo];
			if (listener != null) splits.push({
				event: parsed.tag,
				value: parsedPseudos[l].value,
				pseudo: pseudo,
				original: type,
				listener: listener
			});
		}
		return splits.length ? splits : null;
	};

	return {

		addEvent: function(type, fn, internal){
			var split = splitType(type);
			if (!split) return addEvent.call(this, type, fn, internal);

			var storage = storageOf(this),
				events = storage.retrieve(type, []),
				eventType = split[0].event,
				args = Array.slice(arguments, 2),
				stack = fn,
				self = this;

			split.each(function(item){
				var listener = item.listener,
					stackFn = stack;
				if (listener == false) eventType += ':' + item.pseudo + '(' + item.value + ')';
				else stack = function(){
					listener.call(self, item, stackFn, arguments, stack);
				};
			});

			events.include({type: eventType, event: fn, monitor: stack});
			storage.store(type, events);

			if (type != eventType) addEvent.apply(this, [type, fn].concat(args));
			return addEvent.apply(this, [eventType, stack].concat(args));
		},

		removeEvent: function(type, fn){
			var split = splitType(type);
			if (!split) return removeEvent.call(this, type, fn);

			var storage = storageOf(this),
				events = storage.retrieve(type);
			if (!events) return this;

			var args = Array.slice(arguments, 2);

			removeEvent.apply(this, [type, fn].concat(args));
			events.each(function(monitor, i){
				if (!fn || monitor.event == fn) removeEvent.apply(this, [monitor.type, monitor.monitor].concat(args));
				delete events[i];
			}, this);

			storage.store(type, events);
			return this;
		}

	};

};

var pseudos = {

	once: function(split, fn, args, monitor){
		fn.apply(this, args);
		this.removeEvent(split.event, monitor)
			.removeEvent(split.original, fn);
	},

	throttle: function(split, fn, args){
		if (!fn._throttled){
			fn.apply(this, args);
			fn._throttled = setTimeout(function(){
				fn._throttled = false;
			}, split.value || 250);
		}
	},

	pause: function(split, fn, args){
		clearTimeout(fn._pause);
		fn._pause = fn.delay(split.value || 250, this, args);
	}

};

Events.definePseudo = function(key, listener){
	pseudos[key] = listener;
	return this;
};

Events.lookupPseudo = function(key){
	return pseudos[key];
};

var proto = Events.prototype;
Events.implement(Events.Pseudos(pseudos, proto.addEvent, proto.removeEvent));

['Request', 'Fx'].each(function(klass){
	if (this[klass]) this[klass].implement(Events.prototype);
});

})();

/*
---

name: Element.Event.Pseudos

description: Adds the functionality to add pseudo events for Elements

license: MIT-style license

authors:
  - Arian Stolwijk

requires: [Core/Element.Event, Core/Element.Delegation, Events.Pseudos]

provides: [Element.Event.Pseudos, Element.Delegation.Pseudo]

...
*/

(function(){

var pseudos = {relay: false},
	copyFromEvents = ['once', 'throttle', 'pause'],
	count = copyFromEvents.length;

while (count--) pseudos[copyFromEvents[count]] = Events.lookupPseudo(copyFromEvents[count]);

DOMEvent.definePseudo = function(key, listener){
	pseudos[key] = listener;
	return this;
};

var proto = Element.prototype;
[Element, Window, Document].invoke('implement', Events.Pseudos(pseudos, proto.addEvent, proto.removeEvent));

})();

/*
---

name: Element.Event.Pseudos.Keys

description: Adds functionality fire events if certain keycombinations are pressed

license: MIT-style license

authors:
  - Arian Stolwijk

requires: [Element.Event.Pseudos]

provides: [Element.Event.Pseudos.Keys]

...
*/

(function(){

var keysStoreKey = '$moo:keys-pressed',
	keysKeyupStoreKey = '$moo:keys-keyup';


DOMEvent.definePseudo('keys', function(split, fn, args){

	var event = args[0],
		keys = [],
		pressed = this.retrieve(keysStoreKey, []),
		value = split.value;

	if (value != '+') keys.append(value.replace('++', function(){
		keys.push('+'); // shift++ and shift+++a
		return '';
	}).split('+'));
	else keys = ['+'];

	pressed.include(event.key);

	if (keys.every(function(key){
		return pressed.contains(key);
	})) fn.apply(this, args);

	this.store(keysStoreKey, pressed);

	if (!this.retrieve(keysKeyupStoreKey)){
		var keyup = function(event){
			(function(){
				pressed = this.retrieve(keysStoreKey, []).erase(event.key);
				this.store(keysStoreKey, pressed);
			}).delay(0, this); // Fix for IE
		};
		this.store(keysKeyupStoreKey, keyup).addEvent('keyup', keyup);
	}

});

DOMEvent.defineKeys({
	'16': 'shift',
	'17': 'control',
	'18': 'alt',
	'20': 'capslock',
	'33': 'pageup',
	'34': 'pagedown',
	'35': 'end',
	'36': 'home',
	'144': 'numlock',
	'145': 'scrolllock',
	'186': ';',
	'187': '=',
	'188': ',',
	'190': '.',
	'191': '/',
	'192': '`',
	'219': '[',
	'220': '\\',
	'221': ']',
	'222': "'",
	'107': '+',
	'109': '-', // subtract
	'189': '-'  // dash
})

})();

/*
---

script: Keyboard.js

name: Keyboard

description: KeyboardEvents used to intercept events on a class for keyboard and format modifiers in a specific order so as to make alt+shift+c the same as shift+alt+c.

license: MIT-style license

authors:
  - Perrin Westrich
  - Aaron Newton
  - Scott Kyle

requires:
  - Core/Events
  - Core/Options
  - Core/Element.Event
  - Element.Event.Pseudos.Keys

provides: [Keyboard]

...
*/

(function(){

	var Keyboard = this.Keyboard = new Class({

		Extends: Events,

		Implements: [Options],

		options: {/*
			onActivate: function(){},
			onDeactivate: function(){},*/
			defaultEventType: 'keydown',
			active: false,
			manager: null,
			events: {},
			nonParsedEvents: ['activate', 'deactivate', 'onactivate', 'ondeactivate', 'changed', 'onchanged']
		},

		initialize: function(options){
			if (options && options.manager){
				this._manager = options.manager;
				delete options.manager;
			}
			this.setOptions(options);
			this._setup();
		},

		addEvent: function(type, fn, internal){
			return this.parent(Keyboard.parse(type, this.options.defaultEventType, this.options.nonParsedEvents), fn, internal);
		},

		removeEvent: function(type, fn){
			return this.parent(Keyboard.parse(type, this.options.defaultEventType, this.options.nonParsedEvents), fn);
		},

		toggleActive: function(){
			return this[this.isActive() ? 'deactivate' : 'activate']();
		},

		activate: function(instance){
			if (instance){
				if (instance.isActive()) return this;
				//if we're stealing focus, store the last keyboard to have it so the relinquish command works
				if (this._activeKB && instance != this._activeKB){
					this.previous = this._activeKB;
					this.previous.fireEvent('deactivate');
				}
				//if we're enabling a child, assign it so that events are now passed to it
				this._activeKB = instance.fireEvent('activate');
				Keyboard.manager.fireEvent('changed');
			} else if (this._manager){
				//else we're enabling ourselves, we must ask our parent to do it for us
				this._manager.activate(this);
			}
			return this;
		},

		isActive: function(){
			return this._manager ? (this._manager._activeKB == this) : (Keyboard.manager == this);
		},

		deactivate: function(instance){
			if (instance){
				if (instance === this._activeKB){
					this._activeKB = null;
					instance.fireEvent('deactivate');
					Keyboard.manager.fireEvent('changed');
				}
			} else if (this._manager){
				this._manager.deactivate(this);
			}
			return this;
		},

		relinquish: function(){
			if (this.isActive() && this._manager && this._manager.previous) this._manager.activate(this._manager.previous);
			else this.deactivate();
			return this;
		},

		//management logic
		manage: function(instance){
			if (instance._manager) instance._manager.drop(instance);
			this._instances.push(instance);
			instance._manager = this;
			if (!this._activeKB) this.activate(instance);
			return this;
		},

		drop: function(instance){
			instance.relinquish();
			this._instances.erase(instance);
			if (this._activeKB == instance){
				if (this.previous && this._instances.contains(this.previous)) this.activate(this.previous);
				else this._activeKB = this._instances[0];
			}
			return this;
		},

		trace: function(){
			Keyboard.trace(this);
		},

		each: function(fn){
			Keyboard.each(this, fn);
		},

		/*
			PRIVATE METHODS
		*/

		_instances: [],

		_disable: function(instance){
			if (this._activeKB == instance) this._activeKB = null;
		},

		_setup: function(){
			this.addEvents(this.options.events);
			//if this is the root manager, nothing manages it
			if (Keyboard.manager && !this._manager) Keyboard.manager.manage(this);
			if (this.options.active) this.activate();
			else this.relinquish();
		},

		_handle: function(event, type){
			//Keyboard.stop(event) prevents key propagation
			if (event.preventKeyboardPropagation) return;

			var bubbles = !!this._manager;
			if (bubbles && this._activeKB){
				this._activeKB._handle(event, type);
				if (event.preventKeyboardPropagation) return;
			}
			this.fireEvent(type, event);

			if (!bubbles && this._activeKB) this._activeKB._handle(event, type);
		}

	});

	var parsed = {};
	var modifiers = ['shift', 'control', 'alt', 'meta'];
	var regex = /^(?:shift|control|ctrl|alt|meta)$/;

	Keyboard.parse = function(type, eventType, ignore){
		if (ignore && ignore.contains(type.toLowerCase())) return type;

		type = type.toLowerCase().replace(/^(keyup|keydown):/, function($0, $1){
			eventType = $1;
			return '';
		});

		if (!parsed[type]){
		    if (type != '+'){
				var key, mods = {};
				type.split('+').each(function(part){
					if (regex.test(part)) mods[part] = true;
					else key = part;
				});

				mods.control = mods.control || mods.ctrl; // allow both control and ctrl

				var keys = [];
				modifiers.each(function(mod){
					if (mods[mod]) keys.push(mod);
				});

				if (key) keys.push(key);
				parsed[type] = keys.join('+');
			} else {
			    parsed[type] = type;
			}
		}

		return eventType + ':keys(' + parsed[type] + ')';
	};

	Keyboard.each = function(keyboard, fn){
		var current = keyboard || Keyboard.manager;
		while (current){
			fn(current);
			current = current._activeKB;
		}
	};

	Keyboard.stop = function(event){
		event.preventKeyboardPropagation = true;
	};

	Keyboard.manager = new Keyboard({
		active: true
	});

	Keyboard.trace = function(keyboard){
		keyboard = keyboard || Keyboard.manager;
		var hasConsole = window.console && console.log;
		if (hasConsole) console.log('the following items have focus: ');
		Keyboard.each(keyboard, function(current){
			if (hasConsole) console.log(document.id(current.widget) || current.wiget || current);
		});
	};

	var handler = function(event){
		var keys = [];
		modifiers.each(function(mod){
			if (event[mod]) keys.push(mod);
		});

		if (!regex.test(event.key)) keys.push(event.key);
		Keyboard.manager._handle(event, event.type + ':keys(' + keys.join('+') + ')');
	};

	document.addEvents({
		'keyup': handler,
		'keydown': handler
	});

})();

/*
---

script: Keyboard.Extras.js

name: Keyboard.Extras

description: Enhances Keyboard by adding the ability to name and describe keyboard shortcuts, and the ability to grab shortcuts by name and bind the shortcut to different keys.

license: MIT-style license

authors:
  - Perrin Westrich

requires:
  - Keyboard
  - MooTools.More

provides: [Keyboard.Extras]

...
*/
Keyboard.prototype.options.nonParsedEvents.combine(['rebound', 'onrebound']);

Keyboard.implement({

	/*
		shortcut should be in the format of:
		{
			'keys': 'shift+s', // the default to add as an event.
			'description': 'blah blah blah', // a brief description of the functionality.
			'handler': function(){} // the event handler to run when keys are pressed.
		}
	*/
	addShortcut: function(name, shortcut){
		this._shortcuts = this._shortcuts || [];
		this._shortcutIndex = this._shortcutIndex || {};

		shortcut.getKeyboard = Function.from(this);
		shortcut.name = name;
		this._shortcutIndex[name] = shortcut;
		this._shortcuts.push(shortcut);
		if (shortcut.keys) this.addEvent(shortcut.keys, shortcut.handler);
		return this;
	},

	addShortcuts: function(obj){
		for (var name in obj) this.addShortcut(name, obj[name]);
		return this;
	},

	removeShortcut: function(name){
		var shortcut = this.getShortcut(name);
		if (shortcut && shortcut.keys){
			this.removeEvent(shortcut.keys, shortcut.handler);
			delete this._shortcutIndex[name];
			this._shortcuts.erase(shortcut);
		}
		return this;
	},

	removeShortcuts: function(names){
		names.each(this.removeShortcut, this);
		return this;
	},

	getShortcuts: function(){
		return this._shortcuts || [];
	},

	getShortcut: function(name){
		return (this._shortcutIndex || {})[name];
	}

});

Keyboard.rebind = function(newKeys, shortcuts){
	Array.from(shortcuts).each(function(shortcut){
		shortcut.getKeyboard().removeEvent(shortcut.keys, shortcut.handler);
		shortcut.getKeyboard().addEvent(newKeys, shortcut.handler);
		shortcut.keys = newKeys;
		shortcut.getKeyboard().fireEvent('rebound');
	});
};


Keyboard.getActiveShortcuts = function(keyboard){
	var activeKBS = [], activeSCS = [];
	Keyboard.each(keyboard, [].push.bind(activeKBS));
	activeKBS.each(function(kb){ activeSCS.extend(kb.getShortcuts()); });
	return activeSCS;
};

Keyboard.getShortcut = function(name, keyboard, opts){
	opts = opts || {};
	var shortcuts = opts.many ? [] : null,
		set = opts.many ? function(kb){
				var shortcut = kb.getShortcut(name);
				if (shortcut) shortcuts.push(shortcut);
			} : function(kb){
				if (!shortcuts) shortcuts = kb.getShortcut(name);
			};
	Keyboard.each(keyboard, set);
	return shortcuts;
};

Keyboard.getShortcuts = function(name, keyboard){
	return Keyboard.getShortcut(name, keyboard, { many: true });
};

/*
---

script: Request.JSONP.js

name: Request.JSONP

description: Defines Request.JSONP, a class for cross domain javascript via script injection.

license: MIT-style license

authors:
  - Aaron Newton
  - Guillermo Rauch
  - Arian Stolwijk

requires:
  - Core/Element
  - Core/Request
  - MooTools.More

provides: [Request.JSONP]

...
*/

Request.JSONP = new Class({

	Implements: [Chain, Events, Options],

	options: {/*
		onRequest: function(src, scriptElement){},
		onComplete: function(data){},
		onSuccess: function(data){},
		onCancel: function(){},
		onTimeout: function(){},
		onError: function(){}, */
		onRequest: function(src){
			if (this.options.log && window.console && console.log){
				console.log('JSONP retrieving script with url:' + src);
			}
		},
		onError: function(src){
			if (this.options.log && window.console && console.warn){
				console.warn('JSONP '+ src +' will fail in Internet Explorer, which enforces a 2083 bytes length limit on URIs');
			}
		},
		url: '',
		callbackKey: 'callback',
		injectScript: document.head,
		data: '',
		link: 'ignore',
		timeout: 0,
		log: false
	},

	initialize: function(options){
		this.setOptions(options);
	},

	send: function(options){
		if (!Request.prototype.check.call(this, options)) return this;
		this.running = true;

		var type = typeOf(options);
		if (type == 'string' || type == 'element') options = {data: options};
		options = Object.merge(this.options, options || {});

		var data = options.data;
		switch (typeOf(data)){
			case 'element': data = document.id(data).toQueryString(); break;
			case 'object': case 'hash': data = Object.toQueryString(data);
		}

		var index = this.index = Request.JSONP.counter++;

		var src = options.url +
			(options.url.test('\\?') ? '&' :'?') +
			(options.callbackKey) +
			'=Request.JSONP.request_map.request_'+ index +
			(data ? '&' + data : '');

		if (src.length > 2083) this.fireEvent('error', src);

		Request.JSONP.request_map['request_' + index] = function(){
			this.success(arguments, index);
		}.bind(this);

		var script = this.getScript(src).inject(options.injectScript);
		this.fireEvent('request', [src, script]);

		if (options.timeout) this.timeout.delay(options.timeout, this);

		return this;
	},

	getScript: function(src){
		if (!this.script) this.script = new Element('script', {
			type: 'text/javascript',
			async: true,
			src: src
		});
		return this.script;
	},

	success: function(args, index){
		if (!this.running) return;
		this.clear()
			.fireEvent('complete', args).fireEvent('success', args)
			.callChain();
	},

	cancel: function(){
		if (this.running) this.clear().fireEvent('cancel');
		return this;
	},

	isRunning: function(){
		return !!this.running;
	},

	clear: function(){
		this.running = false;
		if (this.script){
			this.script.destroy();
			this.script = null;
		}
		return this;
	},

	timeout: function(){
		if (this.running){
			this.running = false;
			this.fireEvent('timeout', [this.script.get('src'), this.script]).fireEvent('failure').cancel();
		}
		return this;
	}

});

Request.JSONP.counter = 0;
Request.JSONP.request_map = {};

/*
---

script: String.QueryString.js

name: String.QueryString

description: Methods for dealing with URI query strings.

license: MIT-style license

authors:
  - Sebastian Markbge
  - Aaron Newton
  - Lennart Pilon
  - Valerio Proietti

requires:
  - Core/Array
  - Core/String
  - MooTools.More

provides: [String.QueryString]

...
*/

String.implement({

	parseQueryString: function(decodeKeys, decodeValues){
		if (decodeKeys == null) decodeKeys = true;
		if (decodeValues == null) decodeValues = true;

		var vars = this.split(/[&;]/),
			object = {};
		if (!vars.length) return object;

		vars.each(function(val){
			var index = val.indexOf('=') + 1,
				value = index ? val.substr(index) : '',
				keys = index ? val.substr(0, index - 1).match(/([^\]\[]+|(\B)(?=\]))/g) : [val],
				obj = object;
			if (!keys) return;
			if (decodeValues) value = decodeURIComponent(value);
			keys.each(function(key, i){
				if (decodeKeys) key = decodeURIComponent(key);
				var current = obj[key];

				if (i < keys.length - 1) obj = obj[key] = current || {};
				else if (typeOf(current) == 'array') current.push(value);
				else obj[key] = current != null ? [current, value] : value;
			});
		});

		return object;
	},

	cleanQueryString: function(method){
		return this.split('&').filter(function(val){
			var index = val.indexOf('='),
				key = index < 0 ? '' : val.substr(0, index),
				value = val.substr(index + 1);

			return method ? method.call(null, key, value) : (value || value === 0);
		}).join('&');
	}

});

/*
---

script: URI.js

name: URI

description: Provides methods useful in managing the window location and uris.

license: MIT-style license

authors:
  - Sebastian Markbge
  - Aaron Newton

requires:
  - Core/Object
  - Core/Class
  - Core/Class.Extras
  - Core/Element
  - String.QueryString

provides: [URI]

...
*/

(function(){

var toString = function(){
	return this.get('value');
};

var URI = this.URI = new Class({

	Implements: Options,

	options: {
		/*base: false*/
	},

	regex: /^(?:(\w+):)?(?:\/\/(?:(?:([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)?(\.\.?$|(?:[^?#\/]*\/)*)([^?#]*)(?:\?([^#]*))?(?:#(.*))?/,
	parts: ['scheme', 'user', 'password', 'host', 'port', 'directory', 'file', 'query', 'fragment'],
	schemes: {http: 80, https: 443, ftp: 21, rtsp: 554, mms: 1755, file: 0},

	initialize: function(uri, options){
		this.setOptions(options);
		var base = this.options.base || URI.base;
		if (!uri) uri = base;

		if (uri && uri.parsed) this.parsed = Object.clone(uri.parsed);
		else this.set('value', uri.href || uri.toString(), base ? new URI(base) : false);
	},

	parse: function(value, base){
		var bits = value.match(this.regex);
		if (!bits) return false;
		bits.shift();
		return this.merge(bits.associate(this.parts), base);
	},

	merge: function(bits, base){
		if ((!bits || !bits.scheme) && (!base || !base.scheme)) return false;
		if (base){
			this.parts.every(function(part){
				if (bits[part]) return false;
				bits[part] = base[part] || '';
				return true;
			});
		}
		bits.port = bits.port || this.schemes[bits.scheme.toLowerCase()];
		bits.directory = bits.directory ? this.parseDirectory(bits.directory, base ? base.directory : '') : '/';
		return bits;
	},

	parseDirectory: function(directory, baseDirectory){
		directory = (directory.substr(0, 1) == '/' ? '' : (baseDirectory || '/')) + directory;
		if (!directory.test(URI.regs.directoryDot)) return directory;
		var result = [];
		directory.replace(URI.regs.endSlash, '').split('/').each(function(dir){
			if (dir == '..' && result.length > 0) result.pop();
			else if (dir != '.') result.push(dir);
		});
		return result.join('/') + '/';
	},

	combine: function(bits){
		return bits.value || bits.scheme + '://' +
			(bits.user ? bits.user + (bits.password ? ':' + bits.password : '') + '@' : '') +
			(bits.host || '') + (bits.port && bits.port != this.schemes[bits.scheme] ? ':' + bits.port : '') +
			(bits.directory || '/') + (bits.file || '') +
			(bits.query ? '?' + bits.query : '') +
			(bits.fragment ? '#' + bits.fragment : '');
	},

	set: function(part, value, base){
		if (part == 'value'){
			var scheme = value.match(URI.regs.scheme);
			if (scheme) scheme = scheme[1];
			if (scheme && this.schemes[scheme.toLowerCase()] == null) this.parsed = { scheme: scheme, value: value };
			else this.parsed = this.parse(value, (base || this).parsed) || (scheme ? { scheme: scheme, value: value } : { value: value });
		} else if (part == 'data'){
			this.setData(value);
		} else {
			this.parsed[part] = value;
		}
		return this;
	},

	get: function(part, base){
		switch (part){
			case 'value': return this.combine(this.parsed, base ? base.parsed : false);
			case 'data' : return this.getData();
		}
		return this.parsed[part] || '';
	},

	go: function(){
		document.location.href = this.toString();
	},

	toURI: function(){
		return this;
	},

	getData: function(key, part){
		var qs = this.get(part || 'query');
		if (!(qs || qs === 0)) return key ? null : {};
		var obj = qs.parseQueryString();
		return key ? obj[key] : obj;
	},

	setData: function(values, merge, part){
		if (typeof values == 'string'){
			var data = this.getData();
			data[arguments[0]] = arguments[1];
			values = data;
		} else if (merge){
			values = Object.merge(this.getData(null, part), values);
		}
		return this.set(part || 'query', Object.toQueryString(values));
	},

	clearData: function(part){
		return this.set(part || 'query', '');
	},

	toString: toString,
	valueOf: toString

});

URI.regs = {
	endSlash: /\/$/,
	scheme: /^(\w+):/,
	directoryDot: /\.\/|\.$/
};

URI.base = new URI(Array.from(document.getElements('base[href]', true)).getLast(), {base: document.location});

String.implement({

	toURI: function(options){
		return new URI(this, options);
	}

});

})();

/*
---

script: Assets.js

name: Assets

description: Provides methods to dynamically load JavaScript, CSS, and Image files into the document.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Element.Event
  - MooTools.More

provides: [Assets]

...
*/

var Asset = {

	javascript: function(source, properties){
		if (!properties) properties = {};

		var script = new Element('script', {src: source, type: 'text/javascript'}),
			doc = properties.document || document,
			load = properties.onload || properties.onLoad;

		delete properties.onload;
		delete properties.onLoad;
		delete properties.document;

		if (load){
			if (!script.addEventListener){
				script.addEvent('readystatechange', function(){
					if (['loaded', 'complete'].contains(this.readyState)) load.call(this);
				});
			} else {
				script.addEvent('load', load);
			}
		}

		return script.set(properties).inject(doc.head);
	},

	css: function(source, properties){
		if (!properties) properties = {};

		var load = properties.onload || properties.onLoad,
			doc = properties.document || document,
			timeout = properties.timeout || 3000;

		['onload', 'onLoad', 'document'].each(function(prop){
			delete properties[prop];
		});

		var link = new Element('link', {
			type: 'text/css',
			rel: 'stylesheet',
			media: 'screen',
			href: source
		}).setProperties(properties).inject(doc.head);

		if (load){
			// based on article at http://www.yearofmoo.com/2011/03/cross-browser-stylesheet-preloading.html
			var loaded = false, retries = 0;
			var check = function(){
				var stylesheets = document.styleSheets;
				for (var i = 0; i < stylesheets.length; i++){
					var file = stylesheets[i];
					var owner = file.ownerNode ? file.ownerNode : file.owningElement;
					if (owner && owner == link){
						loaded = true;
						return load.call(link);
					}
				}
				retries++;
				if (!loaded && retries < timeout / 50) return setTimeout(check, 50);
			}
			setTimeout(check, 0);
		}
		return link;
	},

	image: function(source, properties){
		if (!properties) properties = {};

		var image = new Image(),
			element = document.id(image) || new Element('img');

		['load', 'abort', 'error'].each(function(name){
			var type = 'on' + name,
				cap = 'on' + name.capitalize(),
				event = properties[type] || properties[cap] || function(){};

			delete properties[cap];
			delete properties[type];

			image[type] = function(){
				if (!image) return;
				if (!element.parentNode){
					element.width = image.width;
					element.height = image.height;
				}
				image = image.onload = image.onabort = image.onerror = null;
				event.delay(1, element, element);
				element.fireEvent(name, element, 1);
			};
		});

		image.src = element.src = source;
		if (image && image.complete) image.onload.delay(1);
		return element.set(properties);
	},

	images: function(sources, options){
		sources = Array.from(sources);

		var fn = function(){},
			counter = 0;

		options = Object.merge({
			onComplete: fn,
			onProgress: fn,
			onError: fn,
			properties: {}
		}, options);

		return new Elements(sources.map(function(source, index){
			return Asset.image(source, Object.append(options.properties, {
				onload: function(){
					counter++;
					options.onProgress.call(this, counter, index, source);
					if (counter == sources.length) options.onComplete();
				},
				onerror: function(){
					counter++;
					options.onError.call(this, counter, index, source);
					if (counter == sources.length) options.onComplete();
				}
			}));
		}));
	}

};

/*
---

name: Swiff

description: Wrapper for embedding SWF movies. Supports External Interface Communication.

license: MIT-style license.

credits:
  - Flash detection & Internet Explorer + Flash Player 9 fix inspired by SWFObject.

requires: [Core/Options, Core/Object, Core/Element]

provides: Swiff

...
*/

(function(){

var Swiff = this.Swiff = new Class({

	Implements: Options,

	options: {
		id: null,
		height: 1,
		width: 1,
		container: null,
		properties: {},
		params: {
			quality: 'high',
			allowScriptAccess: 'always',
			wMode: 'window',
			swLiveConnect: true
		},
		callBacks: {},
		vars: {}
	},

	toElement: function(){
		return this.object;
	},

	initialize: function(path, options){
		this.instance = 'Swiff_' + String.uniqueID();

		this.setOptions(options);
		options = this.options;
		var id = this.id = options.id || this.instance;
		var container = document.id(options.container);

		Swiff.CallBacks[this.instance] = {};

		var params = options.params, vars = options.vars, callBacks = options.callBacks;
		var properties = Object.append({height: options.height, width: options.width}, options.properties);

		var self = this;

		for (var callBack in callBacks){
			Swiff.CallBacks[this.instance][callBack] = (function(option){
				return function(){
					return option.apply(self.object, arguments);
				};
			})(callBacks[callBack]);
			vars[callBack] = 'Swiff.CallBacks.' + this.instance + '.' + callBack;
		}

		params.flashVars = Object.toQueryString(vars);
		if ('ActiveXObject' in window){
			properties.classid = 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000';
			params.movie = path;
		} else {
			properties.type = 'application/x-shockwave-flash';
		}
		properties.data = path;

		var build = '<object id="' + id + '"';
		for (var property in properties) build += ' ' + property + '="' + properties[property] + '"';
		build += '>';
		for (var param in params){
			if (params[param]) build += '<param name="' + param + '" value="' + params[param] + '" />';
		}
		build += '</object>';
		this.object = ((container) ? container.empty() : new Element('div')).set('html', build).firstChild;
	},

	replaces: function(element){
		element = document.id(element, true);
		element.parentNode.replaceChild(this.toElement(), element);
		return this;
	},

	inject: function(element){
		document.id(element, true).appendChild(this.toElement());
		return this;
	},

	remote: function(){
		return Swiff.remote.apply(Swiff, [this.toElement()].append(arguments));
	}

});

Swiff.CallBacks = {};

Swiff.remote = function(obj, fn){
	var rs = obj.CallFunction('<invoke name="' + fn + '" returntype="javascript">' + __flash__argumentsToXML(arguments, 2) + '</invoke>');
	return eval(rs);
};

})();


/*!
 * accounting.js v0.3.2
 * Copyright 2011, Joss Crowcroft
 *
 * Freely distributable under the MIT license.
 * Portions of accounting.js are inspired or borrowed from underscore.js
 *
 * Full details and documentation:
 * http://josscrowcroft.github.com/accounting.js/
 */

(function(root, undefined) {

    /* --- Setup --- */

    // Create the local library object, to be exported or referenced globally later
    var lib = {};

    // Current version
    lib.version = '0.3.2';


    /* --- Exposed settings --- */

    // The library's settings configuration object. Contains default parameters for
    // currency and number formatting
    lib.settings = {
        currency: {
            symbol : "$",		// default currency symbol is '$'
            format : "%s%v",	// controls output: %s = symbol, %v = value (can be object, see docs)
            decimal : ".",		// decimal point separator
            thousand : ",",		// thousands separator
            precision : 2,		// decimal places
            grouping : 3		// digit grouping (not implemented yet)
        },
        number: {
            precision : 0,		// default precision on numbers is 0
            grouping : 3,		// digit grouping (not implemented yet)
            thousand : ",",
            decimal : "."
        }
    };


    /* --- Internal Helper Methods --- */

    // Store reference to possibly-available ECMAScript 5 methods for later
    var nativeMap = Array.prototype.map,
        nativeIsArray = Array.isArray,
        toString = Object.prototype.toString;

    /**
     * Tests whether supplied parameter is a string
     * from underscore.js
     */
    function isString(obj) {
        return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
    }

    /**
     * Tests whether supplied parameter is a string
     * from underscore.js, delegates to ECMA5's native Array.isArray
     */
    function isArray(obj) {
        return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]';
    }

    /**
     * Tests whether supplied parameter is a true object
     */
    function isObject(obj) {
        return obj && toString.call(obj) === '[object Object]';
    }

    /**
     * Extends an object with a defaults object, similar to underscore's _.defaults
     *
     * Used for abstracting parameter handling from API methods
     */
    function defaults(object, defs) {
        var key;
        object = object || {};
        defs = defs || {};
        // Iterate over object non-prototype properties:
        for (key in defs) {
            if (defs.hasOwnProperty(key)) {
                // Replace values with defaults only if undefined (allow empty/zero values):
                if (object[key] == null) object[key] = defs[key];
            }
        }
        return object;
    }

    /**
     * Implementation of `Array.map()` for iteration loops
     *
     * Returns a new Array as a result of calling `iterator` on each array value.
     * Defers to native Array.map if available
     */
    function map(obj, iterator, context) {
        var results = [], i, j;

        if (!obj) return results;

        // Use native .map method if it exists:
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);

        // Fallback for native .map:
        for (i = 0, j = obj.length; i < j; i++ ) {
            results[i] = iterator.call(context, obj[i], i, obj);
        }
        return results;
    }

    /**
     * Check and normalise the value of precision (must be positive integer)
     */
    function checkPrecision(val, base) {
        val = Math.round(Math.abs(val));
        return isNaN(val)? base : val;
    }


    /**
     * Parses a format string or object and returns format obj for use in rendering
     *
     * `format` is either a string with the default (positive) format, or object
     * containing `pos` (required), `neg` and `zero` values (or a function returning
     * either a string or object)
     *
     * Either string or format.pos must contain "%v" (value) to be valid
     */
    function checkCurrencyFormat(format) {
        var defaults = lib.settings.currency.format;

        // Allow function as format parameter (should return string or object):
        if ( typeof format === "function" ) format = format();

        // Format can be a string, in which case `value` ("%v") must be present:
        if ( isString( format ) && format.match("%v") ) {

            // Create and return positive, negative and zero formats:
            return {
                pos : format,
                neg : format.replace("-", "").replace("%v", "-%v"),
                zero : format
            };

            // If no format, or object is missing valid positive value, use defaults:
        } else if ( !format || !format.pos || !format.pos.match("%v") ) {

            // If defaults is a string, casts it to an object for faster checking next time:
            return ( !isString( defaults ) ) ? defaults : lib.settings.currency.format = {
                pos : defaults,
                neg : defaults.replace("%v", "-%v"),
                zero : defaults
            };

        }
        // Otherwise, assume format was fine:
        return format;
    }


    /* --- API Methods --- */

    /**
     * Takes a string/array of strings, removes all formatting/cruft and returns the raw float value
     * alias: accounting.`parse(string)`
     *
     * Decimal must be included in the regular expression to match floats (defaults to
     * accounting.settings.number.decimal), so if the number uses a non-standard decimal
     * separator, provide it as the second argument.
     *
     * Also matches bracketed negatives (eg. "$ (1.99)" => -1.99)
     *
     * Doesn't throw any errors (`NaN`s become 0) but this may change in future
     */
    var unformat = lib.unformat = lib.parse = function(value, decimal) {
        // Recursively unformat arrays:
        if (isArray(value)) {
            return map(value, function(val) {
                return unformat(val, decimal);
            });
        }

        // Fails silently (need decent errors):
        value = value || 0;

        // Return the value as-is if it's already a number:
        if (typeof value === "number") return value;

        // Default decimal point comes from settings, but could be set to eg. "," in opts:
        decimal = decimal || lib.settings.number.decimal;

        // Build regex to strip out everything except digits, decimal point and minus sign:
        var regex = new RegExp("[^0-9-" + decimal + "]", ["g"]),
            unformatted = parseFloat(
                ("" + value)
                    .replace(/\((.*)\)/, "-$1") // replace bracketed values with negatives
                    .replace(regex, '')         // strip out any cruft
                    .replace(decimal, '.')      // make sure decimal point is standard
            );

        // This will fail silently which may cause trouble, let's wait and see:
        return !isNaN(unformatted) ? unformatted : 0;
    };


    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === "0.61") that present
     * problems for accounting- and finance-related software.
     */
    var toFixed = lib.toFixed = function(value, precision) {
        precision = checkPrecision(precision, lib.settings.number.precision);
        var power = Math.pow(10, precision);

        // Multiply up by precision, round accurately, then divide and use native toFixed():
        return (Math.round(lib.unformat(value) * power) / power).toFixed(precision);
    };


    /**
     * Format a number, with comma-separated thousands and custom precision/decimal places
     *
     * Localise by overriding the precision and thousand / decimal separators
     * 2nd parameter `precision` can be an object matching `settings.number`
     */
    var formatNumber = lib.formatNumber = function(number, precision, thousand, decimal) {
        // Resursively format arrays:
        if (isArray(number)) {
            return map(number, function(val) {
                return formatNumber(val, precision, thousand, decimal);
            });
        }

        // Clean up number:
        number = unformat(number);

        // Build options object from second param (if object) or all params, extending defaults:
        var opts = defaults(
                (isObject(precision) ? precision : {
                    precision : precision,
                    thousand : thousand,
                    decimal : decimal
                }),
                lib.settings.number
            ),

        // Clean up precision
            usePrecision = checkPrecision(opts.precision),

        // Do some calc:
            negative = number < 0 ? "-" : "",
            base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + "",
            mod = base.length > 3 ? base.length % 3 : 0;

        // Format the number:
        return negative + (mod ? base.substr(0, mod) + opts.thousand : "") + base.substr(mod).replace(/(\d{3})(?=\d)/g, "$1" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1] : "");
    };


    /**
     * Format a number into currency
     *
     * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)
     * defaults: (0, "$", 2, ",", ".", "%s%v")
     *
     * Localise by overriding the symbol, precision, thousand / decimal separators and format
     * Second param can be an object matching `settings.currency` which is the easiest way.
     *
     * To do: tidy up the parameters
     */
    var formatMoney = lib.formatMoney = function(number, symbol, precision, thousand, decimal, format) {
        // Resursively format arrays:
        if (isArray(number)) {
            return map(number, function(val){
                return formatMoney(val, symbol, precision, thousand, decimal, format);
            });
        }

        // Clean up number:
        number = unformat(number);

        // Build options object from second param (if object) or all params, extending defaults:
        var opts = defaults(
                (isObject(symbol) ? symbol : {
                    symbol : symbol,
                    precision : precision,
                    thousand : thousand,
                    decimal : decimal,
                    format : format
                }),
                lib.settings.currency
            ),

        // Check format (returns object with pos, neg and zero):
            formats = checkCurrencyFormat(opts.format),

        // Choose which format to use for this value:
            useFormat = number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero;

        // Return with currency symbol added:
        return useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal));
    };


    /**
     * Format a list of numbers into an accounting column, padding with whitespace
     * to line up currency symbols, thousand separators and decimals places
     *
     * List should be an array of numbers
     * Second parameter can be an object containing keys that match the params
     *
     * Returns array of accouting-formatted number strings of same length
     *
     * NB: `white-space:pre` CSS rule is required on the list container to prevent
     * browsers from collapsing the whitespace in the output strings.
     */
    lib.formatColumn = function(list, symbol, precision, thousand, decimal, format) {
        if (!list) return [];

        // Build options object from second param (if object) or all params, extending defaults:
        var opts = defaults(
                (isObject(symbol) ? symbol : {
                    symbol : symbol,
                    precision : precision,
                    thousand : thousand,
                    decimal : decimal,
                    format : format
                }),
                lib.settings.currency
            ),

        // Check format (returns object with pos, neg and zero), only need pos for now:
            formats = checkCurrencyFormat(opts.format),

        // Whether to pad at start of string or after currency symbol:
            padAfterSymbol = formats.pos.indexOf("%s") < formats.pos.indexOf("%v") ? true : false,

        // Store value for the length of the longest string in the column:
            maxLength = 0,

        // Format the list according to options, store the length of the longest string:
            formatted = map(list, function(val, i) {
                if (isArray(val)) {
                    // Recursively format columns if list is a multi-dimensional array:
                    return lib.formatColumn(val, opts);
                } else {
                    // Clean up the value
                    val = unformat(val);

                    // Choose which format to use for this value (pos, neg or zero):
                    var useFormat = val > 0 ? formats.pos : val < 0 ? formats.neg : formats.zero,

                    // Format this value, push into formatted list and save the length:
                        fVal = useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));

                    if (fVal.length > maxLength) maxLength = fVal.length;
                    return fVal;
                }
            });

        // Pad each number in the list and send back the column of numbers:
        return map(formatted, function(val, i) {
            // Only if this is a string (not a nested array, which would have already been padded):
            if (isString(val) && val.length < maxLength) {
                // Depending on symbol position, pad after symbol or at index 0:
                return padAfterSymbol ? val.replace(opts.symbol, opts.symbol+(new Array(maxLength - val.length + 1).join(" "))) : (new Array(maxLength - val.length + 1).join(" ")) + val;
            }
            return val;
        });
    };


    /* --- Module Definition --- */

    // Export accounting for CommonJS. If being loaded as an AMD module, define it as such.
    // Otherwise, just add `accounting` to the global object
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = lib;
        }
        exports.accounting = lib;
    } else if (typeof define === 'function' && define.amd) {
        // Return the library as an AMD module:
        define([], function() {
            return lib;
        });
    } else {
        // Use accounting.noConflict to restore `accounting` back to its original value.
        // Returns a reference to the library's `accounting` object;
        // e.g. `var numbers = accounting.noConflict();`
        lib.noConflict = (function(oldAccounting) {
            return function() {
                // Reset the value of the root's `accounting` variable:
                root.accounting = oldAccounting;
                // Delete the noConflict method:
                lib.noConflict = undefined;
                // Return reference to the library to re-assign it:
                return lib;
            };
        })(root.accounting);

        // Declare `fx` on the root (global/window) object:
        root['accounting'] = lib;
    }

    // Root will be `window` in browser or `global` on the server:
}(this));


/*!
 * moment.js v2.6.0
 * Copyright (c) 2011-2014 Tim Wood, Iskren Chernev, Moment.js contributors
 *
 * Freely distributable under the MIT license.
  *
 * Full details and documentation:
 * http://momentjs.com/
 */

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.6.0",
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error("Implement me");
        }
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                    typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
            if (strict) { return parseTokenThreeDigits; }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = getLangDefinition(config._l).weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, lang;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            lang = getLangDefinition(config._l);
            dow = lang._week.dow;
            doy = lang._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
            "moment construction falls back to js Date. This is " +
            "discouraged and will be removed in upcoming major " +
            "release. Please refer to " +
            "https://github.com/moment/moment/issues/1407 for more info.",
            function (config) {
        config._d = new Date(config._i);
    });

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: deprecate(
                 "moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                "moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    "Accessing Moment through the global scope is " +
                    "deprecated, and will be removed in an upcoming " +
                    "release.",
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    //if (hasModule) {
    //    module.exports = moment;
    //} else if (typeof define === "function" && define.amd) {
    //    define("moment", function (require, exports, module) {
    //        if (module.config && module.config() && module.config().noGlobal === true) {
    //            // release the global variable
    //            globalScope.moment = oldGlobalMoment;
    //        }
    //
    //        return moment;
    //    });
    //    makeGlobal(true);
    //} else {
       makeGlobal();
    //}
}).call(this);


// moment.js language configuration
// language : canadian english (en-ca)
// author : Jonathan Abourbih : https://github.com/jonbca

(function (factory) {
    //if (typeof define === 'function' && define.amd) {
    //    define(['moment'], factory); // AMD
    //} else if (typeof exports === 'object') {
    //    module.exports = factory(require('../moment')); // Node
    //} else {
    factory(window.moment); // Browser global
    //}
}(function (moment) {
    return moment.lang('en-ca', {
        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat : {
            LT : "h:mm A",
            L : "YYYY-MM-DD",
            LL : "D MMMM, YYYY",
            LLL : "D MMMM, YYYY LT",
            LLLL : "dddd, D MMMM, YYYY LT"
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        ordinal : function (number) {
            var b = number % 10,
                output = (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });
}));


// moment.js language configuration
// language : great britain english (en-gb)
// author : Chris Gedrim : https://github.com/chrisgedrim

(function (factory) {
    //if (typeof define === 'function' && define.amd) {
    //    define(['moment'], factory); // AMD
    //} else if (typeof exports === 'object') {
    //    module.exports = factory(require('../moment')); // Node
    //} else {
    factory(window.moment); // Browser global
    //}
}(function (moment) {
    return moment.lang('en-gb', {
        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "DD/MM/YYYY",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY LT",
            LLLL : "dddd, D MMMM YYYY LT"
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        ordinal : function (number) {
            var b = number % 10,
                output = (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));


// moment.js language configuration
// language : french (fr)
// author : John Fischer : https://github.com/jfroffice

(function (factory) {
    //if (typeof define === 'function' && define.amd) {
    //    define(['moment'], factory); // AMD
    //} else if (typeof exports === 'object') {
    //    module.exports = factory(require('../moment')); // Node
    //} else {
    factory(window.moment); // Browser global
    //}
}(function (moment) {
    return moment.lang('fr', {
        months : "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort : "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        weekdays : "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort : "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin : "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "DD/MM/YYYY",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY LT",
            LLLL : "dddd D MMMM YYYY LT"
        },
        calendar : {
            sameDay: "[Aujourd'hui ] LT",
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : "dans %s",
            past : "il y a %s",
            s : "quelques secondes",
            m : "une minute",
            mm : "%d minutes",
            h : "une heure",
            hh : "%d heures",
            d : "un jour",
            dd : "%d jours",
            M : "un mois",
            MM : "%d mois",
            y : "un an",
            yy : "%d ans"
        },
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));


// moment.js language configuration
// language : canadian french (fr-ca)
// author : Jonathan Abourbih : https://github.com/jonbca

(function (factory) {
    //if (typeof define === 'function' && define.amd) {
    //    define(['moment'], factory); // AMD
    //} else if (typeof exports === 'object') {
    //    module.exports = factory(require('../moment')); // Node
    //} else {
    factory(window.moment); // Browser global
    //}
}(function (moment) {
    return moment.lang('fr-ca', {
        months : "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort : "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        weekdays : "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort : "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin : "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "YYYY-MM-DD",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY LT",
            LLLL : "dddd D MMMM YYYY LT"
        },
        calendar : {
            sameDay: "[Aujourd'hui ] LT",
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : "dans %s",
            past : "il y a %s",
            s : "quelques secondes",
            m : "une minute",
            mm : "%d minutes",
            h : "une heure",
            hh : "%d heures",
            d : "un jour",
            dd : "%d jours",
            M : "un mois",
            MM : "%d mois",
            y : "un an",
            yy : "%d ans"
        },
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        }
    });
}));


// moment.js language configuration
// language : russian (ru)
// author : Viktorminator : https://github.com/Viktorminator
// Author : Menelion Elensle : https://github.com/Oire

(function (factory) {
    //if (typeof define === 'function' && define.amd) {
    //    define(['moment'], factory); // AMD
    //} else if (typeof exports === 'object') {
    //    module.exports = factory(require('../moment')); // Node
    //} else {
    factory(window.moment); // Browser global
    //}
}(function (moment) {
    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }

    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    function monthsCaseReplace(m, format) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },

        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';

        return months[nounCase][m.month()];
    }

    function monthsShortCaseReplace(m, format) {
        var monthsShort = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },

        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';

        return monthsShort[nounCase][m.month()];
    }

    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_')
        },

        nounCase = (/\[ ?[] ?(?:|)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';

        return weekdays[nounCase][m.day()];
    }

    return moment.lang('ru', {
        months : monthsCaseReplace,
        monthsShort : monthsShortCaseReplace,
        weekdays : weekdaysCaseReplace,
        weekdaysShort : "______".split("_"),
        weekdaysMin : "______".split("_"),
        monthsParse : [/^/i, /^/i, /^/i, /^/i, /^[|]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
        longDateFormat : {
            LT : "HH:mm",
            L : "DD.MM.YYYY",
            LL : "D MMMM YYYY .",
            LLL : "D MMMM YYYY ., LT",
            LLLL : "dddd, D MMMM YYYY ., LT"
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function () {
                return this.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                    return '[ ] dddd [] LT';
                case 3:
                case 5:
                case 6:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : " %s",
            past : "%s ",
            s : " ",
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : "",
            hh : relativeTimeWithPlural,
            d : "",
            dd : relativeTimeWithPlural,
            M : "",
            MM : relativeTimeWithPlural,
            y : "",
            yy : relativeTimeWithPlural
        },

        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason

        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return "";
            } else if (hour < 12) {
                return "";
            } else if (hour < 17) {
                return "";
            } else {
                return "";
            }
        },

        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-';
            case 'D':
                return number + '-';
            case 'w':
            case 'W':
                return number + '-';
            default:
                return number;
            }
        },

        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });
}));


// moment.js language configuration
// language : great britain english (en-gb)
// author : Chris Gedrim : https://github.com/chrisgedrim


(function (factory) {
    //if (typeof define === 'function' && define.amd) {
    //    define(['moment'], factory); // AMD
    //} else if (typeof exports === 'object') {
    //    module.exports = factory(require('../moment')); // Node
    //} else {
    factory(window.moment); // Browser global
    //}
}(function (moment) {
    return moment.lang('en-zz', {

        months : "___________".split("_"),
        monthsShort : "___________".split("_"),
        weekdays : "______".split("_"),
        weekdaysShort : "______".split("_"),
        weekdaysMin : "______".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "DD/MM/YYYY",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY LT",
            LLLL : "dddd, D MMMM YYYY LT"
        },
        calendar : {
            sameDay : '[_ ] LT',
            nextDay : '[_ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[_ _] LT',
            lastWeek : '[_] dddd [] LT',
            sameElse : '[]'
        },
        relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        ordinal : function (number) {
            var b = number % 10,
                output = (~~ (number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '' : '';
            } else {
                return isLower ? '' : '';
            }
        }
    });
}));


/*!
 * mOxie - multi-runtime File API & XMLHttpRequest L2 Polyfill
 * v1.2.0
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 *
 * Date: 2014-01-16
 */
/**
 * Compiled inline version. (Library mode)
 */

/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
/*globals $code */

(function(exports, undefined) {
	"use strict";

	var modules = {};

	function require(ids, callback) {
		var module, defs = [];

		for (var i = 0; i < ids.length; ++i) {
			module = modules[ids[i]] || resolve(ids[i]);
			if (!module) {
				throw 'module definition dependecy not found: ' + ids[i];
			}

			defs.push(module);
		}

		callback.apply(null, defs);
	}

	function define(id, dependencies, definition) {
		if (typeof id !== 'string') {
			throw 'invalid module definition, module id must be defined and be a string';
		}

		if (dependencies === undefined) {
			throw 'invalid module definition, dependencies must be specified';
		}

		if (definition === undefined) {
			throw 'invalid module definition, definition function must be specified';
		}

		require(dependencies, function() {
			modules[id] = definition.apply(null, arguments);
		});
	}

	function defined(id) {
		return !!modules[id];
	}

	function resolve(id) {
		var target = exports;
		var fragments = id.split(/[.\/]/);

		for (var fi = 0; fi < fragments.length; ++fi) {
			if (!target[fragments[fi]]) {
				return;
			}

			target = target[fragments[fi]];
		}

		return target;
	}

	function expose(ids) {
		for (var i = 0; i < ids.length; i++) {
			var target = exports;
			var id = ids[i];
			var fragments = id.split(/[.\/]/);

			for (var fi = 0; fi < fragments.length - 1; ++fi) {
				if (target[fragments[fi]] === undefined) {
					target[fragments[fi]] = {};
				}

				target = target[fragments[fi]];
			}

			target[fragments[fragments.length - 1]] = modules[id];
		}
	}

// Included from: src/javascript/core/utils/Basic.js

/**
 * Basic.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Basic', [], function() {
	/**
	Gets the true type of the built-in object (better version of typeof).
	@author Angus Croll (http://javascriptweblog.wordpress.com/)

	@method typeOf
	@for Utils
	@static
	@param {Object} o Object to check.
	@return {String} Object [[Class]]
	*/
	var typeOf = function(o) {
		var undef;

		if (o === undef) {
			return 'undefined';
		} else if (o === null) {
			return 'null';
		} else if (o.nodeType) {
			return 'node';
		}

		// the snippet below is awesome, however it fails to detect null, undefined and arguments types in IE lte 8
		return ({}).toString.call(o).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
	};
		
	/**
	Extends the specified object with another object.

	@method extend
	@static
	@param {Object} target Object to extend.
	@param {Object} [obj]* Multiple objects to extend with.
	@return {Object} Same as target, the extended object.
	*/
	var extend = function(target) {
		var undef;

		each(arguments, function(arg, i) {
			if (i > 0) {
				each(arg, function(value, key) {
					if (value !== undef) {
						if (typeOf(target[key]) === typeOf(value) && !!~inArray(typeOf(value), ['array', 'object'])) {
							extend(target[key], value);
						} else {
							target[key] = value;
						}
					}
				});
			}
		});
		return target;
	};
		
	/**
	Executes the callback function for each item in array/object. If you return false in the
	callback it will break the loop.

	@method each
	@static
	@param {Object} obj Object to iterate.
	@param {function} callback Callback function to execute for each item.
	*/
	var each = function(obj, callback) {
		var length, key, i, undef;

		if (obj) {
			try {
				length = obj.length;
			} catch(ex) {
				length = undef;
			}

			if (length === undef) {
				// Loop object items
				for (key in obj) {
					if (obj.hasOwnProperty(key)) {
						if (callback(obj[key], key) === false) {
							return;
						}
					}
				}
			} else {
				// Loop array items
				for (i = 0; i < length; i++) {
					if (callback(obj[i], i) === false) {
						return;
					}
				}
			}
		}
	};

	/**
	Checks if object is empty.
	
	@method isEmptyObj
	@static
	@param {Object} o Object to check.
	@return {Boolean}
	*/
	var isEmptyObj = function(obj) {
		var prop;

		if (!obj || typeOf(obj) !== 'object') {
			return true;
		}

		for (prop in obj) {
			return false;
		}

		return true;
	};

	/**
	Recieve an array of functions (usually async) to call in sequence, each  function
	receives a callback as first argument that it should call, when it completes. Finally,
	after everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the sequence and invoke main callback
	immediately.

	@method inSeries
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of erro
	*/
	var inSeries = function(queue, cb) {
		var i = 0, length = queue.length;

		if (typeOf(cb) !== 'function') {
			cb = function() {};
		}

		if (!queue || !queue.length) {
			cb();
		}

		function callNext(i) {
			if (typeOf(queue[i]) === 'function') {
				queue[i](function(error) {
					/*jshint expr:true */
					++i < length && !error ? callNext(i) : cb(error);
				});
			}
		}
		callNext(i);
	};


	/**
	Recieve an array of functions (usually async) to call in parallel, each  function
	receives a callback as first argument that it should call, when it completes. After 
	everything is complete, main callback is called. Passing truthy value to the
	callback as a first argument will interrupt the process and invoke main callback
	immediately.

	@method inParallel
	@static
	@param {Array} queue Array of functions to call in sequence
	@param {Function} cb Main callback that is called in the end, or in case of erro
	*/
	var inParallel = function(queue, cb) {
		var count = 0, num = queue.length, cbArgs = new Array(num);

		each(queue, function(fn, i) {
			fn(function(error) {
				if (error) {
					return cb(error);
				}
				
				var args = [].slice.call(arguments);
				args.shift(); // strip error - undefined or not

				cbArgs[i] = args;
				count++;

				if (count === num) {
					cbArgs.unshift(null);
					cb.apply(this, cbArgs);
				} 
			});
		});
	};
	
	
	/**
	Find an element in array and return it's index if present, otherwise return -1.
	
	@method inArray
	@static
	@param {Mixed} needle Element to find
	@param {Array} array
	@return {Int} Index of the element, or -1 if not found
	*/
	var inArray = function(needle, array) {
		if (array) {
			if (Array.prototype.indexOf) {
				return Array.prototype.indexOf.call(array, needle);
			}
		
			for (var i = 0, length = array.length; i < length; i++) {
				if (array[i] === needle) {
					return i;
				}
			}
		}
		return -1;
	};


	/**
	Returns elements of first array if they are not present in second. And false - otherwise.

	@private
	@method arrayDiff
	@param {Array} needles
	@param {Array} array
	@return {Array|Boolean}
	*/
	var arrayDiff = function(needles, array) {
		var diff = [];

		if (typeOf(needles) !== 'array') {
			needles = [needles];
		}

		if (typeOf(array) !== 'array') {
			array = [array];
		}

		for (var i in needles) {
			if (inArray(needles[i], array) === -1) {
				diff.push(needles[i]);
			}	
		}
		return diff.length ? diff : false;
	};


	/**
	Find intersection of two arrays.

	@private
	@method arrayIntersect
	@param {Array} array1
	@param {Array} array2
	@return {Array} Intersection of two arrays or null if there is none
	*/
	var arrayIntersect = function(array1, array2) {
		var result = [];
		each(array1, function(item) {
			if (inArray(item, array2) !== -1) {
				result.push(item);
			}
		});
		return result.length ? result : null;
	};
	
	
	/**
	Forces anything into an array.
	
	@method toArray
	@static
	@param {Object} obj Object with length field.
	@return {Array} Array object containing all items.
	*/
	var toArray = function(obj) {
		var i, arr = [];

		for (i = 0; i < obj.length; i++) {
			arr[i] = obj[i];
		}

		return arr;
	};
	
			
	/**
	Generates an unique ID. This is 99.99% unique since it takes the current time and 5 random numbers.
	The only way a user would be able to get the same ID is if the two persons at the same exact milisecond manages
	to get 5 the same random numbers between 0-65535 it also uses a counter so each call will be guaranteed to be page unique.
	It's more probable for the earth to be hit with an ansteriod. Y
	
	@method guid
	@static
	@param {String} prefix to prepend (by default 'o' will be prepended).
	@method guid
	@return {String} Virtually unique id.
	*/
	var guid = (function() {
		var counter = 0;
		
		return function(prefix) {
			var guid = new Date().getTime().toString(32), i;

			for (i = 0; i < 5; i++) {
				guid += Math.floor(Math.random() * 65535).toString(32);
			}
			
			return (prefix || 'o_') + guid + (counter++).toString(32);
		};
	}());
	

	/**
	Trims white spaces around the string
	
	@method trim
	@static
	@param {String} str
	@return {String}
	*/
	var trim = function(str) {
		if (!str) {
			return str;
		}
		return String.prototype.trim ? String.prototype.trim.call(str) : str.toString().replace(/^\s*/, '').replace(/\s*$/, '');
	};


	/**
	Parses the specified size string into a byte value. For example 10kb becomes 10240.
	
	@method parseSizeStr
	@static
	@param {String/Number} size String to parse or number to just pass through.
	@return {Number} Size in bytes.
	*/
	var parseSizeStr = function(size) {
		if (typeof(size) !== 'string') {
			return size;
		}
		
		var muls = {
				t: 1099511627776,
				g: 1073741824,
				m: 1048576,
				k: 1024
			},
			mul;

		size = /^([0-9]+)([mgk]?)$/.exec(size.toLowerCase().replace(/[^0-9mkg]/g, ''));
		mul = size[2];
		size = +size[1];
		
		if (muls.hasOwnProperty(mul)) {
			size *= muls[mul];
		}
		return size;
	};
	

	return {
		guid: guid,
		typeOf: typeOf,
		extend: extend,
		each: each,
		isEmptyObj: isEmptyObj,
		inSeries: inSeries,
		inParallel: inParallel,
		inArray: inArray,
		arrayDiff: arrayDiff,
		arrayIntersect: arrayIntersect,
		toArray: toArray,
		trim: trim,
		parseSizeStr: parseSizeStr
	};
});

// Included from: src/javascript/core/I18n.js

/**
 * I18n.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/I18n", [
	"moxie/core/utils/Basic"
], function(Basic) {
	var i18n = {};

	return {
		/**
		 * Extends the language pack object with new items.
		 *
		 * @param {Object} pack Language pack items to add.
		 * @return {Object} Extended language pack object.
		 */
		addI18n: function(pack) {
			return Basic.extend(i18n, pack);
		},

		/**
		 * Translates the specified string by checking for the english string in the language pack lookup.
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		translate: function(str) {
			return i18n[str] || str;
		},

		/**
		 * Shortcut for translate function
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		_: function(str) {
			return this.translate(str);
		},

		/**
		 * Pseudo sprintf implementation - simple way to replace tokens with specified values.
		 *
		 * @param {String} str String with tokens
		 * @return {String} String with replaced tokens
		 */
		sprintf: function(str) {
			var args = [].slice.call(arguments, 1);

			return str.replace(/%[a-z]/g, function() {
				var value = args.shift();
				return Basic.typeOf(value) !== 'undefined' ? value : '';
			});
		}
	};
});

// Included from: src/javascript/core/utils/Mime.js

/**
 * Mime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/utils/Mime", [
	"moxie/core/utils/Basic",
	"moxie/core/I18n"
], function(Basic, I18n) {
	
	var mimeData = "" +
		"application/msword,doc dot," +
		"application/pdf,pdf," +
		"application/pgp-signature,pgp," +
		"application/postscript,ps ai eps," +
		"application/rtf,rtf," +
		"application/vnd.ms-excel,xls xlb," +
		"application/vnd.ms-powerpoint,ppt pps pot," +
		"application/zip,zip," +
		"application/x-shockwave-flash,swf swfl," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document,docx," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template,dotx," +
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,xlsx," +
		"application/vnd.openxmlformats-officedocument.presentationml.presentation,pptx," +
		"application/vnd.openxmlformats-officedocument.presentationml.template,potx," +
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow,ppsx," +
		"application/x-javascript,js," +
		"application/json,json," +
		"audio/mpeg,mp3 mpga mpega mp2," +
		"audio/x-wav,wav," +
		"audio/x-m4a,m4a," +
		"audio/ogg,oga ogg," +
		"audio/aiff,aiff aif," +
		"audio/flac,flac," +
		"audio/aac,aac," +
		"audio/ac3,ac3," +
		"audio/x-ms-wma,wma," +
		"image/bmp,bmp," +
		"image/gif,gif," +
		"image/jpeg,jpg jpeg jpe," +
		"image/photoshop,psd," +
		"image/png,png," +
		"image/svg+xml,svg svgz," +
		"image/tiff,tiff tif," +
		"text/plain,asc txt text diff log," +
		"text/html,htm html xhtml," +
		"text/css,css," +
		"text/csv,csv," +
		"text/rtf,rtf," +
		"video/mpeg,mpeg mpg mpe m2v," +
		"video/quicktime,qt mov," +
		"video/mp4,mp4," +
		"video/x-m4v,m4v," +
		"video/x-flv,flv," +
		"video/x-ms-wmv,wmv," +
		"video/avi,avi," +
		"video/webm,webm," +
		"video/3gpp,3gpp 3gp," +
		"video/3gpp2,3g2," +
		"video/vnd.rn-realvideo,rv," +
		"video/ogg,ogv," + 
		"video/x-matroska,mkv," +
		"application/vnd.oasis.opendocument.formula-template,otf," +
		"application/octet-stream,exe";
	
	
	var Mime = {

		mimes: {},

		extensions: {},

		// Parses the default mime types string into a mimes and extensions lookup maps
		addMimeType: function (mimeData) {
			var items = mimeData.split(/,/), i, ii, ext;
			
			for (i = 0; i < items.length; i += 2) {
				ext = items[i + 1].split(/ /);

				// extension to mime lookup
				for (ii = 0; ii < ext.length; ii++) {
					this.mimes[ext[ii]] = items[i];
				}
				// mime to extension lookup
				this.extensions[items[i]] = ext;
			}
		},


		extList2mimes: function (filters, addMissingExtensions) {
			var self = this, ext, i, ii, type, mimes = [];
			
			// convert extensions to mime types list
			for (i = 0; i < filters.length; i++) {
				ext = filters[i].extensions.split(/\s*,\s*/);

				for (ii = 0; ii < ext.length; ii++) {
					
					// if there's an asterisk in the list, then accept attribute is not required
					if (ext[ii] === '*') {
						return [];
					}
					
					type = self.mimes[ext[ii]];
					if (!type) {
						if (addMissingExtensions && /^\w+$/.test(ext[ii])) {
							mimes.push('.' + ext[ii]);
						} else {
							return []; // accept all
						}
					} else if (Basic.inArray(type, mimes) === -1) {
						mimes.push(type);
					}
				}
			}
			return mimes;
		},


		mimes2exts: function(mimes) {
			var self = this, exts = [];
			
			Basic.each(mimes, function(mime) {
				if (mime === '*') {
					exts = [];
					return false;
				}

				// check if this thing looks like mime type
				var m = mime.match(/^(\w+)\/(\*|\w+)$/);
				if (m) {
					if (m[2] === '*') { 
						// wildcard mime type detected
						Basic.each(self.extensions, function(arr, mime) {
							if ((new RegExp('^' + m[1] + '/')).test(mime)) {
								[].push.apply(exts, self.extensions[mime]);
							}
						});
					} else if (self.extensions[mime]) {
						[].push.apply(exts, self.extensions[mime]);
					}
				}
			});
			return exts;
		},


		mimes2extList: function(mimes) {
			var accept = [], exts = [];

			if (Basic.typeOf(mimes) === 'string') {
				mimes = Basic.trim(mimes).split(/\s*,\s*/);
			}

			exts = this.mimes2exts(mimes);
			
			accept.push({
				title: I18n.translate('Files'),
				extensions: exts.length ? exts.join(',') : '*'
			});
			
			// save original mimes string
			accept.mimes = mimes;

			return accept;
		},


		getFileExtension: function(fileName) {
			var matches = fileName && fileName.match(/\.([^.]+)$/);
			if (matches) {
				return matches[1].toLowerCase();
			}
			return '';
		},

		getFileMime: function(fileName) {
			return this.mimes[this.getFileExtension(fileName)] || '';
		}
	};

	Mime.addMimeType(mimeData);

	return Mime;
});

// Included from: src/javascript/core/utils/Env.js

/**
 * Env.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/core/utils/Env", [
	"moxie/core/utils/Basic"
], function(Basic) {
	
	// UAParser.js v0.6.2
	// Lightweight JavaScript-based User-Agent string parser
	// https://github.com/faisalman/ua-parser-js
	//
	// Copyright ? 2012-2013 Faisalman <fyzlman@gmail.com>
	// Dual licensed under GPLv2 & MIT

	var UAParser = (function (undefined) {

	    //////////////
	    // Constants
	    /////////////


	    var EMPTY       = '',
	        UNKNOWN     = '?',
	        FUNC_TYPE   = 'function',
	        UNDEF_TYPE  = 'undefined',
	        OBJ_TYPE    = 'object',
	        MAJOR       = 'major',
	        MODEL       = 'model',
	        NAME        = 'name',
	        TYPE        = 'type',
	        VENDOR      = 'vendor',
	        VERSION     = 'version',
	        ARCHITECTURE= 'architecture',
	        CONSOLE     = 'console',
	        MOBILE      = 'mobile',
	        TABLET      = 'tablet';


	    ///////////
	    // Helper
	    //////////


	    var util = {
	        has : function (str1, str2) {
	            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
	        },
	        lowerize : function (str) {
	            return str.toLowerCase();
	        }
	    };


	    ///////////////
	    // Map helper
	    //////////////


	    var mapper = {

	        rgx : function () {

	            // loop through all regexes maps
	            for (var result, i = 0, j, k, p, q, matches, match, args = arguments; i < args.length; i += 2) {

	                var regex = args[i],       // even sequence (0,2,4,..)
	                    props = args[i + 1];   // odd sequence (1,3,5,..)

	                // construct object barebones
	                if (typeof(result) === UNDEF_TYPE) {
	                    result = {};
	                    for (p in props) {
	                        q = props[p];
	                        if (typeof(q) === OBJ_TYPE) {
	                            result[q[0]] = undefined;
	                        } else {
	                            result[q] = undefined;
	                        }
	                    }
	                }

	                // try matching uastring with regexes
	                for (j = k = 0; j < regex.length; j++) {
	                    matches = regex[j].exec(this.getUA());
	                    if (!!matches) {
	                        for (p = 0; p < props.length; p++) {
	                            match = matches[++k];
	                            q = props[p];
	                            // check if given property is actually array
	                            if (typeof(q) === OBJ_TYPE && q.length > 0) {
	                                if (q.length == 2) {
	                                    if (typeof(q[1]) == FUNC_TYPE) {
	                                        // assign modified match
	                                        result[q[0]] = q[1].call(this, match);
	                                    } else {
	                                        // assign given value, ignore regex match
	                                        result[q[0]] = q[1];
	                                    }
	                                } else if (q.length == 3) {
	                                    // check whether function or regex
	                                    if (typeof(q[1]) === FUNC_TYPE && !(q[1].exec && q[1].test)) {
	                                        // call function (usually string mapper)
	                                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
	                                    } else {
	                                        // sanitize match using given regex
	                                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
	                                    }
	                                } else if (q.length == 4) {
	                                        result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
	                                }
	                            } else {
	                                result[q] = match ? match : undefined;
	                            }
	                        }
	                        break;
	                    }
	                }

	                if(!!matches) break; // break the loop immediately if match found
	            }
	            return result;
	        },

	        str : function (str, map) {

	            for (var i in map) {
	                // check if array
	                if (typeof(map[i]) === OBJ_TYPE && map[i].length > 0) {
	                    for (var j = 0; j < map[i].length; j++) {
	                        if (util.has(map[i][j], str)) {
	                            return (i === UNKNOWN) ? undefined : i;
	                        }
	                    }
	                } else if (util.has(map[i], str)) {
	                    return (i === UNKNOWN) ? undefined : i;
	                }
	            }
	            return str;
	        }
	    };


	    ///////////////
	    // String map
	    //////////////


	    var maps = {

	        browser : {
	            oldsafari : {
	                major : {
	                    '1' : ['/8', '/1', '/3'],
	                    '2' : '/4',
	                    '?' : '/'
	                },
	                version : {
	                    '1.0'   : '/8',
	                    '1.2'   : '/1',
	                    '1.3'   : '/3',
	                    '2.0'   : '/412',
	                    '2.0.2' : '/416',
	                    '2.0.3' : '/417',
	                    '2.0.4' : '/419',
	                    '?'     : '/'
	                }
	            }
	        },

	        device : {
	            sprint : {
	                model : {
	                    'Evo Shift 4G' : '7373KT'
	                },
	                vendor : {
	                    'HTC'       : 'APA',
	                    'Sprint'    : 'Sprint'
	                }
	            }
	        },

	        os : {
	            windows : {
	                version : {
	                    'ME'        : '4.90',
	                    'NT 3.11'   : 'NT3.51',
	                    'NT 4.0'    : 'NT4.0',
	                    '2000'      : 'NT 5.0',
	                    'XP'        : ['NT 5.1', 'NT 5.2'],
	                    'Vista'     : 'NT 6.0',
	                    '7'         : 'NT 6.1',
	                    '8'         : 'NT 6.2',
	                    '8.1'       : 'NT 6.3',
	                    'RT'        : 'ARM'
	                }
	            }
	        }
	    };


	    //////////////
	    // Regex map
	    /////////////


	    var regexes = {

	        browser : [[

	            // Presto based
	            /(opera\smini)\/((\d+)?[\w\.-]+)/i,                                 // Opera Mini
	            /(opera\s[mobiletab]+).+version\/((\d+)?[\w\.-]+)/i,                // Opera Mobi/Tablet
	            /(opera).+version\/((\d+)?[\w\.]+)/i,                               // Opera > 9.80
	            /(opera)[\/\s]+((\d+)?[\w\.]+)/i                                    // Opera < 9.80
	            
	            ], [NAME, VERSION, MAJOR], [

	            /\s(opr)\/((\d+)?[\w\.]+)/i                                         // Opera Webkit
	            ], [[NAME, 'Opera'], VERSION, MAJOR], [

	            // Mixed
	            /(kindle)\/((\d+)?[\w\.]+)/i,                                       // Kindle
	            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?((\d+)?[\w\.]+)*/i,
	                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

	            // Trident based
	            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?((\d+)?[\w\.]*)/i,
	                                                                                // Avant/IEMobile/SlimBrowser/Baidu
	            /(?:ms|\()(ie)\s((\d+)?[\w\.]+)/i,                                  // Internet Explorer

	            // Webkit/KHTML based
	            /(rekonq)((?:\/)[\w\.]+)*/i,                                        // Rekonq
	            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron)\/((\d+)?[\w\.-]+)/i
	                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron
	            ], [NAME, VERSION, MAJOR], [

	            /(trident).+rv[:\s]((\d+)?[\w\.]+).+like\sgecko/i                   // IE11
	            ], [[NAME, 'IE'], VERSION, MAJOR], [

	            /(yabrowser)\/((\d+)?[\w\.]+)/i                                     // Yandex
	            ], [[NAME, 'Yandex'], VERSION, MAJOR], [

	            /(comodo_dragon)\/((\d+)?[\w\.]+)/i                                 // Comodo Dragon
	            ], [[NAME, /_/g, ' '], VERSION, MAJOR], [

	            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?((\d+)?[\w\.]+)/i
	                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
	            ], [NAME, VERSION, MAJOR], [

	            /(dolfin)\/((\d+)?[\w\.]+)/i                                        // Dolphin
	            ], [[NAME, 'Dolphin'], VERSION, MAJOR], [

	            /((?:android.+)crmo|crios)\/((\d+)?[\w\.]+)/i                       // Chrome for Android/iOS
	            ], [[NAME, 'Chrome'], VERSION, MAJOR], [

	            /((?:android.+))version\/((\d+)?[\w\.]+)\smobile\ssafari/i          // Android Browser
	            ], [[NAME, 'Android Browser'], VERSION, MAJOR], [

	            /version\/((\d+)?[\w\.]+).+?mobile\/\w+\s(safari)/i                 // Mobile Safari
	            ], [VERSION, MAJOR, [NAME, 'Mobile Safari']], [

	            /version\/((\d+)?[\w\.]+).+?(mobile\s?safari|safari)/i              // Safari & Safari Mobile
	            ], [VERSION, MAJOR, NAME], [

	            /webkit.+?(mobile\s?safari|safari)((\/[\w\.]+))/i                   // Safari < 3.0
	            ], [NAME, [MAJOR, mapper.str, maps.browser.oldsafari.major], [VERSION, mapper.str, maps.browser.oldsafari.version]], [

	            /(konqueror)\/((\d+)?[\w\.]+)/i,                                    // Konqueror
	            /(webkit|khtml)\/((\d+)?[\w\.]+)/i
	            ], [NAME, VERSION, MAJOR], [

	            // Gecko based
	            /(navigator|netscape)\/((\d+)?[\w\.-]+)/i                           // Netscape
	            ], [[NAME, 'Netscape'], VERSION, MAJOR], [
	            /(swiftfox)/i,                                                      // Swiftfox
	            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?((\d+)?[\w\.\+]+)/i,
	                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
	            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/((\d+)?[\w\.-]+)/i,
	                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
	            /(mozilla)\/((\d+)?[\w\.]+).+rv\:.+gecko\/\d+/i,                    // Mozilla

	            // Other
	            /(uc\s?browser|polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|qqbrowser)[\/\s]?((\d+)?[\w\.]+)/i,
	                                                                                // UCBrowser/Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/QQBrowser
	            /(links)\s\(((\d+)?[\w\.]+)/i,                                      // Links
	            /(gobrowser)\/?((\d+)?[\w\.]+)*/i,                                  // GoBrowser
	            /(ice\s?browser)\/v?((\d+)?[\w\._]+)/i,                             // ICE Browser
	            /(mosaic)[\/\s]((\d+)?[\w\.]+)/i                                    // Mosaic
	            ], [NAME, VERSION, MAJOR]
	        ],

	        engine : [[

	            /(presto)\/([\w\.]+)/i,                                             // Presto
	            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
	            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
	            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
	            ], [NAME, VERSION], [

	            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
	            ], [VERSION, NAME]
	        ],

	        os : [[

	            // Windows based
	            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
	            /(windows\sphone(?:\sos)*|windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
	            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
	            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
	            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

	            // Mobile/Embedded OS
	            /\((bb)(10);/i                                                      // BlackBerry 10
	            ], [[NAME, 'BlackBerry'], VERSION], [
	            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
	            /(tizen)\/([\w\.]+)/i,                                              // Tizen
	            /(android|webos|palm\os|qnx|bada|rim\stablet\sos|meego)[\/\s-]?([\w\.]+)*/i
	                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo
	            ], [NAME, VERSION], [
	            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
	            ], [[NAME, 'Symbian'], VERSION],[
	            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
	            ], [[NAME, 'Firefox OS'], VERSION], [

	            // Console
	            /(nintendo|playstation)\s([wids3portablevu]+)/i,                    // Nintendo/Playstation

	            // GNU/Linux based
	            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
	            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk)[\/\s-]?([\w\.-]+)*/i,
	                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
	                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk
	            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
	            /(gnu)\s?([\w\.]+)*/i                                               // GNU
	            ], [NAME, VERSION], [

	            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
	            ], [[NAME, 'Chromium OS'], VERSION],[

	            // Solaris
	            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
	            ], [[NAME, 'Solaris'], VERSION], [

	            // BSD based
	            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
	            ], [NAME, VERSION],[

	            /(ip[honead]+)(?:.*os\s*([\w]+)*\slike\smac|;\sopera)/i             // iOS
	            ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [

	            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i                                    // Mac OS
	            ], [NAME, [VERSION, /_/g, '.']], [

	            // Other
	            /(haiku)\s(\w+)/i,                                                  // Haiku
	            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
	            /(macintosh|mac(?=_powerpc)|plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos)/i,
	                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS
	            /(unix)\s?([\w\.]+)*/i                                              // UNIX
	            ], [NAME, VERSION]
	        ]
	    };


	    /////////////////
	    // Constructor
	    ////////////////


	    var UAParser = function (uastring) {

	        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);

	        this.getBrowser = function () {
	            return mapper.rgx.apply(this, regexes.browser);
	        };
	        this.getEngine = function () {
	            return mapper.rgx.apply(this, regexes.engine);
	        };
	        this.getOS = function () {
	            return mapper.rgx.apply(this, regexes.os);
	        };
	        this.getResult = function() {
	            return {
	                ua      : this.getUA(),
	                browser : this.getBrowser(),
	                engine  : this.getEngine(),
	                os      : this.getOS()
	            };
	        };
	        this.getUA = function () {
	            return ua;
	        };
	        this.setUA = function (uastring) {
	            ua = uastring;
	            return this;
	        };
	        this.setUA(ua);
	    };

	    return new UAParser().getResult();
	})();


	function version_compare(v1, v2, operator) {
	  // From: http://phpjs.org/functions
	  // +      original by: Philippe Jausions (http://pear.php.net/user/jausions)
	  // +      original by: Aidan Lister (http://aidanlister.com/)
	  // + reimplemented by: Kankrelune (http://www.webfaktory.info/)
	  // +      improved by: Brett Zamir (http://brett-zamir.me)
	  // +      improved by: Scott Baker
	  // +      improved by: Theriault
	  // *        example 1: version_compare('8.2.5rc', '8.2.5a');
	  // *        returns 1: 1
	  // *        example 2: version_compare('8.2.50', '8.2.52', '<');
	  // *        returns 2: true
	  // *        example 3: version_compare('5.3.0-dev', '5.3.0');
	  // *        returns 3: -1
	  // *        example 4: version_compare('4.1.0.52','4.01.0.51');
	  // *        returns 4: 1

	  // Important: compare must be initialized at 0.
	  var i = 0,
	    x = 0,
	    compare = 0,
	    // vm maps textual PHP versions to negatives so they're less than 0.
	    // PHP currently defines these as CASE-SENSITIVE. It is important to
	    // leave these as negatives so that they can come before numerical versions
	    // and as if no letters were there to begin with.
	    // (1alpha is < 1 and < 1.1 but > 1dev1)
	    // If a non-numerical value can't be mapped to this table, it receives
	    // -7 as its value.
	    vm = {
	      'dev': -6,
	      'alpha': -5,
	      'a': -5,
	      'beta': -4,
	      'b': -4,
	      'RC': -3,
	      'rc': -3,
	      '#': -2,
	      'p': 1,
	      'pl': 1
	    },
	    // This function will be called to prepare each version argument.
	    // It replaces every _, -, and + with a dot.
	    // It surrounds any nonsequence of numbers/dots with dots.
	    // It replaces sequences of dots with a single dot.
	    //    version_compare('4..0', '4.0') == 0
	    // Important: A string of 0 length needs to be converted into a value
	    // even less than an unexisting value in vm (-7), hence [-8].
	    // It's also important to not strip spaces because of this.
	    //   version_compare('', ' ') == 1
	    prepVersion = function (v) {
	      v = ('' + v).replace(/[_\-+]/g, '.');
	      v = v.replace(/([^.\d]+)/g, '.$1.').replace(/\.{2,}/g, '.');
	      return (!v.length ? [-8] : v.split('.'));
	    },
	    // This converts a version component to a number.
	    // Empty component becomes 0.
	    // Non-numerical component becomes a negative number.
	    // Numerical component becomes itself as an integer.
	    numVersion = function (v) {
	      return !v ? 0 : (isNaN(v) ? vm[v] || -7 : parseInt(v, 10));
	    };

	  v1 = prepVersion(v1);
	  v2 = prepVersion(v2);
	  x = Math.max(v1.length, v2.length);
	  for (i = 0; i < x; i++) {
	    if (v1[i] == v2[i]) {
	      continue;
	    }
	    v1[i] = numVersion(v1[i]);
	    v2[i] = numVersion(v2[i]);
	    if (v1[i] < v2[i]) {
	      compare = -1;
	      break;
	    } else if (v1[i] > v2[i]) {
	      compare = 1;
	      break;
	    }
	  }
	  if (!operator) {
	    return compare;
	  }

	  // Important: operator is CASE-SENSITIVE.
	  // "No operator" seems to be treated as "<."
	  // Any other values seem to make the function return null.
	  switch (operator) {
	  case '>':
	  case 'gt':
	    return (compare > 0);
	  case '>=':
	  case 'ge':
	    return (compare >= 0);
	  case '<=':
	  case 'le':
	    return (compare <= 0);
	  case '==':
	  case '=':
	  case 'eq':
	    return (compare === 0);
	  case '<>':
	  case '!=':
	  case 'ne':
	    return (compare !== 0);
	  case '':
	  case '<':
	  case 'lt':
	    return (compare < 0);
	  default:
	    return null;
	  }
	}


	var can = (function() {
		var caps = {
				define_property: (function() {
					/* // currently too much extra code required, not exactly worth it
					try { // as of IE8, getters/setters are supported only on DOM elements
						var obj = {};
						if (Object.defineProperty) {
							Object.defineProperty(obj, 'prop', {
								enumerable: true,
								configurable: true
							});
							return true;
						}
					} catch(ex) {}

					if (Object.prototype.__defineGetter__ && Object.prototype.__defineSetter__) {
						return true;
					}*/
					return false;
				}()),

				create_canvas: (function() {
					// On the S60 and BB Storm, getContext exists, but always returns undefined
					// so we actually have to call getContext() to verify
					// github.com/Modernizr/Modernizr/issues/issue/97/
					var el = document.createElement('canvas');
					return !!(el.getContext && el.getContext('2d'));
				}()),

				return_response_type: function(responseType) {
					try {
						if (Basic.inArray(responseType, ['', 'text', 'document']) !== -1) {
							return true;
						} else if (window.XMLHttpRequest) {
							var xhr = new XMLHttpRequest();
							xhr.open('get', '/'); // otherwise Gecko throws an exception
							if ('responseType' in xhr) {
								xhr.responseType = responseType;
								// as of 23.0.1271.64, Chrome switched from throwing exception to merely logging it to the console (why? o why?)
								if (xhr.responseType !== responseType) {
									return false;
								}
								return true;
							}
						}
					} catch (ex) {}
					return false;
				},

				// ideas for this heavily come from Modernizr (http://modernizr.com/)
				use_data_uri: (function() {
					var du = new Image();

					du.onload = function() {
						caps.use_data_uri = (du.width === 1 && du.height === 1);
					};
					
					setTimeout(function() {
						du.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP8AAAAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==";
					}, 1);
					return false;
				}()),

				use_data_uri_over32kb: function() { // IE8
					return caps.use_data_uri && (Env.browser !== 'IE' || Env.version >= 9);
				},

				use_data_uri_of: function(bytes) {
					return (caps.use_data_uri && bytes < 33000 || caps.use_data_uri_over32kb());
				},

				use_fileinput: function() {
					var el = document.createElement('input');
					el.setAttribute('type', 'file');
					return !el.disabled;
				}
			};

		return function(cap) {
			var args = [].slice.call(arguments);
			args.shift(); // shift of cap
			return Basic.typeOf(caps[cap]) === 'function' ? caps[cap].apply(this, args) : !!caps[cap];
		};
	}());


	var Env = {
		can: can,
		
		browser: UAParser.browser.name,
		version: parseFloat(UAParser.browser.major),
		os: UAParser.os.name, // everybody intuitively types it in a lowercase for some reason
		osVersion: UAParser.os.version,

		verComp: version_compare,
		
		swf_url: "../flash/Moxie.swf",
		xap_url: "../silverlight/Moxie.xap",
		global_event_dispatcher: "moxie.core.EventTarget.instance.dispatchEvent"
	};

	// for backward compatibility
	// @deprecated Use `Env.os` instead
	Env.OS = Env.os;

	return Env;
});

// Included from: src/javascript/core/utils/Dom.js

/**
 * Dom.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Dom', ['moxie/core/utils/Env'], function(Env) {

	/**
	Get DOM Element by it's id.

	@method get
	@for Utils
	@param {String} id Identifier of the DOM Element
	@return {DOMElement}
	*/
	var get = function(id) {
		if (typeof id !== 'string') {
			return id;
		}
		return document.getElementById(id);
	};

	/**
	Checks if specified DOM element has specified class.

	@method hasClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var hasClass = function(obj, name) {
		if (!obj.className) {
			return false;
		}

		var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");
		return regExp.test(obj.className);
	};

	/**
	Adds specified className to specified DOM element.

	@method addClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var addClass = function(obj, name) {
		if (!hasClass(obj, name)) {
			obj.className = !obj.className ? name : obj.className.replace(/\s+$/, '') + ' ' + name;
		}
	};

	/**
	Removes specified className from specified DOM element.

	@method removeClass
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Class name
	*/
	var removeClass = function(obj, name) {
		if (obj.className) {
			var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");
			obj.className = obj.className.replace(regExp, function($0, $1, $2) {
				return $1 === ' ' && $2 === ' ' ? ' ' : '';
			});
		}
	};

	/**
	Returns a given computed style of a DOM element.

	@method getStyle
	@static
	@param {Object} obj DOM element like object.
	@param {String} name Style you want to get from the DOM element
	*/
	var getStyle = function(obj, name) {
		if (obj.currentStyle) {
			return obj.currentStyle[name];
		} else if (window.getComputedStyle) {
			return window.getComputedStyle(obj, null)[name];
		}
	};


	/**
	Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.

	@method getPos
	@static
	@param {Element} node HTML element or element id to get x, y position from.
	@param {Element} root Optional root element to stop calculations at.
	@return {object} Absolute position of the specified element object with x, y fields.
	*/
	var getPos = function(node, root) {
		var x = 0, y = 0, parent, doc = document, nodeRect, rootRect;

		node = node;
		root = root || doc.body;

		// Returns the x, y cordinate for an element on IE 6 and IE 7
		function getIEPos(node) {
			var bodyElm, rect, x = 0, y = 0;

			if (node) {
				rect = node.getBoundingClientRect();
				bodyElm = doc.compatMode === "CSS1Compat" ? doc.documentElement : doc.body;
				x = rect.left + bodyElm.scrollLeft;
				y = rect.top + bodyElm.scrollTop;
			}

			return {
				x : x,
				y : y
			};
		}

		// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode
		if (node && node.getBoundingClientRect && Env.browser === 'IE' && (!doc.documentMode || doc.documentMode < 8)) {
			nodeRect = getIEPos(node);
			rootRect = getIEPos(root);

			return {
				x : nodeRect.x - rootRect.x,
				y : nodeRect.y - rootRect.y
			};
		}

		parent = node;
		while (parent && parent != root && parent.nodeType) {
			x += parent.offsetLeft || 0;
			y += parent.offsetTop || 0;
			parent = parent.offsetParent;
		}

		parent = node.parentNode;
		while (parent && parent != root && parent.nodeType) {
			x -= parent.scrollLeft || 0;
			y -= parent.scrollTop || 0;
			parent = parent.parentNode;
		}

		return {
			x : x,
			y : y
		};
	};

	/**
	Returns the size of the specified node in pixels.

	@method getSize
	@static
	@param {Node} node Node to get the size of.
	@return {Object} Object with a w and h property.
	*/
	var getSize = function(node) {
		return {
			w : node.offsetWidth || node.clientWidth,
			h : node.offsetHeight || node.clientHeight
		};
	};

	return {
		get: get,
		hasClass: hasClass,
		addClass: addClass,
		removeClass: removeClass,
		getStyle: getStyle,
		getPos: getPos,
		getSize: getSize
	};
});

// Included from: src/javascript/core/Exceptions.js

/**
 * Exceptions.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/Exceptions', [
	'moxie/core/utils/Basic'
], function(Basic) {
	function _findKey(obj, value) {
		var key;
		for (key in obj) {
			if (obj[key] === value) {
				return key;
			}
		}
		return null;
	}

	return {
		RuntimeError: (function() {
			var namecodes = {
				NOT_INIT_ERR: 1,
				NOT_SUPPORTED_ERR: 9,
				JS_ERR: 4
			};

			function RuntimeError(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": RuntimeError " + this.code;
			}
			
			Basic.extend(RuntimeError, namecodes);
			RuntimeError.prototype = Error.prototype;
			return RuntimeError;
		}()),
		
		OperationNotAllowedException: (function() {
			
			function OperationNotAllowedException(code) {
				this.code = code;
				this.name = 'OperationNotAllowedException';
			}
			
			Basic.extend(OperationNotAllowedException, {
				NOT_ALLOWED_ERR: 1
			});
			
			OperationNotAllowedException.prototype = Error.prototype;
			
			return OperationNotAllowedException;
		}()),

		ImageError: (function() {
			var namecodes = {
				WRONG_FORMAT: 1,
				MAX_RESOLUTION_ERR: 2
			};

			function ImageError(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": ImageError " + this.code;
			}
			
			Basic.extend(ImageError, namecodes);
			ImageError.prototype = Error.prototype;

			return ImageError;
		}()),

		FileException: (function() {
			var namecodes = {
				NOT_FOUND_ERR: 1,
				SECURITY_ERR: 2,
				ABORT_ERR: 3,
				NOT_READABLE_ERR: 4,
				ENCODING_ERR: 5,
				NO_MODIFICATION_ALLOWED_ERR: 6,
				INVALID_STATE_ERR: 7,
				SYNTAX_ERR: 8
			};

			function FileException(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": FileException " + this.code;
			}
			
			Basic.extend(FileException, namecodes);
			FileException.prototype = Error.prototype;
			return FileException;
		}()),
		
		DOMException: (function() {
			var namecodes = {
				INDEX_SIZE_ERR: 1,
				DOMSTRING_SIZE_ERR: 2,
				HIERARCHY_REQUEST_ERR: 3,
				WRONG_DOCUMENT_ERR: 4,
				INVALID_CHARACTER_ERR: 5,
				NO_DATA_ALLOWED_ERR: 6,
				NO_MODIFICATION_ALLOWED_ERR: 7,
				NOT_FOUND_ERR: 8,
				NOT_SUPPORTED_ERR: 9,
				INUSE_ATTRIBUTE_ERR: 10,
				INVALID_STATE_ERR: 11,
				SYNTAX_ERR: 12,
				INVALID_MODIFICATION_ERR: 13,
				NAMESPACE_ERR: 14,
				INVALID_ACCESS_ERR: 15,
				VALIDATION_ERR: 16,
				TYPE_MISMATCH_ERR: 17,
				SECURITY_ERR: 18,
				NETWORK_ERR: 19,
				ABORT_ERR: 20,
				URL_MISMATCH_ERR: 21,
				QUOTA_EXCEEDED_ERR: 22,
				TIMEOUT_ERR: 23,
				INVALID_NODE_TYPE_ERR: 24,
				DATA_CLONE_ERR: 25
			};

			function DOMException(code) {
				this.code = code;
				this.name = _findKey(namecodes, code);
				this.message = this.name + ": DOMException " + this.code;
			}
			
			Basic.extend(DOMException, namecodes);
			DOMException.prototype = Error.prototype;
			return DOMException;
		}()),
		
		EventException: (function() {
			function EventException(code) {
				this.code = code;
				this.name = 'EventException';
			}
			
			Basic.extend(EventException, {
				UNSPECIFIED_EVENT_TYPE_ERR: 0
			});
			
			EventException.prototype = Error.prototype;
			
			return EventException;
		}())
	};
});

// Included from: src/javascript/core/EventTarget.js

/**
 * EventTarget.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/EventTarget', [
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic'
], function(x, Basic) {
	/**
	Parent object for all event dispatching components and objects

	@class EventTarget
	@constructor EventTarget
	*/
	function EventTarget() {
		// hash of event listeners by object uid
		var eventpool = {};
				
		Basic.extend(this, {
			
			/**
			Unique id of the event dispatcher, usually overriden by children

			@property uid
			@type String
			*/
			uid: null,
			
			/**
			Can be called from within a child  in order to acquire uniqie id in automated manner

			@method init
			*/
			init: function() {
				if (!this.uid) {
					this.uid = Basic.guid('uid_');
				}
			},

			/**
			Register a handler to a specific event dispatched by the object

			@method addEventListener
			@param {String} type Type or basically a name of the event to subscribe to
			@param {Function} fn Callback function that will be called when event happens
			@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first
			@param {Object} [scope=this] A scope to invoke event handler in
			*/
			addEventListener: function(type, fn, priority, scope) {
				var self = this, list;
				
				type = Basic.trim(type);
				
				if (/\s/.test(type)) {
					// multiple event types were passed for one handler
					Basic.each(type.split(/\s+/), function(type) {
						self.addEventListener(type, fn, priority, scope);
					});
					return;
				}
				
				type = type.toLowerCase();
				priority = parseInt(priority, 10) || 0;
				
				list = eventpool[this.uid] && eventpool[this.uid][type] || [];
				list.push({fn : fn, priority : priority, scope : scope || this});
				
				if (!eventpool[this.uid]) {
					eventpool[this.uid] = {};
				}
				eventpool[this.uid][type] = list;
			},
			
			/**
			Check if any handlers were registered to the specified event

			@method hasEventListener
			@param {String} type Type or basically a name of the event to check
			@return {Mixed} Returns a handler if it was found and false, if - not
			*/
			hasEventListener: function(type) {
				return type ? !!(eventpool[this.uid] && eventpool[this.uid][type]) : !!eventpool[this.uid];
			},
			
			/**
			Unregister the handler from the event, or if former was not specified - unregister all handlers

			@method removeEventListener
			@param {String} type Type or basically a name of the event
			@param {Function} [fn] Handler to unregister
			*/
			removeEventListener: function(type, fn) {
				type = type.toLowerCase();
	
				var list = eventpool[this.uid] && eventpool[this.uid][type], i;
	
				if (list) {
					if (fn) {
						for (i = list.length - 1; i >= 0; i--) {
							if (list[i].fn === fn) {
								list.splice(i, 1);
								break;
							}
						}
					} else {
						list = [];
					}
	
					// delete event list if it has become empty
					if (!list.length) {
						delete eventpool[this.uid][type];
						
						// and object specific entry in a hash if it has no more listeners attached
						if (Basic.isEmptyObj(eventpool[this.uid])) {
							delete eventpool[this.uid];
						}
					}
				}
			},
			
			/**
			Remove all event handlers from the object

			@method removeAllEventListeners
			*/
			removeAllEventListeners: function() {
				if (eventpool[this.uid]) {
					delete eventpool[this.uid];
				}
			},
			
			/**
			Dispatch the event

			@method dispatchEvent
			@param {String/Object} Type of event or event object to dispatch
			@param {Mixed} [...] Variable number of arguments to be passed to a handlers
			@return {Boolean} true by default and false if any handler returned false
			*/
			dispatchEvent: function(type) {
				var uid, list, args, tmpEvt, evt = {}, result = true, undef;
				
				if (Basic.typeOf(type) !== 'string') {
					// we can't use original object directly (because of Silverlight)
					tmpEvt = type;

					if (Basic.typeOf(tmpEvt.type) === 'string') {
						type = tmpEvt.type;

						if (tmpEvt.total !== undef && tmpEvt.loaded !== undef) { // progress event
							evt.total = tmpEvt.total;
							evt.loaded = tmpEvt.loaded;
						}
						evt.async = tmpEvt.async || false;
					} else {
						throw new x.EventException(x.EventException.UNSPECIFIED_EVENT_TYPE_ERR);
					}
				}
				
				// check if event is meant to be dispatched on an object having specific uid
				if (type.indexOf('::') !== -1) {
					(function(arr) {
						uid = arr[0];
						type = arr[1];
					}(type.split('::')));
				} else {
					uid = this.uid;
				}
				
				type = type.toLowerCase();
								
				list = eventpool[uid] && eventpool[uid][type];

				if (list) {
					// sort event list by prority
					list.sort(function(a, b) { return b.priority - a.priority; });
					
					args = [].slice.call(arguments);
					
					// first argument will be pseudo-event object
					args.shift();
					evt.type = type;
					args.unshift(evt);

					// Dispatch event to all listeners
					var queue = [];
					Basic.each(list, function(handler) {
						// explicitly set the target, otherwise events fired from shims do not get it
						args[0].target = handler.scope;
						// if event is marked as async, detach the handler
						if (evt.async) {
							queue.push(function(cb) {
								setTimeout(function() {
									cb(handler.fn.apply(handler.scope, args) === false);
								}, 1);
							});
						} else {
							queue.push(function(cb) {
								cb(handler.fn.apply(handler.scope, args) === false); // if handler returns false stop propagation
							});
						}
					});
					if (queue.length) {
						Basic.inSeries(queue, function(err) {
							result = !err;
						});
					}
				}
				return result;
			},
			
			/**
			Alias for addEventListener

			@method bind
			@protected
			*/
			bind: function() {
				this.addEventListener.apply(this, arguments);
			},
			
			/**
			Alias for removeEventListener

			@method unbind
			@protected
			*/
			unbind: function() {
				this.removeEventListener.apply(this, arguments);
			},
			
			/**
			Alias for removeAllEventListeners

			@method unbindAll
			@protected
			*/
			unbindAll: function() {
				this.removeAllEventListeners.apply(this, arguments);
			},
			
			/**
			Alias for dispatchEvent

			@method trigger
			@protected
			*/
			trigger: function() {
				return this.dispatchEvent.apply(this, arguments);
			},
			
			
			/**
			Converts properties of on[event] type to corresponding event handlers,
			is used to avoid extra hassle around the process of calling them back

			@method convertEventPropsToHandlers
			@private
			*/
			convertEventPropsToHandlers: function(handlers) {
				var h;
						
				if (Basic.typeOf(handlers) !== 'array') {
					handlers = [handlers];
				}

				for (var i = 0; i < handlers.length; i++) {
					h = 'on' + handlers[i];
					
					if (Basic.typeOf(this[h]) === 'function') {
						this.addEventListener(handlers[i], this[h]);
					} else if (Basic.typeOf(this[h]) === 'undefined') {
						this[h] = null; // object must have defined event properties, even if it doesn't make use of them
					}
				}
			}
			
		});
	}

	EventTarget.instance = new EventTarget(); 

	return EventTarget;
});

// Included from: src/javascript/core/utils/Encode.js

/**
 * Encode.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Encode', [], function() {

	/**
	Encode string with UTF-8

	@method utf8_encode
	@for Utils
	@static
	@param {String} str String to encode
	@return {String} UTF-8 encoded string
	*/
	var utf8_encode = function(str) {
		return unescape(encodeURIComponent(str));
	};
	
	/**
	Decode UTF-8 encoded string

	@method utf8_decode
	@static
	@param {String} str String to decode
	@return {String} Decoded string
	*/
	var utf8_decode = function(str_data) {
		return decodeURIComponent(escape(str_data));
	};
	
	/**
	Decode Base64 encoded string (uses browser's default method if available),
	from: https://raw.github.com/kvz/phpjs/master/functions/url/base64_decode.js

	@method atob
	@static
	@param {String} data String to decode
	@return {String} Decoded string
	*/
	var atob = function(data, utf8) {
		if (typeof(window.atob) === 'function') {
			return utf8 ? utf8_decode(window.atob(data)) : window.atob(data);
		}

		// http://kevin.vanzonneveld.net
		// +   original by: Tyler Akins (http://rumkin.com)
		// +   improved by: Thunder.m
		// +      input by: Aman Gupta
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   bugfixed by: Onno Marsman
		// +   bugfixed by: Pellentesque Malesuada
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +      input by: Brett Zamir (http://brett-zamir.me)
		// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
		// *     returns 1: 'Kevin van Zonneveld'
		// mozilla has this native
		// - but breaks in 2.0.0.12!
		//if (typeof this.window.atob == 'function') {
		//    return atob(data);
		//}
		var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			dec = "",
			tmp_arr = [];

		if (!data) {
			return data;
		}

		data += '';

		do { // unpack four hexets into three octets using index points in b64
			h1 = b64.indexOf(data.charAt(i++));
			h2 = b64.indexOf(data.charAt(i++));
			h3 = b64.indexOf(data.charAt(i++));
			h4 = b64.indexOf(data.charAt(i++));

			bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

			o1 = bits >> 16 & 0xff;
			o2 = bits >> 8 & 0xff;
			o3 = bits & 0xff;

			if (h3 == 64) {
				tmp_arr[ac++] = String.fromCharCode(o1);
			} else if (h4 == 64) {
				tmp_arr[ac++] = String.fromCharCode(o1, o2);
			} else {
				tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
			}
		} while (i < data.length);

		dec = tmp_arr.join('');

		return utf8 ? utf8_decode(dec) : dec;
	};
	
	/**
	Base64 encode string (uses browser's default method if available),
	from: https://raw.github.com/kvz/phpjs/master/functions/url/base64_encode.js

	@method btoa
	@static
	@param {String} data String to encode
	@return {String} Base64 encoded string
	*/
	var btoa = function(data, utf8) {
		if (utf8) {
			utf8_encode(data);
		}

		if (typeof(window.btoa) === 'function') {
			return window.btoa(data);
		}

		// http://kevin.vanzonneveld.net
		// +   original by: Tyler Akins (http://rumkin.com)
		// +   improved by: Bayron Guevara
		// +   improved by: Thunder.m
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   bugfixed by: Pellentesque Malesuada
		// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
		// +   improved by: Rafa? Kukawski (http://kukawski.pl)
		// *     example 1: base64_encode('Kevin van Zonneveld');
		// *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
		// mozilla has this native
		// - but breaks in 2.0.0.12!
		var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
			ac = 0,
			enc = "",
			tmp_arr = [];

		if (!data) {
			return data;
		}

		do { // pack three octets into four hexets
			o1 = data.charCodeAt(i++);
			o2 = data.charCodeAt(i++);
			o3 = data.charCodeAt(i++);

			bits = o1 << 16 | o2 << 8 | o3;

			h1 = bits >> 18 & 0x3f;
			h2 = bits >> 12 & 0x3f;
			h3 = bits >> 6 & 0x3f;
			h4 = bits & 0x3f;

			// use hexets to index into b64, and append result to encoded string
			tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
		} while (i < data.length);

		enc = tmp_arr.join('');

		var r = data.length % 3;

		return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
	};


	return {
		utf8_encode: utf8_encode,
		utf8_decode: utf8_decode,
		atob: atob,
		btoa: btoa
	};
});

// Included from: src/javascript/runtime/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/Runtime', [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/EventTarget"
], function(Basic, Dom, EventTarget) {
	var runtimeConstructors = {}, runtimes = {};

	/**
	Common set of methods and properties for every runtime instance

	@class Runtime

	@param {Object} options
	@param {String} type Sanitized name of the runtime
	@param {Object} [caps] Set of capabilities that differentiate specified runtime
	@param {Object} [modeCaps] Set of capabilities that do require specific operational mode
	@param {String} [preferredMode='browser'] Preferred operational mode to choose if no required capabilities were requested
	*/
	function Runtime(options, type, caps, modeCaps, preferredMode) {
		/**
		Dispatched when runtime is initialized and ready.
		Results in RuntimeInit on a connected component.

		@event Init
		*/

		/**
		Dispatched when runtime fails to initialize.
		Results in RuntimeError on a connected component.

		@event Error
		*/

		var self = this
		, _shim
		, _uid = Basic.guid(type + '_')
		, defaultMode = preferredMode || 'browser'
		;

		options = options || {};

		// register runtime in private hash
		runtimes[_uid] = this;

		/**
		Default set of capabilities, which can be redifined later by specific runtime

		@private
		@property caps
		@type Object
		*/
		caps = Basic.extend({
			// Runtime can: 
			// provide access to raw binary data of the file
			access_binary: false,
			// provide access to raw binary data of the image (image extension is optional) 
			access_image_binary: false,
			// display binary data as thumbs for example
			display_media: false,
			// make cross-domain requests
			do_cors: false,
			// accept files dragged and dropped from the desktop
			drag_and_drop: false,
			// filter files in selection dialog by their extensions
			filter_by_extension: true,
			// resize image (and manipulate it raw data of any file in general)
			resize_image: false,
			// periodically report how many bytes of total in the file were uploaded (loaded)
			report_upload_progress: false,
			// provide access to the headers of http response 
			return_response_headers: false,
			// support response of specific type, which should be passed as an argument
			// e.g. runtime.can('return_response_type', 'blob')
			return_response_type: false,
			// return http status code of the response
			return_status_code: true,
			// send custom http header with the request
			send_custom_headers: false,
			// pick up the files from a dialog
			select_file: false,
			// select whole folder in file browse dialog
			select_folder: false,
			// select multiple files at once in file browse dialog
			select_multiple: true,
			// send raw binary data, that is generated after image resizing or manipulation of other kind
			send_binary_string: false,
			// send cookies with http request and therefore retain session
			send_browser_cookies: true,
			// send data formatted as multipart/form-data
			send_multipart: true,
			// slice the file or blob to smaller parts
			slice_blob: false,
			// upload file without preloading it to memory, stream it out directly from disk
			stream_upload: false,
			// programmatically trigger file browse dialog
			summon_file_dialog: false,
			// upload file of specific size, size should be passed as argument
			// e.g. runtime.can('upload_filesize', '500mb')
			upload_filesize: true,
			// initiate http request with specific http method, method should be passed as argument
			// e.g. runtime.can('use_http_method', 'put')
			use_http_method: true
		}, caps);
			
	
		// default to the mode that is compatible with preferred caps
		if (options.preferred_caps) {
			defaultMode = Runtime.getMode(modeCaps, options.preferred_caps, defaultMode);
		}
		
		// small extension factory here (is meant to be extended with actual extensions constructors)
		_shim = (function() {
			var objpool = {};
			return {
				exec: function(uid, comp, fn, args) {
					if (_shim[comp]) {
						if (!objpool[uid]) {
							objpool[uid] = {
								context: this,
								instance: new _shim[comp]()
							};
						}
						if (objpool[uid].instance[fn]) {
							return objpool[uid].instance[fn].apply(this, args);
						}
					}
				},

				removeInstance: function(uid) {
					delete objpool[uid];
				},

				removeAllInstances: function() {
					var self = this;
					Basic.each(objpool, function(obj, uid) {
						if (Basic.typeOf(obj.instance.destroy) === 'function') {
							obj.instance.destroy.call(obj.context);
						}
						self.removeInstance(uid);
					});
				}
			};
		}());


		// public methods
		Basic.extend(this, {
			/**
			Specifies whether runtime instance was initialized or not

			@property initialized
			@type {Boolean}
			@default false
			*/
			initialized: false, // shims require this flag to stop initialization retries

			/**
			Unique ID of the runtime

			@property uid
			@type {String}
			*/
			uid: _uid,

			/**
			Runtime type (e.g. flash, html5, etc)

			@property type
			@type {String}
			*/
			type: type,

			/**
			Runtime (not native one) may operate in browser or client mode.

			@property mode
			@private
			@type {String|Boolean} current mode or false, if none possible
			*/
			mode: Runtime.getMode(modeCaps, (options.required_caps), defaultMode),

			/**
			id of the DOM container for the runtime (if available)

			@property shimid
			@type {String}
			*/
			shimid: _uid + '_container',

			/**
			Number of connected clients. If equal to zero, runtime can be destroyed

			@property clients
			@type {Number}
			*/
			clients: 0,

			/**
			Runtime initialization options

			@property options
			@type {Object}
			*/
			options: options,

			/**
			Checks if the runtime has specific capability

			@method can
			@param {String} cap Name of capability to check
			@param {Mixed} [value] If passed, capability should somehow correlate to the value
			@param {Object} [refCaps] Set of capabilities to check the specified cap against (defaults to internal set)
			@return {Boolean} true if runtime has such capability and false, if - not
			*/
			can: function(cap, value) {
				var refCaps = arguments[2] || caps;

				// if cap var is a comma-separated list of caps, convert it to object (key/value)
				if (Basic.typeOf(cap) === 'string' && Basic.typeOf(value) === 'undefined') {
					cap = Runtime.parseCaps(cap);
				}

				if (Basic.typeOf(cap) === 'object') {
					for (var key in cap) {
						if (!this.can(key, cap[key], refCaps)) {
							return false;
						}
					}
					return true;
				}

				// check the individual cap
				if (Basic.typeOf(refCaps[cap]) === 'function') {
					return refCaps[cap].call(this, value);
				} else {
					return (value === refCaps[cap]);
				}
			},

			/**
			Returns container for the runtime as DOM element

			@method getShimContainer
			@return {DOMElement}
			*/
			getShimContainer: function() {
				var container, shimContainer = Dom.get(this.shimid);

				// if no container for shim, create one
				if (!shimContainer) {
					container = this.options.container ? Dom.get(this.options.container) : document.body;

					// create shim container and insert it at an absolute position into the outer container
					shimContainer = document.createElement('div');
					shimContainer.id = this.shimid;
					shimContainer.className = 'moxie-shim moxie-shim-' + this.type;

					Basic.extend(shimContainer.style, {
						position: 'absolute',
						top: '0px',
						left: '0px',
						width: '1px',
						height: '1px',
						overflow: 'hidden'
					});

					container.appendChild(shimContainer);
					container = null;
				}

				return shimContainer;
			},

			/**
			Returns runtime as DOM element (if appropriate)

			@method getShim
			@return {DOMElement}
			*/
			getShim: function() {
				return _shim;
			},

			/**
			Invokes a method within the runtime itself (might differ across the runtimes)

			@method shimExec
			@param {Mixed} []
			@protected
			@return {Mixed} Depends on the action and component
			*/
			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return self.getShim().exec.call(this, this.uid, component, action, args);
			},

			/**
			Operaional interface that is used by components to invoke specific actions on the runtime
			(is invoked in the scope of component)

			@method exec
			@param {Mixed} []*
			@protected
			@return {Mixed} Depends on the action and component
			*/
			exec: function(component, action) { // this is called in the context of component, not runtime
				var args = [].slice.call(arguments, 2);

				if (self[component] && self[component][action]) {
					return self[component][action].apply(this, args);
				}
				return self.shimExec.apply(this, arguments);
			},

			/**
			Destroys the runtime (removes all events and deletes DOM structures)

			@method destroy
			*/
			destroy: function() {
				if (!self) {
					return; // obviously already destroyed
				}

				var shimContainer = Dom.get(this.shimid);
				if (shimContainer) {
					shimContainer.parentNode.removeChild(shimContainer);
				}

				if (_shim) {
					_shim.removeAllInstances();
				}

				this.unbindAll();
				delete runtimes[this.uid];
				this.uid = null; // mark this runtime as destroyed
				_uid = self = _shim = shimContainer = null;
			}
		});

		// once we got the mode, test against all caps
		if (this.mode && options.required_caps && !this.can(options.required_caps)) {
			this.mode = false;
		}	
	}


	/**
	Default order to try different runtime types

	@property order
	@type String
	@static
	*/
	Runtime.order = 'html5,flash,silverlight,html4';


	/**
	Retrieves runtime from private hash by it's uid

	@method getRuntime
	@private
	@static
	@param {String} uid Unique identifier of the runtime
	@return {Runtime|Boolean} Returns runtime, if it exists and false, if - not
	*/
	Runtime.getRuntime = function(uid) {
		return runtimes[uid] ? runtimes[uid] : false;
	};


	/**
	Register constructor for the Runtime of new (or perhaps modified) type

	@method addConstructor
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@param {Function} construct Constructor for the Runtime type
	*/
	Runtime.addConstructor = function(type, constructor) {
		constructor.prototype = EventTarget.instance;
		runtimeConstructors[type] = constructor;
	};


	/**
	Get the constructor for the specified type.

	method getConstructor
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@return {Function} Constructor for the Runtime type
	*/
	Runtime.getConstructor = function(type) {
		return runtimeConstructors[type] || null;
	};


	/**
	Get info about the runtime (uid, type, capabilities)

	@method getInfo
	@static
	@param {String} uid Unique identifier of the runtime
	@return {Mixed} Info object or null if runtime doesn't exist
	*/
	Runtime.getInfo = function(uid) {
		var runtime = Runtime.getRuntime(uid);

		if (runtime) {
			return {
				uid: runtime.uid,
				type: runtime.type,
				mode: runtime.mode,
				can: function() {
					return runtime.can.apply(runtime, arguments);
				}
			};
		}
		return null;
	};


	/**
	Convert caps represented by a comma-separated string to the object representation.

	@method parseCaps
	@static
	@param {String} capStr Comma-separated list of capabilities
	@return {Object}
	*/
	Runtime.parseCaps = function(capStr) {
		var capObj = {};

		if (Basic.typeOf(capStr) !== 'string') {
			return capStr || {};
		}

		Basic.each(capStr.split(','), function(key) {
			capObj[key] = true; // we assume it to be - true
		});

		return capObj;
	};

	/**
	Test the specified runtime for specific capabilities.

	@method can
	@static
	@param {String} type Runtime type (e.g. flash, html5, etc)
	@param {String|Object} caps Set of capabilities to check
	@return {Boolean} Result of the test
	*/
	Runtime.can = function(type, caps) {
		var runtime
		, constructor = Runtime.getConstructor(type)
		, mode
		;
		if (constructor) {
			runtime = new constructor({
				required_caps: caps
			});
			mode = runtime.mode;
			runtime.destroy();
			return !!mode;
		}
		return false;
	};


	/**
	Figure out a runtime that supports specified capabilities.

	@method thatCan
	@static
	@param {String|Object} caps Set of capabilities to check
	@param {String} [runtimeOrder] Comma-separated list of runtimes to check against
	@return {String} Usable runtime identifier or null
	*/
	Runtime.thatCan = function(caps, runtimeOrder) {
		var types = (runtimeOrder || Runtime.order).split(/\s*,\s*/);
		for (var i in types) {
			if (Runtime.can(types[i], caps)) {
				return types[i];
			}
		}
		return null;
	};


	/**
	Figure out an operational mode for the specified set of capabilities.

	@method getMode
	@static
	@param {Object} modeCaps Set of capabilities that depend on particular runtime mode
	@param {Object} [requiredCaps] Supplied set of capabilities to find operational mode for
	@param {String|Boolean} [defaultMode='browser'] Default mode to use 
	@return {String|Boolean} Compatible operational mode
	*/
	Runtime.getMode = function(modeCaps, requiredCaps, defaultMode) {
		var mode = null;

		if (Basic.typeOf(defaultMode) === 'undefined') { // only if not specified
			defaultMode = 'browser';
		}

		if (requiredCaps && !Basic.isEmptyObj(modeCaps)) {
			// loop over required caps and check if they do require the same mode
			Basic.each(requiredCaps, function(value, cap) {
				if (modeCaps.hasOwnProperty(cap)) {
					var capMode = modeCaps[cap](value);

					// make sure we always have an array
					if (typeof(capMode) === 'string') {
						capMode = [capMode];
					}
					
					if (!mode) {
						mode = capMode;
					} else if (!(mode = Basic.arrayIntersect(mode, capMode))) {
						// if cap requires conflicting mode - runtime cannot fulfill required caps
						return (mode = false);
					}
				}
			});

			if (mode) {
				return Basic.inArray(defaultMode, mode) !== -1 ? defaultMode : mode[0];
			} else if (mode === false) {
				return false;
			}
		}
		return defaultMode; 
	};


	/**
	Capability check that always returns true

	@private
	@static
	@return {True}
	*/
	Runtime.capTrue = function() {
		return true;
	};

	/**
	Capability check that always returns false

	@private
	@static
	@return {False}
	*/
	Runtime.capFalse = function() {
		return false;
	};

	/**
	Evaluate the expression to boolean value and create a function that always returns it.

	@private
	@static
	@param {Mixed} expr Expression to evaluate
	@return {Function} Function returning the result of evaluation
	*/
	Runtime.capTest = function(expr) {
		return function() {
			return !!expr;
		};
	};

	return Runtime;
});

// Included from: src/javascript/runtime/RuntimeClient.js

/**
 * RuntimeClient.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/RuntimeClient', [
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic',
	'moxie/runtime/Runtime'
], function(x, Basic, Runtime) {
	/**
	Set of methods and properties, required by a component to acquire ability to connect to a runtime

	@class RuntimeClient
	*/
	return function RuntimeClient() {
		var runtime;

		Basic.extend(this, {
			/**
			Connects to the runtime specified by the options. Will either connect to existing runtime or create a new one.
			Increments number of clients connected to the specified runtime.

			@method connectRuntime
			@param {Mixed} options Can be a runtme uid or a set of key-value pairs defining requirements and pre-requisites
			*/
			connectRuntime: function(options) {
				var comp = this, ruid;

				function initialize(items) {
					var type, constructor;

					// if we ran out of runtimes
					if (!items.length) {
						comp.trigger('RuntimeError', new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));
						runtime = null;
						return;
					}

					type = items.shift();
					constructor = Runtime.getConstructor(type);
					if (!constructor) {
						initialize(items);
						return;
					}

					// try initializing the runtime
					runtime = new constructor(options);

					runtime.bind('Init', function() {
						// mark runtime as initialized
						runtime.initialized = true;

						// jailbreak ...
						setTimeout(function() {
							runtime.clients++;
							// this will be triggered on component
							comp.trigger('RuntimeInit', runtime);
						}, 1);
					});

					runtime.bind('Error', function() {
						runtime.destroy(); // runtime cannot destroy itself from inside at a right moment, thus we do it here
						initialize(items);
					});

					/*runtime.bind('Exception', function() { });*/

					// check if runtime managed to pick-up operational mode
					if (!runtime.mode) {
						runtime.trigger('Error');
						return;
					}

					runtime.init();
				}

				// check if a particular runtime was requested
				if (Basic.typeOf(options) === 'string') {
					ruid = options;
				} else if (Basic.typeOf(options.ruid) === 'string') {
					ruid = options.ruid;
				}

				if (ruid) {
					runtime = Runtime.getRuntime(ruid);
					if (runtime) {
						runtime.clients++;
						return runtime;
					} else {
						// there should be a runtime and there's none - weird case
						throw new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR);
					}
				}

				// initialize a fresh one, that fits runtime list and required features best
				initialize((options.runtime_order || Runtime.order).split(/\s*,\s*/));
			},

			/**
			Returns the runtime to which the client is currently connected.

			@method getRuntime
			@return {Runtime} Runtime or null if client is not connected
			*/
			getRuntime: function() {
				if (runtime && runtime.uid) {
					return runtime;
				}
				runtime = null; // make sure we do not leave zombies rambling around
				return null;
			},

			/**
			Disconnects from the runtime. Decrements number of clients connected to the specified runtime.

			@method disconnectRuntime
			*/
			disconnectRuntime: function() {
				if (runtime && --runtime.clients <= 0) {
					runtime.destroy();
					runtime = null;
				}
			}

		});
	};


});

// Included from: src/javascript/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/Blob', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Encode',
	'moxie/runtime/RuntimeClient'
], function(Basic, Encode, RuntimeClient) {
	
	var blobpool = {};

	/**
	@class Blob
	@constructor
	@param {String} ruid Unique id of the runtime, to which this blob belongs to
	@param {Object} blob Object "Native" blob object, as it is represented in the runtime
	*/
	function Blob(ruid, blob) {

		function _sliceDetached(start, end, type) {
			var blob, data = blobpool[this.uid];

			if (Basic.typeOf(data) !== 'string' || !data.length) {
				return null; // or throw exception
			}

			blob = new Blob(null, {
				type: type,
				size: end - start
			});
			blob.detach(data.substr(start, blob.size));

			return blob;
		}

		RuntimeClient.call(this);

		if (ruid) {	
			this.connectRuntime(ruid);
		}

		if (!blob) {
			blob = {};
		} else if (Basic.typeOf(blob) === 'string') { // dataUrl or binary string
			blob = { data: blob };
		}

		Basic.extend(this, {
			
			/**
			Unique id of the component

			@property uid
			@type {String}
			*/
			uid: blob.uid || Basic.guid('uid_'),
			
			/**
			Unique id of the connected runtime, if falsy, then runtime will have to be initialized 
			before this Blob can be used, modified or sent

			@property ruid
			@type {String}
			*/
			ruid: ruid,
	
			/**
			Size of blob

			@property size
			@type {Number}
			@default 0
			*/
			size: blob.size || 0,
			
			/**
			Mime type of blob

			@property type
			@type {String}
			@default ''
			*/
			type: blob.type || '',
			
			/**
			@method slice
			@param {Number} [start=0]
			*/
			slice: function(start, end, type) {		
				if (this.isDetached()) {
					return _sliceDetached.apply(this, arguments);
				}
				return this.getRuntime().exec.call(this, 'Blob', 'slice', this.getSource(), start, end, type);
			},

			/**
			Returns "native" blob object (as it is represented in connected runtime) or null if not found

			@method getSource
			@return {Blob} Returns "native" blob object or null if not found
			*/
			getSource: function() {
				if (!blobpool[this.uid]) {
					return null;	
				}
				return blobpool[this.uid];
			},

			/** 
			Detaches blob from any runtime that it depends on and initialize with standalone value

			@method detach
			@protected
			@param {DOMString} [data=''] Standalone value
			*/
			detach: function(data) {
				if (this.ruid) {
					this.getRuntime().exec.call(this, 'Blob', 'destroy', blobpool[this.uid]);
					this.disconnectRuntime();
					this.ruid = null;
				}

				data = data || '';

				// if dataUrl, convert to binary string
				var matches = data.match(/^data:([^;]*);base64,/);
				if (matches) {
					this.type = matches[1];
					data = Encode.atob(data.substring(data.indexOf('base64,') + 7));
				}

				this.size = data.length;

				blobpool[this.uid] = data;
			},

			/**
			Checks if blob is standalone (detached of any runtime)
			
			@method isDetached
			@protected
			@return {Boolean}
			*/
			isDetached: function() {
				return !this.ruid && Basic.typeOf(blobpool[this.uid]) === 'string';
			},
			
			/** 
			Destroy Blob and free any resources it was using

			@method destroy
			*/
			destroy: function() {
				this.detach();
				delete blobpool[this.uid];
			}
		});

		
		if (blob.data) {
			this.detach(blob.data); // auto-detach if payload has been passed
		} else {
			blobpool[this.uid] = blob;	
		}
	}
	
	return Blob;
});

// Included from: src/javascript/file/File.js

/**
 * File.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/File', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Mime',
	'moxie/file/Blob'
], function(Basic, Mime, Blob) {
	/**
	@class File
	@extends Blob
	@constructor
	@param {String} ruid Unique id of the runtime, to which this blob belongs to
	@param {Object} file Object "Native" file object, as it is represented in the runtime
	*/
	function File(ruid, file) {
		var name, type;

		if (!file) { // avoid extra errors in case we overlooked something
			file = {};
		}

		// figure out the type
		if (file.type && file.type !== '') {
			type = file.type;
		} else {
			type = Mime.getFileMime(file.name);
		}

		// sanitize file name or generate new one
		if (file.name) {
			name = file.name.replace(/\\/g, '/');
			name = name.substr(name.lastIndexOf('/') + 1);
		} else {
			var prefix = type.split('/')[0];
			name = Basic.guid((prefix !== '' ? prefix : 'file') + '_');
			
			if (Mime.extensions[type]) {
				name += '.' + Mime.extensions[type][0]; // append proper extension if possible
			}
		}

		Blob.apply(this, arguments);
		
		Basic.extend(this, {
			/**
			File mime type

			@property type
			@type {String}
			@default ''
			*/
			type: type || '',

			/**
			File name

			@property name
			@type {String}
			@default UID
			*/
			name: name || Basic.guid('file_'),
			
			/**
			Date of last modification

			@property lastModifiedDate
			@type {String}
			@default now
			*/
			lastModifiedDate: file.lastModifiedDate || (new Date()).toLocaleString() // Thu Aug 23 2012 19:40:00 GMT+0400 (GET)
		});
	}

	File.prototype = Blob.prototype;

	return File;
});

// Included from: src/javascript/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileInput', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Mime',
	'moxie/core/utils/Dom',
	'moxie/core/Exceptions',
	'moxie/core/EventTarget',
	'moxie/core/I18n',
	'moxie/file/File',
	'moxie/runtime/Runtime',
	'moxie/runtime/RuntimeClient'
], function(Basic, Mime, Dom, x, EventTarget, I18n, File, Runtime, RuntimeClient) {
	/**
	Provides a convenient way to create cross-browser file-picker. Generates file selection dialog on click,
	converts selected files to _File_ objects, to be used in conjunction with _Image_, preloaded in memory
	with _FileReader_ or uploaded to a server through _XMLHttpRequest_.

	@class FileInput
	@constructor
	@extends EventTarget
	@uses RuntimeClient
	@param {Object|String|DOMElement} options If options is string or node, argument is considered as _browse\_button_.
		@param {String|DOMElement} options.browse_button DOM Element to turn into file picker.
		@param {Array} [options.accept] Array of mime types to accept. By default accepts all.
		@param {String} [options.file='file'] Name of the file field (not the filename).
		@param {Boolean} [options.multiple=false] Enable selection of multiple files.
		@param {Boolean} [options.directory=false] Turn file input into the folder input (cannot be both at the same time).
		@param {String|DOMElement} [options.container] DOM Element to use as a container for file-picker. Defaults to parentNode 
		for _browse\_button_.
		@param {Object|String} [options.required_caps] Set of required capabilities, that chosen runtime must support.

	@example
		<div id="container">
			<a id="file-picker" href="javascript:;">Browse...</a>
		</div>

		<script>
			var fileInput = new mOxie.FileInput({
				browse_button: 'file-picker', // or document.getElementById('file-picker')
				container: 'container',
				accept: [
					{title: "Image files", extensions: "jpg,gif,png"} // accept only images
				],
				multiple: true // allow multiple file selection
			});

			fileInput.onchange = function(e) {
				// do something to files array
				console.info(e.target.files); // or this.files or fileInput.files
			};

			fileInput.init(); // initialize
		</script>
	*/
	var dispatches = [
		/**
		Dispatched when runtime is connected and file-picker is ready to be used.

		@event ready
		@param {Object} event
		*/
		'ready',

		/**
		Dispatched right after [ready](#event_ready) event, and whenever [refresh()](#method_refresh) is invoked. 
		Check [corresponding documentation entry](#method_refresh) for more info.

		@event refresh
		@param {Object} event
		*/

		/**
		Dispatched when selection of files in the dialog is complete.

		@event change
		@param {Object} event
		*/
		'change',

		'cancel', // TODO: might be useful

		/**
		Dispatched when mouse cursor enters file-picker area. Can be used to style element
		accordingly.

		@event mouseenter
		@param {Object} event
		*/
		'mouseenter',

		/**
		Dispatched when mouse cursor leaves file-picker area. Can be used to style element
		accordingly.

		@event mouseleave
		@param {Object} event
		*/
		'mouseleave',

		/**
		Dispatched when functional mouse button is pressed on top of file-picker area.

		@event mousedown
		@param {Object} event
		*/
		'mousedown',

		/**
		Dispatched when functional mouse button is released on top of file-picker area.

		@event mouseup
		@param {Object} event
		*/
		'mouseup'
	];

	function FileInput(options) {
		var self = this,
			container, browseButton, defaults;

		// if flat argument passed it should be browse_button id
		if (Basic.inArray(Basic.typeOf(options), ['string', 'node']) !== -1) {
			options = { browse_button : options };
		}

		// this will help us to find proper default container
		browseButton = Dom.get(options.browse_button);
		if (!browseButton) {
			// browse button is required
			throw new x.DOMException(x.DOMException.NOT_FOUND_ERR);
		}

		// figure out the options
		defaults = {
			accept: [{
				title: I18n.translate('All Files'),
				extensions: '*'
			}],
			name: 'file',
			multiple: false,
			required_caps: false,
			container: browseButton.parentNode || document.body
		};
		
		options = Basic.extend({}, defaults, options);

		// convert to object representation
		if (typeof(options.required_caps) === 'string') {
			options.required_caps = Runtime.parseCaps(options.required_caps);
		}
					
		// normalize accept option (could be list of mime types or array of title/extensions pairs)
		if (typeof(options.accept) === 'string') {
			options.accept = Mime.mimes2extList(options.accept);
		}

		container = Dom.get(options.container);
		// make sure we have container
		if (!container) {
			container = document.body;
		}

		// make container relative, if it's not
		if (Dom.getStyle(container, 'position') === 'static') {
			container.style.position = 'relative';
		}

		container = browseButton = null; // IE
						
		RuntimeClient.call(self);
		
		Basic.extend(self, {
			/**
			Unique id of the component

			@property uid
			@protected
			@readOnly
			@type {String}
			@default UID
			*/
			uid: Basic.guid('uid_'),
			
			/**
			Unique id of the connected runtime, if any.

			@property ruid
			@protected
			@type {String}
			*/
			ruid: null,

			/**
			Unique id of the runtime container. Useful to get hold of it for various manipulations.

			@property shimid
			@protected
			@type {String}
			*/
			shimid: null,
			
			/**
			Array of selected mOxie.File objects

			@property files
			@type {Array}
			@default null
			*/
			files: null,

			/**
			Initializes the file-picker, connects it to runtime and dispatches event ready when done.

			@method init
			*/
			init: function() {
				self.convertEventPropsToHandlers(dispatches);

				self.bind('RuntimeInit', function(e, runtime) {
					self.ruid = runtime.uid;
					self.shimid = runtime.shimid;

					self.bind("Ready", function() {
						self.trigger("Refresh");
					}, 999);

					self.bind("Change", function() {
						var files = runtime.exec.call(self, 'FileInput', 'getFiles');

						self.files = [];

						Basic.each(files, function(file) {
							// ignore empty files (IE10 for example hangs if you try to send them via XHR)
							if (file.size === 0) {
								return true; 
							}
							self.files.push(new File(self.ruid, file));
						});
					}, 999);

					// re-position and resize shim container
					self.bind('Refresh', function() {
						var pos, size, browseButton, shimContainer;
						
						browseButton = Dom.get(options.browse_button);
						shimContainer = Dom.get(runtime.shimid); // do not use runtime.getShimContainer(), since it will create container if it doesn't exist

						if (browseButton) {
							pos = Dom.getPos(browseButton, Dom.get(options.container));
							size = Dom.getSize(browseButton);

							if (shimContainer) {
								Basic.extend(shimContainer.style, {
									top     : pos.y + 'px',
									left    : pos.x + 'px',
									width   : size.w + 'px',
									height  : size.h + 'px'
								});
							}
						}
						shimContainer = browseButton = null;
					});
					
					runtime.exec.call(self, 'FileInput', 'init', options);
				});

				// runtime needs: options.required_features, options.runtime_order and options.container
				self.connectRuntime(Basic.extend({}, options, {
					required_caps: {
						select_file: true
					}
				}));
			},

			/**
			Disables file-picker element, so that it doesn't react to mouse clicks.

			@method disable
			@param {Boolean} [state=true] Disable component if - true, enable if - false
			*/
			disable: function(state) {
				var runtime = this.getRuntime();
				if (runtime) {
					runtime.exec.call(this, 'FileInput', 'disable', Basic.typeOf(state) === 'undefined' ? true : state);
				}
			},


			/**
			Reposition and resize dialog trigger to match the position and size of browse_button element.

			@method refresh
			*/
			refresh: function() {
				self.trigger("Refresh");
			},


			/**
			Destroy component.

			@method destroy
			*/
			destroy: function() {
				var runtime = this.getRuntime();
				if (runtime) {
					runtime.exec.call(this, 'FileInput', 'destroy');
					this.disconnectRuntime();
				}

				if (Basic.typeOf(this.files) === 'array') {
					// no sense in leaving associated files behind
					Basic.each(this.files, function(file) {
						file.destroy();
					});
				} 
				this.files = null;
			}
		});
	}

	FileInput.prototype = EventTarget.instance;

	return FileInput;
});

// Included from: src/javascript/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileDrop', [
	'moxie/core/I18n',
	'moxie/core/utils/Dom',
	'moxie/core/Exceptions',
	'moxie/core/utils/Basic',
	'moxie/file/File',
	'moxie/runtime/RuntimeClient',
	'moxie/core/EventTarget',
	'moxie/core/utils/Mime'
], function(I18n, Dom, x, Basic, File, RuntimeClient, EventTarget, Mime) {
	/**
	Turn arbitrary DOM element to a drop zone accepting files. Converts selected files to _File_ objects, to be used 
	in conjunction with _Image_, preloaded in memory with _FileReader_ or uploaded to a server through 
	_XMLHttpRequest_.

	@example
		<div id="drop_zone">
			Drop files here
		</div>
		<br />
		<div id="filelist"></div>

		<script type="text/javascript">
			var fileDrop = new mOxie.FileDrop('drop_zone'), fileList = mOxie.get('filelist');

			fileDrop.ondrop = function() {
				mOxie.each(this.files, function(file) {
					fileList.innerHTML += '<div>' + file.name + '</div>';
				});
			};

			fileDrop.init();
		</script>

	@class FileDrop
	@constructor
	@extends EventTarget
	@uses RuntimeClient
	@param {Object|String} options If options has typeof string, argument is considered as options.drop_zone
		@param {String|DOMElement} options.drop_zone DOM Element to turn into a drop zone
		@param {Array} [options.accept] Array of mime types to accept. By default accepts all
		@param {Object|String} [options.required_caps] Set of required capabilities, that chosen runtime must support
	*/
	var dispatches = [
		/**
		Dispatched when runtime is connected and drop zone is ready to accept files.

		@event ready
		@param {Object} event
		*/
		'ready', 

		/**
		Dispatched when dragging cursor enters the drop zone.

		@event dragenter
		@param {Object} event
		*/
		'dragenter',

		/**
		Dispatched when dragging cursor leaves the drop zone.

		@event dragleave
		@param {Object} event
		*/
		'dragleave', 

		/**
		Dispatched when file is dropped onto the drop zone.

		@event drop
		@param {Object} event
		*/
		'drop', 

		/**
		Dispatched if error occurs.

		@event error
		@param {Object} event
		*/
		'error'
	];

	function FileDrop(options) {
		var self = this, defaults;

		// if flat argument passed it should be drop_zone id
		if (typeof(options) === 'string') {
			options = { drop_zone : options };
		}

		// figure out the options
		defaults = {
			accept: [{
				title: I18n.translate('All Files'),
				extensions: '*'
			}],
			required_caps: {
				drag_and_drop: true
			}
		};
		
		options = typeof(options) === 'object' ? Basic.extend({}, defaults, options) : defaults;

		// this will help us to find proper default container
		options.container = Dom.get(options.drop_zone) || document.body;

		// make container relative, if it is not
		if (Dom.getStyle(options.container, 'position') === 'static') {
			options.container.style.position = 'relative';
		}
					
		// normalize accept option (could be list of mime types or array of title/extensions pairs)
		if (typeof(options.accept) === 'string') {
			options.accept = Mime.mimes2extList(options.accept);
		}

		RuntimeClient.call(self);

		Basic.extend(self, {
			uid: Basic.guid('uid_'),

			ruid: null,

			files: null,

			init: function() {
	
				self.convertEventPropsToHandlers(dispatches);
		
				self.bind('RuntimeInit', function(e, runtime) {
					self.ruid = runtime.uid;

					self.bind("Drop", function() {
						var files = runtime.exec.call(self, 'FileDrop', 'getFiles');

						self.files = [];

						Basic.each(files, function(file) {
							self.files.push(new File(self.ruid, file));
						});
					}, 999);

					runtime.exec.call(self, 'FileDrop', 'init', options);

					self.dispatchEvent('ready');
				});
							
				// runtime needs: options.required_features, options.runtime_order and options.container
				self.connectRuntime(options); // throws RuntimeError
			},

			destroy: function() {
				var runtime = this.getRuntime();
				if (runtime) {
					runtime.exec.call(this, 'FileDrop', 'destroy');
					this.disconnectRuntime();
				}
				this.files = null;
			}
		});
	}

	FileDrop.prototype = EventTarget.instance;

	return FileDrop;
});

// Included from: src/javascript/runtime/RuntimeTarget.js

/**
 * RuntimeTarget.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/runtime/RuntimeTarget', [
	'moxie/core/utils/Basic',
	'moxie/runtime/RuntimeClient',
	"moxie/core/EventTarget"
], function(Basic, RuntimeClient, EventTarget) {
	/**
	Instance of this class can be used as a target for the events dispatched by shims,
	when allowing them onto components is for either reason inappropriate

	@class RuntimeTarget
	@constructor
	@protected
	@extends EventTarget
	*/
	function RuntimeTarget() {
		this.uid = Basic.guid('uid_');
		
		RuntimeClient.call(this);

		this.destroy = function() {
			this.disconnectRuntime();
			this.unbindAll();
		};
	}

	RuntimeTarget.prototype = EventTarget.instance;

	return RuntimeTarget;
});

// Included from: src/javascript/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileReader', [
	'moxie/core/utils/Basic',
	'moxie/core/utils/Encode',
	'moxie/core/Exceptions',
	'moxie/core/EventTarget',
	'moxie/file/Blob',
	'moxie/file/File',
	'moxie/runtime/RuntimeTarget'
], function(Basic, Encode, x, EventTarget, Blob, File, RuntimeTarget) {
	/**
	Utility for preloading o.Blob/o.File objects in memory. By design closely follows [W3C FileReader](http://www.w3.org/TR/FileAPI/#dfn-filereader)
	interface. Where possible uses native FileReader, where - not falls back to shims.

	@class FileReader
	@constructor FileReader
	@extends EventTarget
	@uses RuntimeClient
	*/
	var dispatches = [

		/** 
		Dispatched when the read starts.

		@event loadstart
		@param {Object} event
		*/
		'loadstart', 

		/** 
		Dispatched while reading (and decoding) blob, and reporting partial Blob data (progess.loaded/progress.total).

		@event progress
		@param {Object} event
		*/
		'progress', 

		/** 
		Dispatched when the read has successfully completed.

		@event load
		@param {Object} event
		*/
		'load', 

		/** 
		Dispatched when the read has been aborted. For instance, by invoking the abort() method.

		@event abort
		@param {Object} event
		*/
		'abort', 

		/** 
		Dispatched when the read has failed.

		@event error
		@param {Object} event
		*/
		'error', 

		/** 
		Dispatched when the request has completed (either in success or failure).

		@event loadend
		@param {Object} event
		*/
		'loadend'
	];
	
	function FileReader() {
		var self = this, _fr;
				
		Basic.extend(this, {
			/**
			UID of the component instance.

			@property uid
			@type {String}
			*/
			uid: Basic.guid('uid_'),

			/**
			Contains current state of FileReader object. Can take values of FileReader.EMPTY, FileReader.LOADING
			and FileReader.DONE.

			@property readyState
			@type {Number}
			@default FileReader.EMPTY
			*/
			readyState: FileReader.EMPTY,
			
			/**
			Result of the successful read operation.

			@property result
			@type {String}
			*/
			result: null,
			
			/**
			Stores the error of failed asynchronous read operation.

			@property error
			@type {DOMError}
			*/
			error: null,
			
			/**
			Initiates reading of File/Blob object contents to binary string.

			@method readAsBinaryString
			@param {Blob|File} blob Object to preload
			*/
			readAsBinaryString: function(blob) {
				_read.call(this, 'readAsBinaryString', blob);
			},
			
			/**
			Initiates reading of File/Blob object contents to dataURL string.

			@method readAsDataURL
			@param {Blob|File} blob Object to preload
			*/
			readAsDataURL: function(blob) {
				_read.call(this, 'readAsDataURL', blob);
			},
			
			/**
			Initiates reading of File/Blob object contents to string.

			@method readAsText
			@param {Blob|File} blob Object to preload
			*/
			readAsText: function(blob) {
				_read.call(this, 'readAsText', blob);
			},
			
			/**
			Aborts preloading process.

			@method abort
			*/
			abort: function() {
				this.result = null;
				
				if (Basic.inArray(this.readyState, [FileReader.EMPTY, FileReader.DONE]) !== -1) {
					return;
				} else if (this.readyState === FileReader.LOADING) {
					this.readyState = FileReader.DONE;
				}

				if (_fr) {
					_fr.getRuntime().exec.call(this, 'FileReader', 'abort');
				}
				
				this.trigger('abort');
				this.trigger('loadend');
			},

			/**
			Destroy component and release resources.

			@method destroy
			*/
			destroy: function() {
				this.abort();

				if (_fr) {
					_fr.getRuntime().exec.call(this, 'FileReader', 'destroy');
					_fr.disconnectRuntime();
				}

				self = _fr = null;
			}
		});
		
		
		function _read(op, blob) {
			_fr = new RuntimeTarget();

			function error(err) {
				self.readyState = FileReader.DONE;
				self.error = err;
				self.trigger('error');
				loadEnd();
			}

			function loadEnd() {
				_fr.destroy();
				_fr = null;
				self.trigger('loadend');
			}

			function exec(runtime) {
				_fr.bind('Error', function(e, err) {
					error(err);
				});

				_fr.bind('Progress', function(e) {
					self.result = runtime.exec.call(_fr, 'FileReader', 'getResult');
					self.trigger(e);
				});
				
				_fr.bind('Load', function(e) {
					self.readyState = FileReader.DONE;
					self.result = runtime.exec.call(_fr, 'FileReader', 'getResult');
					self.trigger(e);
					loadEnd();
				});

				runtime.exec.call(_fr, 'FileReader', 'read', op, blob);
			}

			this.convertEventPropsToHandlers(dispatches);

			if (this.readyState === FileReader.LOADING) {
				return error(new x.DOMException(x.DOMException.INVALID_STATE_ERR));
			}

			this.readyState = FileReader.LOADING;
			this.trigger('loadstart');

			// if source is o.Blob/o.File
			if (blob instanceof Blob) {
				if (blob.isDetached()) {
					var src = blob.getSource();
					switch (op) {
						case 'readAsText':
						case 'readAsBinaryString':
							this.result = src;
							break;
						case 'readAsDataURL':
							this.result = 'data:' + blob.type + ';base64,' + Encode.btoa(src);
							break;
					}
					this.readyState = FileReader.DONE;
					this.trigger('load');
					loadEnd();
				} else {
					exec(_fr.connectRuntime(blob.ruid));
				}
			} else {
				error(new x.DOMException(x.DOMException.NOT_FOUND_ERR));
			}
		}
	}
	
	/**
	Initial FileReader state

	@property EMPTY
	@type {Number}
	@final
	@static
	@default 0
	*/
	FileReader.EMPTY = 0;

	/**
	FileReader switches to this state when it is preloading the source

	@property LOADING
	@type {Number}
	@final
	@static
	@default 1
	*/
	FileReader.LOADING = 1;

	/**
	Preloading is complete, this is a final state

	@property DONE
	@type {Number}
	@final
	@static
	@default 2
	*/
	FileReader.DONE = 2;

	FileReader.prototype = EventTarget.instance;

	return FileReader;
});

// Included from: src/javascript/core/utils/Url.js

/**
 * Url.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Url', [], function() {
	/**
	Parse url into separate components and fill in absent parts with parts from current url,
	based on https://raw.github.com/kvz/phpjs/master/functions/url/parse_url.js

	@method parseUrl
	@for Utils
	@static
	@param {String} url Url to parse (defaults to empty string if undefined)
	@return {Object} Hash containing extracted uri components
	*/
	var parseUrl = function(url, currentUrl) {
		var key = ['source', 'scheme', 'authority', 'userInfo', 'user', 'pass', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'fragment']
		, i = key.length
		, ports = {
			http: 80,
			https: 443
		}
		, uri = {}
		, regex = /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/
		, m = regex.exec(url || '')
		;
					
		while (i--) {
			if (m[i]) {
				uri[key[i]] = m[i];
			}
		}

		// when url is relative, we set the origin and the path ourselves
		if (!uri.scheme) {
			// come up with defaults
			if (!currentUrl || typeof(currentUrl) === 'string') {
				currentUrl = parseUrl(currentUrl || document.location.href);
			}

			uri.scheme = currentUrl.scheme;
			uri.host = currentUrl.host;
			uri.port = currentUrl.port;

			var path = '';
			// for urls without trailing slash we need to figure out the path
			if (/^[^\/]/.test(uri.path)) {
				path = currentUrl.path;
				// if path ends with a filename, strip it
				if (!/(\/|\/[^\.]+)$/.test(path)) {
					path = path.replace(/\/[^\/]+$/, '/');
				} else {
					path += '/';
				}
			}
			uri.path = path + (uri.path || ''); // site may reside at domain.com or domain.com/subdir
		}

		if (!uri.port) {
			uri.port = ports[uri.scheme] || 80;
		} 
		
		uri.port = parseInt(uri.port, 10);

		if (!uri.path) {
			uri.path = "/";
		}

		delete uri.source;

		return uri;
	};

	/**
	Resolve url - among other things will turn relative url to absolute

	@method resolveUrl
	@static
	@param {String} url Either absolute or relative
	@return {String} Resolved, absolute url
	*/
	var resolveUrl = function(url) {
		var ports = { // we ignore default ports
			http: 80,
			https: 443
		}
		, urlp = parseUrl(url)
		;

		return urlp.scheme + '://' + urlp.host + (urlp.port !== ports[urlp.scheme] ? ':' + urlp.port : '') + urlp.path + (urlp.query ? urlp.query : '');
	};

	/**
	Check if specified url has the same origin as the current document

	@method hasSameOrigin
	@param {String|Object} url
	@return {Boolean}
	*/
	var hasSameOrigin = function(url) {
		function origin(url) {
			return [url.scheme, url.host, url.port].join('/');
		}
			
		if (typeof url === 'string') {
			url = parseUrl(url);
		}	
		
		return origin(parseUrl()) === origin(url);
	};

	return {
		parseUrl: parseUrl,
		resolveUrl: resolveUrl,
		hasSameOrigin: hasSameOrigin
	};
});

// Included from: src/javascript/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/file/FileReaderSync', [
	'moxie/core/utils/Basic',
	'moxie/runtime/RuntimeClient',
	'moxie/core/utils/Encode'
], function(Basic, RuntimeClient, Encode) {
	/**
	Synchronous FileReader implementation. Something like this is available in WebWorkers environment, here
	it can be used to read only preloaded blobs/files and only below certain size (not yet sure what that'd be,
	but probably < 1mb). Not meant to be used directly by user.

	@class FileReaderSync
	@private
	@constructor
	*/
	return function() {
		RuntimeClient.call(this);

		Basic.extend(this, {
			uid: Basic.guid('uid_'),

			readAsBinaryString: function(blob) {
				return _read.call(this, 'readAsBinaryString', blob);
			},
			
			readAsDataURL: function(blob) {
				return _read.call(this, 'readAsDataURL', blob);
			},
			
			/*readAsArrayBuffer: function(blob) {
				return _read.call(this, 'readAsArrayBuffer', blob);
			},*/
			
			readAsText: function(blob) {
				return _read.call(this, 'readAsText', blob);
			}
		});

		function _read(op, blob) {
			if (blob.isDetached()) {
				var src = blob.getSource();
				switch (op) {
					case 'readAsBinaryString':
						return src;
					case 'readAsDataURL':
						return 'data:' + blob.type + ';base64,' + Encode.btoa(src);
					case 'readAsText':
						var txt = '';
						for (var i = 0, length = src.length; i < length; i++) {
							txt += String.fromCharCode(src[i]);
						}
						return txt;
				}
			} else {
				var result = this.connectRuntime(blob.ruid).exec.call(this, 'FileReaderSync', 'read', op, blob);
				this.disconnectRuntime();
				return result;
			}
		}
	};
});

// Included from: src/javascript/xhr/FormData.js

/**
 * FormData.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/xhr/FormData", [
	"moxie/core/Exceptions",
	"moxie/core/utils/Basic",
	"moxie/file/Blob"
], function(x, Basic, Blob) {
	/**
	FormData

	@class FormData
	@constructor
	*/
	function FormData() {
		var _blob, _fields = [];

		Basic.extend(this, {
			/**
			Append another key-value pair to the FormData object

			@method append
			@param {String} name Name for the new field
			@param {String|Blob|Array|Object} value Value for the field
			*/
			append: function(name, value) {
				var self = this, valueType = Basic.typeOf(value);

				// according to specs value might be either Blob or String
				if (value instanceof Blob) {
					_blob = {
						name: name,
						value: value // unfortunately we can only send single Blob in one FormData
					};
				} else if ('array' === valueType) {
					name += '[]';

					Basic.each(value, function(value) {
						self.append(name, value);
					});
				} else if ('object' === valueType) {
					Basic.each(value, function(value, key) {
						self.append(name + '[' + key + ']', value);
					});
				} else if ('null' === valueType || 'undefined' === valueType || 'number' === valueType && isNaN(value)) {
					self.append(name, "false");
				} else {
					_fields.push({
						name: name,
						value: value.toString()
					});
				}
			},

			/**
			Checks if FormData contains Blob.

			@method hasBlob
			@return {Boolean}
			*/
			hasBlob: function() {
				return !!this.getBlob();
			},

			/**
			Retrieves blob.

			@method getBlob
			@return {Object} Either Blob if found or null
			*/
			getBlob: function() {
				return _blob && _blob.value || null;
			},

			/**
			Retrieves blob field name.

			@method getBlobName
			@return {String} Either Blob field name or null
			*/
			getBlobName: function() {
				return _blob && _blob.name || null;
			},

			/**
			Loop over the fields in FormData and invoke the callback for each of them.

			@method each
			@param {Function} cb Callback to call for each field
			*/
			each: function(cb) {
				Basic.each(_fields, function(field) {
					cb(field.value, field.name);
				});

				if (_blob) {
					cb(_blob.value, _blob.name);
				}
			},

			destroy: function() {
				_blob = null;
				_fields = [];
			}
		});
	}

	return FormData;
});

// Included from: src/javascript/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/xhr/XMLHttpRequest", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/core/EventTarget",
	"moxie/core/utils/Encode",
	"moxie/core/utils/Url",
	"moxie/runtime/Runtime",
	"moxie/runtime/RuntimeTarget",
	"moxie/file/Blob",
	"moxie/file/FileReaderSync",
	"moxie/xhr/FormData",
	"moxie/core/utils/Env",
	"moxie/core/utils/Mime"
], function(Basic, x, EventTarget, Encode, Url, Runtime, RuntimeTarget, Blob, FileReaderSync, FormData, Env, Mime) {

	var httpCode = {
		100: 'Continue',
		101: 'Switching Protocols',
		102: 'Processing',

		200: 'OK',
		201: 'Created',
		202: 'Accepted',
		203: 'Non-Authoritative Information',
		204: 'No Content',
		205: 'Reset Content',
		206: 'Partial Content',
		207: 'Multi-Status',
		226: 'IM Used',

		300: 'Multiple Choices',
		301: 'Moved Permanently',
		302: 'Found',
		303: 'See Other',
		304: 'Not Modified',
		305: 'Use Proxy',
		306: 'Reserved',
		307: 'Temporary Redirect',

		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Timeout',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Request Entity Too Large',
		414: 'Request-URI Too Long',
		415: 'Unsupported Media Type',
		416: 'Requested Range Not Satisfiable',
		417: 'Expectation Failed',
		422: 'Unprocessable Entity',
		423: 'Locked',
		424: 'Failed Dependency',
		426: 'Upgrade Required',

		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Timeout',
		505: 'HTTP Version Not Supported',
		506: 'Variant Also Negotiates',
		507: 'Insufficient Storage',
		510: 'Not Extended'
	};

	function XMLHttpRequestUpload() {
		this.uid = Basic.guid('uid_');
	}
	
	XMLHttpRequestUpload.prototype = EventTarget.instance;

	/**
	Implementation of XMLHttpRequest

	@class XMLHttpRequest
	@constructor
	@uses RuntimeClient
	@extends EventTarget
	*/
	var dispatches = ['loadstart', 'progress', 'abort', 'error', 'load', 'timeout', 'loadend']; // & readystatechange (for historical reasons)
	
	var NATIVE = 1, RUNTIME = 2;
					
	function XMLHttpRequest() {
		var self = this,
			// this (together with _p() @see below) is here to gracefully upgrade to setter/getter syntax where possible
			props = {
				/**
				The amount of milliseconds a request can take before being terminated. Initially zero. Zero means there is no timeout.

				@property timeout
				@type Number
				@default 0
				*/
				timeout: 0,

				/**
				Current state, can take following values:
				UNSENT (numeric value 0)
				The object has been constructed.

				OPENED (numeric value 1)
				The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the request can be made using the send() method.

				HEADERS_RECEIVED (numeric value 2)
				All redirects (if any) have been followed and all HTTP headers of the final response have been received. Several response members of the object are now available.

				LOADING (numeric value 3)
				The response entity body is being received.

				DONE (numeric value 4)

				@property readyState
				@type Number
				@default 0 (UNSENT)
				*/
				readyState: XMLHttpRequest.UNSENT,

				/**
				True when user credentials are to be included in a cross-origin request. False when they are to be excluded
				in a cross-origin request and when cookies are to be ignored in its response. Initially false.

				@property withCredentials
				@type Boolean
				@default false
				*/
				withCredentials: false,

				/**
				Returns the HTTP status code.

				@property status
				@type Number
				@default 0
				*/
				status: 0,

				/**
				Returns the HTTP status text.

				@property statusText
				@type String
				*/
				statusText: "",

				/**
				Returns the response type. Can be set to change the response type. Values are:
				the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
				
				@property responseType
				@type String
				*/
				responseType: "",

				/**
				Returns the document response entity body.
				
				Throws an "InvalidStateError" exception if responseType is not the empty string or "document".

				@property responseXML
				@type Document
				*/
				responseXML: null,

				/**
				Returns the text response entity body.
				
				Throws an "InvalidStateError" exception if responseType is not the empty string or "text".

				@property responseText
				@type String
				*/
				responseText: null,

				/**
				Returns the response entity body (http://www.w3.org/TR/XMLHttpRequest/#response-entity-body).
				Can become: ArrayBuffer, Blob, Document, JSON, Text
				
				@property response
				@type Mixed
				*/
				response: null
			},

			_async = true,
			_url,
			_method,
			_headers = {},
			_user,
			_password,
			_encoding = null,
			_mimeType = null,

			// flags
			_sync_flag = false,
			_send_flag = false,
			_upload_events_flag = false,
			_upload_complete_flag = false,
			_error_flag = false,
			_same_origin_flag = false,

			// times
			_start_time,
			_timeoutset_time,

			_finalMime = null,
			_finalCharset = null,

			_options = {},
			_xhr,
			_responseHeaders = '',
			_responseHeadersBag
			;

		
		Basic.extend(this, props, {
			/**
			Unique id of the component

			@property uid
			@type String
			*/
			uid: Basic.guid('uid_'),
			
			/**
			Target for Upload events

			@property upload
			@type XMLHttpRequestUpload
			*/
			upload: new XMLHttpRequestUpload(),
			

			/**
			Sets the request method, request URL, synchronous flag, request username, and request password.

			Throws a "SyntaxError" exception if one of the following is true:

			method is not a valid HTTP method.
			url cannot be resolved.
			url contains the "user:password" format in the userinfo production.
			Throws a "SecurityError" exception if method is a case-insensitive match for CONNECT, TRACE or TRACK.

			Throws an "InvalidAccessError" exception if one of the following is true:

			Either user or password is passed as argument and the origin of url does not match the XMLHttpRequest origin.
			There is an associated XMLHttpRequest document and either the timeout attribute is not zero,
			the withCredentials attribute is true, or the responseType attribute is not the empty string.


			@method open
			@param {String} method HTTP method to use on request
			@param {String} url URL to request
			@param {Boolean} [async=true] If false request will be done in synchronous manner. Asynchronous by default.
			@param {String} [user] Username to use in HTTP authentication process on server-side
			@param {String} [password] Password to use in HTTP authentication process on server-side
			*/
			open: function(method, url, async, user, password) {
				var urlp;
				
				// first two arguments are required
				if (!method || !url) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}
				
				// 2 - check if any code point in method is higher than U+00FF or after deflating method it does not match the method
				if (/[\u0100-\uffff]/.test(method) || Encode.utf8_encode(method) !== method) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 3
				if (!!~Basic.inArray(method.toUpperCase(), ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'])) {
					_method = method.toUpperCase();
				}
				
				
				// 4 - allowing these methods poses a security risk
				if (!!~Basic.inArray(_method, ['CONNECT', 'TRACE', 'TRACK'])) {
					throw new x.DOMException(x.DOMException.SECURITY_ERR);
				}

				// 5
				url = Encode.utf8_encode(url);
				
				// 6 - Resolve url relative to the XMLHttpRequest base URL. If the algorithm returns an error, throw a "SyntaxError".
				urlp = Url.parseUrl(url);

				_same_origin_flag = Url.hasSameOrigin(urlp);
																
				// 7 - manually build up absolute url
				_url = Url.resolveUrl(url);
		
				// 9-10, 12-13
				if ((user || password) && !_same_origin_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				_user = user || urlp.user;
				_password = password || urlp.pass;
				
				// 11
				_async = async || true;
				
				if (_async === false && (_p('timeout') || _p('withCredentials') || _p('responseType') !== "")) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}
				
				// 14 - terminate abort()
				
				// 15 - terminate send()

				// 18
				_sync_flag = !_async;
				_send_flag = false;
				_headers = {};
				_reset.call(this);

				// 19
				_p('readyState', XMLHttpRequest.OPENED);
				
				// 20
				this.convertEventPropsToHandlers(['readystatechange']); // unify event handlers
				this.dispatchEvent('readystatechange');
			},
			
			/**
			Appends an header to the list of author request headers, or if header is already
			in the list of author request headers, combines its value with value.

			Throws an "InvalidStateError" exception if the state is not OPENED or if the send() flag is set.
			Throws a "SyntaxError" exception if header is not a valid HTTP header field name or if value
			is not a valid HTTP header field value.
			
			@method setRequestHeader
			@param {String} header
			@param {String|Number} value
			*/
			setRequestHeader: function(header, value) {
				var uaHeaders = [ // these headers are controlled by the user agent
						"accept-charset",
						"accept-encoding",
						"access-control-request-headers",
						"access-control-request-method",
						"connection",
						"content-length",
						"cookie",
						"cookie2",
						"content-transfer-encoding",
						"date",
						"expect",
						"host",
						"keep-alive",
						"origin",
						"referer",
						"te",
						"trailer",
						"transfer-encoding",
						"upgrade",
						"user-agent",
						"via"
					];
				
				// 1-2
				if (_p('readyState') !== XMLHttpRequest.OPENED || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3
				if (/[\u0100-\uffff]/.test(header) || Encode.utf8_encode(header) !== header) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 4
				/* this step is seemingly bypassed in browsers, probably to allow various unicode characters in header values
				if (/[\u0100-\uffff]/.test(value) || Encode.utf8_encode(value) !== value) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}*/

				header = Basic.trim(header).toLowerCase();
				
				// setting of proxy-* and sec-* headers is prohibited by spec
				if (!!~Basic.inArray(header, uaHeaders) || /^(proxy\-|sec\-)/.test(header)) {
					return false;
				}

				// camelize
				// browsers lowercase header names (at least for custom ones)
				// header = header.replace(/\b\w/g, function($1) { return $1.toUpperCase(); });
				
				if (!_headers[header]) {
					_headers[header] = value;
				} else {
					// http://tools.ietf.org/html/rfc2616#section-4.2 (last paragraph)
					_headers[header] += ', ' + value;
				}
				return true;
			},

			/**
			Returns all headers from the response, with the exception of those whose field name is Set-Cookie or Set-Cookie2.

			@method getAllResponseHeaders
			@return {String} reponse headers or empty string
			*/
			getAllResponseHeaders: function() {
				return _responseHeaders || '';
			},

			/**
			Returns the header field value from the response of which the field name matches header, 
			unless the field name is Set-Cookie or Set-Cookie2.

			@method getResponseHeader
			@param {String} header
			@return {String} value(s) for the specified header or null
			*/
			getResponseHeader: function(header) {
				header = header.toLowerCase();

				if (_error_flag || !!~Basic.inArray(header, ['set-cookie', 'set-cookie2'])) {
					return null;
				}

				if (_responseHeaders && _responseHeaders !== '') {
					// if we didn't parse response headers until now, do it and keep for later
					if (!_responseHeadersBag) {
						_responseHeadersBag = {};
						Basic.each(_responseHeaders.split(/\r\n/), function(line) {
							var pair = line.split(/:\s+/);
							if (pair.length === 2) { // last line might be empty, omit
								pair[0] = Basic.trim(pair[0]); // just in case
								_responseHeadersBag[pair[0].toLowerCase()] = { // simply to retain header name in original form
									header: pair[0],
									value: Basic.trim(pair[1])
								};
							}
						});
					}
					if (_responseHeadersBag.hasOwnProperty(header)) {
						return _responseHeadersBag[header].header + ': ' + _responseHeadersBag[header].value;
					}
				}
				return null;
			},
			
			/**
			Sets the Content-Type header for the response to mime.
			Throws an "InvalidStateError" exception if the state is LOADING or DONE.
			Throws a "SyntaxError" exception if mime is not a valid media type.

			@method overrideMimeType
			@param String mime Mime type to set
			*/
			overrideMimeType: function(mime) {
				var matches, charset;
			
				// 1
				if (!!~Basic.inArray(_p('readyState'), [XMLHttpRequest.LOADING, XMLHttpRequest.DONE])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2
				mime = Basic.trim(mime.toLowerCase());

				if (/;/.test(mime) && (matches = mime.match(/^([^;]+)(?:;\scharset\=)?(.*)$/))) {
					mime = matches[1];
					if (matches[2]) {
						charset = matches[2];
					}
				}

				if (!Mime.mimes[mime]) {
					throw new x.DOMException(x.DOMException.SYNTAX_ERR);
				}

				// 3-4
				_finalMime = mime;
				_finalCharset = charset;
			},
			
			/**
			Initiates the request. The optional argument provides the request entity body.
			The argument is ignored if request method is GET or HEAD.

			Throws an "InvalidStateError" exception if the state is not OPENED or if the send() flag is set.

			@method send
			@param {Blob|Document|String|FormData} [data] Request entity body
			@param {Object} [options] Set of requirements and pre-requisities for runtime initialization
			*/
			send: function(data, options) {					
				if (Basic.typeOf(options) === 'string') {
					_options = { ruid: options };
				} else if (!options) {
					_options = {};
				} else {
					_options = options;
				}
													
				this.convertEventPropsToHandlers(dispatches);
				this.upload.convertEventPropsToHandlers(dispatches);
															
				// 1-2
				if (this.readyState !== XMLHttpRequest.OPENED || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}
				
				// 3					
				// sending Blob
				if (data instanceof Blob) {
					_options.ruid = data.ruid;
					_mimeType = data.type || 'application/octet-stream';
				}
				
				// FormData
				else if (data instanceof FormData) {
					if (data.hasBlob()) {
						var blob = data.getBlob();
						_options.ruid = blob.ruid;
						_mimeType = blob.type || 'application/octet-stream';
					}
				}
				
				// DOMString
				else if (typeof data === 'string') {
					_encoding = 'UTF-8';
					_mimeType = 'text/plain;charset=UTF-8';
					
					// data should be converted to Unicode and encoded as UTF-8
					data = Encode.utf8_encode(data);
				}

				// if withCredentials not set, but requested, set it automatically
				if (!this.withCredentials) {
					this.withCredentials = (_options.required_caps && _options.required_caps.send_browser_cookies) && !_same_origin_flag;
				}

				// 4 - storage mutex
				// 5
				_upload_events_flag = (!_sync_flag && this.upload.hasEventListener()); // DSAP
				// 6
				_error_flag = false;
				// 7
				_upload_complete_flag = !data;
				// 8 - Asynchronous steps
				if (!_sync_flag) {
					// 8.1
					_send_flag = true;
					// 8.2
					// this.dispatchEvent('loadstart'); // will be dispatched either by native or runtime xhr
					// 8.3
					//if (!_upload_complete_flag) {
						// this.upload.dispatchEvent('loadstart');	// will be dispatched either by native or runtime xhr
					//}
				}
				// 8.5 - Return the send() method call, but continue running the steps in this algorithm.
				_doXHR.call(this, data);
			},
			
			/**
			Cancels any network activity.
			
			@method abort
			*/
			abort: function() {
				_error_flag = true;
				_sync_flag = false;

				if (!~Basic.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED, XMLHttpRequest.DONE])) {
					_p('readyState', XMLHttpRequest.DONE);
					_send_flag = false;

					if (_xhr) {
						_xhr.getRuntime().exec.call(_xhr, 'XMLHttpRequest', 'abort', _upload_complete_flag);
					} else {
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}

					_upload_complete_flag = true;
				} else {
					_p('readyState', XMLHttpRequest.UNSENT);
				}
			},

			destroy: function() {
				if (_xhr) {
					if (Basic.typeOf(_xhr.destroy) === 'function') {
						_xhr.destroy();
					}
					_xhr = null;
				}

				this.unbindAll();

				if (this.upload) {
					this.upload.unbindAll();
					this.upload = null;
				}
			}
		});

		/* this is nice, but maybe too lengthy

		// if supported by JS version, set getters/setters for specific properties
		o.defineProperty(this, 'readyState', {
			configurable: false,

			get: function() {
				return _p('readyState');
			}
		});

		o.defineProperty(this, 'timeout', {
			configurable: false,

			get: function() {
				return _p('timeout');
			},

			set: function(value) {

				if (_sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// timeout still should be measured relative to the start time of request
				_timeoutset_time = (new Date).getTime();

				_p('timeout', value);
			}
		});

		// the withCredentials attribute has no effect when fetching same-origin resources
		o.defineProperty(this, 'withCredentials', {
			configurable: false,

			get: function() {
				return _p('withCredentials');
			},

			set: function(value) {
				// 1-2
				if (!~o.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED]) || _send_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 3-4
				if (_anonymous_flag || _sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 5
				_p('withCredentials', value);
			}
		});

		o.defineProperty(this, 'status', {
			configurable: false,

			get: function() {
				return _p('status');
			}
		});

		o.defineProperty(this, 'statusText', {
			configurable: false,

			get: function() {
				return _p('statusText');
			}
		});

		o.defineProperty(this, 'responseType', {
			configurable: false,

			get: function() {
				return _p('responseType');
			},

			set: function(value) {
				// 1
				if (!!~o.inArray(_p('readyState'), [XMLHttpRequest.LOADING, XMLHttpRequest.DONE])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2
				if (_sync_flag) {
					throw new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);
				}

				// 3
				_p('responseType', value.toLowerCase());
			}
		});

		o.defineProperty(this, 'responseText', {
			configurable: false,

			get: function() {
				// 1
				if (!~o.inArray(_p('responseType'), ['', 'text'])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2-3
				if (_p('readyState') !== XMLHttpRequest.DONE && _p('readyState') !== XMLHttpRequest.LOADING || _error_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				return _p('responseText');
			}
		});

		o.defineProperty(this, 'responseXML', {
			configurable: false,

			get: function() {
				// 1
				if (!~o.inArray(_p('responseType'), ['', 'document'])) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				// 2-3
				if (_p('readyState') !== XMLHttpRequest.DONE || _error_flag) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				return _p('responseXML');
			}
		});

		o.defineProperty(this, 'response', {
			configurable: false,

			get: function() {
				if (!!~o.inArray(_p('responseType'), ['', 'text'])) {
					if (_p('readyState') !== XMLHttpRequest.DONE && _p('readyState') !== XMLHttpRequest.LOADING || _error_flag) {
						return '';
					}
				}

				if (_p('readyState') !== XMLHttpRequest.DONE || _error_flag) {
					return null;
				}

				return _p('response');
			}
		});

		*/

		function _p(prop, value) {
			if (!props.hasOwnProperty(prop)) {
				return;
			}
			if (arguments.length === 1) { // get
				return Env.can('define_property') ? props[prop] : self[prop];
			} else { // set
				if (Env.can('define_property')) {
					props[prop] = value;
				} else {
					self[prop] = value;
				}
			}
		}
		
		/*
		function _toASCII(str, AllowUnassigned, UseSTD3ASCIIRules) {
			// TODO: http://tools.ietf.org/html/rfc3490#section-4.1
			return str.toLowerCase();
		}
		*/
		
		
		function _doXHR(data) {
			var self = this;
			
			_start_time = new Date().getTime();

			_xhr = new RuntimeTarget();

			function loadEnd() {
				_xhr.destroy();
				_xhr = null;
				self.dispatchEvent('loadend');
				self = null;
			}

			function exec(runtime) {
				_xhr.bind('LoadStart', function(e) {
					_p('readyState', XMLHttpRequest.LOADING);
					self.dispatchEvent('readystatechange');

					self.dispatchEvent(e);
					
					if (_upload_events_flag) {
						self.upload.dispatchEvent(e);
					}
				});
				
				_xhr.bind('Progress', function(e) {
					if (_p('readyState') !== XMLHttpRequest.LOADING) {
						_p('readyState', XMLHttpRequest.LOADING); // LoadStart unreliable (in Flash for example)
						self.dispatchEvent('readystatechange');
					}
					self.dispatchEvent(e);
				});
				
				_xhr.bind('UploadProgress', function(e) {
					if (_upload_events_flag) {
						self.upload.dispatchEvent({
							type: 'progress',
							lengthComputable: false,
							total: e.total,
							loaded: e.loaded
						});
					}
				});
				
				_xhr.bind('Load', function(e) {
					_p('readyState', XMLHttpRequest.DONE);
					_p('status', Number(runtime.exec.call(_xhr, 'XMLHttpRequest', 'getStatus') || 0));
					_p('statusText', httpCode[_p('status')] || "");
					
					_p('response', runtime.exec.call(_xhr, 'XMLHttpRequest', 'getResponse', _p('responseType')));

					if (!!~Basic.inArray(_p('responseType'), ['text', ''])) {
						_p('responseText', _p('response'));
					} else if (_p('responseType') === 'document') {
						_p('responseXML', _p('response'));
					}

					_responseHeaders = runtime.exec.call(_xhr, 'XMLHttpRequest', 'getAllResponseHeaders');

					self.dispatchEvent('readystatechange');
					
					if (_p('status') > 0) { // status 0 usually means that server is unreachable
						if (_upload_events_flag) {
							self.upload.dispatchEvent(e);
						}
						self.dispatchEvent(e);
					} else {
						_error_flag = true;
						self.dispatchEvent('error');
					}
					loadEnd();
				});

				_xhr.bind('Abort', function(e) {
					self.dispatchEvent(e);
					loadEnd();
				});
				
				_xhr.bind('Error', function(e) {
					_error_flag = true;
					_p('readyState', XMLHttpRequest.DONE);
					self.dispatchEvent('readystatechange');
					_upload_complete_flag = true;
					self.dispatchEvent(e);
					loadEnd();
				});

				runtime.exec.call(_xhr, 'XMLHttpRequest', 'send', {
					url: _url,
					method: _method,
					async: _async,
					user: _user,
					password: _password,
					headers: _headers,
					mimeType: _mimeType,
					encoding: _encoding,
					responseType: self.responseType,
					withCredentials: self.withCredentials,
					options: _options
				}, data);
			}

			// clarify our requirements
			if (typeof(_options.required_caps) === 'string') {
				_options.required_caps = Runtime.parseCaps(_options.required_caps);
			}

			_options.required_caps = Basic.extend({}, _options.required_caps, {
				return_response_type: self.responseType
			});

			if (data instanceof FormData) {
				_options.required_caps.send_multipart = true;
			}

			if (!_same_origin_flag) {
				_options.required_caps.do_cors = true;
			}
			

			if (_options.ruid) { // we do not need to wait if we can connect directly
				exec(_xhr.connectRuntime(_options));
			} else {
				_xhr.bind('RuntimeInit', function(e, runtime) {
					exec(runtime);
				});
				_xhr.bind('RuntimeError', function(e, err) {
					self.dispatchEvent('RuntimeError', err);
				});
				_xhr.connectRuntime(_options);
			}
		}
	
		
		function _reset() {
			_p('responseText', "");
			_p('responseXML', null);
			_p('response', null);
			_p('status', 0);
			_p('statusText', "");
			_start_time = _timeoutset_time = null;
		}
	}

	XMLHttpRequest.UNSENT = 0;
	XMLHttpRequest.OPENED = 1;
	XMLHttpRequest.HEADERS_RECEIVED = 2;
	XMLHttpRequest.LOADING = 3;
	XMLHttpRequest.DONE = 4;
	
	XMLHttpRequest.prototype = EventTarget.instance;

	return XMLHttpRequest;
});

// Included from: src/javascript/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/runtime/Transporter", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Encode",
	"moxie/runtime/RuntimeClient",
	"moxie/core/EventTarget"
], function(Basic, Encode, RuntimeClient, EventTarget) {
	function Transporter() {
		var mod, _runtime, _data, _size, _pos, _chunk_size;

		RuntimeClient.call(this);

		Basic.extend(this, {
			uid: Basic.guid('uid_'),

			state: Transporter.IDLE,

			result: null,

			transport: function(data, type, options) {
				var self = this;

				options = Basic.extend({
					chunk_size: 204798
				}, options);

				// should divide by three, base64 requires this
				if ((mod = options.chunk_size % 3)) {
					options.chunk_size += 3 - mod;
				}

				_chunk_size = options.chunk_size;

				_reset.call(this);
				_data = data;
				_size = data.length;

				if (Basic.typeOf(options) === 'string' || options.ruid) {
					_run.call(self, type, this.connectRuntime(options));
				} else {
					// we require this to run only once
					var cb = function(e, runtime) {
						self.unbind("RuntimeInit", cb);
						_run.call(self, type, runtime);
					};
					this.bind("RuntimeInit", cb);
					this.connectRuntime(options);
				}
			},

			abort: function() {
				var self = this;

				self.state = Transporter.IDLE;
				if (_runtime) {
					_runtime.exec.call(self, 'Transporter', 'clear');
					self.trigger("TransportingAborted");
				}

				_reset.call(self);
			},


			destroy: function() {
				this.unbindAll();
				_runtime = null;
				this.disconnectRuntime();
				_reset.call(this);
			}
		});

		function _reset() {
			_size = _pos = 0;
			_data = this.result = null;
		}

		function _run(type, runtime) {
			var self = this;

			_runtime = runtime;

			//self.unbind("RuntimeInit");

			self.bind("TransportingProgress", function(e) {
				_pos = e.loaded;

				if (_pos < _size && Basic.inArray(self.state, [Transporter.IDLE, Transporter.DONE]) === -1) {
					_transport.call(self);
				}
			}, 999);

			self.bind("TransportingComplete", function() {
				_pos = _size;
				self.state = Transporter.DONE;
				_data = null; // clean a bit
				self.result = _runtime.exec.call(self, 'Transporter', 'getAsBlob', type || '');
			}, 999);

			self.state = Transporter.BUSY;
			self.trigger("TransportingStarted");
			_transport.call(self);
		}

		function _transport() {
			var self = this,
				chunk,
				bytesLeft = _size - _pos;

			if (_chunk_size > bytesLeft) {
				_chunk_size = bytesLeft;
			}

			chunk = Encode.btoa(_data.substr(_pos, _chunk_size));
			_runtime.exec.call(self, 'Transporter', 'receive', chunk, _size);
		}
	}

	Transporter.IDLE = 0;
	Transporter.BUSY = 1;
	Transporter.DONE = 2;

	Transporter.prototype = EventTarget.instance;

	return Transporter;
});

// Included from: src/javascript/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define("moxie/image/Image", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/file/FileReaderSync",
	"moxie/xhr/XMLHttpRequest",
	"moxie/runtime/Runtime",
	"moxie/runtime/RuntimeClient",
	"moxie/runtime/Transporter",
	"moxie/core/utils/Env",
	"moxie/core/EventTarget",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/core/utils/Encode"
], function(Basic, Dom, x, FileReaderSync, XMLHttpRequest, Runtime, RuntimeClient, Transporter, Env, EventTarget, Blob, File, Encode) {
	/**
	Image preloading and manipulation utility. Additionally it provides access to image meta info (Exif, GPS) and raw binary data.

	@class Image
	@constructor
	@extends EventTarget
	*/
	var dispatches = [
		'progress',

		/**
		Dispatched when loading is complete.

		@event load
		@param {Object} event
		*/
		'load',

		'error',

		/**
		Dispatched when resize operation is complete.
		
		@event resize
		@param {Object} event
		*/
		'resize',

		/**
		Dispatched when visual representation of the image is successfully embedded
		into the corresponsing container.

		@event embedded
		@param {Object} event
		*/
		'embedded'
	];

	function Image() {
		RuntimeClient.call(this);

		Basic.extend(this, {
			/**
			Unique id of the component

			@property uid
			@type {String}
			*/
			uid: Basic.guid('uid_'),

			/**
			Unique id of the connected runtime, if any.

			@property ruid
			@type {String}
			*/
			ruid: null,

			/**
			Name of the file, that was used to create an image, if available. If not equals to empty string.

			@property name
			@type {String}
			@default ""
			*/
			name: "",

			/**
			Size of the image in bytes. Actual value is set only after image is preloaded.

			@property size
			@type {Number}
			@default 0
			*/
			size: 0,

			/**
			Width of the image. Actual value is set only after image is preloaded.

			@property width
			@type {Number}
			@default 0
			*/
			width: 0,

			/**
			Height of the image. Actual value is set only after image is preloaded.

			@property height
			@type {Number}
			@default 0
			*/
			height: 0,

			/**
			Mime type of the image. Currently only image/jpeg and image/png are supported. Actual value is set only after image is preloaded.

			@property type
			@type {String}
			@default ""
			*/
			type: "",

			/**
			Holds meta info (Exif, GPS). Is populated only for image/jpeg. Actual value is set only after image is preloaded.

			@property meta
			@type {Object}
			@default {}
			*/
			meta: {},

			/**
			Alias for load method, that takes another mOxie.Image object as a source (see load).

			@method clone
			@param {Image} src Source for the image
			@param {Boolean} [exact=false] Whether to activate in-depth clone mode
			*/
			clone: function() {
				this.load.apply(this, arguments);
			},

			/**
			Loads image from various sources. Currently the source for new image can be: mOxie.Image, mOxie.Blob/mOxie.File, 
			native Blob/File, dataUrl or URL. Depending on the type of the source, arguments - differ. When source is URL, 
			Image will be downloaded from remote destination and loaded in memory.

			@example
				var img = new mOxie.Image();
				img.onload = function() {
					var blob = img.getAsBlob();
					
					var formData = new mOxie.FormData();
					formData.append('file', blob);

					var xhr = new mOxie.XMLHttpRequest();
					xhr.onload = function() {
						// upload complete
					};
					xhr.open('post', 'upload.php');
					xhr.send(formData);
				};
				img.load("http://www.moxiecode.com/images/mox-logo.jpg"); // notice file extension (.jpg)
			

			@method load
			@param {Image|Blob|File|String} src Source for the image
			@param {Boolean|Object} [mixed]
			*/
			load: function() {
				// this is here because to bind properly we need an uid first, which is created above
				this.bind('Load Resize', function() {
					_updateInfo.call(this);
				}, 999);

				this.convertEventPropsToHandlers(dispatches);

				_load.apply(this, arguments);
			},

			/**
			Downsizes the image to fit the specified width/height. If crop is supplied, image will be cropped to exact dimensions.

			@method downsize
			@param {Number} width Resulting width
			@param {Number} [height=width] Resulting height (optional, if not supplied will default to width)
			@param {Boolean} [crop=false] Whether to crop the image to exact dimensions
			@param {Boolean} [preserveHeaders=true] Whether to preserve meta headers (on JPEGs after resize)
			*/
			downsize: function(width, height, crop, preserveHeaders) {
				try {
					if (!this.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}

					// no way to reliably intercept the crash due to high resolution, so we simply avoid it
					if (this.width > Image.MAX_RESIZE_WIDTH || this.height > Image.MAX_RESIZE_HEIGHT) {
						throw new x.ImageError(x.ImageError.MAX_RESOLUTION_ERR);
					}

					if (!width && !height || Basic.typeOf(crop) === 'undefined') {
						crop = false;
					}

					width = width || this.width;
					height = height || this.height;

					preserveHeaders = (Basic.typeOf(preserveHeaders) === 'undefined' ? true : !!preserveHeaders);

					this.getRuntime().exec.call(this, 'Image', 'downsize', width, height, crop, preserveHeaders);
				} catch(ex) {
					// for now simply trigger error event
					this.trigger('error', ex);
				}
			},

			/**
			Alias for downsize(width, height, true). (see downsize)
			
			@method crop
			@param {Number} width Resulting width
			@param {Number} [height=width] Resulting height (optional, if not supplied will default to width)
			@param {Boolean} [preserveHeaders=true] Whether to preserve meta headers (on JPEGs after resize)
			*/
			crop: function(width, height, preserveHeaders) {
				this.downsize(width, height, true, preserveHeaders);
			},

			getAsCanvas: function() {
				if (!Env.can('create_canvas')) {
					throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
				}

				var runtime = this.connectRuntime(this.ruid);
				return runtime.exec.call(this, 'Image', 'getAsCanvas');
			},

			/**
			Retrieves image in it's current state as mOxie.Blob object. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsBlob
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {Blob} Image as Blob
			*/
			getAsBlob: function(type, quality) {
				if (!this.size) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}

				if (!type) {
					type = 'image/jpeg';
				}

				if (type === 'image/jpeg' && !quality) {
					quality = 90;
				}

				return this.getRuntime().exec.call(this, 'Image', 'getAsBlob', type, quality);
			},

			/**
			Retrieves image in it's current state as dataURL string. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsDataURL
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {String} Image as dataURL string
			*/
			getAsDataURL: function(type, quality) {
				if (!this.size) {
					throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
				}
				return this.getRuntime().exec.call(this, 'Image', 'getAsDataURL', type, quality);
			},

			/**
			Retrieves image in it's current state as binary string. Cannot be run on empty or image in progress (throws
			DOMException.INVALID_STATE_ERR).

			@method getAsBinaryString
			@param {String} [type="image/jpeg"] Mime type of resulting blob. Can either be image/jpeg or image/png
			@param {Number} [quality=90] Applicable only together with mime type image/jpeg
			@return {String} Image as binary string
			*/
			getAsBinaryString: function(type, quality) {
				var dataUrl = this.getAsDataURL(type, quality);
				return Encode.atob(dataUrl.substring(dataUrl.indexOf('base64,') + 7));
			},

			/**
			Embeds the image, or better to say, it's visual representation into the specified node. Depending on the runtime
			in use, might be a canvas, or image (actual ) element or shim object (Flash or SilverLight - very rare, used for
			legacy browsers that do not have canvas or proper dataURI support).

			@method embed
			@param {DOMElement} el DOM element to insert the image object into
			@param {Object} options Set of key/value pairs controlling the mime type, dimensions and cropping factor of resulting
			representation
			*/
			embed: function(el) {
				var self = this
				, imgCopy
				, type, quality, crop
				, options = arguments[1] || {}
				, width = this.width
				, height = this.height
				, runtime // this has to be outside of all the closures to contain proper runtime
				;

				function onResize() {
					// if possible, embed a canvas element directly
					if (Env.can('create_canvas')) {
						var canvas = imgCopy.getAsCanvas();
						if (canvas) {
							el.appendChild(canvas);
							canvas = null;
							imgCopy.destroy();
							self.trigger('embedded');
							return;
						}
					}

					var dataUrl = imgCopy.getAsDataURL(type, quality);
					if (!dataUrl) {
						throw new x.ImageError(x.ImageError.WRONG_FORMAT);
					}

					if (Env.can('use_data_uri_of', dataUrl.length)) {
						el.innerHTML = '<img src="' + dataUrl + '" width="' + imgCopy.width + '" height="' + imgCopy.height + '" />';
						imgCopy.destroy();
						self.trigger('embedded');
					} else {
						var tr = new Transporter();

						tr.bind("TransportingComplete", function() {
							runtime = self.connectRuntime(this.result.ruid);

							self.bind("Embedded", function() {
								// position and size properly
								Basic.extend(runtime.getShimContainer().style, {
									//position: 'relative',
									top: '0px',
									left: '0px',
									width: imgCopy.width + 'px',
									height: imgCopy.height + 'px'
								});

								// some shims (Flash/SilverLight) reinitialize, if parent element is hidden, reordered or it's
								// position type changes (in Gecko), but since we basically need this only in IEs 6/7 and
								// sometimes 8 and they do not have this problem, we can comment this for now
								/*tr.bind("RuntimeInit", function(e, runtime) {
									tr.destroy();
									runtime.destroy();
									onResize.call(self); // re-feed our image data
								});*/

								runtime = null;
							}, 999);

							runtime.exec.call(self, "ImageView", "display", this.result.uid, width, height);
							imgCopy.destroy();
						});

						tr.transport(Encode.atob(dataUrl.substring(dataUrl.indexOf('base64,') + 7)), type, Basic.extend({}, options, {
							required_caps: {
								display_media: true
							},
							runtime_order: 'flash,silverlight',
							container: el
						}));
					}
				}

				try {
					if (!(el = Dom.get(el))) {
						throw new x.DOMException(x.DOMException.INVALID_NODE_TYPE_ERR);
					}

					if (!this.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}

					if (this.width > Image.MAX_RESIZE_WIDTH || this.height > Image.MAX_RESIZE_HEIGHT) {
						throw new x.ImageError(x.ImageError.MAX_RESOLUTION_ERR);
					}

					type = options.type || this.type || 'image/jpeg';
					quality = options.quality || 90;
					crop = Basic.typeOf(options.crop) !== 'undefined' ? options.crop : false;

					// figure out dimensions for the thumb
					if (options.width) {
						width = options.width;
						height = options.height || width;
					} else {
						// if container element has > 0 dimensions, take them
						var dimensions = Dom.getSize(el);
						if (dimensions.w && dimensions.h) { // both should be > 0
							width = dimensions.w;
							height = dimensions.h;
						}
					}

					imgCopy = new Image();

					imgCopy.bind("Resize", function() {
						onResize.call(self);
					});

					imgCopy.bind("Load", function() {
						imgCopy.downsize(width, height, crop, false);
					});

					imgCopy.clone(this, false);

					return imgCopy;
				} catch(ex) {
					// for now simply trigger error event
					this.trigger('error', ex);
				}
			},

			/**
			Properly destroys the image and frees resources in use. If any. Recommended way to dispose mOxie.Image object.

			@method destroy
			*/
			destroy: function() {
				if (this.ruid) {
					this.getRuntime().exec.call(this, 'Image', 'destroy');
					this.disconnectRuntime();
				}
				this.unbindAll();
			}
		});


		function _updateInfo(info) {
			if (!info) {
				info = this.getRuntime().exec.call(this, 'Image', 'getInfo');
			}

			this.size = info.size;
			this.width = info.width;
			this.height = info.height;
			this.type = info.type;
			this.meta = info.meta;

			// update file name, only if empty
			if (this.name === '') {
				this.name = info.name;
			}
		}
		

		function _load(src) {
			var srcType = Basic.typeOf(src);

			try {
				// if source is Image
				if (src instanceof Image) {
					if (!src.size) { // only preloaded image objects can be used as source
						throw new x.DOMException(x.DOMException.INVALID_STATE_ERR);
					}
					_loadFromImage.apply(this, arguments);
				}
				// if source is o.Blob/o.File
				else if (src instanceof Blob) {
					if (!~Basic.inArray(src.type, ['image/jpeg', 'image/png'])) {
						throw new x.ImageError(x.ImageError.WRONG_FORMAT);
					}
					_loadFromBlob.apply(this, arguments);
				}
				// if native blob/file
				else if (Basic.inArray(srcType, ['blob', 'file']) !== -1) {
					_load.call(this, new File(null, src), arguments[1]);
				}
				// if String
				else if (srcType === 'string') {
					// if dataUrl String
					if (/^data:[^;]*;base64,/.test(src)) {
						_load.call(this, new Blob(null, { data: src }), arguments[1]);
					}
					// else assume Url, either relative or absolute
					else {
						_loadFromUrl.apply(this, arguments);
					}
				}
				// if source seems to be an img node
				else if (srcType === 'node' && src.nodeName.toLowerCase() === 'img') {
					_load.call(this, src.src, arguments[1]);
				}
				else {
					throw new x.DOMException(x.DOMException.TYPE_MISMATCH_ERR);
				}
			} catch(ex) {
				// for now simply trigger error event
				this.trigger('error', ex);
			}
		}


		function _loadFromImage(img, exact) {
			var runtime = this.connectRuntime(img.ruid);
			this.ruid = runtime.uid;
			runtime.exec.call(this, 'Image', 'loadFromImage', img, (Basic.typeOf(exact) === 'undefined' ? true : exact));
		}


		function _loadFromBlob(blob, options) {
			var self = this;

			self.name = blob.name || '';

			function exec(runtime) {
				self.ruid = runtime.uid;
				runtime.exec.call(self, 'Image', 'loadFromBlob', blob);
			}

			if (blob.isDetached()) {
				this.bind('RuntimeInit', function(e, runtime) {
					exec(runtime);
				});

				// convert to object representation
				if (options && typeof(options.required_caps) === 'string') {
					options.required_caps = Runtime.parseCaps(options.required_caps);
				}

				this.connectRuntime(Basic.extend({
					required_caps: {
						access_image_binary: true,
						resize_image: true
					}
				}, options));
			} else {
				exec(this.connectRuntime(blob.ruid));
			}
		}


		function _loadFromUrl(url, options) {
			var self = this, xhr;

			xhr = new XMLHttpRequest();

			xhr.open('get', url);
			xhr.responseType = 'blob';

			xhr.onprogress = function(e) {
				self.trigger(e);
			};

			xhr.onload = function() {
				_loadFromBlob.call(self, xhr.response, true);
			};

			xhr.onerror = function(e) {
				self.trigger(e);
			};

			xhr.onloadend = function() {
				xhr.destroy();
			};

			xhr.bind('RuntimeError', function(e, err) {
				self.trigger('RuntimeError', err);
			});

			xhr.send(null, options);
		}
	}

	// virtual world will crash on you if image has a resolution higher than this:
	Image.MAX_RESIZE_WIDTH = 6500;
	Image.MAX_RESIZE_HEIGHT = 6500; 

	Image.prototype = EventTarget.instance;

	return Image;
});

// Included from: src/javascript/runtime/html5/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global File:true */

/**
Defines constructor for HTML5 runtime.

@class moxie/runtime/html5/Runtime
@private
*/
define("moxie/runtime/html5/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime",
	"moxie/core/utils/Env"
], function(Basic, x, Runtime, Env) {
	
	var type = "html5", extensions = {};
	
	function Html5Runtime(options) {
		var I = this
		, Test = Runtime.capTest
		, True = Runtime.capTrue
		;

		var caps = Basic.extend({
				access_binary: Test(window.FileReader || window.File && window.File.getAsDataURL),
				access_image_binary: function() {
					return I.can('access_binary') && !!extensions.Image;
				},
				display_media: Test(Env.can('create_canvas') || Env.can('use_data_uri_over32kb')),
				do_cors: Test(window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()),
				drag_and_drop: Test(function() {
					// this comes directly from Modernizr: http://www.modernizr.com/
					var div = document.createElement('div');
					// IE has support for drag and drop since version 5, but doesn't support dropping files from desktop
					return (('draggable' in div) || ('ondragstart' in div && 'ondrop' in div)) && (Env.browser !== 'IE' || Env.version > 9);
				}()),
				filter_by_extension: Test(function() { // if you know how to feature-detect this, please suggest
					return (Env.browser === 'Chrome' && Env.version >= 28) || (Env.browser === 'IE' && Env.version >= 10);
				}()),
				return_response_headers: True,
				return_response_type: function(responseType) {
					if (responseType === 'json' && !!window.JSON) { // we can fake this one even if it's not supported
						return true;
					} 
					return Env.can('return_response_type', responseType);
				},
				return_status_code: True,
				report_upload_progress: Test(window.XMLHttpRequest && new XMLHttpRequest().upload),
				resize_image: function() {
					return I.can('access_binary') && Env.can('create_canvas');
				},
				select_file: function() {
					return Env.can('use_fileinput') && window.File;
				},
				select_folder: function() {
					return I.can('select_file') && Env.browser === 'Chrome' && Env.version >= 21;
				},
				select_multiple: function() {
					// it is buggy on Safari Windows and iOS
					return I.can('select_file') && 
						!(Env.browser === 'Safari' && Env.os === 'Windows') && 
						!(Env.os === 'iOS' && Env.verComp(Env.osVersion, "7.0.4", '<'));
				},
				send_binary_string: Test(window.XMLHttpRequest && (new XMLHttpRequest().sendAsBinary || (window.Uint8Array && window.ArrayBuffer))),
				send_custom_headers: Test(window.XMLHttpRequest),
				send_multipart: function() {
					return !!(window.XMLHttpRequest && new XMLHttpRequest().upload && window.FormData) || I.can('send_binary_string');
				},
				slice_blob: Test(window.File && (File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice)),
				stream_upload: function(){
					return I.can('slice_blob') && I.can('send_multipart');
				},
				summon_file_dialog: Test(function() { // yeah... some dirty sniffing here...
					return (Env.browser === 'Firefox' && Env.version >= 4) ||
						(Env.browser === 'Opera' && Env.version >= 12) ||
						(Env.browser === 'IE' && Env.version >= 10) ||
						!!~Basic.inArray(Env.browser, ['Chrome', 'Safari']);
				}()),
				upload_filesize: True
			}, 
			arguments[2]
		);

		Runtime.call(this, options, (arguments[1] || type), caps);


		Basic.extend(this, {

			init : function() {
				this.trigger("Init");
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					destroy = I = null;
				};
			}(this.destroy))
		});

		Basic.extend(this.getShim(), extensions);
	}

	Runtime.addConstructor(type, Html5Runtime);

	return extensions;
});

// Included from: src/javascript/runtime/html5/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/Blob
@private
*/
define("moxie/runtime/html5/file/Blob", [
	"moxie/runtime/html5/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	function HTML5Blob() {
		function w3cBlobSlice(blob, start, end) {
			var blobSlice;

			if (window.File.prototype.slice) {
				try {
					blob.slice();	// depricated version will throw WRONG_ARGUMENTS_ERR exception
					return blob.slice(start, end);
				} catch (e) {
					// depricated slice method
					return blob.slice(start, end - start);
				}
			// slice method got prefixed: https://bugzilla.mozilla.org/show_bug.cgi?id=649672
			} else if ((blobSlice = window.File.prototype.webkitSlice || window.File.prototype.mozSlice)) {
				return blobSlice.call(blob, start, end);
			} else {
				return null; // or throw some exception
			}
		}

		this.slice = function() {
			return new Blob(this.getRuntime().uid, w3cBlobSlice.apply(this, arguments));
		};
	}

	return (extensions.Blob = HTML5Blob);
});

// Included from: src/javascript/core/utils/Events.js

/**
 * Events.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

define('moxie/core/utils/Events', [
	'moxie/core/utils/Basic'
], function(Basic) {
	var eventhash = {}, uid = 'moxie_' + Basic.guid();
	
	// IE W3C like event funcs
	function preventDefault() {
		this.returnValue = false;
	}

	function stopPropagation() {
		this.cancelBubble = true;
	}

	/**
	Adds an event handler to the specified object and store reference to the handler
	in objects internal Plupload registry (@see removeEvent).
	
	@method addEvent
	@for Utils
	@static
	@param {Object} obj DOM element like object to add handler to.
	@param {String} name Name to add event listener to.
	@param {Function} callback Function to call when event occurs.
	@param {String} [key] that might be used to add specifity to the event record.
	*/
	var addEvent = function(obj, name, callback, key) {
		var func, events;
					
		name = name.toLowerCase();

		// Add event listener
		if (obj.addEventListener) {
			func = callback;
			
			obj.addEventListener(name, func, false);
		} else if (obj.attachEvent) {
			func = function() {
				var evt = window.event;

				if (!evt.target) {
					evt.target = evt.srcElement;
				}

				evt.preventDefault = preventDefault;
				evt.stopPropagation = stopPropagation;

				callback(evt);
			};

			obj.attachEvent('on' + name, func);
		}
		
		// Log event handler to objects internal mOxie registry
		if (!obj[uid]) {
			obj[uid] = Basic.guid();
		}
		
		if (!eventhash.hasOwnProperty(obj[uid])) {
			eventhash[obj[uid]] = {};
		}
		
		events = eventhash[obj[uid]];
		
		if (!events.hasOwnProperty(name)) {
			events[name] = [];
		}
				
		events[name].push({
			func: func,
			orig: callback, // store original callback for IE
			key: key
		});
	};
	
	
	/**
	Remove event handler from the specified object. If third argument (callback)
	is not specified remove all events with the specified name.
	
	@method removeEvent
	@static
	@param {Object} obj DOM element to remove event listener(s) from.
	@param {String} name Name of event listener to remove.
	@param {Function|String} [callback] might be a callback or unique key to match.
	*/
	var removeEvent = function(obj, name, callback) {
		var type, undef;
		
		name = name.toLowerCase();
		
		if (obj[uid] && eventhash[obj[uid]] && eventhash[obj[uid]][name]) {
			type = eventhash[obj[uid]][name];
		} else {
			return;
		}
			
		for (var i = type.length - 1; i >= 0; i--) {
			// undefined or not, key should match
			if (type[i].orig === callback || type[i].key === callback) {
				if (obj.removeEventListener) {
					obj.removeEventListener(name, type[i].func, false);
				} else if (obj.detachEvent) {
					obj.detachEvent('on'+name, type[i].func);
				}
				
				type[i].orig = null;
				type[i].func = null;
				type.splice(i, 1);
				
				// If callback was passed we are done here, otherwise proceed
				if (callback !== undef) {
					break;
				}
			}
		}
		
		// If event array got empty, remove it
		if (!type.length) {
			delete eventhash[obj[uid]][name];
		}
		
		// If mOxie registry has become empty, remove it
		if (Basic.isEmptyObj(eventhash[obj[uid]])) {
			delete eventhash[obj[uid]];
			
			// IE doesn't let you remove DOM object property with - delete
			try {
				delete obj[uid];
			} catch(e) {
				obj[uid] = undef;
			}
		}
	};
	
	
	/**
	Remove all kind of events from the specified object
	
	@method removeAllEvents
	@static
	@param {Object} obj DOM element to remove event listeners from.
	@param {String} [key] unique key to match, when removing events.
	*/
	var removeAllEvents = function(obj, key) {		
		if (!obj || !obj[uid]) {
			return;
		}
		
		Basic.each(eventhash[obj[uid]], function(events, name) {
			removeEvent(obj, name, key);
		});
	};

	return {
		addEvent: addEvent,
		removeEvent: removeEvent,
		removeAllEvents: removeAllEvents
	};
});

// Included from: src/javascript/runtime/html5/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileInput
@private
*/
define("moxie/runtime/html5/file/FileInput", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, Basic, Dom, Events, Mime, Env) {
	
	function FileInput() {
		var _files = [], _options;

		Basic.extend(this, {
			init: function(options) {
				var comp = this, I = comp.getRuntime(), input, shimContainer, mimes, browseButton, zIndex, top;

				_options = options;
				_files = [];

				// figure out accept string
				mimes = _options.accept.mimes || Mime.extList2mimes(_options.accept, I.can('filter_by_extension'));

				shimContainer = I.getShimContainer();

				shimContainer.innerHTML = '<input id="' + I.uid +'" type="file" style="font-size:999px;opacity:0;"' +
					(_options.multiple && I.can('select_multiple') ? 'multiple' : '') + 
					(_options.directory && I.can('select_folder') ? 'webkitdirectory directory' : '') + // Chrome 11+
					(mimes ? ' accept="' + mimes.join(',') + '"' : '') + ' />';

				input = Dom.get(I.uid);

				// prepare file input to be placed underneath the browse_button element
				Basic.extend(input.style, {
					position: 'absolute',
					top: 0,
					left: 0,
					width: '100%',
					height: '100%'
				});


				browseButton = Dom.get(_options.browse_button);

				// Route click event to the input[type=file] element for browsers that support such behavior
				if (I.can('summon_file_dialog')) {
					if (Dom.getStyle(browseButton, 'position') === 'static') {
						browseButton.style.position = 'relative';
					}

					zIndex = parseInt(Dom.getStyle(browseButton, 'z-index'), 10) || 1;

					browseButton.style.zIndex = zIndex;
					shimContainer.style.zIndex = zIndex - 1;

					Events.addEvent(browseButton, 'click', function(e) {
						var input = Dom.get(I.uid);
						if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
							input.click();
						}
						e.preventDefault();
					}, comp.uid);
				}

				/* Since we have to place input[type=file] on top of the browse_button for some browsers,
				browse_button loses interactivity, so we restore it here */
				top = I.can('summon_file_dialog') ? browseButton : shimContainer;

				Events.addEvent(top, 'mouseover', function() {
					comp.trigger('mouseenter');
				}, comp.uid);

				Events.addEvent(top, 'mouseout', function() {
					comp.trigger('mouseleave');
				}, comp.uid);

				Events.addEvent(top, 'mousedown', function() {
					comp.trigger('mousedown');
				}, comp.uid);

				Events.addEvent(Dom.get(_options.container), 'mouseup', function() {
					comp.trigger('mouseup');
				}, comp.uid);


				input.onchange = function onChange() { // there should be only one handler for this
					_files = [];

					if (_options.directory) {
						// folders are represented by dots, filter them out (Chrome 11+)
						Basic.each(this.files, function(file) {
							if (file.name !== ".") { // if it doesn't looks like a folder
								_files.push(file);
							}
						});
					} else {
						_files = [].slice.call(this.files);
					}

					// clearing the value enables the user to select the same file again if they want to
					if (Env.browser !== 'IE') {
						this.value = '';
					} else {
						// in IE input[type="file"] is read-only so the only way to reset it is to re-insert it
						var clone = this.cloneNode(true);
						this.parentNode.replaceChild(clone, this);
						clone.onchange = onChange;
					}
					comp.trigger('change');
				};

				// ready event is perfectly asynchronous
				comp.trigger({
					type: 'ready',
					async: true
				});

				shimContainer = null;
			},

			getFiles: function() {
				return _files;
			},

			disable: function(state) {
				var I = this.getRuntime(), input;

				if ((input = Dom.get(I.uid))) {
					input.disabled = !!state;
				}
			},

			destroy: function() {
				var I = this.getRuntime()
				, shim = I.getShim()
				, shimContainer = I.getShimContainer()
				;
				
				Events.removeAllEvents(shimContainer, this.uid);
				Events.removeAllEvents(_options && Dom.get(_options.container), this.uid);
				Events.removeAllEvents(_options && Dom.get(_options.browse_button), this.uid);
				
				if (shimContainer) {
					shimContainer.innerHTML = '';
				}

				shim.removeInstance(this.uid);

				_files = _options = shimContainer = shim = null;
			}
		});
	}

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/html5/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileDrop
@private
*/
define("moxie/runtime/html5/file/FileDrop", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime"
], function(extensions, Basic, Dom, Events, Mime) {
	
	function FileDrop() {
		var _files = [], _allowedExts = [], _options;

		Basic.extend(this, {
			init: function(options) {
				var comp = this, dropZone;

				_options = options;
				_allowedExts = _extractExts(_options.accept);
				dropZone = _options.container;

				Events.addEvent(dropZone, 'dragover', function(e) {
					e.preventDefault();
					e.stopPropagation();
					e.dataTransfer.dropEffect = 'copy';
				}, comp.uid);

				Events.addEvent(dropZone, 'drop', function(e) {
					e.preventDefault();
					e.stopPropagation();

					_files = [];

					// Chrome 21+ accepts folders via Drag'n'Drop
					if (e.dataTransfer.items && e.dataTransfer.items[0].webkitGetAsEntry) {
						_readItems(e.dataTransfer.items, function() {
							comp.trigger("drop");
						});
					} else {
						Basic.each(e.dataTransfer.files, function(file) {
							if (_isAcceptable(file)) {
								_files.push(file);
							}
						});
						comp.trigger("drop");
					}
				}, comp.uid);

				Events.addEvent(dropZone, 'dragenter', function(e) {
					e.preventDefault();
					e.stopPropagation();
					comp.trigger("dragenter");
				}, comp.uid);

				Events.addEvent(dropZone, 'dragleave', function(e) {
					e.preventDefault();
					e.stopPropagation();
					comp.trigger("dragleave");
				}, comp.uid);
			},

			getFiles: function() {
				return _files;
			},

			destroy: function() {
				Events.removeAllEvents(_options && Dom.get(_options.container), this.uid);
				_files = _allowedExts = _options = null;
			}
		});

		
		function _extractExts(accept) {
			var exts = [];
			for (var i = 0; i < accept.length; i++) {
				[].push.apply(exts, accept[i].extensions.split(/\s*,\s*/));
			}
			return Basic.inArray('*', exts) === -1 ? exts : [];
		}


		function _isAcceptable(file) {
			var ext = Mime.getFileExtension(file.name);
			return !ext || !_allowedExts.length || Basic.inArray(ext, _allowedExts) !== -1;
		}


		function _readItems(items, cb) {
			var entries = [];
			Basic.each(items, function(item) {
				var entry = item.webkitGetAsEntry();
				// Address #998 (https://code.google.com/p/chromium/issues/detail?id=332579)
				if (entry) {
					// file() fails on OSX when the filename contains a special character (e.g. umlaut): see #61
					if (entry.isFile) {
						var file = item.getAsFile();
						if (_isAcceptable(file)) {
							_files.push(file);
						}
					} else {
						entries.push(entry);
					}
				}
			});

			if (entries.length) {
				_readEntries(entries, cb);
			} else {
				cb();
			}
		}


		function _readEntries(entries, cb) {
			var queue = [];
			Basic.each(entries, function(entry) {
				queue.push(function(cbcb) {
					_readEntry(entry, cbcb);
				});
			});
			Basic.inSeries(queue, function() {
				cb();
			});
		}

		function _readEntry(entry, cb) {
			if (entry.isFile) {
				entry.file(function(file) {
					if (_isAcceptable(file)) {
						_files.push(file);
					}
					cb();
				}, function() {
					// fire an error event maybe
					cb();
				});
			} else if (entry.isDirectory) {
				_readDirEntry(entry, cb);
			} else {
				cb(); // not file, not directory? what then?..
			}
		}

		function _readDirEntry(dirEntry, cb) {
			var entries = [], dirReader = dirEntry.createReader();

			// keep quering recursively till no more entries
			function getEntries(cbcb) {
				dirReader.readEntries(function(moreEntries) {
					if (moreEntries.length) {
						[].push.apply(entries, moreEntries);
						getEntries(cbcb);
					} else {
						cbcb();
					}
				}, cbcb);
			}

			// ...and you thought FileReader was crazy...
			getEntries(function() {
				_readEntries(entries, cb);
			}); 
		}
	}

	return (extensions.FileDrop = FileDrop);
});

// Included from: src/javascript/runtime/html5/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/file/FileReader
@private
*/
define("moxie/runtime/html5/file/FileReader", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Encode",
	"moxie/core/utils/Basic"
], function(extensions, Encode, Basic) {
	
	function FileReader() {
		var _fr, _convertToBinary = false;

		Basic.extend(this, {

			read: function(op, blob) {
				var target = this;

				_fr = new window.FileReader();

				_fr.addEventListener('progress', function(e) {
					target.trigger(e);
				});

				_fr.addEventListener('load', function(e) {
					target.trigger(e);
				});

				_fr.addEventListener('error', function(e) {
					target.trigger(e, _fr.error);
				});

				_fr.addEventListener('loadend', function() {
					_fr = null;
				});

				if (Basic.typeOf(_fr[op]) === 'function') {
					_convertToBinary = false;
					_fr[op](blob.getSource());
				} else if (op === 'readAsBinaryString') { // readAsBinaryString is depricated in general and never existed in IE10+
					_convertToBinary = true;
					_fr.readAsDataURL(blob.getSource());
				}
			},

			getResult: function() {
				return _fr && _fr.result ? (_convertToBinary ? _toBinary(_fr.result) : _fr.result) : null;
			},

			abort: function() {
				if (_fr) {
					_fr.abort();
				}
			},

			destroy: function() {
				_fr = null;
			}
		});

		function _toBinary(str) {
			return Encode.atob(str.substring(str.indexOf('base64,') + 7));
		}
	}

	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/html5/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
@class moxie/runtime/html5/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/html5/xhr/XMLHttpRequest", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Url",
	"moxie/file/File",
	"moxie/file/Blob",
	"moxie/xhr/FormData",
	"moxie/core/Exceptions",
	"moxie/core/utils/Env"
], function(extensions, Basic, Mime, Url, File, Blob, FormData, x, Env) {
	
	function XMLHttpRequest() {
		var self = this
		, _xhr
		, _filename
		;

		Basic.extend(this, {
			send: function(meta, data) {
				var target = this
				, isGecko2_5_6 = (Env.browser === 'Mozilla' && Env.version >= 4 && Env.version < 7)
				, isAndroidBrowser = Env.browser === 'Android Browser'
				, mustSendAsBinary = false
				;

				// extract file name
				_filename = meta.url.replace(/^.+?\/([\w\-\.]+)$/, '$1').toLowerCase();

				_xhr = _getNativeXHR();
				_xhr.open(meta.method, meta.url, meta.async, meta.user, meta.password);


				// prepare data to be sent
				if (data instanceof Blob) {
					if (data.isDetached()) {
						mustSendAsBinary = true;
					}
					data = data.getSource();
				} else if (data instanceof FormData) {

					if (data.hasBlob()) {
						if (data.getBlob().isDetached()) {
							data = _prepareMultipart.call(target, data); // _xhr must be instantiated and be in OPENED state
							mustSendAsBinary = true;
						} else if ((isGecko2_5_6 || isAndroidBrowser) && Basic.typeOf(data.getBlob().getSource()) === 'blob' && window.FileReader) {
							// Gecko 2/5/6 can't send blob in FormData: https://bugzilla.mozilla.org/show_bug.cgi?id=649150
							// Android browsers (default one and Dolphin) seem to have the same issue, see: #613
							_preloadAndSend.call(target, meta, data);
							return; // _preloadAndSend will reinvoke send() with transmutated FormData =%D
						}	
					}

					// transfer fields to real FormData
					if (data instanceof FormData) { // if still a FormData, e.g. not mangled by _prepareMultipart()
						var fd = new window.FormData();
						data.each(function(value, name) {
							if (value instanceof Blob) {
								fd.append(name, value.getSource());
							} else {
								fd.append(name, value);
							}
						});
						data = fd;
					}
				}


				// if XHR L2
				if (_xhr.upload) {
					if (meta.withCredentials) {
						_xhr.withCredentials = true;
					}

					_xhr.addEventListener('load', function(e) {
						target.trigger(e);
					});

					_xhr.addEventListener('error', function(e) {
						target.trigger(e);
					});

					// additionally listen to progress events
					_xhr.addEventListener('progress', function(e) {
						target.trigger(e);
					});

					_xhr.upload.addEventListener('progress', function(e) {
						target.trigger({
							type: 'UploadProgress',
							loaded: e.loaded,
							total: e.total
						});
					});
				// ... otherwise simulate XHR L2
				} else {
					_xhr.onreadystatechange = function onReadyStateChange() {
						
						// fake Level 2 events
						switch (_xhr.readyState) {
							
							case 1: // XMLHttpRequest.OPENED
								// readystatechanged is fired twice for OPENED state (in IE and Mozilla) - neu
								break;
							
							// looks like HEADERS_RECEIVED (state 2) is not reported in Opera (or it's old versions) - neu
							case 2: // XMLHttpRequest.HEADERS_RECEIVED
								break;
								
							case 3: // XMLHttpRequest.LOADING 
								// try to fire progress event for not XHR L2
								var total, loaded;
								
								try {
									if (Url.hasSameOrigin(meta.url)) { // Content-Length not accessible for cross-domain on some browsers
										total = _xhr.getResponseHeader('Content-Length') || 0; // old Safari throws an exception here
									}

									if (_xhr.responseText) { // responseText was introduced in IE7
										loaded = _xhr.responseText.length;
									}
								} catch(ex) {
									total = loaded = 0;
								}

								target.trigger({
									type: 'progress',
									lengthComputable: !!total,
									total: parseInt(total, 10),
									loaded: loaded
								});
								break;
								
							case 4: // XMLHttpRequest.DONE
								// release readystatechange handler (mostly for IE)
								_xhr.onreadystatechange = function() {};

								// usually status 0 is returned when server is unreachable, but FF also fails to status 0 for 408 timeout
								if (_xhr.status === 0) {
									target.trigger('error');
								} else {
									target.trigger('load');
								}							
								break;
						}
					};
				}
				

				// set request headers
				if (!Basic.isEmptyObj(meta.headers)) {
					Basic.each(meta.headers, function(value, header) {
						_xhr.setRequestHeader(header, value);
					});
				}

				// request response type
				if ("" !== meta.responseType && 'responseType' in _xhr) {
					if ('json' === meta.responseType && !Env.can('return_response_type', 'json')) { // we can fake this one
						_xhr.responseType = 'text';
					} else {
						_xhr.responseType = meta.responseType;
					}
				}

				// send ...
				if (!mustSendAsBinary) {
					_xhr.send(data);
				} else {
					if (_xhr.sendAsBinary) { // Gecko
						_xhr.sendAsBinary(data);
					} else { // other browsers having support for typed arrays
						(function() {
							// mimic Gecko's sendAsBinary
							var ui8a = new Uint8Array(data.length);
							for (var i = 0; i < data.length; i++) {
								ui8a[i] = (data.charCodeAt(i) & 0xff);
							}
							_xhr.send(ui8a.buffer);
						}());
					}
				}

				target.trigger('loadstart');
			},

			getStatus: function() {
				// according to W3C spec it should return 0 for readyState < 3, but instead it throws an exception
				try {
					if (_xhr) {
						return _xhr.status;
					}
				} catch(ex) {}
				return 0;
			},

			getResponse: function(responseType) {
				var I = this.getRuntime();

				try {
					switch (responseType) {
						case 'blob':
							var file = new File(I.uid, _xhr.response);
							
							// try to extract file name from content-disposition if possible (might be - not, if CORS for example)	
							var disposition = _xhr.getResponseHeader('Content-Disposition');
							if (disposition) {
								// extract filename from response header if available
								var match = disposition.match(/filename=([\'\"'])([^\1]+)\1/);
								if (match) {
									_filename = match[2];
								}
							}
							file.name = _filename;

							// pre-webkit Opera doesn't set type property on the blob response
							if (!file.type) {
								file.type = Mime.getFileMime(_filename);
							}
							return file;

						case 'json':
							if (!Env.can('return_response_type', 'json')) {
								return _xhr.status === 200 && !!window.JSON ? JSON.parse(_xhr.responseText) : null;
							}
							return _xhr.response;

						case 'document':
							return _getDocument(_xhr);

						default:
							return _xhr.responseText !== '' ? _xhr.responseText : null; // against the specs, but for consistency across the runtimes
					}
				} catch(ex) {
					return null;
				}				
			},

			getAllResponseHeaders: function() {
				try {
					return _xhr.getAllResponseHeaders();
				} catch(ex) {}
				return '';
			},

			abort: function() {
				if (_xhr) {
					_xhr.abort();
				}
			},

			destroy: function() {
				self = _filename = null;
			}
		});


		// here we go... ugly fix for ugly bug
		function _preloadAndSend(meta, data) {
			var target = this, blob, fr;
				
			// get original blob
			blob = data.getBlob().getSource();
			
			// preload blob in memory to be sent as binary string
			fr = new window.FileReader();
			fr.onload = function() {
				// overwrite original blob
				data.append(data.getBlobName(), new Blob(null, {
					type: blob.type,
					data: fr.result
				}));
				// invoke send operation again
				self.send.call(target, meta, data);
			};
			fr.readAsBinaryString(blob);
		}

		
		function _getNativeXHR() {
			if (window.XMLHttpRequest && !(Env.browser === 'IE' && Env.version < 8)) { // IE7 has native XHR but it's buggy
				return new window.XMLHttpRequest();
			} else {
				return (function() {
					var progIDs = ['Msxml2.XMLHTTP.6.0', 'Microsoft.XMLHTTP']; // if 6.0 available, use it, otherwise failback to default 3.0
					for (var i = 0; i < progIDs.length; i++) {
						try {
							return new ActiveXObject(progIDs[i]);
						} catch (ex) {}
					}
				})();
			}
		}
		
		// @credits Sergey Ilinsky	(http://www.ilinsky.com/)
		function _getDocument(xhr) {
			var rXML = xhr.responseXML;
			var rText = xhr.responseText;
			
			// Try parsing responseText (@see: http://www.ilinsky.com/articles/XMLHttpRequest/#bugs-ie-responseXML-content-type)
			if (Env.browser === 'IE' && rText && rXML && !rXML.documentElement && /[^\/]+\/[^\+]+\+xml/.test(xhr.getResponseHeader("Content-Type"))) {
				rXML = new window.ActiveXObject("Microsoft.XMLDOM");
				rXML.async = false;
				rXML.validateOnParse = false;
				rXML.loadXML(rText);
			}
	
			// Check if there is no error in document
			if (rXML) {
				if ((Env.browser === 'IE' && rXML.parseError !== 0) || !rXML.documentElement || rXML.documentElement.tagName === "parsererror") {
					return null;
				}
			}
			return rXML;
		}


		function _prepareMultipart(fd) {
			var boundary = '----moxieboundary' + new Date().getTime()
			, dashdash = '--'
			, crlf = '\r\n'
			, multipart = ''
			, I = this.getRuntime()
			;

			if (!I.can('send_binary_string')) {
				throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
			}

			_xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);

			// append multipart parameters
			fd.each(function(value, name) {
				// Firefox 3.6 failed to convert multibyte characters to UTF-8 in sendAsBinary(), 
				// so we try it here ourselves with: unescape(encodeURIComponent(value))
				if (value instanceof Blob) {
					// Build RFC2388 blob
					multipart += dashdash + boundary + crlf +
						'Content-Disposition: form-data; name="' + name + '"; filename="' + unescape(encodeURIComponent(value.name || 'blob')) + '"' + crlf +
						'Content-Type: ' + (value.type || 'application/octet-stream') + crlf + crlf +
						value.getSource() + crlf;
				} else {
					multipart += dashdash + boundary + crlf +
						'Content-Disposition: form-data; name="' + name + '"' + crlf + crlf +
						unescape(encodeURIComponent(value)) + crlf;
				}
			});

			multipart += dashdash + boundary + dashdash + crlf;

			return multipart;
		}
	}

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/html5/utils/BinaryReader.js

/**
 * BinaryReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/utils/BinaryReader
@private
*/
define("moxie/runtime/html5/utils/BinaryReader", [], function() {
	return function() {
		var II = false, bin;

		// Private functions
		function read(idx, size) {
			var mv = II ? 0 : -8 * (size - 1), sum = 0, i;

			for (i = 0; i < size; i++) {
				sum |= (bin.charCodeAt(idx + i) << Math.abs(mv + i*8));
			}

			return sum;
		}

		function putstr(segment, idx, length) {
			length = arguments.length === 3 ? length : bin.length - idx - 1;
			bin = bin.substr(0, idx) + segment + bin.substr(length + idx);
		}

		function write(idx, num, size) {
			var str = '', mv = II ? 0 : -8 * (size - 1), i;

			for (i = 0; i < size; i++) {
				str += String.fromCharCode((num >> Math.abs(mv + i*8)) & 255);
			}

			putstr(str, idx, size);
		}

		// Public functions
		return {
			II: function(order) {
				if (order === undefined) {
					return II;
				} else {
					II = order;
				}
			},

			init: function(binData) {
				II = false;
				bin = binData;
			},

			SEGMENT: function(idx, length, segment) {
				switch (arguments.length) {
					case 1:
						return bin.substr(idx, bin.length - idx - 1);
					case 2:
						return bin.substr(idx, length);
					case 3:
						putstr(segment, idx, length);
						break;
					default: return bin;
				}
			},

			BYTE: function(idx) {
				return read(idx, 1);
			},

			SHORT: function(idx) {
				return read(idx, 2);
			},

			LONG: function(idx, num) {
				if (num === undefined) {
					return read(idx, 4);
				} else {
					write(idx, num, 4);
				}
			},

			SLONG: function(idx) { // 2's complement notation
				var num = read(idx, 4);

				return (num > 2147483647 ? num - 4294967296 : num);
			},

			STRING: function(idx, size) {
				var str = '';

				for (size += idx; idx < size; idx++) {
					str += String.fromCharCode(read(idx, 1));
				}

				return str;
			}
		};
	};
});

// Included from: src/javascript/runtime/html5/image/JPEGHeaders.js

/**
 * JPEGHeaders.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */
 
/**
@class moxie/runtime/html5/image/JPEGHeaders
@private
*/
define("moxie/runtime/html5/image/JPEGHeaders", [
	"moxie/runtime/html5/utils/BinaryReader"
], function(BinaryReader) {
	
	return function JPEGHeaders(data) {
		var headers = [], read, idx, marker, length = 0;

		read = new BinaryReader();
		read.init(data);

		// Check if data is jpeg
		if (read.SHORT(0) !== 0xFFD8) {
			return;
		}

		idx = 2;

		while (idx <= data.length) {
			marker = read.SHORT(idx);

			// omit RST (restart) markers
			if (marker >= 0xFFD0 && marker <= 0xFFD7) {
				idx += 2;
				continue;
			}

			// no headers allowed after SOS marker
			if (marker === 0xFFDA || marker === 0xFFD9) {
				break;
			}

			length = read.SHORT(idx + 2) + 2;

			// APPn marker detected
			if (marker >= 0xFFE1 && marker <= 0xFFEF) {
				headers.push({
					hex: marker,
					name: 'APP' + (marker & 0x000F),
					start: idx,
					length: length,
					segment: read.SEGMENT(idx, length)
				});
			}

			idx += length;
		}

		read.init(null); // free memory

		return {
			headers: headers,

			restore: function(data) {
				var max, i;

				read.init(data);

				idx = read.SHORT(2) == 0xFFE0 ? 4 + read.SHORT(4) : 2;

				for (i = 0, max = headers.length; i < max; i++) {
					read.SEGMENT(idx, 0, headers[i].segment);
					idx += headers[i].length;
				}

				data = read.SEGMENT();
				read.init(null);
				return data;
			},

			strip: function(data) {
				var headers, jpegHeaders, i;

				jpegHeaders = new JPEGHeaders(data);
				headers = jpegHeaders.headers;
				jpegHeaders.purge();

				read.init(data);

				i = headers.length;
				while (i--) {
					read.SEGMENT(headers[i].start, headers[i].length, '');
				}
				
				data = read.SEGMENT();
				read.init(null);
				return data;
			},

			get: function(name) {
				var array = [];

				for (var i = 0, max = headers.length; i < max; i++) {
					if (headers[i].name === name.toUpperCase()) {
						array.push(headers[i].segment);
					}
				}
				return array;
			},

			set: function(name, segment) {
				var array = [], i, ii, max;

				if (typeof(segment) === 'string') {
					array.push(segment);
				} else {
					array = segment;
				}

				for (i = ii = 0, max = headers.length; i < max; i++) {
					if (headers[i].name === name.toUpperCase()) {
						headers[i].segment = array[ii];
						headers[i].length = array[ii].length;
						ii++;
					}
					if (ii >= array.length) {
						break;
					}
				}
			},

			purge: function() {
				headers = [];
				read.init(null);
				read = null;
			}
		};
	};
});

// Included from: src/javascript/runtime/html5/image/ExifParser.js

/**
 * ExifParser.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/ExifParser
@private
*/
define("moxie/runtime/html5/image/ExifParser", [
	"moxie/core/utils/Basic",
	"moxie/runtime/html5/utils/BinaryReader"
], function(Basic, BinaryReader) {
	
	return function ExifParser() {
		// Private ExifParser fields
		var data, tags, Tiff, offsets = {}, tagDescs;

		data = new BinaryReader();

		tags = {
			tiff : {
				/*
				The image orientation viewed in terms of rows and columns.

				1 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
				2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
				3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
				4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
				5 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
				6 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
				7 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
				8 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
				*/
				0x0112: 'Orientation',
				0x010E: 'ImageDescription',
				0x010F: 'Make',
				0x0110: 'Model',
				0x0131: 'Software',
				0x8769: 'ExifIFDPointer',
				0x8825:	'GPSInfoIFDPointer'
			},
			exif : {
				0x9000: 'ExifVersion',
				0xA001: 'ColorSpace',
				0xA002: 'PixelXDimension',
				0xA003: 'PixelYDimension',
				0x9003: 'DateTimeOriginal',
				0x829A: 'ExposureTime',
				0x829D: 'FNumber',
				0x8827: 'ISOSpeedRatings',
				0x9201: 'ShutterSpeedValue',
				0x9202: 'ApertureValue'	,
				0x9207: 'MeteringMode',
				0x9208: 'LightSource',
				0x9209: 'Flash',
				0x920A: 'FocalLength',
				0xA402: 'ExposureMode',
				0xA403: 'WhiteBalance',
				0xA406: 'SceneCaptureType',
				0xA404: 'DigitalZoomRatio',
				0xA408: 'Contrast',
				0xA409: 'Saturation',
				0xA40A: 'Sharpness'
			},
			gps : {
				0x0000: 'GPSVersionID',
				0x0001: 'GPSLatitudeRef',
				0x0002: 'GPSLatitude',
				0x0003: 'GPSLongitudeRef',
				0x0004: 'GPSLongitude'
			}
		};

		tagDescs = {
			'ColorSpace': {
				1: 'sRGB',
				0: 'Uncalibrated'
			},

			'MeteringMode': {
				0: 'Unknown',
				1: 'Average',
				2: 'CenterWeightedAverage',
				3: 'Spot',
				4: 'MultiSpot',
				5: 'Pattern',
				6: 'Partial',
				255: 'Other'
			},

			'LightSource': {
				1: 'Daylight',
				2: 'Fliorescent',
				3: 'Tungsten',
				4: 'Flash',
				9: 'Fine weather',
				10: 'Cloudy weather',
				11: 'Shade',
				12: 'Daylight fluorescent (D 5700 - 7100K)',
				13: 'Day white fluorescent (N 4600 -5400K)',
				14: 'Cool white fluorescent (W 3900 - 4500K)',
				15: 'White fluorescent (WW 3200 - 3700K)',
				17: 'Standard light A',
				18: 'Standard light B',
				19: 'Standard light C',
				20: 'D55',
				21: 'D65',
				22: 'D75',
				23: 'D50',
				24: 'ISO studio tungsten',
				255: 'Other'
			},

			'Flash': {
				0x0000: 'Flash did not fire.',
				0x0001: 'Flash fired.',
				0x0005: 'Strobe return light not detected.',
				0x0007: 'Strobe return light detected.',
				0x0009: 'Flash fired, compulsory flash mode',
				0x000D: 'Flash fired, compulsory flash mode, return light not detected',
				0x000F: 'Flash fired, compulsory flash mode, return light detected',
				0x0010: 'Flash did not fire, compulsory flash mode',
				0x0018: 'Flash did not fire, auto mode',
				0x0019: 'Flash fired, auto mode',
				0x001D: 'Flash fired, auto mode, return light not detected',
				0x001F: 'Flash fired, auto mode, return light detected',
				0x0020: 'No flash function',
				0x0041: 'Flash fired, red-eye reduction mode',
				0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
				0x0047: 'Flash fired, red-eye reduction mode, return light detected',
				0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
				0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
				0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
				0x0059: 'Flash fired, auto mode, red-eye reduction mode',
				0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
				0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
			},

			'ExposureMode': {
				0: 'Auto exposure',
				1: 'Manual exposure',
				2: 'Auto bracket'
			},

			'WhiteBalance': {
				0: 'Auto white balance',
				1: 'Manual white balance'
			},

			'SceneCaptureType': {
				0: 'Standard',
				1: 'Landscape',
				2: 'Portrait',
				3: 'Night scene'
			},

			'Contrast': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			'Saturation': {
				0: 'Normal',
				1: 'Low saturation',
				2: 'High saturation'
			},

			'Sharpness': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			// GPS related
			'GPSLatitudeRef': {
				N: 'North latitude',
				S: 'South latitude'
			},

			'GPSLongitudeRef': {
				E: 'East longitude',
				W: 'West longitude'
			}
		};

		function extractTags(IFD_offset, tags2extract) {
			var length = data.SHORT(IFD_offset), i, ii,
				tag, type, count, tagOffset, offset, value, values = [], hash = {};

			for (i = 0; i < length; i++) {
				// Set binary reader pointer to beginning of the next tag
				offset = tagOffset = IFD_offset + 12 * i + 2;

				tag = tags2extract[data.SHORT(offset)];

				if (tag === undefined) {
					continue; // Not the tag we requested
				}

				type = data.SHORT(offset+=2);
				count = data.LONG(offset+=2);

				offset += 4;
				values = [];

				switch (type) {
					case 1: // BYTE
					case 7: // UNDEFINED
						if (count > 4) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.BYTE(offset + ii);
						}

						break;

					case 2: // STRING
						if (count > 4) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						hash[tag] = data.STRING(offset, count - 1);

						continue;

					case 3: // SHORT
						if (count > 2) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SHORT(offset + ii*2);
						}

						break;

					case 4: // LONG
						if (count > 1) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.LONG(offset + ii*4);
						}

						break;

					case 5: // RATIONAL
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.LONG(offset + ii*4) / data.LONG(offset + ii*4 + 4);
						}

						break;

					case 9: // SLONG
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SLONG(offset + ii*4);
						}

						break;

					case 10: // SRATIONAL
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SLONG(offset + ii*4) / data.SLONG(offset + ii*4 + 4);
						}

						break;

					default:
						continue;
				}

				value = (count == 1 ? values[0] : values);

				if (tagDescs.hasOwnProperty(tag) && typeof value != 'object') {
					hash[tag] = tagDescs[tag][value];
				} else {
					hash[tag] = value;
				}
			}

			return hash;
		}

		function getIFDOffsets() {
			var idx = offsets.tiffHeader;

			// Set read order of multi-byte data
			data.II(data.SHORT(idx) == 0x4949);

			// Check if always present bytes are indeed present
			if (data.SHORT(idx+=2) !== 0x002A) {
				return false;
			}

			offsets.IFD0 = offsets.tiffHeader + data.LONG(idx += 2);
			Tiff = extractTags(offsets.IFD0, tags.tiff);

			if ('ExifIFDPointer' in Tiff) {
				offsets.exifIFD = offsets.tiffHeader + Tiff.ExifIFDPointer;
				delete Tiff.ExifIFDPointer;
			}

			if ('GPSInfoIFDPointer' in Tiff) {
				offsets.gpsIFD = offsets.tiffHeader + Tiff.GPSInfoIFDPointer;
				delete Tiff.GPSInfoIFDPointer;
			}
			return true;
		}

		// At the moment only setting of simple (LONG) values, that do not require offset recalculation, is supported
		function setTag(ifd, tag, value) {
			var offset, length, tagOffset, valueOffset = 0;

			// If tag name passed translate into hex key
			if (typeof(tag) === 'string') {
				var tmpTags = tags[ifd.toLowerCase()];
				for (var hex in tmpTags) {
					if (tmpTags[hex] === tag) {
						tag = hex;
						break;
					}
				}
			}
			offset = offsets[ifd.toLowerCase() + 'IFD'];
			length = data.SHORT(offset);

			for (var i = 0; i < length; i++) {
				tagOffset = offset + 12 * i + 2;

				if (data.SHORT(tagOffset) == tag) {
					valueOffset = tagOffset + 8;
					break;
				}
			}

			if (!valueOffset) {
				return false;
			}

			data.LONG(valueOffset, value);
			return true;
		}


		// Public functions
		return {
			init: function(segment) {
				// Reset internal data
				offsets = {
					tiffHeader: 10
				};

				if (segment === undefined || !segment.length) {
					return false;
				}

				data.init(segment);

				// Check if that's APP1 and that it has EXIF
				if (data.SHORT(0) === 0xFFE1 && data.STRING(4, 5).toUpperCase() === "EXIF\0") {
					return getIFDOffsets();
				}
				return false;
			},

			TIFF: function() {
				return Tiff;
			},

			EXIF: function() {
				var Exif;

				// Populate EXIF hash
				Exif = extractTags(offsets.exifIFD, tags.exif);

				// Fix formatting of some tags
				if (Exif.ExifVersion && Basic.typeOf(Exif.ExifVersion) === 'array') {
					for (var i = 0, exifVersion = ''; i < Exif.ExifVersion.length; i++) {
						exifVersion += String.fromCharCode(Exif.ExifVersion[i]);
					}
					Exif.ExifVersion = exifVersion;
				}

				return Exif;
			},

			GPS: function() {
				var GPS;

				GPS = extractTags(offsets.gpsIFD, tags.gps);

				// iOS devices (and probably some others) do not put in GPSVersionID tag (why?..)
				if (GPS.GPSVersionID && Basic.typeOf(GPS.GPSVersionID) === 'array') {
					GPS.GPSVersionID = GPS.GPSVersionID.join('.');
				}

				return GPS;
			},

			setExif: function(tag, value) {
				// Right now only setting of width/height is possible
				if (tag !== 'PixelXDimension' && tag !== 'PixelYDimension') {return false;}

				return setTag('exif', tag, value);
			},


			getBinary: function() {
				return data.SEGMENT();
			},

			purge: function() {
				data.init(null);
				data = Tiff = null;
				offsets = {};
			}
		};
	};
});

// Included from: src/javascript/runtime/html5/image/JPEG.js

/**
 * JPEG.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/JPEG
@private
*/
define("moxie/runtime/html5/image/JPEG", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/html5/image/JPEGHeaders",
	"moxie/runtime/html5/utils/BinaryReader",
	"moxie/runtime/html5/image/ExifParser"
], function(Basic, x, JPEGHeaders, BinaryReader, ExifParser) {
	
	function JPEG(binstr) {
		var _binstr, _br, _hm, _ep, _info, hasExif;

		function _getDimensions() {
			var idx = 0, marker, length;

			// examine all through the end, since some images might have very large APP segments
			while (idx <= _binstr.length) {
				marker = _br.SHORT(idx += 2);

				if (marker >= 0xFFC0 && marker <= 0xFFC3) { // SOFn
					idx += 5; // marker (2 bytes) + length (2 bytes) + Sample precision (1 byte)
					return {
						height: _br.SHORT(idx),
						width: _br.SHORT(idx += 2)
					};
				}
				length = _br.SHORT(idx += 2);
				idx += length - 2;
			}
			return null;
		}

		_binstr = binstr;

		_br = new BinaryReader();
		_br.init(_binstr);

		// check if it is jpeg
		if (_br.SHORT(0) !== 0xFFD8) {
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}

		// backup headers
		_hm = new JPEGHeaders(binstr);

		// extract exif info
		_ep = new ExifParser();
		hasExif = !!_ep.init(_hm.get('app1')[0]);

		// get dimensions
		_info = _getDimensions.call(this);

		Basic.extend(this, {
			type: 'image/jpeg',

			size: _binstr.length,

			width: _info && _info.width || 0,

			height: _info && _info.height || 0,

			setExif: function(tag, value) {
				if (!hasExif) {
					return false; // or throw an exception
				}

				if (Basic.typeOf(tag) === 'object') {
					Basic.each(tag, function(value, tag) {
						_ep.setExif(tag, value);
					});
				} else {
					_ep.setExif(tag, value);
				}

				// update internal headers
				_hm.set('app1', _ep.getBinary());
			},

			writeHeaders: function() {
				if (!arguments.length) {
					// if no arguments passed, update headers internally
					return (_binstr = _hm.restore(_binstr));
				}
				return _hm.restore(arguments[0]);
			},

			stripHeaders: function(binstr) {
				return _hm.strip(binstr);
			},

			purge: function() {
				_purge.call(this);
			}
		});

		if (hasExif) {
			this.meta = {
				tiff: _ep.TIFF(),
				exif: _ep.EXIF(),
				gps: _ep.GPS()
			};
		}

		function _purge() {
			if (!_ep || !_hm || !_br) { 
				return; // ignore any repeating purge requests
			}
			_ep.purge();
			_hm.purge();
			_br.init(null);
			_binstr = _info = _hm = _ep = _br = null;
		}
	}

	return JPEG;
});

// Included from: src/javascript/runtime/html5/image/PNG.js

/**
 * PNG.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/PNG
@private
*/
define("moxie/runtime/html5/image/PNG", [
	"moxie/core/Exceptions",
	"moxie/core/utils/Basic",
	"moxie/runtime/html5/utils/BinaryReader"
], function(x, Basic, BinaryReader) {
	
	function PNG(binstr) {
		var _binstr, _br, _hm, _ep, _info;

		_binstr = binstr;

		_br = new BinaryReader();
		_br.init(_binstr);

		// check if it's png
		(function() {
			var idx = 0, i = 0
			, signature = [0x8950, 0x4E47, 0x0D0A, 0x1A0A]
			;

			for (i = 0; i < signature.length; i++, idx += 2) {
				if (signature[i] != _br.SHORT(idx)) {
					throw new x.ImageError(x.ImageError.WRONG_FORMAT);
				}
			}
		}());

		function _getDimensions() {
			var chunk, idx;

			chunk = _getChunkAt.call(this, 8);

			if (chunk.type == 'IHDR') {
				idx = chunk.start;
				return {
					width: _br.LONG(idx),
					height: _br.LONG(idx += 4)
				};
			}
			return null;
		}

		function _purge() {
			if (!_br) {
				return; // ignore any repeating purge requests
			}
			_br.init(null);
			_binstr = _info = _hm = _ep = _br = null;
		}

		_info = _getDimensions.call(this);

		Basic.extend(this, {
			type: 'image/png',

			size: _binstr.length,

			width: _info.width,

			height: _info.height,

			purge: function() {
				_purge.call(this);
			}
		});

		// for PNG we can safely trigger purge automatically, as we do not keep any data for later
		_purge.call(this);

		function _getChunkAt(idx) {
			var length, type, start, CRC;

			length = _br.LONG(idx);
			type = _br.STRING(idx += 4, 4);
			start = idx += 4;
			CRC = _br.LONG(idx + length);

			return {
				length: length,
				type: type,
				start: start,
				CRC: CRC
			};
		}
	}

	return PNG;
});

// Included from: src/javascript/runtime/html5/image/ImageInfo.js

/**
 * ImageInfo.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/ImageInfo
@private
*/
define("moxie/runtime/html5/image/ImageInfo", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/html5/image/JPEG",
	"moxie/runtime/html5/image/PNG"
], function(Basic, x, JPEG, PNG) {
	/**
	Optional image investigation tool for HTML5 runtime. Provides the following features:
	- ability to distinguish image type (JPEG or PNG) by signature
	- ability to extract image width/height directly from it's internals, without preloading in memory (fast)
	- ability to extract APP headers from JPEGs (Exif, GPS, etc)
	- ability to replace width/height tags in extracted JPEG headers
	- ability to restore APP headers, that were for example stripped during image manipulation

	@class ImageInfo
	@constructor
	@param {String} binstr Image source as binary string
	*/
	return function(binstr) {
		var _cs = [JPEG, PNG], _img;

		// figure out the format, throw: ImageError.WRONG_FORMAT if not supported
		_img = (function() {
			for (var i = 0; i < _cs.length; i++) {
				try {
					return new _cs[i](binstr);
				} catch (ex) {
					// console.info(ex);
				}
			}
			throw new x.ImageError(x.ImageError.WRONG_FORMAT);
		}());

		Basic.extend(this, {
			/**
			Image Mime Type extracted from it's depths

			@property type
			@type {String}
			@default ''
			*/
			type: '',

			/**
			Image size in bytes

			@property size
			@type {Number}
			@default 0
			*/
			size: 0,

			/**
			Image width extracted from image source

			@property width
			@type {Number}
			@default 0
			*/
			width: 0,

			/**
			Image height extracted from image source

			@property height
			@type {Number}
			@default 0
			*/
			height: 0,

			/**
			Sets Exif tag. Currently applicable only for width and height tags. Obviously works only with JPEGs.

			@method setExif
			@param {String} tag Tag to set
			@param {Mixed} value Value to assign to the tag
			*/
			setExif: function() {},

			/**
			Restores headers to the source.

			@method writeHeaders
			@param {String} data Image source as binary string
			@return {String} Updated binary string
			*/
			writeHeaders: function(data) {
				return data;
			},

			/**
			Strip all headers from the source.

			@method stripHeaders
			@param {String} data Image source as binary string
			@return {String} Updated binary string
			*/
			stripHeaders: function(data) {
				return data;
			},

			/**
			Dispose resources.

			@method purge
			*/
			purge: function() {}
		});

		Basic.extend(this, _img);

		this.purge = function() {
			_img.purge();
			_img = null;
		};
	};
});

// Included from: src/javascript/runtime/html5/image/MegaPixel.js

/**
(The MIT License)

Copyright (c) 2012 Shinichi Tomita <shinichi.tomita@gmail.com>;

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * Mega pixel image rendering library for iOS6 Safari
 *
 * Fixes iOS6 Safari's image file rendering issue for large size image (over mega-pixel),
 * which causes unexpected subsampling when drawing it in canvas.
 * By using this library, you can safely render the image with proper stretching.
 *
 * Copyright (c) 2012 Shinichi Tomita <shinichi.tomita@gmail.com>
 * Released under the MIT license
 */

/**
@class moxie/runtime/html5/image/MegaPixel
@private
*/
define("moxie/runtime/html5/image/MegaPixel", [], function() {

	/**
	 * Rendering image element (with resizing) into the canvas element
	 */
	function renderImageToCanvas(img, canvas, options) {
		var iw = img.naturalWidth, ih = img.naturalHeight;
		var width = options.width, height = options.height;
		var x = options.x || 0, y = options.y || 0;
		var ctx = canvas.getContext('2d');
		if (detectSubsampling(img)) {
			iw /= 2;
			ih /= 2;
		}
		var d = 1024; // size of tiling canvas
		var tmpCanvas = document.createElement('canvas');
		tmpCanvas.width = tmpCanvas.height = d;
		var tmpCtx = tmpCanvas.getContext('2d');
		var vertSquashRatio = detectVerticalSquash(img, iw, ih);
		var sy = 0;
		while (sy < ih) {
			var sh = sy + d > ih ? ih - sy : d;
			var sx = 0;
			while (sx < iw) {
				var sw = sx + d > iw ? iw - sx : d;
				tmpCtx.clearRect(0, 0, d, d);
				tmpCtx.drawImage(img, -sx, -sy);
				var dx = (sx * width / iw + x) << 0;
				var dw = Math.ceil(sw * width / iw);
				var dy = (sy * height / ih / vertSquashRatio + y) << 0;
				var dh = Math.ceil(sh * height / ih / vertSquashRatio);
				ctx.drawImage(tmpCanvas, 0, 0, sw, sh, dx, dy, dw, dh);
				sx += d;
			}
			sy += d;
		}
		tmpCanvas = tmpCtx = null;
	}

	/**
	 * Detect subsampling in loaded image.
	 * In iOS, larger images than 2M pixels may be subsampled in rendering.
	 */
	function detectSubsampling(img) {
		var iw = img.naturalWidth, ih = img.naturalHeight;
		if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image
			var canvas = document.createElement('canvas');
			canvas.width = canvas.height = 1;
			var ctx = canvas.getContext('2d');
			ctx.drawImage(img, -iw + 1, 0);
			// subsampled image becomes half smaller in rendering size.
			// check alpha channel value to confirm image is covering edge pixel or not.
			// if alpha value is 0 image is not covering, hence subsampled.
			return ctx.getImageData(0, 0, 1, 1).data[3] === 0;
		} else {
			return false;
		}
	}


	/**
	 * Detecting vertical squash in loaded image.
	 * Fixes a bug which squash image vertically while drawing into canvas for some images.
	 */
	function detectVerticalSquash(img, iw, ih) {
		var canvas = document.createElement('canvas');
		canvas.width = 1;
		canvas.height = ih;
		var ctx = canvas.getContext('2d');
		ctx.drawImage(img, 0, 0);
		var data = ctx.getImageData(0, 0, 1, ih).data;
		// search image edge pixel position in case it is squashed vertically.
		var sy = 0;
		var ey = ih;
		var py = ih;
		while (py > sy) {
			var alpha = data[(py - 1) * 4 + 3];
			if (alpha === 0) {
				ey = py;
			} else {
			sy = py;
			}
			py = (ey + sy) >> 1;
		}
		canvas = null;
		var ratio = (py / ih);
		return (ratio === 0) ? 1 : ratio;
	}

	return {
		isSubsampled: detectSubsampling,
		renderTo: renderImageToCanvas
	};
});

// Included from: src/javascript/runtime/html5/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html5/image/Image
@private
*/
define("moxie/runtime/html5/image/Image", [
	"moxie/runtime/html5/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/core/utils/Encode",
	"moxie/file/File",
	"moxie/runtime/html5/image/ImageInfo",
	"moxie/runtime/html5/image/MegaPixel",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, Basic, x, Encode, File, ImageInfo, MegaPixel, Mime, Env) {
	
	function HTML5Image() {
		var me = this
		, _img, _imgInfo, _canvas, _binStr, _blob
		, _modified = false // is set true whenever image is modified
		, _preserveHeaders = true
		;

		Basic.extend(this, {
			loadFromBlob: function(blob) {
				var comp = this, I = comp.getRuntime()
				, asBinary = arguments.length > 1 ? arguments[1] : true
				;

				if (!I.can('access_binary')) {
					throw new x.RuntimeError(x.RuntimeError.NOT_SUPPORTED_ERR);
				}

				_blob = blob;

				if (blob.isDetached()) {
					_binStr = blob.getSource();
					_preload.call(this, _binStr);
					return;
				} else {
					_readAsDataUrl.call(this, blob.getSource(), function(dataUrl) {
						if (asBinary) {
							_binStr = _toBinary(dataUrl);
						}
						_preload.call(comp, dataUrl);
					});
				}
			},

			loadFromImage: function(img, exact) {
				this.meta = img.meta;

				_blob = new File(null, {
					name: img.name,
					size: img.size,
					type: img.type
				});

				_preload.call(this, exact ? (_binStr = img.getAsBinaryString()) : img.getAsDataURL());
			},

			getInfo: function() {
				var I = this.getRuntime(), info;

				if (!_imgInfo && _binStr && I.can('access_image_binary')) {
					_imgInfo = new ImageInfo(_binStr);
				}

				info = {
					width: _getImg().width || 0,
					height: _getImg().height || 0,
					type: _blob.type || Mime.getFileMime(_blob.name),
					size: _binStr && _binStr.length || _blob.size || 0,
					name: _blob.name || '',
					meta: _imgInfo && _imgInfo.meta || this.meta || {}
				};

				return info;
			},

			downsize: function() {
				_downsize.apply(this, arguments);
			},

			getAsCanvas: function() {
				if (_canvas) {
					_canvas.id = this.uid + '_canvas';
				}
				return _canvas;
			},

			getAsBlob: function(type, quality) {
				if (type !== this.type) {
					// if different mime type requested prepare image for conversion
					_downsize.call(this, this.width, this.height, false);
				}
				return new File(null, {
					name: _blob.name || '',
					type: type,
					data: me.getAsBinaryString.call(this, type, quality)
				});
			},

			getAsDataURL: function(type) {
				var quality = arguments[1] || 90;

				// if image has not been modified, return the source right away
				if (!_modified) {
					return _img.src;
				}

				if ('image/jpeg' !== type) {
					return _canvas.toDataURL('image/png');
				} else {
					try {
						// older Geckos used to result in an exception on quality argument
						return _canvas.toDataURL('image/jpeg', quality/100);
					} catch (ex) {
						return _canvas.toDataURL('image/jpeg');
					}
				}
			},

			getAsBinaryString: function(type, quality) {
				// if image has not been modified, return the source right away
				if (!_modified) {
					// if image was not loaded from binary string
					if (!_binStr) {
						_binStr = _toBinary(me.getAsDataURL(type, quality));
					}
					return _binStr;
				}

				if ('image/jpeg' !== type) {
					_binStr = _toBinary(me.getAsDataURL(type, quality));
				} else {
					var dataUrl;

					// if jpeg
					if (!quality) {
						quality = 90;
					}

					try {
						// older Geckos used to result in an exception on quality argument
						dataUrl = _canvas.toDataURL('image/jpeg', quality/100);
					} catch (ex) {
						dataUrl = _canvas.toDataURL('image/jpeg');
					}

					_binStr = _toBinary(dataUrl);

					if (_imgInfo) {
						_binStr = _imgInfo.stripHeaders(_binStr);

						if (_preserveHeaders) {
							// update dimensions info in exif
							if (_imgInfo.meta && _imgInfo.meta.exif) {
								_imgInfo.setExif({
									PixelXDimension: this.width,
									PixelYDimension: this.height
								});
							}

							// re-inject the headers
							_binStr = _imgInfo.writeHeaders(_binStr);
						}

						// will be re-created from fresh on next getInfo call
						_imgInfo.purge();
						_imgInfo = null;
					}
				}

				_modified = false;

				return _binStr;
			},

			destroy: function() {
				me = null;
				_purge.call(this);
				this.getRuntime().getShim().removeInstance(this.uid);
			}
		});


		function _getImg() {
			if (!_canvas && !_img) {
				throw new x.ImageError(x.DOMException.INVALID_STATE_ERR);
			}
			return _canvas || _img;
		}


		function _toBinary(str) {
			return Encode.atob(str.substring(str.indexOf('base64,') + 7));
		}


		function _toDataUrl(str, type) {
			return 'data:' + (type || '') + ';base64,' + Encode.btoa(str);
		}


		function _preload(str) {
			var comp = this;

			_img = new Image();
			_img.onerror = function() {
				_purge.call(this);
				comp.trigger('error', new x.ImageError(x.ImageError.WRONG_FORMAT));
			};
			_img.onload = function() {
				comp.trigger('load');
			};

			_img.src = /^data:[^;]*;base64,/.test(str) ? str : _toDataUrl(str, _blob.type);
		}


		function _readAsDataUrl(file, callback) {
			var comp = this, fr;

			// use FileReader if it's available
			if (window.FileReader) {
				fr = new FileReader();
				fr.onload = function() {
					callback(this.result);
				};
				fr.onerror = function() {
					comp.trigger('error', new x.FileException(x.FileException.NOT_READABLE_ERR));
				};
				fr.readAsDataURL(file);
			} else {
				return callback(file.getAsDataURL());
			}
		}

		function _downsize(width, height, crop, preserveHeaders) {
			var self = this
			, scale
			, mathFn
			, x = 0
			, y = 0
			, img
			, destWidth
			, destHeight
			, orientation
			;

			_preserveHeaders = preserveHeaders; // we will need to check this on export (see getAsBinaryString())

			// take into account orientation tag
			orientation = (this.meta && this.meta.tiff && this.meta.tiff.Orientation) || 1;

			if (Basic.inArray(orientation, [5,6,7,8]) !== -1) { // values that require 90 degree rotation
				// swap dimensions
				var tmp = width;
				width = height;
				height = tmp;
			}

			img = _getImg();

			// unify dimensions
			mathFn = !crop ? Math.min : Math.max;
			scale = mathFn(width/img.width, height/img.height);
		
			// we only downsize here
			if (scale > 1 && (!crop || preserveHeaders)) { // when cropping one of dimensions may still exceed max, so process it anyway
				this.trigger('Resize');
				return;
			}

			// prepare canvas if necessary
			if (!_canvas) {
				_canvas = document.createElement("canvas");
			}

			// calculate dimensions of proportionally resized image
			destWidth = Math.round(img.width * scale);	
			destHeight = Math.round(img.height * scale);


			// scale image and canvas
			if (crop) {
				_canvas.width = width;
				_canvas.height = height;

				// if dimensions of the resulting image still larger than canvas, center it
				if (destWidth > width) {
					x = Math.round((destWidth - width) / 2);
				}

				if (destHeight > height) {
					y = Math.round((destHeight - height) / 2);
				}
			} else {
				_canvas.width = destWidth;
				_canvas.height = destHeight;
			}

			// rotate if required, according to orientation tag
			if (!_preserveHeaders) {
				_rotateToOrientaion(_canvas.width, _canvas.height, orientation);
			}

			_drawToCanvas.call(this, img, _canvas, -x, -y, destWidth, destHeight);

			this.width = _canvas.width;
			this.height = _canvas.height;

			_modified = true;
			self.trigger('Resize');
		}


		function _drawToCanvas(img, canvas, x, y, w, h) {
			if (Env.OS === 'iOS') { 
				// avoid squish bug in iOS6
				MegaPixel.renderTo(img, canvas, { width: w, height: h, x: x, y: y });
			} else {
				var ctx = canvas.getContext('2d');
				ctx.drawImage(img, x, y, w, h);
			}
		}


		/**
		* Transform canvas coordination according to specified frame size and orientation
		* Orientation value is from EXIF tag
		* @author Shinichi Tomita <shinichi.tomita@gmail.com>
		*/
		function _rotateToOrientaion(width, height, orientation) {
			switch (orientation) {
				case 5:
				case 6:
				case 7:
				case 8:
					_canvas.width = height;
					_canvas.height = width;
					break;
				default:
					_canvas.width = width;
					_canvas.height = height;
			}

			/**
			1 = The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
			2 = The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
			3 = The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
			4 = The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
			5 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
			6 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
			7 = The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
			8 = The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
			*/

			var ctx = _canvas.getContext('2d');
			switch (orientation) {
				case 2:
					// horizontal flip
					ctx.translate(width, 0);
					ctx.scale(-1, 1);
					break;
				case 3:
					// 180 rotate left
					ctx.translate(width, height);
					ctx.rotate(Math.PI);
					break;
				case 4:
					// vertical flip
					ctx.translate(0, height);
					ctx.scale(1, -1);
					break;
				case 5:
					// vertical flip + 90 rotate right
					ctx.rotate(0.5 * Math.PI);
					ctx.scale(1, -1);
					break;
				case 6:
					// 90 rotate right
					ctx.rotate(0.5 * Math.PI);
					ctx.translate(0, -height);
					break;
				case 7:
					// horizontal flip + 90 rotate right
					ctx.rotate(0.5 * Math.PI);
					ctx.translate(width, -height);
					ctx.scale(-1, 1);
					break;
				case 8:
					// 90 rotate left
					ctx.rotate(-0.5 * Math.PI);
					ctx.translate(-width, 0);
					break;
			}
		}


		function _purge() {
			if (_imgInfo) {
				_imgInfo.purge();
				_imgInfo = null;
			}
			_binStr = _img = _canvas = _blob = null;
			_modified = false;
		}
	}

	return (extensions.Image = HTML5Image);
});

// Included from: src/javascript/runtime/flash/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
Defines constructor for Flash runtime.

@class moxie/runtime/flash/Runtime
@private
*/
define("moxie/runtime/flash/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Env",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime"
], function(Basic, Env, Dom, x, Runtime) {
	
	var type = 'flash', extensions = {};

	/**
	Get the version of the Flash Player

	@method getShimVersion
	@private
	@return {Number} Flash Player version
	*/
	function getShimVersion() {
		var version;

		try {
			version = navigator.plugins['Shockwave Flash'];
			version = version.description;
		} catch (e1) {
			try {
				version = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
			} catch (e2) {
				version = '0.0';
			}
		}
		version = version.match(/\d+/g);
		return parseFloat(version[0] + '.' + version[1]);
	}

	/**
	Constructor for the Flash Runtime

	@class FlashRuntime
	@extends Runtime
	*/
	function FlashRuntime(options) {
		var I = this, initTimer;

		options = Basic.extend({ swf_url: Env.swf_url }, options);

		Runtime.call(this, options, type, {
			access_binary: function(value) {
				return value && I.mode === 'browser';
			},
			access_image_binary: function(value) {
				return value && I.mode === 'browser';
			},
			display_media: Runtime.capTrue,
			do_cors: Runtime.capTrue,
			drag_and_drop: false,
			report_upload_progress: function() {
				return I.mode === 'client';
			},
			resize_image: Runtime.capTrue,
			return_response_headers: false,
			return_response_type: function(responseType) {
				if (responseType === 'json' && !!window.JSON) {
					return true;
				} 
				return !Basic.arrayDiff(responseType, ['', 'text', 'document']) || I.mode === 'browser';
			},
			return_status_code: function(code) {
				return I.mode === 'browser' || !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: Runtime.capTrue,
			select_multiple: Runtime.capTrue,
			send_binary_string: function(value) {
				return value && I.mode === 'browser';
			},
			send_browser_cookies: function(value) {
				return value && I.mode === 'browser';
			},
			send_custom_headers: function(value) {
				return value && I.mode === 'browser';
			},
			send_multipart: Runtime.capTrue,
			slice_blob: Runtime.capTrue,
			stream_upload: function(value) {
				return value && I.mode === 'browser';
			},
			summon_file_dialog: false,
			upload_filesize: function(size) {
				return Basic.parseSizeStr(size) <= 2097152 || I.mode === 'client';
			},
			use_http_method: function(methods) {
				return !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		}, { 
			// capabilities that require specific mode
			access_binary: function(value) {
				return value ? 'browser' : 'client';
			},
			access_image_binary: function(value) {
				return value ? 'browser' : 'client';
			},
			report_upload_progress: function(value) {
				return value ? 'browser' : 'client';
			},
			return_response_type: function(responseType) {
				return Basic.arrayDiff(responseType, ['', 'text', 'json', 'document']) ? 'browser' : ['client', 'browser'];
			},
			return_status_code: function(code) {
				return Basic.arrayDiff(code, [200, 404]) ? 'browser' : ['client', 'browser'];
			},
			send_binary_string: function(value) {
				return value ? 'browser' : 'client';
			},
			send_browser_cookies: function(value) {
				return value ? 'browser' : 'client';
			},
			send_custom_headers: function(value) {
				return value ? 'browser' : 'client';
			},
			stream_upload: function(value) {
				return value ? 'client' : 'browser';
			},
			upload_filesize: function(size) {
				return Basic.parseSizeStr(size) >= 2097152 ? 'client' : 'browser';
			}
		}, 'client');


		// minimal requirement for Flash Player version
		if (getShimVersion() < 10) {
			this.mode = false; // with falsy mode, runtime won't operable, no matter what the mode was before
		}


		Basic.extend(this, {

			getShim: function() {
				return Dom.get(this.uid);
			},

			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return I.getShim().exec(this.uid, component, action, args);
			},

			init: function() {
				var html, el, container;

				container = this.getShimContainer();

				// if not the minimal height, shims are not initialized in older browsers (e.g FF3.6, IE6,7,8, Safari 4.0,5.0, etc)
				Basic.extend(container.style, {
					position: 'absolute',
					top: '-8px',
					left: '-8px',
					width: '9px',
					height: '9px',
					overflow: 'hidden'
				});

				// insert flash object
				html = '<object id="' + this.uid + '" type="application/x-shockwave-flash" data="' +  options.swf_url + '" ';

				if (Env.browser === 'IE') {
					html += 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" ';
				}

				html += 'width="100%" height="100%" style="outline:0">'  +
					'<param name="movie" value="' + options.swf_url + '" />' +
					'<param name="flashvars" value="uid=' + escape(this.uid) + '&target=' + Env.global_event_dispatcher + '" />' +
					'<param name="wmode" value="transparent" />' +
					'<param name="allowscriptaccess" value="always" />' +
				'</object>';

				if (Env.browser === 'IE') {
					el = document.createElement('div');
					container.appendChild(el);
					el.outerHTML = html;
					el = container = null; // just in case
				} else {
					container.innerHTML = html;
				}

				// Init is dispatched by the shim
				initTimer = setTimeout(function() {
					if (I && !I.initialized) { // runtime might be already destroyed by this moment
						I.trigger("Error", new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));
					}
				}, 5000);
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					clearTimeout(initTimer); // initialization check might be still onwait
					options = initTimer = destroy = I = null;
				};
			}(this.destroy))

		}, extensions);
	}

	Runtime.addConstructor(type, FlashRuntime);

	return extensions;
});

// Included from: src/javascript/runtime/flash/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/Blob
@private
*/
define("moxie/runtime/flash/file/Blob", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	var FlashBlob = {
		slice: function(blob, start, end, type) {
			var self = this.getRuntime();

			if (start < 0) {
				start = Math.max(blob.size + start, 0);
			} else if (start > 0) {
				start = Math.min(start, blob.size);
			}

			if (end < 0) {
				end = Math.max(blob.size + end, 0);
			} else if (end > 0) {
				end = Math.min(end, blob.size);
			}

			blob = self.shimExec.call(this, 'Blob', 'slice', start, end, type || '');

			if (blob) {
				blob = new Blob(self.uid, blob);
			}
			return blob;
		}
	};

	return (extensions.Blob = FlashBlob);
});

// Included from: src/javascript/runtime/flash/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileInput
@private
*/
define("moxie/runtime/flash/file/FileInput", [
	"moxie/runtime/flash/Runtime"
], function(extensions) {
	
	var FileInput = {		
		init: function(options) {
			this.getRuntime().shimExec.call(this, 'FileInput', 'init', {
				name: options.name,
				accept: options.accept,
				multiple: options.multiple
			});
			this.trigger('ready');
		}
	};

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/flash/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileReader
@private
*/
define("moxie/runtime/flash/file/FileReader", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Encode"
], function(extensions, Encode) {

	var _result = '';

	function _formatData(data, op) {
		switch (op) {
			case 'readAsText':
				return Encode.atob(data, 'utf8');
			case 'readAsBinaryString':
				return Encode.atob(data);
			case 'readAsDataURL':
				return data;
		}
		return null;
	}

	var FileReader = {
		read: function(op, blob) {
			var target = this, self = target.getRuntime();

			// special prefix for DataURL read mode
			if (op === 'readAsDataURL') {
				_result = 'data:' + (blob.type || '') + ';base64,';
			}

			target.bind('Progress', function(e, data) {
				if (data) {
					_result += _formatData(data, op);
				}
			});

			return self.shimExec.call(this, 'FileReader', 'readAsBase64', blob.uid);
		},

		getResult: function() {
			return _result;
		},

		destroy: function() {
			_result = null;
		}
	};

	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/flash/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/file/FileReaderSync
@private
*/
define("moxie/runtime/flash/file/FileReaderSync", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Encode"
], function(extensions, Encode) {
	
	function _formatData(data, op) {
		switch (op) {
			case 'readAsText':
				return Encode.atob(data, 'utf8');
			case 'readAsBinaryString':
				return Encode.atob(data);
			case 'readAsDataURL':
				return data;
		}
		return null;
	}

	var FileReaderSync = {
		read: function(op, blob) {
			var result, self = this.getRuntime();

			result = self.shimExec.call(this, 'FileReaderSync', 'readAsBase64', blob.uid);
			if (!result) {
				return null; // or throw ex
			}

			// special prefix for DataURL read mode
			if (op === 'readAsDataURL') {
				result = 'data:' + (blob.type || '') + ';base64,' + result;
			}

			return _formatData(result, op, blob.type);
		}
	};

	return (extensions.FileReaderSync = FileReaderSync);
});

// Included from: src/javascript/runtime/flash/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/flash/xhr/XMLHttpRequest", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Basic",
	"moxie/file/Blob",
	"moxie/file/File",
	"moxie/file/FileReaderSync",
	"moxie/xhr/FormData",
	"moxie/runtime/Transporter"
], function(extensions, Basic, Blob, File, FileReaderSync, FormData, Transporter) {
	
	var XMLHttpRequest = {

		send: function(meta, data) {
			var target = this, self = target.getRuntime();

			function send() {
				meta.transport = self.mode;
				self.shimExec.call(target, 'XMLHttpRequest', 'send', meta, data);
			}


			function appendBlob(name, blob) {
				self.shimExec.call(target, 'XMLHttpRequest', 'appendBlob', name, blob.uid);
				data = null;
				send();
			}


			function attachBlob(blob, cb) {
				var tr = new Transporter();

				tr.bind("TransportingComplete", function() {
					cb(this.result);
				});

				tr.transport(blob.getSource(), blob.type, {
					ruid: self.uid
				});
			}

			// copy over the headers if any
			if (!Basic.isEmptyObj(meta.headers)) {
				Basic.each(meta.headers, function(value, header) {
					self.shimExec.call(target, 'XMLHttpRequest', 'setRequestHeader', header, value.toString()); // Silverlight doesn't accept integers into the arguments of type object
				});
			}

			// transfer over multipart params and blob itself
			if (data instanceof FormData) {
				var blobField;
				data.each(function(value, name) {
					if (value instanceof Blob) {
						blobField = name;
					} else {
						self.shimExec.call(target, 'XMLHttpRequest', 'append', name, value);
					}
				});

				if (!data.hasBlob()) {
					data = null;
					send();
				} else {
					var blob = data.getBlob();
					if (blob.isDetached()) {
						attachBlob(blob, function(attachedBlob) {
							blob.destroy();
							appendBlob(blobField, attachedBlob);		
						});
					} else {
						appendBlob(blobField, blob);
					}
				}
			} else if (data instanceof Blob) {
				if (data.isDetached()) {
					attachBlob(data, function(attachedBlob) {
						data.destroy();
						data = attachedBlob.uid;
						send();
					});
				} else {
					data = data.uid;
					send();
				}
			} else {
				send();
			}
		},

		getResponse: function(responseType) {
			var frs, blob, self = this.getRuntime();

			blob = self.shimExec.call(this, 'XMLHttpRequest', 'getResponseAsBlob');

			if (blob) {
				blob = new File(self.uid, blob);

				if ('blob' === responseType) {
					return blob;
				}

				try { 
					frs = new FileReaderSync();

					if (!!~Basic.inArray(responseType, ["", "text"])) {
						return frs.readAsText(blob);
					} else if ('json' === responseType && !!window.JSON) {
						return JSON.parse(frs.readAsText(blob));
					}
				} finally {
					blob.destroy();
				}
			}
			return null;
		},

		abort: function(upload_complete_flag) {
			var self = this.getRuntime();

			self.shimExec.call(this, 'XMLHttpRequest', 'abort');

			this.dispatchEvent('readystatechange');
			// this.dispatchEvent('progress');
			this.dispatchEvent('abort');

			//if (!upload_complete_flag) {
				// this.dispatchEvent('uploadprogress');
			//}
		}
	};

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/flash/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/runtime/Transporter
@private
*/
define("moxie/runtime/flash/runtime/Transporter", [
	"moxie/runtime/flash/Runtime",
	"moxie/file/Blob"
], function(extensions, Blob) {

	var Transporter = {
		getAsBlob: function(type) {
			var self = this.getRuntime()
			, blob = self.shimExec.call(this, 'Transporter', 'getAsBlob', type)
			;
			if (blob) {
				return new Blob(self.uid, blob);
			}
			return null;
		}
	};

	return (extensions.Transporter = Transporter);
});

// Included from: src/javascript/runtime/flash/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/flash/image/Image
@private
*/
define("moxie/runtime/flash/image/Image", [
	"moxie/runtime/flash/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/Transporter",
	"moxie/file/Blob",
	"moxie/file/FileReaderSync"
], function(extensions, Basic, Transporter, Blob, FileReaderSync) {
	
	var Image = {
		loadFromBlob: function(blob) {
			var comp = this, self = comp.getRuntime();

			function exec(srcBlob) {
				self.shimExec.call(comp, 'Image', 'loadFromBlob', srcBlob.uid);
				comp = self = null;
			}

			if (blob.isDetached()) { // binary string
				var tr = new Transporter();
				tr.bind("TransportingComplete", function() {
					exec(tr.result.getSource());
				});
				tr.transport(blob.getSource(), blob.type, { ruid: self.uid });
			} else {
				exec(blob.getSource());
			}
		},

		loadFromImage: function(img) {
			var self = this.getRuntime();
			return self.shimExec.call(this, 'Image', 'loadFromImage', img.uid);
		},

		getAsBlob: function(type, quality) {
			var self = this.getRuntime()
			, blob = self.shimExec.call(this, 'Image', 'getAsBlob', type, quality)
			;
			if (blob) {
				return new Blob(self.uid, blob);
			}
			return null;
		},

		getAsDataURL: function() {
			var self = this.getRuntime()
			, blob = self.Image.getAsBlob.apply(this, arguments)
			, frs
			;
			if (!blob) {
				return null;
			}
			frs = new FileReaderSync();
			return frs.readAsDataURL(blob);
		}
	};

	return (extensions.Image = Image);
});

// Included from: src/javascript/runtime/silverlight/Runtime.js

/**
 * RunTime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global ActiveXObject:true */

/**
Defines constructor for Silverlight runtime.

@class moxie/runtime/silverlight/Runtime
@private
*/
define("moxie/runtime/silverlight/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/utils/Env",
	"moxie/core/utils/Dom",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime"
], function(Basic, Env, Dom, x, Runtime) {
	
	var type = "silverlight", extensions = {};

	function isInstalled(version) {
		var isVersionSupported = false, control = null, actualVer,
			actualVerArray, reqVerArray, requiredVersionPart, actualVersionPart, index = 0;

		try {
			try {
				control = new ActiveXObject('AgControl.AgControl');

				if (control.IsVersionSupported(version)) {
					isVersionSupported = true;
				}

				control = null;
			} catch (e) {
				var plugin = navigator.plugins["Silverlight Plug-In"];

				if (plugin) {
					actualVer = plugin.description;

					if (actualVer === "1.0.30226.2") {
						actualVer = "2.0.30226.2";
					}

					actualVerArray = actualVer.split(".");

					while (actualVerArray.length > 3) {
						actualVerArray.pop();
					}

					while ( actualVerArray.length < 4) {
						actualVerArray.push(0);
					}

					reqVerArray = version.split(".");

					while (reqVerArray.length > 4) {
						reqVerArray.pop();
					}

					do {
						requiredVersionPart = parseInt(reqVerArray[index], 10);
						actualVersionPart = parseInt(actualVerArray[index], 10);
						index++;
					} while (index < reqVerArray.length && requiredVersionPart === actualVersionPart);

					if (requiredVersionPart <= actualVersionPart && !isNaN(requiredVersionPart)) {
						isVersionSupported = true;
					}
				}
			}
		} catch (e2) {
			isVersionSupported = false;
		}

		return isVersionSupported;
	}

	/**
	Constructor for the Silverlight Runtime

	@class SilverlightRuntime
	@extends Runtime
	*/
	function SilverlightRuntime(options) {
		var I = this, initTimer;

		options = Basic.extend({ xap_url: Env.xap_url }, options);

		Runtime.call(this, options, type, {
			access_binary: Runtime.capTrue,
			access_image_binary: Runtime.capTrue,
			display_media: Runtime.capTrue,
			do_cors: Runtime.capTrue,
			drag_and_drop: false,
			report_upload_progress: Runtime.capTrue,
			resize_image: Runtime.capTrue,
			return_response_headers: function(value) {
				return value && I.mode === 'client';
			},
			return_response_type: function(responseType) {
				if (responseType !== 'json') {
					return true;
				} else {
					return !!window.JSON;
				}
			},
			return_status_code: function(code) {
				return I.mode === 'client' || !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: Runtime.capTrue,
			select_multiple: Runtime.capTrue,
			send_binary_string: Runtime.capTrue,
			send_browser_cookies: function(value) {
				return value && I.mode === 'browser';
			},
			send_custom_headers: function(value) {
				return value && I.mode === 'client';
			},
			send_multipart: Runtime.capTrue,
			slice_blob: Runtime.capTrue,
			stream_upload: true,
			summon_file_dialog: false,
			upload_filesize: Runtime.capTrue,
			use_http_method: function(methods) {
				return I.mode === 'client' || !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		}, { 
			// capabilities that require specific mode
			return_response_headers: function(value) {
				return value ? 'client' : 'browser';
			},
			return_status_code: function(code) {
				return Basic.arrayDiff(code, [200, 404]) ? 'client' : ['client', 'browser'];
			},
			send_browser_cookies: function(value) {
				return value ? 'browser' : 'client';
			},
			send_custom_headers: function(value) {
				return value ? 'client' : 'browser';
			},
			use_http_method: function(methods) {
				return Basic.arrayDiff(methods, ['GET', 'POST']) ? 'client' : ['client', 'browser'];
			}
		});


		// minimal requirement
		if (!isInstalled('2.0.31005.0') || Env.browser === 'Opera') {
			this.mode = false;
		}


		Basic.extend(this, {
			getShim: function() {
				return Dom.get(this.uid).content.Moxie;
			},

			shimExec: function(component, action) {
				var args = [].slice.call(arguments, 2);
				return I.getShim().exec(this.uid, component, action, args);
			},

			init : function() {
				var container;

				container = this.getShimContainer();

				container.innerHTML = '<object id="' + this.uid + '" data="data:application/x-silverlight," type="application/x-silverlight-2" width="100%" height="100%" style="outline:none;">' +
					'<param name="source" value="' + options.xap_url + '"/>' +
					'<param name="background" value="Transparent"/>' +
					'<param name="windowless" value="true"/>' +
					'<param name="enablehtmlaccess" value="true"/>' +
					'<param name="initParams" value="uid=' + this.uid + ',target=' + Env.global_event_dispatcher + '"/>' +
				'</object>';

				// Init is dispatched by the shim
				initTimer = setTimeout(function() {
					if (I && !I.initialized) { // runtime might be already destroyed by this moment
						I.trigger("Error", new x.RuntimeError(x.RuntimeError.NOT_INIT_ERR));
					}
				}, Env.OS !== 'Windows'? 10000 : 5000); // give it more time to initialize in non Windows OS (like Mac)
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					clearTimeout(initTimer); // initialization check might be still onwait
					options = initTimer = destroy = I = null;
				};
			}(this.destroy))

		}, extensions);
	}

	Runtime.addConstructor(type, SilverlightRuntime); 

	return extensions;
});

// Included from: src/javascript/runtime/silverlight/file/Blob.js

/**
 * Blob.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/Blob
@private
*/
define("moxie/runtime/silverlight/file/Blob", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/Blob"
], function(extensions, Basic, Blob) {
	return (extensions.Blob = Basic.extend({}, Blob));
});

// Included from: src/javascript/runtime/silverlight/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileInput
@private
*/
define("moxie/runtime/silverlight/file/FileInput", [
	"moxie/runtime/silverlight/Runtime"
], function(extensions) {
	
	var FileInput = {
		init: function(options) {

			function toFilters(accept) {
				var filter = '';
				for (var i = 0; i < accept.length; i++) {
					filter += (filter !== '' ? '|' : '') + accept[i].title + " | *." + accept[i].extensions.replace(/,/g, ';*.');
				}
				return filter;
			}
			
			this.getRuntime().shimExec.call(this, 'FileInput', 'init', toFilters(options.accept), options.name, options.multiple);
			this.trigger('ready');
		}
	};

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/silverlight/file/FileDrop.js

/**
 * FileDrop.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileDrop
@private
*/
define("moxie/runtime/silverlight/file/FileDrop", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Dom", 
	"moxie/core/utils/Events"
], function(extensions, Dom, Events) {

	// not exactly useful, since works only in safari (...crickets...)
	var FileDrop = {
		init: function() {
			var comp = this, self = comp.getRuntime(), dropZone;

			dropZone = self.getShimContainer();

			Events.addEvent(dropZone, 'dragover', function(e) {
				e.preventDefault();
				e.stopPropagation();
				e.dataTransfer.dropEffect = 'copy';
			}, comp.uid);

			Events.addEvent(dropZone, 'dragenter', function(e) {
				e.preventDefault();
				var flag = Dom.get(self.uid).dragEnter(e);
				// If handled, then stop propagation of event in DOM
				if (flag) {
					e.stopPropagation();
				}
			}, comp.uid);

			Events.addEvent(dropZone, 'drop', function(e) {
				e.preventDefault();
				var flag = Dom.get(self.uid).dragDrop(e);
				// If handled, then stop propagation of event in DOM
				if (flag) {
					e.stopPropagation();
				}
			}, comp.uid);

			return self.shimExec.call(this, 'FileDrop', 'init');
		}
	};

	return (extensions.FileDrop = FileDrop);
});

// Included from: src/javascript/runtime/silverlight/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileReader
@private
*/
define("moxie/runtime/silverlight/file/FileReader", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/FileReader"
], function(extensions, Basic, FileReader) {
	return (extensions.FileReader = Basic.extend({}, FileReader));
});

// Included from: src/javascript/runtime/silverlight/file/FileReaderSync.js

/**
 * FileReaderSync.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/file/FileReaderSync
@private
*/
define("moxie/runtime/silverlight/file/FileReaderSync", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/file/FileReaderSync"
], function(extensions, Basic, FileReaderSync) {
	return (extensions.FileReaderSync = Basic.extend({}, FileReaderSync));
});

// Included from: src/javascript/runtime/silverlight/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/silverlight/xhr/XMLHttpRequest", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/xhr/XMLHttpRequest"
], function(extensions, Basic, XMLHttpRequest) {
	return (extensions.XMLHttpRequest = Basic.extend({}, XMLHttpRequest));
});

// Included from: src/javascript/runtime/silverlight/runtime/Transporter.js

/**
 * Transporter.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/silverlight/runtime/Transporter
@private
*/
define("moxie/runtime/silverlight/runtime/Transporter", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/runtime/Transporter"
], function(extensions, Basic, Transporter) {
	return (extensions.Transporter = Basic.extend({}, Transporter));
});

// Included from: src/javascript/runtime/silverlight/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */
 
/**
@class moxie/runtime/silverlight/image/Image
@private
*/
define("moxie/runtime/silverlight/image/Image", [
	"moxie/runtime/silverlight/Runtime",
	"moxie/core/utils/Basic",
	"moxie/runtime/flash/image/Image"
], function(extensions, Basic, Image) {
	return (extensions.Image = Basic.extend({}, Image, {

		getInfo: function() {
			var self = this.getRuntime()
			, grps = ['tiff', 'exif', 'gps']
			, info = { meta: {} }
			, rawInfo = self.shimExec.call(this, 'Image', 'getInfo')
			;

			if (rawInfo.meta) {
				Basic.each(grps, function(grp) {
					var meta = rawInfo.meta[grp]
					, tag
					, i
					, length
					, value
					;
					if (meta && meta.keys) {
						info.meta[grp] = {};
						for (i = 0, length = meta.keys.length; i < length; i++) {
							tag = meta.keys[i];
							value = meta[tag];
							if (value) {
								// convert numbers
								if (/^(\d|[1-9]\d+)$/.test(value)) { // integer (make sure doesn't start with zero)
									value = parseInt(value, 10);
								} else if (/^\d*\.\d+$/.test(value)) { // double
									value = parseFloat(value);
								}
								info.meta[grp][tag] = value;
							}
						}
					}
				});
			}

			info.width = parseInt(rawInfo.width, 10);
			info.height = parseInt(rawInfo.height, 10);
			info.size = parseInt(rawInfo.size, 10);
			info.type = rawInfo.type;
			info.name = rawInfo.name;

			return info;
		}
	}));
});

// Included from: src/javascript/runtime/html4/Runtime.js

/**
 * Runtime.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global File:true */

/**
Defines constructor for HTML4 runtime.

@class moxie/runtime/html4/Runtime
@private
*/
define("moxie/runtime/html4/Runtime", [
	"moxie/core/utils/Basic",
	"moxie/core/Exceptions",
	"moxie/runtime/Runtime",
	"moxie/core/utils/Env"
], function(Basic, x, Runtime, Env) {
	
	var type = 'html4', extensions = {};

	function Html4Runtime(options) {
		var I = this
		, Test = Runtime.capTest
		, True = Runtime.capTrue
		;

		Runtime.call(this, options, type, {
			access_binary: Test(window.FileReader || window.File && File.getAsDataURL),
			access_image_binary: false,
			display_media: Test(extensions.Image && (Env.can('create_canvas') || Env.can('use_data_uri_over32kb'))),
			do_cors: false,
			drag_and_drop: false,
			filter_by_extension: Test(function() { // if you know how to feature-detect this, please suggest
				return (Env.browser === 'Chrome' && Env.version >= 28) || (Env.browser === 'IE' && Env.version >= 10);
			}()),
			resize_image: function() {
				return extensions.Image && I.can('access_binary') && Env.can('create_canvas');
			},
			report_upload_progress: false,
			return_response_headers: false,
			return_response_type: function(responseType) {
				if (responseType === 'json' && !!window.JSON) {
					return true;
				} 
				return !!~Basic.inArray(responseType, ['text', 'document', '']);
			},
			return_status_code: function(code) {
				return !Basic.arrayDiff(code, [200, 404]);
			},
			select_file: function() {
				return Env.can('use_fileinput');
			},
			select_multiple: false,
			send_binary_string: false,
			send_custom_headers: false,
			send_multipart: true,
			slice_blob: false,
			stream_upload: function() {
				return I.can('select_file');
			},
			summon_file_dialog: Test(function() { // yeah... some dirty sniffing here...
				return (Env.browser === 'Firefox' && Env.version >= 4) ||
					(Env.browser === 'Opera' && Env.version >= 12) ||
					!!~Basic.inArray(Env.browser, ['Chrome', 'Safari']);
			}()),
			upload_filesize: True,
			use_http_method: function(methods) {
				return !Basic.arrayDiff(methods, ['GET', 'POST']);
			}
		});


		Basic.extend(this, {
			init : function() {
				this.trigger("Init");
			},

			destroy: (function(destroy) { // extend default destroy method
				return function() {
					destroy.call(I);
					destroy = I = null;
				};
			}(this.destroy))
		});

		Basic.extend(this.getShim(), extensions);
	}

	Runtime.addConstructor(type, Html4Runtime);

	return extensions;
});

// Included from: src/javascript/runtime/html4/file/FileInput.js

/**
 * FileInput.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/file/FileInput
@private
*/
define("moxie/runtime/html4/file/FileInput", [
	"moxie/runtime/html4/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Events",
	"moxie/core/utils/Mime",
	"moxie/core/utils/Env"
], function(extensions, Basic, Dom, Events, Mime, Env) {
	
	function FileInput() {
		var _uid, _files = [], _mimes = [], _options;

		function addInput() {
			var comp = this, I = comp.getRuntime(), shimContainer, browseButton, currForm, form, input, uid;

			uid = Basic.guid('uid_');

			shimContainer = I.getShimContainer(); // we get new ref everytime to avoid memory leaks in IE

			if (_uid) { // move previous form out of the view
				currForm = Dom.get(_uid + '_form');
				if (currForm) {
					Basic.extend(currForm.style, { top: '100%' });
				}
			}

			// build form in DOM, since innerHTML version not able to submit file for some reason
			form = document.createElement('form');
			form.setAttribute('id', uid + '_form');
			form.setAttribute('method', 'post');
			form.setAttribute('enctype', 'multipart/form-data');
			form.setAttribute('encoding', 'multipart/form-data');

			Basic.extend(form.style, {
				overflow: 'hidden',
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
				height: '100%'
			});

			input = document.createElement('input');
			input.setAttribute('id', uid);
			input.setAttribute('type', 'file');
			input.setAttribute('name', _options.name || 'Filedata');
			input.setAttribute('accept', _mimes.join(','));

			Basic.extend(input.style, {
				fontSize: '999px',
				opacity: 0
			});

			form.appendChild(input);
			shimContainer.appendChild(form);

			// prepare file input to be placed underneath the browse_button element
			Basic.extend(input.style, {
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
				height: '100%'
			});

			if (Env.browser === 'IE' && Env.version < 10) {
				Basic.extend(input.style, {
					filter : "progid:DXImageTransform.Microsoft.Alpha(opacity=0)"
				});
			}

			input.onchange = function() { // there should be only one handler for this
				var file;

				if (!this.value) {
					return;
				}

				if (this.files) {
					file = this.files[0];
				} else {
					file = {
						name: this.value
					};
				}

				_files = [file];

				this.onchange = function() {}; // clear event handler
				addInput.call(comp);

				// after file is initialized as o.File, we need to update form and input ids
				comp.bind('change', function onChange() {
					var input = Dom.get(uid), form = Dom.get(uid + '_form'), file;

					comp.unbind('change', onChange);

					if (comp.files.length && input && form) {
						file = comp.files[0];

						input.setAttribute('id', file.uid);
						form.setAttribute('id', file.uid + '_form');

						// set upload target
						form.setAttribute('target', file.uid + '_iframe');
					}
					input = form = null;
				}, 998);

				input = form = null;
				comp.trigger('change');
			};


			// route click event to the input
			if (I.can('summon_file_dialog')) {
				browseButton = Dom.get(_options.browse_button);
				Events.removeEvent(browseButton, 'click', comp.uid);
				Events.addEvent(browseButton, 'click', function(e) {
					if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
						input.click();
					}
					e.preventDefault();
				}, comp.uid);
			}

			_uid = uid;

			shimContainer = currForm = browseButton = null;
		}

		Basic.extend(this, {
			init: function(options) {
				var comp = this, I = comp.getRuntime(), shimContainer;

				// figure out accept string
				_options = options;
				_mimes = options.accept.mimes || Mime.extList2mimes(options.accept, I.can('filter_by_extension'));

				shimContainer = I.getShimContainer();

				(function() {
					var browseButton, zIndex, top;

					browseButton = Dom.get(options.browse_button);

					// Route click event to the input[type=file] element for browsers that support such behavior
					if (I.can('summon_file_dialog')) {
						if (Dom.getStyle(browseButton, 'position') === 'static') {
							browseButton.style.position = 'relative';
						}

						zIndex = parseInt(Dom.getStyle(browseButton, 'z-index'), 10) || 1;

						browseButton.style.zIndex = zIndex;
						shimContainer.style.zIndex = zIndex - 1;
					}

					/* Since we have to place input[type=file] on top of the browse_button for some browsers,
					browse_button loses interactivity, so we restore it here */
					top = I.can('summon_file_dialog') ? browseButton : shimContainer;

					Events.addEvent(top, 'mouseover', function() {
						comp.trigger('mouseenter');
					}, comp.uid);

					Events.addEvent(top, 'mouseout', function() {
						comp.trigger('mouseleave');
					}, comp.uid);

					Events.addEvent(top, 'mousedown', function() {
						comp.trigger('mousedown');
					}, comp.uid);

					Events.addEvent(Dom.get(options.container), 'mouseup', function() {
						comp.trigger('mouseup');
					}, comp.uid);

					browseButton = null;
				}());

				addInput.call(this);

				shimContainer = null;

				// trigger ready event asynchronously
				comp.trigger({
					type: 'ready',
					async: true
				});
			},

			getFiles: function() {
				return _files;
			},

			disable: function(state) {
				var input;

				if ((input = Dom.get(_uid))) {
					input.disabled = !!state;
				}
			},

			destroy: function() {
				var I = this.getRuntime()
				, shim = I.getShim()
				, shimContainer = I.getShimContainer()
				;
				
				Events.removeAllEvents(shimContainer, this.uid);
				Events.removeAllEvents(_options && Dom.get(_options.container), this.uid);
				Events.removeAllEvents(_options && Dom.get(_options.browse_button), this.uid);
				
				if (shimContainer) {
					shimContainer.innerHTML = '';
				}

				shim.removeInstance(this.uid);

				_uid = _files = _mimes = _options = shimContainer = shim = null;
			}
		});
	}

	return (extensions.FileInput = FileInput);
});

// Included from: src/javascript/runtime/html4/file/FileReader.js

/**
 * FileReader.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/file/FileReader
@private
*/
define("moxie/runtime/html4/file/FileReader", [
	"moxie/runtime/html4/Runtime",
	"moxie/runtime/html5/file/FileReader"
], function(extensions, FileReader) {
	return (extensions.FileReader = FileReader);
});

// Included from: src/javascript/runtime/html4/xhr/XMLHttpRequest.js

/**
 * XMLHttpRequest.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/xhr/XMLHttpRequest
@private
*/
define("moxie/runtime/html4/xhr/XMLHttpRequest", [
	"moxie/runtime/html4/Runtime",
	"moxie/core/utils/Basic",
	"moxie/core/utils/Dom",
	"moxie/core/utils/Url",
	"moxie/core/Exceptions",
	"moxie/core/utils/Events",
	"moxie/file/Blob",
	"moxie/xhr/FormData"
], function(extensions, Basic, Dom, Url, x, Events, Blob, FormData) {
	
	function XMLHttpRequest() {
		var _status, _response, _iframe;

		function cleanup(cb) {
			var target = this, uid, form, inputs, i, hasFile = false;

			if (!_iframe) {
				return;
			}

			uid = _iframe.id.replace(/_iframe$/, '');

			form = Dom.get(uid + '_form');
			if (form) {
				inputs = form.getElementsByTagName('input');
				i = inputs.length;

				while (i--) {
					switch (inputs[i].getAttribute('type')) {
						case 'hidden':
							inputs[i].parentNode.removeChild(inputs[i]);
							break;
						case 'file':
							hasFile = true; // flag the case for later
							break;
					}
				}
				inputs = [];

				if (!hasFile) { // we need to keep the form for sake of possible retries
					form.parentNode.removeChild(form);
				}
				form = null;
			}

			// without timeout, request is marked as canceled (in console)
			setTimeout(function() {
				Events.removeEvent(_iframe, 'load', target.uid);
				if (_iframe.parentNode) { // #382
					_iframe.parentNode.removeChild(_iframe);
				}

				// check if shim container has any other children, if - not, remove it as well
				var shimContainer = target.getRuntime().getShimContainer();
				if (!shimContainer.children.length) {
					shimContainer.parentNode.removeChild(shimContainer);
				}

				shimContainer = _iframe = null;
				cb();
			}, 1);
		}

		Basic.extend(this, {
			send: function(meta, data) {
				var target = this, I = target.getRuntime(), uid, form, input, blob;

				_status = _response = null;

				function createIframe() {
					var container = I.getShimContainer() || document.body
					, temp = document.createElement('div')
					;

					// IE 6 won't be able to set the name using setAttribute or iframe.name
					temp.innerHTML = '<iframe id="' + uid + '_iframe" name="' + uid + '_iframe" src="javascript:&quot;&quot;" style="display:none"></iframe>';
					_iframe = temp.firstChild;
					container.appendChild(_iframe);

					/* _iframe.onreadystatechange = function() {
						console.info(_iframe.readyState);
					};*/

					Events.addEvent(_iframe, 'load', function() { // _iframe.onload doesn't work in IE lte 8
						var el;

						try {
							el = _iframe.contentWindow.document || _iframe.contentDocument || window.frames[_iframe.id].document;

							// try to detect some standard error pages
							if (/^4(0[0-9]|1[0-7]|2[2346])\s/.test(el.title)) { // test if title starts with 4xx HTTP error
								_status = el.title.replace(/^(\d+).*$/, '$1');
							} else {
								_status = 200;
								// get result
								_response = Basic.trim(el.body.innerHTML);

								// we need to fire these at least once
								target.trigger({
									type: 'progress',
									loaded: _response.length,
									total: _response.length
								});

								if (blob) { // if we were uploading a file
									target.trigger({
										type: 'uploadprogress',
										loaded: blob.size || 1025,
										total: blob.size || 1025
									});
								}
							}
						} catch (ex) {
							if (Url.hasSameOrigin(meta.url)) {
								// if response is sent with error code, iframe in IE gets redirected to res://ieframe.dll/http_x.htm
								// which obviously results to cross domain error (wtf?)
								_status = 404;
							} else {
								cleanup.call(target, function() {
									target.trigger('error');
								});
								return;
							}
						}	
					
						cleanup.call(target, function() {
							target.trigger('load');
						});
					}, target.uid);
				} // end createIframe

				// prepare data to be sent and convert if required
				if (data instanceof FormData && data.hasBlob()) {
					blob = data.getBlob();
					uid = blob.uid;
					input = Dom.get(uid);
					form = Dom.get(uid + '_form');
					if (!form) {
						throw new x.DOMException(x.DOMException.NOT_FOUND_ERR);
					}
				} else {
					uid = Basic.guid('uid_');

					form = document.createElement('form');
					form.setAttribute('id', uid + '_form');
					form.setAttribute('method', meta.method);
					form.setAttribute('enctype', 'multipart/form-data');
					form.setAttribute('encoding', 'multipart/form-data');
					form.setAttribute('target', uid + '_iframe');

					I.getShimContainer().appendChild(form);
				}

				if (data instanceof FormData) {
					data.each(function(value, name) {
						if (value instanceof Blob) {
							if (input) {
								input.setAttribute('name', name);
							}
						} else {
							var hidden = document.createElement('input');

							Basic.extend(hidden, {
								type : 'hidden',
								name : name,
								value : value
							});

							// make sure that input[type="file"], if it's there, comes last
							if (input) {
								form.insertBefore(hidden, input);
							} else {
								form.appendChild(hidden);
							}
						}
					});
				}

				// set destination url
				form.setAttribute("action", meta.url);

				createIframe();
				form.submit();
				target.trigger('loadstart');
			},

			getStatus: function() {
				return _status;
			},

			getResponse: function(responseType) {
				if ('json' === responseType) {
					// strip off <pre>..</pre> tags that might be enclosing the response
					if (Basic.typeOf(_response) === 'string' && !!window.JSON) {
						try {
							return JSON.parse(_response.replace(/^\s*<pre[^>]*>/, '').replace(/<\/pre>\s*$/, ''));
						} catch (ex) {
							return null;
						}
					} 
				} else if ('document' === responseType) {

				}
				return _response;
			},

			abort: function() {
				var target = this;

				if (_iframe && _iframe.contentWindow) {
					if (_iframe.contentWindow.stop) { // FireFox/Safari/Chrome
						_iframe.contentWindow.stop();
					} else if (_iframe.contentWindow.document.execCommand) { // IE
						_iframe.contentWindow.document.execCommand('Stop');
					} else {
						_iframe.src = "about:blank";
					}
				}

				cleanup.call(this, function() {
					// target.dispatchEvent('readystatechange');
					target.dispatchEvent('abort');
				});
			}
		});
	}

	return (extensions.XMLHttpRequest = XMLHttpRequest);
});

// Included from: src/javascript/runtime/html4/image/Image.js

/**
 * Image.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/**
@class moxie/runtime/html4/image/Image
@private
*/
define("moxie/runtime/html4/image/Image", [
	"moxie/runtime/html4/Runtime",
	"moxie/runtime/html5/image/Image"
], function(extensions, Image) {
	return (extensions.Image = Image);
});

expose(["moxie/core/utils/Basic","moxie/core/I18n","moxie/core/utils/Mime","moxie/core/utils/Env","moxie/core/utils/Dom","moxie/core/Exceptions","moxie/core/EventTarget","moxie/core/utils/Encode","moxie/runtime/Runtime","moxie/runtime/RuntimeClient","moxie/file/Blob","moxie/file/File","moxie/file/FileInput","moxie/file/FileDrop","moxie/runtime/RuntimeTarget","moxie/file/FileReader","moxie/core/utils/Url","moxie/file/FileReaderSync","moxie/xhr/FormData","moxie/xhr/XMLHttpRequest","moxie/runtime/Transporter","moxie/image/Image","moxie/core/utils/Events"]);
})(this);/**
 * o.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global moxie:true */

/**
Globally exposed namespace with the most frequently used public classes and handy methods.

@class o
@static
@private
*/
(function() {
	"use strict";

	var o = {}, inArray = moxie.core.utils.Basic.inArray;

	// directly add some public classes
	// (we do it dynamically here, since for custom builds we cannot know beforehand what modules were included)
	(function addAlias(ns) {
		var name, itemType;
		for (name in ns) {
			itemType = typeof(ns[name]);
			if (itemType === 'object' && !~inArray(name, ['Exceptions', 'Env', 'Mime'])) {
				addAlias(ns[name]);
			} else if (itemType === 'function') {
				o[name] = ns[name];
			}
		}
	})(window.moxie);

	// add some manually
	o.Env = window.moxie.core.utils.Env;
	o.Mime = window.moxie.core.utils.Mime;
	o.Exceptions = window.moxie.core.Exceptions;

	// expose globally
	window.mOxie = o;
	if (!window.o) {
		window.o = o;
	}
	return o;
})();
















/**
 * Plupload - multi-runtime File Uploader
 * v2.1.1
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 *
 * Date: 2014-01-16
 */
/**
 * Plupload.js
 *
 * Copyright 2013, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

/*global mOxie:true */

;(function(window, o, undef) {

var delay = window.setTimeout
, fileFilters = {}
;

// convert plupload features to caps acceptable by mOxie
function normalizeCaps(settings) {		
	var features = settings.required_features, caps = {};

	function resolve(feature, value, strict) {
		// Feature notation is deprecated, use caps (this thing here is required for backward compatibility)
		var map = { 
			chunks: 'slice_blob',
			jpgresize: 'send_binary_string',
			pngresize: 'send_binary_string',
			progress: 'report_upload_progress',
			multi_selection: 'select_multiple',
			dragdrop: 'drag_and_drop',
			drop_element: 'drag_and_drop',
			headers: 'send_custom_headers',
			canSendBinary: 'send_binary',
			triggerDialog: 'summon_file_dialog'
		};

		if (map[feature]) {
			caps[map[feature]] = value;
		} else if (!strict) {
			caps[feature] = value;
		}
	}

	if (typeof(features) === 'string') {
		plupload.each(features.split(/\s*,\s*/), function(feature) {
			resolve(feature, true);
		});
	} else if (typeof(features) === 'object') {
		plupload.each(features, function(value, feature) {
			resolve(feature, value);
		});
	} else if (features === true) {
		// check settings for required features
		if (!settings.multipart) { // special care for multipart: false
			caps.send_binary_string = true;
		}

		if (settings.chunk_size > 0) {
			caps.slice_blob = true;
		}

		if (settings.resize.enabled) {
			caps.send_binary_string = true;
		}
		
		plupload.each(settings, function(value, feature) {
			resolve(feature, !!value, true); // strict check
		});
	}
	
	return caps;
}

/** 
 * @module plupload	
 * @static
 */
var plupload = {
	/**
	 * Plupload version will be replaced on build.
	 *
	 * @property VERSION
	 * @for Plupload
	 * @static
	 * @final
	 */
	VERSION : '2.1.1',

	/**
	 * Inital state of the queue and also the state ones it's finished all it's uploads.
	 *
	 * @property STOPPED
	 * @static
	 * @final
	 */
	STOPPED : 1,

	/**
	 * Upload process is running
	 *
	 * @property STARTED
	 * @static
	 * @final
	 */
	STARTED : 2,

	/**
	 * File is queued for upload
	 *
	 * @property QUEUED
	 * @static
	 * @final
	 */
	QUEUED : 1,

	/**
	 * File is being uploaded
	 *
	 * @property UPLOADING
	 * @static
	 * @final
	 */
	UPLOADING : 2,

	/**
	 * File has failed to be uploaded
	 *
	 * @property FAILED
	 * @static
	 * @final
	 */
	FAILED : 4,

	/**
	 * File has been uploaded successfully
	 *
	 * @property DONE
	 * @static
	 * @final
	 */
	DONE : 5,

	// Error constants used by the Error event

	/**
	 * Generic error for example if an exception is thrown inside Silverlight.
	 *
	 * @property GENERIC_ERROR
	 * @static
	 * @final
	 */
	GENERIC_ERROR : -100,

	/**
	 * HTTP transport error. For example if the server produces a HTTP status other than 200.
	 *
	 * @property HTTP_ERROR
	 * @static
	 * @final
	 */
	HTTP_ERROR : -200,

	/**
	 * Generic I/O error. For exampe if it wasn't possible to open the file stream on local machine.
	 *
	 * @property IO_ERROR
	 * @static
	 * @final
	 */
	IO_ERROR : -300,

	/**
	 * Generic I/O error. For exampe if it wasn't possible to open the file stream on local machine.
	 *
	 * @property SECURITY_ERROR
	 * @static
	 * @final
	 */
	SECURITY_ERROR : -400,

	/**
	 * Initialization error. Will be triggered if no runtime was initialized.
	 *
	 * @property INIT_ERROR
	 * @static
	 * @final
	 */
	INIT_ERROR : -500,

	/**
	 * File size error. If the user selects a file that is too large it will be blocked and an error of this type will be triggered.
	 *
	 * @property FILE_SIZE_ERROR
	 * @static
	 * @final
	 */
	FILE_SIZE_ERROR : -600,

	/**
	 * File extension error. If the user selects a file that isn't valid according to the filters setting.
	 *
	 * @property FILE_EXTENSION_ERROR
	 * @static
	 * @final
	 */
	FILE_EXTENSION_ERROR : -601,

	/**
	 * Duplicate file error. If prevent_duplicates is set to true and user selects the same file again.
	 *
	 * @property FILE_DUPLICATE_ERROR
	 * @static
	 * @final
	 */
	FILE_DUPLICATE_ERROR : -602,

	/**
	 * Runtime will try to detect if image is proper one. Otherwise will throw this error.
	 *
	 * @property IMAGE_FORMAT_ERROR
	 * @static
	 * @final
	 */
	IMAGE_FORMAT_ERROR : -700,

	/**
	 * While working on the image runtime will try to detect if the operation may potentially run out of memeory and will throw this error.
	 *
	 * @property IMAGE_MEMORY_ERROR
	 * @static
	 * @final
	 */
	IMAGE_MEMORY_ERROR : -701,

	/**
	 * Each runtime has an upper limit on a dimension of the image it can handle. If bigger, will throw this error.
	 *
	 * @property IMAGE_DIMENSIONS_ERROR
	 * @static
	 * @final
	 */
	IMAGE_DIMENSIONS_ERROR : -702,

	/**
	 * Mime type lookup table.
	 *
	 * @property mimeTypes
	 * @type Object
	 * @final
	 */
	mimeTypes : o.mimes,

	/**
	 * In some cases sniffing is the only way around :(
	 */
	ua: o.ua,

	/**
	 * Gets the true type of the built-in object (better version of typeof).
	 * @credits Angus Croll (http://javascriptweblog.wordpress.com/)
	 *
	 * @method typeOf
	 * @static
	 * @param {Object} o Object to check.
	 * @return {String} Object [[Class]]
	 */
	typeOf: o.typeOf,

	/**
	 * Extends the specified object with another object.
	 *
	 * @method extend
	 * @static
	 * @param {Object} target Object to extend.
	 * @param {Object..} obj Multiple objects to extend with.
	 * @return {Object} Same as target, the extended object.
	 */
	extend : o.extend,

	/**
	 * Generates an unique ID. This is 99.99% unique since it takes the current time and 5 random numbers.
	 * The only way a user would be able to get the same ID is if the two persons at the same exact milisecond manages
	 * to get 5 the same random numbers between 0-65535 it also uses a counter so each call will be guaranteed to be page unique.
	 * It's more probable for the earth to be hit with an ansteriod. You can also if you want to be 100% sure set the plupload.guidPrefix property
	 * to an user unique key.
	 *
	 * @method guid
	 * @static
	 * @return {String} Virtually unique id.
	 */
	guid : o.guid,

	/**
	 * Get array of DOM Elements by their ids.
	 * 
	 * @method get
	 * @for Utils
	 * @param {String} id Identifier of the DOM Element
	 * @return {Array}
	*/
	get : function get(ids) {
		var els = [], el;

		if (o.typeOf(ids) !== 'array') {
			ids = [ids];
		}

		var i = ids.length;
		while (i--) {
			el = o.get(ids[i]);
			if (el) {
				els.push(el);
			}
		}

		return els.length ? els : null;
	},

	/**
	 * Executes the callback function for each item in array/object. If you return false in the
	 * callback it will break the loop.
	 *
	 * @method each
	 * @static
	 * @param {Object} obj Object to iterate.
	 * @param {function} callback Callback function to execute for each item.
	 */
	each : o.each,

	/**
	 * Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.
	 *
	 * @method getPos
	 * @static
	 * @param {Element} node HTML element or element id to get x, y position from.
	 * @param {Element} root Optional root element to stop calculations at.
	 * @return {object} Absolute position of the specified element object with x, y fields.
	 */
	getPos : o.getPos,

	/**
	 * Returns the size of the specified node in pixels.
	 *
	 * @method getSize
	 * @static
	 * @param {Node} node Node to get the size of.
	 * @return {Object} Object with a w and h property.
	 */
	getSize : o.getSize,

	/**
	 * Encodes the specified string.
	 *
	 * @method xmlEncode
	 * @static
	 * @param {String} s String to encode.
	 * @return {String} Encoded string.
	 */
	xmlEncode : function(str) {
		var xmlEncodeChars = {'<' : 'lt', '>' : 'gt', '&' : 'amp', '"' : 'quot', '\'' : '#39'}, xmlEncodeRegExp = /[<>&\"\']/g;

		return str ? ('' + str).replace(xmlEncodeRegExp, function(chr) {
			return xmlEncodeChars[chr] ? '&' + xmlEncodeChars[chr] + ';' : chr;
		}) : str;
	},

	/**
	 * Forces anything into an array.
	 *
	 * @method toArray
	 * @static
	 * @param {Object} obj Object with length field.
	 * @return {Array} Array object containing all items.
	 */
	toArray : o.toArray,

	/**
	 * Find an element in array and return it's index if present, otherwise return -1.
	 *
	 * @method inArray
	 * @static
	 * @param {mixed} needle Element to find
	 * @param {Array} array
	 * @return {Int} Index of the element, or -1 if not found
	 */
	inArray : o.inArray,

	/**
	 * Extends the language pack object with new items.
	 *
	 * @method addI18n
	 * @static
	 * @param {Object} pack Language pack items to add.
	 * @return {Object} Extended language pack object.
	 */
	addI18n : o.addI18n,

	/**
	 * Translates the specified string by checking for the english string in the language pack lookup.
	 *
	 * @method translate
	 * @static
	 * @param {String} str String to look for.
	 * @return {String} Translated string or the input string if it wasn't found.
	 */
	translate : o.translate,

	/**
	 * Checks if object is empty.
	 *
	 * @method isEmptyObj
	 * @static
	 * @param {Object} obj Object to check.
	 * @return {Boolean}
	 */
	isEmptyObj : o.isEmptyObj,

	/**
	 * Checks if specified DOM element has specified class.
	 *
	 * @method hasClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	hasClass : o.hasClass,

	/**
	 * Adds specified className to specified DOM element.
	 *
	 * @method addClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	addClass : o.addClass,

	/**
	 * Removes specified className from specified DOM element.
	 *
	 * @method removeClass
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Class name
	 */
	removeClass : o.removeClass,

	/**
	 * Returns a given computed style of a DOM element.
	 *
	 * @method getStyle
	 * @static
	 * @param {Object} obj DOM element like object.
	 * @param {String} name Style you want to get from the DOM element
	 */
	getStyle : o.getStyle,

	/**
	 * Adds an event handler to the specified object and store reference to the handler
	 * in objects internal Plupload registry (@see removeEvent).
	 *
	 * @method addEvent
	 * @static
	 * @param {Object} obj DOM element like object to add handler to.
	 * @param {String} name Name to add event listener to.
	 * @param {Function} callback Function to call when event occurs.
	 * @param {String} (optional) key that might be used to add specifity to the event record.
	 */
	addEvent : o.addEvent,

	/**
	 * Remove event handler from the specified object. If third argument (callback)
	 * is not specified remove all events with the specified name.
	 *
	 * @method removeEvent
	 * @static
	 * @param {Object} obj DOM element to remove event listener(s) from.
	 * @param {String} name Name of event listener to remove.
	 * @param {Function|String} (optional) might be a callback or unique key to match.
	 */
	removeEvent: o.removeEvent,

	/**
	 * Remove all kind of events from the specified object
	 *
	 * @method removeAllEvents
	 * @static
	 * @param {Object} obj DOM element to remove event listeners from.
	 * @param {String} (optional) unique key to match, when removing events.
	 */
	removeAllEvents: o.removeAllEvents,

	/**
	 * Cleans the specified name from national characters (diacritics). The result will be a name with only a-z, 0-9 and _.
	 *
	 * @method cleanName
	 * @static
	 * @param {String} s String to clean up.
	 * @return {String} Cleaned string.
	 */
	cleanName : function(name) {
		var i, lookup;

		// Replace diacritics
		lookup = [
			/[\300-\306]/g, 'A', /[\340-\346]/g, 'a',
			/\307/g, 'C', /\347/g, 'c',
			/[\310-\313]/g, 'E', /[\350-\353]/g, 'e',
			/[\314-\317]/g, 'I', /[\354-\357]/g, 'i',
			/\321/g, 'N', /\361/g, 'n',
			/[\322-\330]/g, 'O', /[\362-\370]/g, 'o',
			/[\331-\334]/g, 'U', /[\371-\374]/g, 'u'
		];

		for (i = 0; i < lookup.length; i += 2) {
			name = name.replace(lookup[i], lookup[i + 1]);
		}

		// Replace whitespace
		name = name.replace(/\s+/g, '_');

		// Remove anything else
		name = name.replace(/[^a-z0-9_\-\.]+/gi, '');

		return name;
	},

	/**
	 * Builds a full url out of a base URL and an object with items to append as query string items.
	 *
	 * @method buildUrl
	 * @static
	 * @param {String} url Base URL to append query string items to.
	 * @param {Object} items Name/value object to serialize as a querystring.
	 * @return {String} String with url + serialized query string items.
	 */
	buildUrl : function(url, items) {
		var query = '';

		plupload.each(items, function(value, name) {
			query += (query ? '&' : '') + encodeURIComponent(name) + '=' + encodeURIComponent(value);
		});

		if (query) {
			url += (url.indexOf('?') > 0 ? '&' : '?') + query;
		}

		return url;
	},

	/**
	 * Formats the specified number as a size string for example 1024 becomes 1 KB.
	 *
	 * @method formatSize
	 * @static
	 * @param {Number} size Size to format as string.
	 * @return {String} Formatted size string.
	 */
	formatSize : function(size) {

		if (size === undef || /\D/.test(size)) {
			return plupload.translate('N/A');
		}

		function round(num, precision) {
			return Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);
		}

		var boundary = Math.pow(1024, 4);

		// TB
		if (size > boundary) {
			return round(size / boundary, 1) + " " + plupload.translate('tb');
		}

		// GB
		if (size > (boundary/=1024)) {
			return round(size / boundary, 1) + " " + plupload.translate('gb');
		}

		// MB
		if (size > (boundary/=1024)) {
			return round(size / boundary, 1) + " " + plupload.translate('mb');
		}

		// KB
		if (size > 1024) {
			return Math.round(size / 1024) + " " + plupload.translate('kb');
		}

		return size + " " + plupload.translate('b');
	},


	/**
	 * Parses the specified size string into a byte value. For example 10kb becomes 10240.
	 *
	 * @method parseSize
	 * @static
	 * @param {String|Number} size String to parse or number to just pass through.
	 * @return {Number} Size in bytes.
	 */
	parseSize : o.parseSizeStr,


	/**
	 * A way to predict what runtime will be choosen in the current environment with the
	 * specified settings.
	 *
	 * @method predictRuntime
	 * @static
	 * @param {Object|String} config Plupload settings to check
	 * @param {String} [runtimes] Comma-separated list of runtimes to check against
	 * @return {String} Type of compatible runtime
	 */
	predictRuntime : function(config, runtimes) {
		var up, runtime;

		up = new plupload.Uploader(config);
		runtime = o.Runtime.thatCan(up.getOption().required_features, runtimes || config.runtimes);
		up.destroy();
		return runtime;
	},

	/**
	 * Registers a filter that will be executed for each file added to the queue.
	 * If callback returns false, file will not be added.
	 *
	 * Callback receives two arguments: a value for the filter as it was specified in settings.filters
	 * and a file to be filtered. Callback is executed in the context of uploader instance.
	 *
	 * @method addFileFilter
	 * @static
	 * @param {String} name Name of the filter by which it can be referenced in settings.filters
	 * @param {String} cb Callback - the actual routine that every added file must pass
	 */
	addFileFilter: function(name, cb) {
		fileFilters[name] = cb;
	}
};


plupload.addFileFilter('mime_types', function(filters, file, cb) {
	if (filters.length && !filters.regexp.test(file.name)) {
		this.trigger('Error', {
			code : plupload.FILE_EXTENSION_ERROR,
			message : plupload.translate('File extension error.'),
			file : file
		});
		cb(false);
	} else {
		cb(true);
	}
});


plupload.addFileFilter('max_file_size', function(maxSize, file, cb) {
	var undef;

	maxSize = plupload.parseSize(maxSize);

	// Invalid file size
	if (file.size !== undef && maxSize && file.size > maxSize) {
		this.trigger('Error', {
			code : plupload.FILE_SIZE_ERROR,
			message : plupload.translate('File size error.'),
			file : file
		});
		cb(false);
	} else {
		cb(true);
	}
});


plupload.addFileFilter('prevent_duplicates', function(value, file, cb) {
	if (value) {
		var ii = this.files.length;
		while (ii--) {
			// Compare by name and size (size might be 0 or undefined, but still equivalent for both)
			if (file.name === this.files[ii].name && file.size === this.files[ii].size) {
				this.trigger('Error', {
					code : plupload.FILE_DUPLICATE_ERROR,
					message : plupload.translate('Duplicate file error.'),
					file : file
				});
				cb(false);
				return;
			}
		}
	}
	cb(true);
});


/**
@class Uploader
@constructor

@param {Object} settings For detailed information about each option check documentation.
	@param {String|DOMElement} settings.browse_button id of the DOM element or DOM element itself to use as file dialog trigger.
	@param {String} settings.url URL of the server-side upload handler.
	@param {Number|String} [settings.chunk_size=0] Chunk size in bytes to slice the file into. Shorcuts with b, kb, mb, gb, tb suffixes also supported. `e.g. 204800 or "204800b" or "200kb"`. By default - disabled.
	@param {String} [settings.container] id of the DOM element to use as a container for uploader structures. Defaults to document.body.
	@param {String|DOMElement} [settings.drop_element] id of the DOM element or DOM element itself to use as a drop zone for Drag-n-Drop.
	@param {String} [settings.file_data_name="file"] Name for the file field in Multipart formated message.
	@param {Object} [settings.filters={}] Set of file type filters.
		@param {Array} [settings.filters.mime_types=[]] List of file types to accept, each one defined by title and list of extensions. `e.g. {title : "Image files", extensions : "jpg,jpeg,gif,png"}`. Dispatches `plupload.FILE_EXTENSION_ERROR`
		@param {String|Number} [settings.filters.max_file_size=0] Maximum file size that the user can pick, in bytes. Optionally supports b, kb, mb, gb, tb suffixes. `e.g. "10mb" or "1gb"`. By default - not set. Dispatches `plupload.FILE_SIZE_ERROR`.
		@param {Boolean} [settings.filters.prevent_duplicates=false] Do not let duplicates into the queue. Dispatches `plupload.FILE_DUPLICATE_ERROR`.
	@param {String} [settings.flash_swf_url] URL of the Flash swf.
	@param {Object} [settings.headers] Custom headers to send with the upload. Hash of name/value pairs.
	@param {Number} [settings.max_retries=0] How many times to retry the chunk or file, before triggering Error event.
	@param {Boolean} [settings.multipart=true] Whether to send file and additional parameters as Multipart formated message.
	@param {Object} [settings.multipart_params] Hash of key/value pairs to send with every file upload.
	@param {Boolean} [settings.multi_selection=true] Enable ability to select multiple files at once in file dialog.
	@param {String|Object} [settings.required_features] Either comma-separated list or hash of required features that chosen runtime should absolutely possess.
	@param {Object} [settings.resize] Enable resizng of images on client-side. Applies to `image/jpeg` and `image/png` only. `e.g. {width : 200, height : 200, quality : 90, crop: true}`
		@param {Number} [settings.resize.width] If image is bigger, it will be resized.
		@param {Number} [settings.resize.height] If image is bigger, it will be resized.
		@param {Number} [settings.resize.quality=90] Compression quality for jpegs (1-100).
		@param {Boolean} [settings.resize.crop=false] Whether to crop images to exact dimensions. By default they will be resized proportionally.
	@param {String} [settings.runtimes="html5,flash,silverlight,html4"] Comma separated list of runtimes, that Plupload will try in turn, moving to the next if previous fails.
	@param {String} [settings.silverlight_xap_url] URL of the Silverlight xap.
	@param {Boolean} [settings.unique_names=false] If true will generate unique filenames for uploaded files.
*/
plupload.Uploader = function(options) {
	/**
	 * Fires when the current RunTime has been initialized.
	 *
	 * @event Init
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	 * Fires after the init event incase you need to perform actions there.
	 *
	 * @event PostInit
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	 * Fires when the option is changed in via uploader.setOption().
	 *
	 * @event OptionChanged
	 * @since 2.1
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {String} name Name of the option that was changed
	 * @param {Mixed} value New value for the specified option
	 * @param {Mixed} oldValue Previous value of the option
	 */

	/**
	 * Fires when the silverlight/flash or other shim needs to move.
	 *
	 * @event Refresh
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	 * Fires when the overall state is being changed for the upload queue.
	 *
	 * @event StateChanged
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	 * Fires when a file is to be uploaded by the runtime.
	 *
	 * @event UploadFile
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {plupload.File} file File to be uploaded.
	 */

	/**
	 * Fires when just before a file is uploaded. This event enables you to override settings
	 * on the uploader instance before the file is uploaded.
	 *
	 * @event BeforeUpload
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {plupload.File} file File to be uploaded.
	 */

	/**
	 * Fires when the file queue is changed. In other words when files are added/removed to the files array of the uploader instance.
	 *
	 * @event QueueChanged
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 */

	/**
	 * Fires while a file is being uploaded. Use this event to update the current file upload progress.
	 *
	 * @event UploadProgress
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {plupload.File} file File that is currently being uploaded.
	 */

	/**
	 * Fires when file is removed from the queue.
	 *
	 * @event FilesRemoved
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {Array} files Array of files that got removed.
	 */

	/**
	 * Fires for every filtered file before it is added to the queue.
	 * 
	 * @event FileFiltered
	 * @since 2.1
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {plupload.File} file Another file that has to be added to the queue.
	 */

	/**
	 * Fires after files were filtered and added to the queue.
	 *
	 * @event FilesAdded
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {Array} files Array of file objects that were added to queue by the user.
	 */

	/**
	 * Fires when a file is successfully uploaded.
	 *
	 * @event FileUploaded
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {plupload.File} file File that was uploaded.
	 * @param {Object} response Object with response properties.
	 */

	/**
	 * Fires when file chunk is uploaded.
	 *
	 * @event ChunkUploaded
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {plupload.File} file File that the chunk was uploaded for.
	 * @param {Object} response Object with response properties.
	 */

	/**
	 * Fires when all files in a queue are uploaded.
	 *
	 * @event UploadComplete
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {Array} files Array of file objects that was added to queue/selected by the user.
	 */

	/**
	 * Fires when a error occurs.
	 *
	 * @event Error
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 * @param {Object} error Contains code, message and sometimes file and other details.
	 */

	/**
	 * Fires when destroy method is called.
	 *
	 * @event Destroy
	 * @param {plupload.Uploader} uploader Uploader instance sending the event.
	 */
	var uid = plupload.guid()
	, settings
	, files = []
	, preferred_caps = {}
	, fileInputs = []
	, fileDrops = []
	, startTime
	, total
	, disabled = false
	, xhr
	;


	// Private methods
	function uploadNext() {
		var file, count = 0, i;

		if (this.state == plupload.STARTED) {
			// Find first QUEUED file
			for (i = 0; i < files.length; i++) {
				if (!file && files[i].status == plupload.QUEUED) {
					file = files[i];
					if (this.trigger("BeforeUpload", file)) {
						file.status = plupload.UPLOADING;
						this.trigger("UploadFile", file);
					}
				} else {
					count++;
				}
			}

			// All files are DONE or FAILED
			if (count == files.length) {
				if (this.state !== plupload.STOPPED) {
					this.state = plupload.STOPPED;
					this.trigger("StateChanged");
				}
				this.trigger("UploadComplete", files);
			}
		}
	}


	function calcFile(file) {
		file.percent = file.size > 0 ? Math.ceil(file.loaded / file.size * 100) : 100;
		calc();
	}


	function calc() {
		var i, file;

		// Reset stats
		total.reset();

		// Check status, size, loaded etc on all files
		for (i = 0; i < files.length; i++) {
			file = files[i];

			if (file.size !== undef) {
				// We calculate totals based on original file size
				total.size += file.origSize;

				// Since we cannot predict file size after resize, we do opposite and
				// interpolate loaded amount to match magnitude of total
				total.loaded += file.loaded * file.origSize / file.size;
			} else {
				total.size = undef;
			}

			if (file.status == plupload.DONE) {
				total.uploaded++;
			} else if (file.status == plupload.FAILED) {
				total.failed++;
			} else {
				total.queued++;
			}
		}

		// If we couldn't calculate a total file size then use the number of files to calc percent
		if (total.size === undef) {
			total.percent = files.length > 0 ? Math.ceil(total.uploaded / files.length * 100) : 0;
		} else {
			total.bytesPerSec = Math.ceil(total.loaded / ((+new Date() - startTime || 1) / 1000.0));
			total.percent = total.size > 0 ? Math.ceil(total.loaded / total.size * 100) : 0;
		}
	}


	function getRUID() {
		var ctrl = fileInputs[0] || fileDrops[0];
		if (ctrl) {
			return ctrl.getRuntime().uid;
		}
		return false;
	}


	function runtimeCan(file, cap) {
		if (file.ruid) {
			var info = o.Runtime.getInfo(file.ruid);
			if (info) {
				return info.can(cap);
			}
		}
		return false;
	}


	function bindEventListeners() {
		this.bind('FilesAdded', onFilesAdded);

		this.bind('CancelUpload', onCancelUpload);
		
		this.bind('BeforeUpload', onBeforeUpload);

		this.bind('UploadFile', onUploadFile);

		this.bind('UploadProgress', onUploadProgress);

		this.bind('StateChanged', onStateChanged);

		this.bind('QueueChanged', calc);

		this.bind('Error', onError);

		this.bind('FileUploaded', onFileUploaded);

		this.bind('Destroy', onDestroy);
	}


	function initControls(settings, cb) {
		var self = this, inited = 0, queue = [];

		// common settings
		var options = {
			accept: settings.filters.mime_types,
			runtime_order: settings.runtimes,
			required_caps: settings.required_features,
			preferred_caps: preferred_caps,
			swf_url: settings.flash_swf_url,
			xap_url: settings.silverlight_xap_url
		};

		// add runtime specific options if any
		plupload.each(settings.runtimes.split(/\s*,\s*/), function(runtime) {
			if (settings[runtime]) {
				options[runtime] = settings[runtime];
			}
		});

		// initialize file pickers - there can be many
		if (settings.browse_button) {
			plupload.each(settings.browse_button, function(el) {
				queue.push(function(cb) {
					var fileInput = new o.FileInput(plupload.extend({}, options, {
						name: settings.file_data_name,
						multiple: settings.multi_selection,
						container: settings.container,
						browse_button: el
					}));

					fileInput.onready = function() {
						var info = o.Runtime.getInfo(this.ruid);

						// for backward compatibility
						o.extend(self.features, {
							chunks: info.can('slice_blob'),
							multipart: info.can('send_multipart'),
							multi_selection: info.can('select_multiple')
						});

						inited++;
						fileInputs.push(this);
						cb();
					};

					fileInput.onchange = function() {
						self.addFile(this.files);
					};

					fileInput.bind('mouseenter mouseleave mousedown mouseup', function(e) {
						if (!disabled) {
							if (settings.browse_button_hover) {
								if ('mouseenter' === e.type) {
									o.addClass(el, settings.browse_button_hover);
								} else if ('mouseleave' === e.type) {
									o.removeClass(el, settings.browse_button_hover);
								}
							}

							if (settings.browse_button_active) {
								if ('mousedown' === e.type) {
									o.addClass(el, settings.browse_button_active);
								} else if ('mouseup' === e.type) {
									o.removeClass(el, settings.browse_button_active);
								}
							}
						}
					});

					fileInput.bind('error runtimeerror', function() {
						fileInput = null;
						cb();
					});

					fileInput.init();
				});
			});
		}

		// initialize drop zones
		if (settings.drop_element) {
			plupload.each(settings.drop_element, function(el) {
				queue.push(function(cb) {
					var fileDrop = new o.FileDrop(plupload.extend({}, options, {
						drop_zone: el
					}));

					fileDrop.onready = function() {
						var info = o.Runtime.getInfo(this.ruid);

						self.features.dragdrop = info.can('drag_and_drop'); // for backward compatibility

						inited++;
						fileDrops.push(this);
						cb();
					};

					fileDrop.ondrop = function() {
						self.addFile(this.files);
					};

					fileDrop.bind('error runtimeerror', function() {
						fileDrop = null;
						cb();
					});

					fileDrop.init();
				});
			});
		}


		o.inSeries(queue, function() {
			if (typeof(cb) === 'function') {
				cb(inited);
			}
		});
	}


	function resizeImage(blob, params, cb) {
		var img = new o.Image();

		try {
			img.onload = function() {
				img.downsize(params.width, params.height, params.crop, params.preserve_headers);
			};

			img.onresize = function() {
				cb(this.getAsBlob(blob.type, params.quality));
				this.destroy();
			};

			img.onerror = function() {
				cb(blob);
			};

			img.load(blob);
		} catch(ex) {
			cb(blob);
		}
	}


	function setOption(option, value, init) {
		var self = this, reinitRequired = false;

		function _setOption(option, value, init) {
			var oldValue = settings[option];

			switch (option) {
				case 'max_file_size':
					if (option === 'max_file_size') {
						settings.max_file_size = settings.filters.max_file_size = value;
					}
					break;

				case 'chunk_size':
					if (value = plupload.parseSize(value)) {
						settings[option] = value;
					}
					break;

				case 'filters':
					// for sake of backward compatibility
					if (plupload.typeOf(value) === 'array') {
						value = {
							mime_types: value
						};
					}

					if (init) {
						plupload.extend(settings.filters, value);
					} else {
						settings.filters = value;
					}

					// if file format filters are being updated, regenerate the matching expressions
					if (value.mime_types) {
						settings.filters.mime_types.regexp = (function(filters) {
							var extensionsRegExp = [];

							plupload.each(filters, function(filter) {
								plupload.each(filter.extensions.split(/,/), function(ext) {
									if (/^\s*\*\s*$/.test(ext)) {
										extensionsRegExp.push('\\.*');
									} else {
										extensionsRegExp.push('\\.' + ext.replace(new RegExp('[' + ('/^$.*+?|()[]{}\\'.replace(/./g, '\\$&')) + ']', 'g'), '\\$&'));
									}
								});
							});

							return new RegExp('(' + extensionsRegExp.join('|') + ')$', 'i');
						}(settings.filters.mime_types));
					}
					break;
	
				case 'resize':
					if (init) {
						plupload.extend(settings.resize, value, {
							enabled: true
						});
					} else {
						settings.resize = value;
					}
					break;

				case 'prevent_duplicates':
					settings.prevent_duplicates = settings.filters.prevent_duplicates = !!value;
					break;

				case 'browse_button':
				case 'drop_element':
						value = plupload.get(value);

				case 'container':
				case 'runtimes':
				case 'multi_selection':
				case 'flash_swf_url':
				case 'silverlight_xap_url':
					settings[option] = value;
					if (!init) {
						reinitRequired = true;
					}
					break;

				default:
					settings[option] = value;
			}

			if (!init) {
				self.trigger('OptionChanged', option, value, oldValue);
			}
		}

		if (typeof(option) === 'object') {
			plupload.each(option, function(value, option) {
				_setOption(option, value, init);
			});
		} else {
			_setOption(option, value, init);
		}

		if (init) {
			// Normalize the list of required capabilities
			settings.required_features = normalizeCaps(plupload.extend({}, settings));

			// Come up with the list of capabilities that can affect default mode in a multi-mode runtimes
			preferred_caps = normalizeCaps(plupload.extend({}, settings, {
				required_features: true
			}));
		} else if (reinitRequired) {
			self.trigger('Destroy');
			
			initControls.call(self, settings, function(inited) {
				if (inited) {
					self.runtime = o.Runtime.getInfo(getRUID()).type;
					self.trigger('Init', { runtime: self.runtime });
					self.trigger('PostInit');
				} else {
					self.trigger('Error', {
						code : plupload.INIT_ERROR,
						message : plupload.translate('Init error.')
					});
				}
			});
		}
	}


	// Internal event handlers
	function onFilesAdded(up, filteredFiles) {
		// Add files to queue				
		[].push.apply(files, filteredFiles);

		up.trigger('QueueChanged');
		up.refresh();
	}


	function onBeforeUpload(up, file) {
		// Generate unique target filenames
		if (settings.unique_names) {
			var matches = file.name.match(/\.([^.]+)$/), ext = "part";
			if (matches) {
				ext = matches[1];
			}
			file.target_name = file.id + '.' + ext;
		}
	}


	function onUploadFile(up, file) {
		var url = up.settings.url
		, chunkSize = up.settings.chunk_size
		, retries = up.settings.max_retries
		, features = up.features
		, offset = 0
		, blob
		;

		// make sure we start at a predictable offset
		if (file.loaded) {
			offset = file.loaded = chunkSize * Math.floor(file.loaded / chunkSize);
		}

		function handleError() {
			if (retries-- > 0) {
				delay(uploadNextChunk, 1000);
			} else {
				file.loaded = offset; // reset all progress

				up.trigger('Error', {
					code : plupload.HTTP_ERROR,
					message : plupload.translate('HTTP Error.'),
					file : file,
					response : xhr.responseText,
					status : xhr.status,
					responseHeaders: xhr.getAllResponseHeaders()
				});
			}
		}

		function uploadNextChunk() {
			var chunkBlob, formData, args, curChunkSize;

			// File upload finished
			if (file.status == plupload.DONE || file.status == plupload.FAILED || up.state == plupload.STOPPED) {
				return;
			}

			// Standard arguments
			args = {name : file.target_name || file.name};

			if (chunkSize && features.chunks && blob.size > chunkSize) { // blob will be of type string if it was loaded in memory 
				curChunkSize = Math.min(chunkSize, blob.size - offset);
				chunkBlob = blob.slice(offset, offset + curChunkSize);
			} else {
				curChunkSize = blob.size;
				chunkBlob = blob;
			}

			// If chunking is enabled add corresponding args, no matter if file is bigger than chunk or smaller
			if (chunkSize && features.chunks) {
				// Setup query string arguments
				if (up.settings.send_chunk_number) {
					args.chunk = Math.ceil(offset / chunkSize);
					args.chunks = Math.ceil(blob.size / chunkSize);
				} else { // keep support for experimental chunk format, just in case
					args.offset = offset;
					args.total = blob.size;
				}
			}

			xhr = new o.XMLHttpRequest();

			// Do we have upload progress support
			if (xhr.upload) {
				xhr.upload.onprogress = function(e) {
					file.loaded = Math.min(file.size, offset + e.loaded);
					up.trigger('UploadProgress', file);
				};
			}

			xhr.onload = function() {
				// check if upload made itself through
				if (xhr.status >= 400) {
					handleError();
					return;
				}

				retries = up.settings.max_retries; // reset the counter

				// Handle chunk response
				if (curChunkSize < blob.size) {
					chunkBlob.destroy();

					offset += curChunkSize;
					file.loaded = Math.min(offset, blob.size);

					up.trigger('ChunkUploaded', file, {
						offset : file.loaded,
						total : blob.size,
						response : xhr.responseText,
						status : xhr.status,
						responseHeaders: xhr.getAllResponseHeaders()
					});

					// stock Android browser doesn't fire upload progress events, but in chunking mode we can fake them
					if (o.Env.browser === 'Android Browser') {
						// doesn't harm in general, but is not required anywhere else
						up.trigger('UploadProgress', file);
					} 
				} else {
					file.loaded = file.size;
				}

				chunkBlob = formData = null; // Free memory

				// Check if file is uploaded
				if (!offset || offset >= blob.size) {
					// If file was modified, destory the copy
					if (file.size != file.origSize) {
						blob.destroy();
						blob = null;
					}

					up.trigger('UploadProgress', file);

					file.status = plupload.DONE;

					up.trigger('FileUploaded', file, {
						response : xhr.responseText,
						status : xhr.status,
						responseHeaders: xhr.getAllResponseHeaders()
					});
				} else {
					// Still chunks left
					delay(uploadNextChunk, 1); // run detached, otherwise event handlers interfere
				}
			};

			xhr.onerror = function() {
				handleError();
			};

			xhr.onloadend = function() {
				this.destroy();
				xhr = null;
			};

			// Build multipart request
			if (up.settings.multipart && features.multipart) {

				args.name = file.target_name || file.name;

				xhr.open("post", url, true);

				// Set custom headers
				plupload.each(up.settings.headers, function(value, name) {
					xhr.setRequestHeader(name, value);
				});

				formData = new o.FormData();

				// Add multipart params
				plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
					formData.append(name, value);
				});

				// Add file and send it
				formData.append(up.settings.file_data_name, chunkBlob);
				xhr.send(formData, {
					runtime_order: up.settings.runtimes,
					required_caps: up.settings.required_features,
					preferred_caps: preferred_caps,
					swf_url: up.settings.flash_swf_url,
					xap_url: up.settings.silverlight_xap_url
				});
			} else {
				// if no multipart, send as binary stream
				url = plupload.buildUrl(up.settings.url, plupload.extend(args, up.settings.multipart_params));

				xhr.open("post", url, true);

				xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // Binary stream header

				// Set custom headers
				plupload.each(up.settings.headers, function(value, name) {
					xhr.setRequestHeader(name, value);
				});

				xhr.send(chunkBlob, {
					runtime_order: up.settings.runtimes,
					required_caps: up.settings.required_features,
					preferred_caps: preferred_caps,
					swf_url: up.settings.flash_swf_url,
					xap_url: up.settings.silverlight_xap_url
				});
			}
		}

		blob = file.getSource();

		// Start uploading chunks
		if (up.settings.resize.enabled && runtimeCan(blob, 'send_binary_string') && !!~o.inArray(blob.type, ['image/jpeg', 'image/png'])) {
			// Resize if required
			resizeImage.call(this, blob, up.settings.resize, function(resizedBlob) {
				blob = resizedBlob;
				file.size = resizedBlob.size;
				uploadNextChunk();
			});
		} else {
			uploadNextChunk();
		}
	}


	function onUploadProgress(up, file) {
		calcFile(file);
	}


	function onStateChanged(up) {
		if (up.state == plupload.STARTED) {
			// Get start time to calculate bps
			startTime = (+new Date());
		} else if (up.state == plupload.STOPPED) {
			// Reset currently uploading files
			for (var i = up.files.length - 1; i >= 0; i--) {
				if (up.files[i].status == plupload.UPLOADING) {
					up.files[i].status = plupload.QUEUED;
					calc();
				}
			}
		}
	}


	function onCancelUpload() {
		if (xhr) {
			xhr.abort();
		}
	}


	function onFileUploaded(up) {
		calc();

		// Upload next file but detach it from the error event
		// since other custom listeners might want to stop the queue
		delay(function() {
			uploadNext.call(up);
		}, 1);
	}


	function onError(up, err) {
		// Set failed status if an error occured on a file
		if (err.file) {
			err.file.status = plupload.FAILED;
			calcFile(err.file);

			// Upload next file but detach it from the error event
			// since other custom listeners might want to stop the queue
			if (up.state == plupload.STARTED) { // upload in progress
				up.trigger('CancelUpload');
				delay(function() {
					uploadNext.call(up);
				}, 1);
			}
		}
	}


	function onDestroy(up) {
		up.stop();

		// Purge the queue
		plupload.each(files, function(file) {
			file.destroy();
		});
		files = [];

		if (fileInputs.length) {
			plupload.each(fileInputs, function(fileInput) {
				fileInput.destroy();
			});
			fileInputs = [];
		}

		if (fileDrops.length) {
			plupload.each(fileDrops, function(fileDrop) {
				fileDrop.destroy();
			});
			fileDrops = [];
		}

		preferred_caps = {};
		disabled = false;
		startTime = xhr = null;
		total.reset();
	}


	// Default settings
	settings = {
		runtimes: o.Runtime.order,
		max_retries: 0,
		chunk_size: 0,
		multipart: true,
		multi_selection: true,
		file_data_name: 'file',
		flash_swf_url: 'js/Moxie.swf',
		silverlight_xap_url: 'js/Moxie.xap',
		filters: {
			mime_types: [],
			prevent_duplicates: false,
			max_file_size: 0
		},
		resize: {
			enabled: false,
			preserve_headers: true,
			crop: false
		},
		send_chunk_number: true // whether to send chunks and chunk numbers, or total and offset bytes
	};

	
	setOption.call(this, options, null, true);

	// Inital total state
	total = new plupload.QueueProgress(); 

	// Add public methods
	plupload.extend(this, {

		/**
		 * Unique id for the Uploader instance.
		 *
		 * @property id
		 * @type String
		 */
		id : uid,
		uid : uid, // mOxie uses this to differentiate between event targets

		/**
		 * Current state of the total uploading progress. This one can either be plupload.STARTED or plupload.STOPPED.
		 * These states are controlled by the stop/start methods. The default value is STOPPED.
		 *
		 * @property state
		 * @type Number
		 */
		state : plupload.STOPPED,

		/**
		 * Map of features that are available for the uploader runtime. Features will be filled
		 * before the init event is called, these features can then be used to alter the UI for the end user.
		 * Some of the current features that might be in this map is: dragdrop, chunks, jpgresize, pngresize.
		 *
		 * @property features
		 * @type Object
		 */
		features : {},

		/**
		 * Current runtime name.
		 *
		 * @property runtime
		 * @type String
		 */
		runtime : null,

		/**
		 * Current upload queue, an array of File instances.
		 *
		 * @property files
		 * @type Array
		 * @see plupload.File
		 */
		files : files,

		/**
		 * Object with name/value settings.
		 *
		 * @property settings
		 * @type Object
		 */
		settings : settings,

		/**
		 * Total progess information. How many files has been uploaded, total percent etc.
		 *
		 * @property total
		 * @type plupload.QueueProgress
		 */
		total : total,


		/**
		 * Initializes the Uploader instance and adds internal event listeners.
		 *
		 * @method init
		 */
		init : function() {
			var self = this;

			if (typeof(settings.preinit) == "function") {
				settings.preinit(self);
			} else {
				plupload.each(settings.preinit, function(func, name) {
					self.bind(name, func);
				});
			}

			// Check for required options
			if (!settings.browse_button || !settings.url) {
				this.trigger('Error', {
					code : plupload.INIT_ERROR,
					message : plupload.translate('Init error.')
				});
				return;
			}

			bindEventListeners.call(this);

			initControls.call(this, settings, function(inited) {
				if (typeof(settings.init) == "function") {
					settings.init(self);
				} else {
					plupload.each(settings.init, function(func, name) {
						self.bind(name, func);
					});
				}

				if (inited) {
					self.runtime = o.Runtime.getInfo(getRUID()).type;
					self.trigger('Init', { runtime: self.runtime });
					self.trigger('PostInit');
				} else {
					self.trigger('Error', {
						code : plupload.INIT_ERROR,
						message : plupload.translate('Init error.')
					});
				}
			});
		},

		/**
		 * Set the value for the specified option(s).
		 *
		 * @method setOption
		 * @since 2.1
		 * @param {String|Object} option Name of the option to change or the set of key/value pairs
		 * @param {Mixed} [value] Value for the option (is ignored, if first argument is object)
		 */
		setOption: function(option, value) {
			setOption.call(this, option, value, !this.runtime); // until runtime not set we do not need to reinitialize
		},

		/**
		 * Get the value for the specified option or the whole configuration, if not specified.
		 * 
		 * @method getOption
		 * @since 2.1
		 * @param {String} [option] Name of the option to get
		 * @return {Mixed} Value for the option or the whole set
		 */
		getOption: function(option) {
			if (!option) {
				return settings;
			}
			return settings[option];
		},

		/**
		 * Refreshes the upload instance by dispatching out a refresh event to all runtimes.
		 * This would for example reposition flash/silverlight shims on the page.
		 *
		 * @method refresh
		 */
		refresh : function() {
			if (fileInputs.length) {
				plupload.each(fileInputs, function(fileInput) {
					fileInput.trigger('Refresh');
				});
			}
			this.trigger('Refresh');
		},

		/**
		 * Starts uploading the queued files.
		 *
		 * @method start
		 */
		start : function() {
			if (this.state != plupload.STARTED) {
				this.state = plupload.STARTED;
				this.trigger('StateChanged');

				uploadNext.call(this);
			}
		},

		/**
		 * Stops the upload of the queued files.
		 *
		 * @method stop
		 */
		stop : function() {
			if (this.state != plupload.STOPPED) {
				this.state = plupload.STOPPED;
				this.trigger('StateChanged');
				this.trigger('CancelUpload');
			}
		},


		/**
		 * Disables/enables browse button on request.
		 *
		 * @method disableBrowse
		 * @param {Boolean} disable Whether to disable or enable (default: true)
		 */
		disableBrowse : function() {
			disabled = arguments[0] !== undef ? arguments[0] : true;

			if (fileInputs.length) {
				plupload.each(fileInputs, function(fileInput) {
					fileInput.disable(disabled);
				});
			}

			this.trigger('DisableBrowse', disabled);
		},

		/**
		 * Returns the specified file object by id.
		 *
		 * @method getFile
		 * @param {String} id File id to look for.
		 * @return {plupload.File} File object or undefined if it wasn't found;
		 */
		getFile : function(id) {
			var i;
			for (i = files.length - 1; i >= 0; i--) {
				if (files[i].id === id) {
					return files[i];
				}
			}
		},

		/**
		 * Adds file to the queue programmatically. Can be native file, instance of Plupload.File,
		 * instance of mOxie.File, input[type="file"] element, or array of these. Fires FilesAdded, 
		 * if any files were added to the queue. Otherwise nothing happens.
		 *
		 * @method addFile
		 * @since 2.0
		 * @param {plupload.File|mOxie.File|File|Node|Array} file File or files to add to the queue.
		 * @param {String} [fileName] If specified, will be used as a name for the file
		 */
		addFile : function(file, fileName) {
			var self = this
			, queue = [] 
			, files = []
			, ruid
			;

			function filterFile(file, cb) {
				var queue = [];
				o.each(self.settings.filters, function(rule, name) {
					if (fileFilters[name]) {
						queue.push(function(cb) {
							fileFilters[name].call(self, rule, file, function(res) {
								cb(!res);
							});
						});
					}
				});
				o.inSeries(queue, cb);
			}

			/**
			 * @method resolveFile
			 * @private
			 * @param {o.File|o.Blob|plupload.File|File|Blob|input[type="file"]} file
			 */
			function resolveFile(file) {
				var type = o.typeOf(file);

				// o.File
				if (file instanceof o.File) { 
					if (!file.ruid && !file.isDetached()) {
						if (!ruid) { // weird case
							return false;
						}
						file.ruid = ruid;
						file.connectRuntime(ruid);
					}
					resolveFile(new plupload.File(file));
				}
				// o.Blob 
				else if (file instanceof o.Blob) {
					resolveFile(file.getSource());
					file.destroy();
				} 
				// plupload.File - final step for other branches
				else if (file instanceof plupload.File) {
					if (fileName) {
						file.name = fileName;
					}
					
					queue.push(function(cb) {
						// run through the internal and user-defined filters, if any
						filterFile(file, function(err) {
							if (!err) {
								files.push(file);
								self.trigger("FileFiltered", file);
							}
							delay(cb, 1); // do not build up recursions or eventually we might hit the limits
						});
					});
				} 
				// native File or blob
				else if (o.inArray(type, ['file', 'blob']) !== -1) {
					resolveFile(new o.File(null, file));
				} 
				// input[type="file"]
				else if (type === 'node' && o.typeOf(file.files) === 'filelist') {
					// if we are dealing with input[type="file"]
					o.each(file.files, resolveFile);
				} 
				// mixed array of any supported types (see above)
				else if (type === 'array') {
					fileName = null; // should never happen, but unset anyway to avoid funny situations
					o.each(file, resolveFile);
				}
			}

			ruid = getRUID();
			
			resolveFile(file);

			if (queue.length) {
				o.inSeries(queue, function() {
					// if any files left after filtration, trigger FilesAdded
					if (files.length) {
						self.trigger("FilesAdded", files);
					}
				});
			}
		},

		/**
		 * Removes a specific file.
		 *
		 * @method removeFile
		 * @param {plupload.File|String} file File to remove from queue.
		 */
		removeFile : function(file) {
			var id = typeof(file) === 'string' ? file : file.id;

			for (var i = files.length - 1; i >= 0; i--) {
				if (files[i].id === id) {
					return this.splice(i, 1)[0];
				}
			}
		},

		/**
		 * Removes part of the queue and returns the files removed. This will also trigger the FilesRemoved and QueueChanged events.
		 *
		 * @method splice
		 * @param {Number} start (Optional) Start index to remove from.
		 * @param {Number} length (Optional) Lengh of items to remove.
		 * @return {Array} Array of files that was removed.
		 */
		splice : function(start, length) {
			// Splice and trigger events
			var removed = files.splice(start === undef ? 0 : start, length === undef ? files.length : length);

			// if upload is in progress we need to stop it and restart after files are removed
			var restartRequired = false;
			if (this.state == plupload.STARTED) { // upload in progress
				restartRequired = true;
				this.stop();
			}

			this.trigger("FilesRemoved", removed);

			// Dispose any resources allocated by those files
			plupload.each(removed, function(file) {
				file.destroy();
			});

			this.trigger("QueueChanged");
			this.refresh();

			if (restartRequired) {
				this.start();
			}

			return removed;
		},

		/**
		 * Dispatches the specified event name and it's arguments to all listeners.
		 *
		 *
		 * @method trigger
		 * @param {String} name Event name to fire.
		 * @param {Object..} Multiple arguments to pass along to the listener functions.
		 */

		/**
		 * Check whether uploader has any listeners to the specified event.
		 *
		 * @method hasEventListener
		 * @param {String} name Event name to check for.
		 */


		/**
		 * Adds an event listener by name.
		 *
		 * @method bind
		 * @param {String} name Event name to listen for.
		 * @param {function} func Function to call ones the event gets fired.
		 * @param {Object} scope Optional scope to execute the specified function in.
		 */
		bind : function(name, func, scope) {
			var self = this;
			// adapt moxie EventTarget style to Plupload-like
			plupload.Uploader.prototype.bind.call(this, name, function() {
				var args = [].slice.call(arguments);
				args.splice(0, 1, self); // replace event object with uploader instance
				return func.apply(this, args);
			}, 0, scope);
		},

		/**
		 * Removes the specified event listener.
		 *
		 * @method unbind
		 * @param {String} name Name of event to remove.
		 * @param {function} func Function to remove from listener.
		 */

		/**
		 * Removes all event listeners.
		 *
		 * @method unbindAll
		 */


		/**
		 * Destroys Plupload instance and cleans after itself.
		 *
		 * @method destroy
		 */
		destroy : function() {
			this.trigger('Destroy');
			settings = total = null; // purge these exclusively
			this.unbindAll();
		}
	});
};

plupload.Uploader.prototype = o.EventTarget.instance;

/**
 * Constructs a new file instance.
 *
 * @class File
 * @constructor
 * 
 * @param {Object} file Object containing file properties
 * @param {String} file.name Name of the file.
 * @param {Number} file.size File size.
 */
plupload.File = (function() {
	var filepool = {};

	function PluploadFile(file) {

		plupload.extend(this, {

			/**
			 * File id this is a globally unique id for the specific file.
			 *
			 * @property id
			 * @type String
			 */
			id: plupload.guid(),

			/**
			 * File name for example "myfile.gif".
			 *
			 * @property name
			 * @type String
			 */
			name: file.name || file.fileName,

			/**
			 * File type, `e.g image/jpeg`
			 *
			 * @property type
			 * @type String
			 */
			type: file.type || '',

			/**
			 * File size in bytes (may change after client-side manupilation).
			 *
			 * @property size
			 * @type Number
			 */
			size: file.size || file.fileSize,

			/**
			 * Original file size in bytes.
			 *
			 * @property origSize
			 * @type Number
			 */
			origSize: file.size || file.fileSize,

			/**
			 * Number of bytes uploaded of the files total size.
			 *
			 * @property loaded
			 * @type Number
			 */
			loaded: 0,

			/**
			 * Number of percentage uploaded of the file.
			 *
			 * @property percent
			 * @type Number
			 */
			percent: 0,

			/**
			 * Status constant matching the plupload states QUEUED, UPLOADING, FAILED, DONE.
			 *
			 * @property status
			 * @type Number
			 * @see plupload
			 */
			status: plupload.QUEUED,

			/**
			 * Date of last modification.
			 *
			 * @property lastModifiedDate
			 * @type {String}
			 */
			lastModifiedDate: file.lastModifiedDate || (new Date()).toLocaleString(), // Thu Aug 23 2012 19:40:00 GMT+0400 (GET)

			/**
			 * Returns native window.File object, when it's available.
			 *
			 * @method getNative
			 * @return {window.File} or null, if plupload.File is of different origin
			 */
			getNative: function() {
				var file = this.getSource().getSource();
				return o.inArray(o.typeOf(file), ['blob', 'file']) !== -1 ? file : null;
			},

			/**
			 * Returns mOxie.File - unified wrapper object that can be used across runtimes.
			 *
			 * @method getSource
			 * @return {mOxie.File} or null
			 */
			getSource: function() {
				if (!filepool[this.id]) {
					return null;
				}
				return filepool[this.id];
			},

			/**
			 * Destroys plupload.File object.
			 *
			 * @method destroy
			 */
			destroy: function() {
				var src = this.getSource();
				if (src) {
					src.destroy();
					delete filepool[this.id];
				}
			}
		});

		filepool[this.id] = file;
	}

	return PluploadFile;
}());


/**
 * Constructs a queue progress.
 *
 * @class QueueProgress
 * @constructor
 */
 plupload.QueueProgress = function() {
	var self = this; // Setup alias for self to reduce code size when it's compressed

	/**
	 * Total queue file size.
	 *
	 * @property size
	 * @type Number
	 */
	self.size = 0;

	/**
	 * Total bytes uploaded.
	 *
	 * @property loaded
	 * @type Number
	 */
	self.loaded = 0;

	/**
	 * Number of files uploaded.
	 *
	 * @property uploaded
	 * @type Number
	 */
	self.uploaded = 0;

	/**
	 * Number of files failed to upload.
	 *
	 * @property failed
	 * @type Number
	 */
	self.failed = 0;

	/**
	 * Number of files yet to be uploaded.
	 *
	 * @property queued
	 * @type Number
	 */
	self.queued = 0;

	/**
	 * Total percent of the uploaded bytes.
	 *
	 * @property percent
	 * @type Number
	 */
	self.percent = 0;

	/**
	 * Bytes uploaded per second.
	 *
	 * @property bytesPerSec
	 * @type Number
	 */
	self.bytesPerSec = 0;

	/**
	 * Resets the progress to it's initial values.
	 *
	 * @method reset
	 */
	self.reset = function() {
		self.size = self.loaded = self.uploaded = self.failed = self.queued = self.percent = self.bytesPerSec = 0;
	};
};

window.plupload = plupload;

}(window, mOxie));


function getQueryStringParameterByName(name) {
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}

function html_entity_decode(string, quote_style)
{
    var histogram = {}, symbol = '', tmp_str = '', entity = '';
    tmp_str = string.toString();

    if (false === (histogram = get_html_translation_table('HTML_ENTITIES', quote_style))) {
        return false;
    }

    // &amp; must be the last character when decoding!
    delete(histogram['&']);
    histogram['&'] = '&amp;';

    for (symbol in histogram) {
        entity = histogram[symbol];
        tmp_str = tmp_str.split(entity).join(symbol);
    }

    return tmp_str;
}

function get_html_translation_table(table, quote_style)
{
    var entities = {}, histogram = {}, decimal = 0, symbol = '';
    var constMappingTable = {}, constMappingQuoteStyle = {};
    var useTable = {}, useQuoteStyle = {};

    useTable = (table ? table.toUpperCase() : 'HTML_SPECIALCHARS');
    useQuoteStyle = (quote_style ? quote_style.toUpperCase() : 'ENT_COMPAT');

    // Translate arguments
    constMappingTable[0] = 'HTML_SPECIALCHARS';
    constMappingTable[1] = 'HTML_ENTITIES';
    constMappingQuoteStyle[0] = 'ENT_NOQUOTES';
    constMappingQuoteStyle[2] = 'ENT_COMPAT';
    constMappingQuoteStyle[3] = 'ENT_QUOTES';

    // Map numbers to strings for compatibilty with PHP constants
    if (!isNaN(useTable)) {
        useTable = constMappingTable[useTable];
    }
    if (!isNaN(useQuoteStyle)) {
        useQuoteStyle = constMappingQuoteStyle[useQuoteStyle];
    }

    if (useTable == 'HTML_SPECIALCHARS') {
        // ascii decimals for better compatibility
        entities['38'] = '&amp;';
        if (useQuoteStyle != 'ENT_NOQUOTES') {
            entities['34'] = '&quot;';
        }
        if (useQuoteStyle == 'ENT_QUOTES') {
            entities['39'] = '&#039;';
        }
        entities['60'] = '&lt;';
        entities['62'] = '&gt;';
    } else if (useTable == 'HTML_ENTITIES') {
        // ascii decimals for better compatibility
        entities['38'] = '&amp;';
        if (useQuoteStyle != 'ENT_NOQUOTES') {
            entities['34'] = '&quot;';
        }
        if (useQuoteStyle == 'ENT_QUOTES') {
            entities['39'] = '&#039;';
        }
        entities['60'] = '&lt;';
        entities['62'] = '&gt;';
        entities['160'] = '&nbsp;';
        entities['161'] = '&iexcl;';
        entities['162'] = '&cent;';
        entities['163'] = '&pound;';
        entities['164'] = '&curren;';
        entities['165'] = '&yen;';
        entities['166'] = '&brvbar;';
        entities['167'] = '&sect;';
        entities['168'] = '&uml;';
        entities['169'] = '&copy;';
        entities['170'] = '&ordf;';
        entities['171'] = '&laquo;';
        entities['172'] = '&not;';
        entities['173'] = '&shy;';
        entities['174'] = '&reg;';
        entities['175'] = '&macr;';
        entities['176'] = '&deg;';
        entities['177'] = '&plusmn;';
        entities['178'] = '&sup2;';
        entities['179'] = '&sup3;';
        entities['180'] = '&acute;';
        entities['181'] = '&micro;';
        entities['182'] = '&para;';
        entities['183'] = '&middot;';
        entities['184'] = '&cedil;';
        entities['185'] = '&sup1;';
        entities['186'] = '&ordm;';
        entities['187'] = '&raquo;';
        entities['188'] = '&frac14;';
        entities['189'] = '&frac12;';
        entities['190'] = '&frac34;';
        entities['191'] = '&iquest;';
        entities['192'] = '&Agrave;';
        entities['193'] = '&Aacute;';
        entities['194'] = '&Acirc;';
        entities['195'] = '&Atilde;';
        entities['196'] = '&Auml;';
        entities['197'] = '&Aring;';
        entities['198'] = '&AElig;';
        entities['199'] = '&Ccedil;';
        entities['200'] = '&Egrave;';
        entities['201'] = '&Eacute;';
        entities['202'] = '&Ecirc;';
        entities['203'] = '&Euml;';
        entities['204'] = '&Igrave;';
        entities['205'] = '&Iacute;';
        entities['206'] = '&Icirc;';
        entities['207'] = '&Iuml;';
        entities['208'] = '&ETH;';
        entities['209'] = '&Ntilde;';
        entities['210'] = '&Ograve;';
        entities['211'] = '&Oacute;';
        entities['212'] = '&Ocirc;';
        entities['213'] = '&Otilde;';
        entities['214'] = '&Ouml;';
        entities['215'] = '&times;';
        entities['216'] = '&Oslash;';
        entities['217'] = '&Ugrave;';
        entities['218'] = '&Uacute;';
        entities['219'] = '&Ucirc;';
        entities['220'] = '&Uuml;';
        entities['221'] = '&Yacute;';
        entities['222'] = '&THORN;';
        entities['223'] = '&szlig;';
        entities['224'] = '&agrave;';
        entities['225'] = '&aacute;';
        entities['226'] = '&acirc;';
        entities['227'] = '&atilde;';
        entities['228'] = '&auml;';
        entities['229'] = '&aring;';
        entities['230'] = '&aelig;';
        entities['231'] = '&ccedil;';
        entities['232'] = '&egrave;';
        entities['233'] = '&eacute;';
        entities['234'] = '&ecirc;';
        entities['235'] = '&euml;';
        entities['236'] = '&igrave;';
        entities['237'] = '&iacute;';
        entities['238'] = '&icirc;';
        entities['239'] = '&iuml;';
        entities['240'] = '&eth;';
        entities['241'] = '&ntilde;';
        entities['242'] = '&ograve;';
        entities['243'] = '&oacute;';
        entities['244'] = '&ocirc;';
        entities['245'] = '&otilde;';
        entities['246'] = '&ouml;';
        entities['247'] = '&divide;';
        entities['248'] = '&oslash;';
        entities['249'] = '&ugrave;';
        entities['250'] = '&uacute;';
        entities['251'] = '&ucirc;';
        entities['252'] = '&uuml;';
        entities['253'] = '&yacute;';
        entities['254'] = '&thorn;';
        entities['255'] = '&yuml;';
    } else {
        throw Error("Table: " + useTable + ' not supported');
    }

    // ascii decimals to real symbols
    for (decimal in entities) {
        symbol = String.fromCharCode(decimal);
        histogram[symbol] = entities[decimal];
    }

    return histogram;
}

function htmlentities(string, quote_style)
{
    var histogram = {}, symbol = '', tmp_str = '', entity = '';
    tmp_str = string.toString();

    if (false === (histogram = get_html_translation_table('HTML_ENTITIES', quote_style))) {
        return false;
    }

    for (symbol in histogram) {
        entity = histogram[symbol];
        tmp_str = tmp_str.split(symbol).join(entity);
    }

    return tmp_str;
}

/**
 * Returns string with quotes " encoded to HTML entities &quot;
 * @param {String} string
 */
function htmlquotes(string)
{
    return string.toString().replace('"', '&quot;');
}

function rawurlencode(str)
{
    var histogram = {};
    var ret = str.toString();

    var replacer = function(search, replace, str)
    {
        var tmp_arr = [];
        tmp_arr = str.split(search);
        return tmp_arr.join(replace);
    };

    // The histogram is identical to the one in urldecode.
    histogram["'"] = '%27';
    histogram['('] = '%28';
    histogram[')'] = '%29';
    histogram['*'] = '%2A';
    histogram['~'] = '%7E';
    histogram['!'] = '%21';
    histogram['\u20AC'] = '%80';
    histogram['\u0081'] = '%81';
    histogram['\u201A'] = '%82';
    histogram['\u0192'] = '%83';
    histogram['\u201E'] = '%84';
    histogram['\u2026'] = '%85';
    histogram['\u2020'] = '%86';
    histogram['\u2021'] = '%87';
    histogram['\u02C6'] = '%88';
    histogram['\u2030'] = '%89';
    histogram['\u0160'] = '%8A';
    histogram['\u2039'] = '%8B';
    histogram['\u0152'] = '%8C';
    histogram['\u008D'] = '%8D';
    histogram['\u017D'] = '%8E';
    histogram['\u008F'] = '%8F';
    histogram['\u0090'] = '%90';
    histogram['\u2018'] = '%91';
    histogram['\u2019'] = '%92';
    histogram['\u201C'] = '%93';
    histogram['\u201D'] = '%94';
    histogram['\u2022'] = '%95';
    histogram['\u2013'] = '%96';
    histogram['\u2014'] = '%97';
    histogram['\u02DC'] = '%98';
    histogram['\u2122'] = '%99';
    histogram['\u0161'] = '%9A';
    histogram['\u203A'] = '%9B';
    histogram['\u0153'] = '%9C';
    histogram['\u009D'] = '%9D';
    histogram['\u017E'] = '%9E';
    histogram['\u0178'] = '%9F';


    // Begin with encodeURIComponent, which most resembles PHP's encoding functions
    ret = encodeURIComponent(ret);

    // Restore spaces, converted by encodeURIComponent which is not rawurlencode compatible
    ret = replacer('%20', ' ', ret); // Custom replace. No regexing

    for (search in histogram) {
        replace = histogram[search];
        ret = replacer(search, replace, ret); // Custom replace. No regexing
    }

    // Uppercase for full PHP compatibility
    return ret.replace(/(\%([a-z0-9]{2}))/g, function(full, m1, m2)
    {
        return "%" + m2.toUpperCase();
    });
}

function createPreloader(id)
{
    return new Element('div', {
        'id'     : id,
        'html'   : '<table><tbody><tr>' +
            '<td style="padding: 10px"><img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/loader_blue.gif') + '" alt="" /></td>' +
            '<td style="font-weight: bold; vertical-align: middle">'+RC.Lang.Common.RCLOAD_WAIT+'</td>' +
            '</tr></tbody></table>',
        'styles' : {
            'width'     : '160px',
            'height'    : '120px',
            'left'      : '270px',
            'top'       : '20px',
            'position'  : 'relative'
        }
    });
}

var NUMBER_TYPE_CONTACT = 1;
var NUMBER_TYPE_PORTING = 3;
var NUMBER_TYPE_FAXOUT = 4;

function waitForRender(el, handler, count, size)
{

    if (!count)
        var count = 0;

    if (!size)
        var size = {x:0,y:0};

    var xy = el.getSize();

    //if ((xy.x != 0 || xy.y != 0) && (xy.x == size.x || xy.y == size.y)) { //if rendered (dX or dY chanded)
    if (xy.x != 0 && xy.y != 0 && xy.x == size.x && xy.y == size.y) { //if rendered (dX and dY chanded)
        count++;
        if (count == 2) {
            setTimeout(function()
            {
                handler();
            }, 200)
            return;
        }
    }
    setTimeout(function()
    {
        waitForRender(el, handler, count, xy);
    }, 50)
}

function formatExtensionName(pin, name)
{
    return pin < 0 ? name : RC.UI.Message('<div class="extLabel">{0} {1} - {2}</div>', RC.Lang.Common.EXT_DOT, pin, name);
}

var extensions = null;

function hideExtensions(formName)
{
    if (!RC.isEmpty(RC.getCmp(formName).getItem('mailboxId'))) {
        RC.getCmp(formName).setVisible('mailboxId', false);
    }
    if (!RC.isEmpty(RC.getCmp(formName).getItem('mailboxId-scrollbox'))) {
        RC.getCmp(formName).setVisible('mailboxId-scrollbox', false);
    }
}
function clearAllCaches() {
    clearExtensionsCache();
    RC.Model && RC.Model.PhoneLine && RC.Model.PhoneLine.clearCache();
    if (RC.Models) {
        RC.Models.Extensions && RC.Models.Extensions.clearCache();
        RC.Models.Rule && RC.Models.Rule.ExtensionsCache && RC.Models.Rule.ExtensionsCache.clearCache();
        RC.Models.AvailableAdditionalServices && RC.Models.AvailableAdditionalServices.clearCache();
    }
    RC.Console.log('clear all caches');
}
function clearExtensionsCache() {
    RC.Console.log('clear extensions cache');
    extensions = null;
}
function getAllExtensions(cback, force)
{
    if (RC.isEmpty(extensions) || RC.isTrue(force)) {
        Wrapper.Extensions.listExtensionsBrief(new Wrapper.Requests.ListExtensionsRequest(), function(o)
        {
            extensions = o.extensions;
            cback(extensions);
        });
    } else {
        cback(extensions);
    }
}

function getUserExtensions(cback)
{
    Wrapper.Extensions.listExtensionsBrief(new Wrapper.Requests.ListExtensionsRequest(null, 'User'), function(o)
    {
        cback(o.extensions);
    });
}

function getDepartmentMembers(cback)
{
    Wrapper.Extensions.listDepartmentMembers(function(o)
   {
        cback(o.extensions);
    });
}

function getVoicemailRecipientsExtensions(cback)
{
    Wrapper.Extensions.listVoicemailRecipients(function(o)
    {
        cback(o.extensions);
    });
}

function getCallDestinationRecipientsExtensions(cback)
{
    Wrapper.Extensions.listCallDestinationRecipients(function(o)
    {
        cback(o.extensions);
    });
}

function canAddExtension(type, cback)
{
    Wrapper.System.canAddExtension(type, function(o)
    {
        cback(o);
    });
}

function getPayNowInfo(config)
{
    config = config || {};
    config.onSuccess = config.onSuccess || function() {};
    config.onMonthlyBillingFailed = config.onMonthlyBillingFailed || null;

    RC.Loader.show({});

    (new RC.Ajax).send({
        cmd: 'billing.getPayNowInfo',
        useWrapper: true,
        onSuccess : function(response)
        {
            var isMonthlyBillingFailed = response.info.monthlyBillingFailed;
            if (isMonthlyBillingFailed) {
                if (RC.isEmpty(config.onMonthlyBillingFailed)) {
                    RC.ComponentMgr.load('system/payNow.js',
                        function()
                        {
                            RC.Loader.hide();
                            var cmp = new RC.UI.System.PayNow(response.info);
                            var win = new RC.Window(cmp.getPanel());
                            win.show();
                        });
                } else {
                    RC.Loader.hide();
                    config.onMonthlyBillingFailed(response);
                }
            }
            else {
                RC.Loader.hide();
                config.onSuccess();
            }

        }
    });
}


function getDialByNameDirectoryExtensions(extensions, cback)
{
    getAllExtensions(function(exts){
        var dialByNameExts = [];
        exts.each(function(ext){
            RC.utils.Extension.isDialByNameAvailableMailbox(ext) && dialByNameExts.unshift({
                id: ext.id,
                includedInDbNDir: extensions.contains(ext.id),
                name: ext.name,
                pin: ext.pin
            });
        });
        cback(dialByNameExts);
    }, false);
}

function getExtension(mbId)
{
    if (RC.isEmpty(extensions)) {
        return null;
    }
    for (var i = 0; i < extensions.length; i++) {
        if (extensions[i].id == mbId) {
            return extensions[i];
        }
    }
    return null;
}

function getSystemExtension()
{
    if (RC.isEmpty(extensions)) {
        return null;
    }
    for (var i = 0; i < extensions.length; i++) {
        if (extensions[i].system) {
            return extensions[i];
        }
    }
    return null;
}

function getOperatorExtension()
{
    if (userInfo.operatorMailboxId > 0) {
        return getExtension(userInfo.operatorMailboxId);
    } else {
        return getSystemExtension();
    }
}

function truncate(text, length)
{
    if (text == '&nbsp;' || text == '&#160;')
        return text;
    //workaround this non-latin symbols
    var htmlValue = new Element('div', {
        'html' : text
    });
    text = htmlValue.get('text');

    // try to cut unnecessary symbols
    if (length != null && text.length > length)
        return text.substr(0, length) + "...";
    else
        return text;
}

/**
 * @async
 * @cfg {Function} onSuccess
 * @cfg {Function} onError
 * @param {Object} config The config object
 * */
loadDefaultShippingAddress = function(config) {
    config = config || {};
    config.onSuccess = config.onSuccess || function() {};
    config.onError = config.onError || function() {};
    (new RC.Ajax).send({
        cmd: 'extensions.getDefaultShippingAddress',
        useWrapper: true,
        onSuccess : function(response) {
            config.onSuccess(response.shippingAddress);
        },
        onError : function(response) {
            config.onError(response.status);
        }
    });

};

/**
 * @async
 * @cfg {Function} onSuccess
 * @cfg {Function} onError
 * @param {Object} config The config object
 * */
isShippingAllowed = function(config) {
    config = config || {};
    config.onSuccess = config.onSuccess || function() {};
    config.onError = config.onError || function() {};
    (new RC.Ajax).send({
        cmd: 'digitalLine.isShippingAllowed',
        params: {
            checkHardPhone: true
        },
        useWrapper: true,
        onSuccess : function(response) {
            config.onSuccess(response.result);
        },
        onError : function(response) {
            config.onSuccess(false);
        }
    });

};

function injectLearnMoreLink(options)
{

    options = options || {};
    var message = options.message || '';
    var title = options.title || '';

    if (!RC.isEmpty(message) && !RC.isEmpty(title)) {

        hideLearnMoreLink();
        new Element('a', {
            'id'    : 'learnMoreLinkElement',
            'class': 'x-learnMore',
            'html': RC.Lang.Common.LEARN_MORE,
            'href': '#',
            'events': {
                    click: function(e)
                    {

                        e.stop();
                    new RC.WindowAlert(message, {title: title,closable:true});
                        return false;

                    }
                }
        }).inject(RC.panel.Manager.getPageContent(), 'top');

    }
}

function hideLearnMoreLink()
{
    if(!RC.isEmpty($("learnMoreLinkElement"))){
        $("learnMoreLinkElement").destroy();
    }
}

function joinMaps(first, second)
{
    var result = new Object(first);
    for (var key in second) {
        result[key] = second[key];
    }
    return result;
}

function getPaymentTypeForPhoneNumber(paymentType, isAddButton)
{
    if ((paymentType == 'Local' && !isAddButton) ||
        (paymentType == 'TollFree' && isAddButton))
        return RC.Lang.Common.LOCAL;
    else
        return RC.Lang.Common.TOLL_FREE;
}


function getContactDisplayName(item, sortField) {

    if (item.lastName || item.firstName){
        return (sortField == 'lastName') ? (item.lastName ? item.lastName + ' ' : '') + item.firstName : (item.firstName ? item.firstName + ' ' : '') + item.lastName;
    }
    if (item.company){
        return item.company;
    }
    if (item.businessPhone){
        return item.businessPhone;
    }
    if (item.mobilePhone){
        return item.mobilePhone;
    }
    if (item.homePhone){
        return item.homePhone;
    }
    if (item.businessPhone2){
        return item.businessPhone2;
    }
    if (item.homePhone2){
        return item.homePhone2;
    }
    if (item.businessFax){
        return item.businessFax;
    }
    if (item.otherFax){
        return item.otherFax;
    }
    if (item.companyPhone){
        return item.companyPhone;
    }
    if (item.assistantPhone){
        return item.assistantPhone;
    }
    if (item.carPhone){
        return item.carPhone;
    }
    if (item.otherPhone){
        return item.otherPhone;
    }
    if (item.callbackPhone){
        return item.callbackPhone;
    }

    return '';
};

function prepareMsgDownloadUrl()
{
    return correctUrl('/mobile/media?cmd=downloadMessage');
}

/**
 * Adds JSESSIONID if any
 * @param path
 */
function correctUrl(path)
{
    var schemeAndHostRe = new RegExp("^[^/]+\/\/[^/]+\/");
    var hasSchemeAndHostBefore = !!path.match(schemeAndHostRe);

    var jsessionid = null;
    var href = document.location.href;
    // note: we cannot lowercased session id
    var sidLower = href.indexOf(';jsessionid');
    var sidUpper = href.indexOf(';JSESSIONID');
    if (sidLower > 0) {
        jsessionid = sidLower;
    }
    if (sidUpper > 0) {
        jsessionid = sidUpper;
    }
    if (jsessionid != null) {
        jsessionid = href.substr(jsessionid, 44);
    }
    path =  path + (jsessionid != null ? jsessionid : '');

    var uri = new URI(path);
    return hasSchemeAndHostBefore? uri.toString() : uri.toString().replace(schemeAndHostRe, "/");
}

/**
 * Loads audio player
 * @param fn
 */
function loadAudioPlayer(fn)
{
    RC.ComponentMgr.load('player.js', function()
    {
        fn();
    });
}

(function ES5(){
    function notFn( val ){
        return typeof val !== 'function';
    }

    var defineMethod = (function(){
        if ( notFn(Object.defineProperty) )
            Object.defineProperty = function( object, propertyName, descriptor ){
                object[propertyName] = descriptor.value;
                // ignore other descriptors - may cause problems in for-in operator(IE 6/7)
            };

        return function ( obj, name, fn ){
            if ( notFn(obj[name]) )
                Object.defineProperty( obj, name, {
                    value: fn,
                    enumerable: false,
                    configurable: true,
                    writable: true
                });
        }
    })();

    // Object.keys
    defineMethod( Object, 'keys', function( object ){
        var keys = [],
            key;

        for ( key in object ) if ( object.hasOwnProperty(key) )
            keys.push( key );

        return keys;
    });
})();

function isPhonesSectionAllowed(includeSLGs)
{
    return isDigitalUsersExist(true, includeSLGs);
}

function isDigitalUsersExist(withUnassignedPhones, includeSLGs)
{
    var result = false;
    if (!RC.Config.isUserBasedTier) {
        return true;
    }

    (new RC.Ajax).send({
        cmd: 'system.isDigitalUsersExist',
        useWrapper: true,
        async: false,
        params : {
            includeUnassignedPhones : RC.isTrue(withUnassignedPhones),
            includeSLGs: RC.isTrue(includeSLGs)
        },
        onSuccess: function (o) {
            if (o.result) {
                result = true;
            } else {
                RC.Loader.show({});
                (new RC.Ajax).send (
                    {
                        cmd: 'system.getCounters',
                        useWrapper: true,
                        onSuccess: function (o) {
                            RC.Msg.alert(RC.Lang.Common.ALERT, RC.UI.Message(
                                RC.Lang.Common.GET_COUNTERS_TEXT,
                                RC.Lang.Common.AVAILABLE_MAILBOX_TYPES[o.availableMailboxTypes.DigitalUser.toUpperCase()]
                            ),null,true);
                            RC.Loader.hide();
                        }
                    }
                );

            }
        }
    });

    return result;
}

function arraySplit(source, splitterFn){
    var result = [];
    if (source && source.length) {
        source.each(function (record, idx) {
            var splitIdx = Number(splitterFn(record, idx));
            switch (splitIdx) {
                case -1: break; //exclude
                default:
                    if (!result[splitIdx]) {
                        result[splitIdx] = []
                    }
                    result[splitIdx].push(record);
            }
        });
    }

    return result;
}

/**
 * RCLibX core utilities and functions.
 *
 * @class
 * @name RC
 * @copyright 2010 RingCentral, Inc.
 * @version 2.0
 * @singleton
 */
var RC = {
    /**
     * <tt>true</tt> if RCLibX is ready. Read-only.
     * @type {Boolean}
     */
    isReady : false,
    /**
     * The version of the library. Read-only.
     * @type {String}
     */
    version : '2.1',
    xtypes : [],
    idSeed  : 0,

    // Brand identifier to be used for requesting RCLibX assets.
    // It should be set as soon as RCLibX loaded
    skinName: null,

    /**
     * Return a path to the RCLibX skinned image.
     * @param {String} src Path related to library current skin root
     * @param {Boolean} [substituteLocale] Set locale code into the url (optional, default to false)
     * @returns {String}
     */
    getSkinnedRCLibXImageUrl: function(src, substituteLocale) {
        if (substituteLocale) {
            src = this.substituteLocale(src, RC.configuration.locale);
        }
        return this.getSkinnedRCLibXImageBase() + src + '?v=' + this.configuration.version;
    },

    /**
     * Return a root of RCLibX skinned images.
     * @returns {String}
     */
    getSkinnedRCLibXImageBase: function() {
        return '/RCLibX/assets/skins/' + this.skinName + '/';
    },

    /**
     * Return a path to the service site skinned image.
     * @param {String} src Path related to library current skin root
     * @param {Boolean} [substituteLocale] Set locale code into the url (optional, default to false)
     * @returns {String}
     */
    getSkinnedSSImageUrl: function(src, substituteLocale) {
        if (substituteLocale) {
            src = this.substituteLocale(src, RC.configuration.locale);
        }
        return this.getSkinnedSSImageBase() + src + '?v=' + this.configuration.version;
    },

    /**
     * Set locale code into the specified path
     * @param path {String} File path
     * @param locale {String} Locale code
     * @returns {String}
     */
    substituteLocale: function(path, locale) {
        return path.replace(/^(.+)(\.[a-z0-9]+)$/i, "$1_" + locale + "$2");
    },

    /**
     * Return a root of service site skinned images.
     * @returns {String}
     */
    getSkinnedSSImageBase: function() {
        return '/assets/skins/' + this.skinName+ '/';
    },

    /**
     * Return a path to the service site asset.
     * @param {String} src Path related to library current skin root
     * @returns {String}
     */
    getSSAssetUrl: function(src) {
        return '/assets/' + src + '?v=' + this.configuration.version;
    },

    /**
     * Returns true if the passed value is empty.
     * @param {*} v
     * @return {Boolean}
     */
    isEmpty : function(v)
    {
        if (v === null || v === undefined)
            return true;
        if (RC.isArray(v)) {
            return v.length == 0;
        }
        if (RC.isObject(v)) {
            var isPropExists = false;
            for (var k in v) {
                isPropExists = true;
                break;
            }
            return !isPropExists;
        }
        if (v.length > 0)
            return false;

        v = '' + v + '';
        return v == '';
    },
    /**
     * Returns true if the passed value is array.
     * @param {*} v
     * @return {Boolean}
     */
    isArray : function (v)
    {
        return v && typeof v.length == "number" && typeof v.splice == "function";
    },
    /**
     * Returns true if the passed value is <tt>true</tt>.
     * @param {*} v
     * @return {Boolean}
     */
    isTrue  : function(v)
    {
        return v === undefined ? false : v === true || parseInt(v) == 1 || v == "true";
    },
    /**
     * Returns true if the passed value is <tt>false</tt>.
     *
     * TODO: Remove it.
     * @param {*} v
     * @return {Boolean}
     */
    isFalse  : function(v)
    {
        return v === undefined ? false : v === false || parseInt(v) == 0 || v == "false";
    },
    /**
     * Returns true if the passed value is valid email address.
     * @param {*} v
     * @param {Boolean} multiple Checks multiple comma separated emails according to RFC 2822
     * @return {Boolean}
     */
    isEmail : function(v, multiple)
    {
        if (!!multiple) {
            //this Regexp is also suitable for multiple emails (comma separated)
            return /^(?:[a-z0-9!#$%&'*+=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?[ ,;]*)+$/i.test(v);
        } else {
            return /^[a-z0-9!#$%&'*+=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(v);
        }
    },
    /**
     * Returns true if the passed value is a number. Returns false for non-finite numbers.
     * @param {*} v
     * @return {Boolean}
     */
    isNumeric : function(v)
    {
        return RC.isEmpty(v) ? false : !isNaN(v);
    },

    /**
     * Returns true if the passed value is a string. Returns false for non string.
     * @param {*} v
     * @return {Boolean}
     */
    isString: function(v ) {
        return typeof v == 'string' || v instanceof String;
    },

    /**
     * Returns true if the passed value is an integer.
     * @param {*} v
     * @return {Boolean}
     */
    isInt : function(v)
    {
        if (RC.isEmpty(v)) return false;
        return /^\d+$/.test(v);
    },
    /**
     * Returns true if the passed value is an object.
     * @param {*} v
     * @return {Boolean}
     */
    isObject : function(v)
    {
        return v != null && typeof v == 'object';
    },
    /**
     * Returns true if the passed value is a function.
     * @param {*} v
     * @return {Boolean}
     */
    isFunc : function(v)
    {
        return v != null && typeof v == 'function';
    },
    /**
     * Returns true if the passed value is not undefined.
     * @param {*} value The value to test
     * @return {Boolean}
     */
    isDefined : function(v)
    {
        return typeof v !== 'undefined';
    },
    isBoolean:function(e)
    {
        return typeof e === "boolean"
    },
    /**
     * Converts value to array if it's not an array
     * @param {*} v
     * @return {Array}
     */
    toArray : function(v)
    {
        if (RC.isArray(v)) {
            return v;
        }
        return $A([v]);
    },

    /**
     * Compare two item by it's field name
     * @param {Object} item1
     * @param {Object} item2
     * @param {mix} fieldName, String or String array
     * @param {Boolean} caseInSensitive
     * @return {Boolean}
     */
    compareStringField : function(item1, item2, fieldName, caseInSensitive) {
        var fieldNames = RC.isArray(fieldName) ? fieldName : [fieldName];
        var item1Values =[], item2Values = [];
        fieldNames.forEach(function(fieldName) {
            item1Values.push(getFieldValue(item1, fieldName));
            item2Values.push(getFieldValue(item2, fieldName));
        });

        var item1Value = item1Values.join(' ');
        var item2Value = item2Values.join(' ');

        if (caseInSensitive === true) {
            item1Value = item1Value.toLowerCase();
            item2Value = item2Value.toLowerCase();
        }
        return item1Value.localeCompare(item2Value);

        function getFieldValue(item, fieldName) {
            return RC.isEmpty(item[fieldName]) ? "" : item[fieldName].toString();
        }
    },

    /**
     * Check if provided object is an instance of MooTools Element
     * instanceof Element not working in IE78
     * @param {Object} v
     * @return {Boolean}
     */
    isMooElement: function(v){
        return (v != null && typeof v == 'object' && 'getElements' in v);
    },
    isPOBox : function(address){

        var isPOBox = false;

        (new RC.Ajax).send({
            cmd : 'validation.checkPOBox',
            useWrapper: true,
            params : {
                address: address
            },
            async : false,
            onSuccess : function(o) {
                isPOBox = RC.isTrue(o.result);
            }
        });

        return isPOBox;

    },
    replacePlaceHolders : function(conf, holders)
    {
        //RC.Console.log(Array.toJSON(conf));
        $each(conf, function(val, key)
        {
            //RC.Console.log(Array.toJSON(val) + " " + RC.isObject(val) + " " + RC.isArray(val));
            var new_val;
            if (RC.isObject(val) || RC.isArray(val)) {
                if (typeof val[0] == 'string' && holders[val[0]]) {
                    new_val = holders[val[0]];
                    if (RC.isFunc(new_val)) new_val = new_val(val[1] ? val[1] : undefined);
                    conf[key] = new_val;
                } else
                    conf[key] = this.replacePlaceHolders(val, holders);
            }
        }, this);
        return conf;
    },
    /**
     * Generates unique Id for the component
     * @param {Object/RC.Element} [el] The config object
     * @return {String} Id of the component
     */
    genId   : function(el)
    {
        if (el !== undefined && el.id !== undefined)
            return el.id;
        return (el = $(el) || {}).id = el.id || "rc-gen" + (++RC.idSeed);
    },
    /**
     * Wrapper for meaningful ID creation
     * @cfg {Object/RC.Element} item The config object for RC.genId() call
     * @cfg {String} prefix Prefix which will be inserted without changes
     * @cfg {String} idFromText String which will be changed into ID using RC.utils.Text.idFromText()
     * @param config
     * @return {String}
     */
    genPrefixedId: function(config){
        if (RC.isEmpty(config.item)) config.item = undefined;
        if (!RC.isEmpty(config.id)) return config.id;
        return RC.genId(config.item) +
               (!RC.isEmpty(config.prefix) ? '-' + config.prefix : '') +
               (!RC.isEmpty(config.idFromText) ? '-' + RC.utils.Text.idFromText(config.idFromText) : '');
    },
    /**
     * Returns component by id. Shorthand of {@link RC.ComponentMgr#get}.
     * @param {String} id Id of the component
     * @return {RC.Element|RC.Window}
     */
    getCmp  : function(id)
    {
        var cmp = RC.ComponentMgr.get(id);
        return cmp === undefined ? null : cmp;
    },

    /**
     * Destroys component. TODO: Remove it.
     */
    safeDestroyCmp : function ()
    {
        for (var i = 0, l = arguments.length; i < l; i++) {
            try {
                (arguments[i] || {destroy: function() {}}).destroy();
            } catch(e) {
            }
        }
    },

    /**
     * Destroys component by name. TODO: Remove it.
     */
    safeDestroyCmpByName : function ()
    {
        for (var i = 0, l = arguments.length; i < l; i++) {
            if (!RC.isEmpty(arguments[i])) {
                RC.safeDestroyCmp(RC.getCmp(arguments[i]));
            }
        }
    },
    /**
     * Shorthand for {@link RC.ComponentMgr.registerType}
     *
     * TODO: Implement it as shorthand
     * @param xtype
     * @param object
     */
    reg : function(xtype, object)
    {
        var isExists = false;
        RC.xtypes.each(function(r)
        {
            if (r[0] == xtype) {
                r = [xtype, object];
                isExists = true;
            }
        });
        if (!isExists) {
            RC.xtypes.push([xtype, object]);
        }
    },
    /**
     * Instantiate component by xtype
     * @param {*} cmp
     */
    createComponent : function(cmp)
    {
        if (RC.isEmpty(cmp.xtype)) {
            return cmp instanceof RC.Element || cmp instanceof RC.form.Field ? cmp : null;
        }
        var o = null;
        RC.xtypes.each(function (r)
        {
            if (r[0] == cmp.xtype) {
                o = r[1];
                return false;
            }
        });
        //RC.Console.log(cmp);
        //RC.Console.log(o);
        if (RC.isFunc(o)) {
            return new o(cmp);
        } else {
            return null;
        }
    },
    /**
     * Repeats a string a specified number of times.TODO: Move it to UTILS
     * @param {String} Source string
     * @param {Number} The number of times to repeat the string.
     * @return {String} .
     */
    str_repeat : function(str, n)
    {
        str = str || "";
        return new Array(n + 1).join(str);
    },
    /**
     * Pads a string with the specified character(s) either before or after the current value. TODO: Move it to UTILS
     * @param {String} Source string
     * @param {Number} the number of characters to pad
     * @param {String} the string to use for padding; defaults to a space
     * @param {Number} either 0->(left), 1->(right) or 2->(both) (defaults to 1); the side to add the padding.
     * @return {String}.
     */
    str_pad : function(str, l, s, t)
    {
        str = str || "";
        if ((l -= str.length) > 0) {
            if (!s) s = " ";
            if (t == null) t = 1;

            s = RC.str_repeat(s, Math.ceil(l / s.length));
            var i = t == 0 ? l : (t == 1 ? 0 : Math.floor(l / 2));
            s = s.substr(0, i) + str + s.substr(0, l - i);

            return s;
        }
        return str;
    },
    /**
     * Cuts string to selected length. TODO: Move it to UTILS
     * @param {String} text The text which should be cut off
     * @param {Number} length The length of the string
     * @return {String} Cutted string
     */
    substr : function(text, length)
    {
        // workaround this non-latin symbols
        var htmlValue = new Element('div', {
            'html' : text
        });
        text = htmlValue.get('text');

        // try to cut unnecessary symbols
        if (length != null && text.length > length)
            return text.substr(0, length) + "...";
        else
            return text;
    },
    /**
     * Determines width. TODO: Remove it
     * @param {Object} item
     * @return {String} Width object
     */
    width : function(item)
    {
        if (!RC.isEmpty(item.anchor)) {
            return item.anchor;
        }
        else if (!RC.isEmpty(item.width)) {
            return item.width + 'px';
        }
        else
            return 'auto';
    },
    /**
     * Facade for standard alert. TODO: Should moved to RC.Msg
     * @param {String} str The string to display in alert
     */
    alert : function(str)
    {
        var htmlValue = new Element('div', {
            'html': str
        });
        alert(htmlValue.get('text'));
    },
    /**
     * Encodes UNICODE symbols to HTML presentation. TODO: Rename it
     * @param {String} str The string in unicode format
     * @param {Boolean} isHTML (optional) True if you want to return as html
     * @return {String} The encoded string
     */
    strFromURLEnc : function(str, isHTML)
    {
        if (RC.isEmpty(str) || str == '&nbsp;' || str == '&#160;') {
            return str;
        }
        var htmlValue = new Element('div', {
            'html': String(str).replace(/&(?!amp;|lt;|gt;|#160;|nbsp;)/g, "&amp;")
        });
        var textValue = htmlValue.get(isHTML === true ? 'html' : 'text').replace(/&(?!amp;|lt;|gt;|#160;|nbsp;)/g, "&amp;");
        htmlValue.destroy();
        return textValue;
    },
    /**
     * Returns true if the passed area code is a toll-free.
     * TODO: Move it to UTILS
     * @param {String} areaCode
     * @return {Boolean}
     */
    isTollFreeAreaCode : function (areaCode)
    {
        return areaCode.test(/800|888|877|866|855|844/);
    },

    isCanadaPostalCode : function(code){

        return code.match(/^[a-zA-Z]{1}[0-9]{1}[a-zA-Z]{1} [0-9]{1}[a-zA-Z]{1}[0-9]{1}$/i);

    },
    /**
     * Reloads current document
     */
    reloadLocation : function() {
        var doc = document;
        while (!RC.isEmpty(doc.parent)) {
            doc = doc.parent;
        }
        if(RC.Loader && RC.Loader.show) {
            RC.Loader.reset();
            setTimeout(function() {
                RC.Loader.show({});
            }, 10);
        }
        doc.location.reload();
    },
    /**
     * Loads new location
     */
    changeLocation : function(url, doNotShowLoader)
    {
        if (!RC.isTrue(doNotShowLoader))
            RC.Loader.show({});
        window.open(url, '_top');
    },
    handleSessionTimeout: function() {
        RC.Loader.show({});
        setTimeout(function() {
            RC.changeLocation('/login/timeout.html');
        }, 500);
    },
    /**
     * Inserts item into array by passed index
     * TODO: move to UTILS
     * @param {Array} array
     * @param {Object} item
     * @param {Number} idx
     * @return {Array} Updated array
     */
    insertToArray : function(array, item, idx)
    {
        if (RC.isEmpty(idx)) {
            idx = 0;
        }
        if (item === undefined) {
            item = null;
        }
        var newArray = [];
        if (RC.isEmpty(array)) {
            newArray = [];
            newArray[idx] = item;
        } else {
            var beforeInsert = array.length > idx ? idx : array.length;
            var i = 0;
            for (; i < beforeInsert; i++) {
                newArray[i] = array[i];
            }
            newArray[i] = item;
            i++;
            for (; i <= array.length; i++) {
                newArray[i] = array[i - 1];
            }
        }
        return newArray;
    },

    /**
     * Create namespaces
     */
    namespace:function()
    {
        var D,e;
        $each(arguments, function(E)
        {
            e = E.split(".");
            D = window[e[0]] = window[e[0]] || {};
            $each(e.slice(1), function(F)
            {
                D = D[F] = D[F] || {}
            })
        });
        return D;
    },

    ns : function() {
        this.namespace.apply(this, arguments);
    },

    //todo may be need move to another name space. Tools?
    isVisible:function (obj) {
        if (obj == document) return true;

        if (!obj) return false;
        if (!obj.parentNode) return false;
        if (obj.style) {
            if (obj.style.display == 'none') return false;
            if (obj.style.visibility == 'hidden') return false;
        }

        //Try the computed style in a standard way
        if (window.getComputedStyle) {
            var style = window.getComputedStyle(obj, "");
            if (style.display == 'none') return false;
            if (style.visibility == 'hidden') return false;
        }

        //Or get the computed style using IE's silly proprietary way
        var style = obj.currentStyle;
        if (style) {
            if (style['display'] == 'none') return false;
            if (style['visibility'] == 'hidden') return false;
        }

        return RC.isVisible(obj.parentNode);
    },

    /*
     create namespace

     var NS = RC.createNS("RC.Some.Grid.My");
     NS.factory = 90;
     alert(RC.Some.Grid.My.factory) // 90;
     @deprecated
     */
    createNS : function (str)
    {
        var NS = window;
        $each(str.split("."), function(part, i)
        {
            NS = NS[part] = NS[part] || {};
        });
        return NS;
    },
    /**
     * Temporary fix for undetermined element render event, usage should be generally avoided, but in critical cases is OK
     * TODO Introduce similar method for all form/non-form elements
     * @param {String} selector to find and wait for
     * @param {Function} callback will receive found element(s) as a first parameter
     * @param {int} timeout to override default value
     */
    waitForElement: function(selector, callback, timeout) {

        var waitForRenderTimeOut = timeout || 5000;
        var waitForRenderInterval = 500;

        var startTime = new Date().getTime();

        var recurse = function() {

            setTimeout(function() {

                var element;
                if (RC.isMooElement(selector)) {
                    element = selector;

                } else {
                    element = document.getElements(selector);
                }

                if (element) return callback(element);
                if (new Date().getTime() - waitForRenderTimeOut > startTime) return recurse();
                RC.Console.error("RC.waitForElement(): Element with selector \"%s\" was not found", selector); //TODO Throw something?

            }, waitForRenderInterval);

        };

        recurse();

    },

    /**
     * You will can call returned function only one time
     * If you will call returned function two or more times - nothing will happens
     * */
    onlyOneCall:function (callBack) {
        var loaded = 0;
        return  RC.isFunc(callBack) ? function () { // make sure we only call the event once
            if (++loaded == 1) callBack();
        } : function () {};
    }
};

RC.utils = {};
RC.panel = {};
RC.data = {};
RC.data.proxy = {};
RC.grid = {};

/**
 * Copies all the properties of config to obj.
 * @param {Object} obj The receiver of the properties
 * @param {Object} config The source of the properties
 * @param {Object} [defaults] A different object that will also be applied for default values
 * @return {Object} returns obj
 */
RC.apply = function(obj, config, defaults)
{
    if (defaults) {
        RC.apply(obj, defaults);
    }
    if (obj && config && typeof config == "object") {
        for (var a in config) {
            obj[a] = config[a];
        }
    }
    return obj;
};

/**
 * Copies all the properties of config to obj if they don't already exist.
 * @param {Object} obj The receiver of the properties
 * @param {Object} config The source of the properties
 * @return {Object} returns obj
 */
RC.applyIf = function(o, c)
{
    if (o) {
        for (var p in c) {
            if (!RC.isDefined(o[p])) {
                o[p] = c[p];
            }
        }
    }
    return o;
};


(function()
{
    RC.apply(RC, {
        /**
         * Extends one class to create a subclass and optionally overrides members with the passed literal.
         * This method also adds the function "override()" to the subclass that can be used to override members of the class.
         * @param {Function} superclass The constructor of class being extended
         * @param {Object} overrides A literal with members which are copied into the subclass's prototype, and are therefore shared among all instances of the new class.
         * @return {Function} The subclass constructor from the <code>overrides</code> parameter, or a generated one if not provided.
         */
        extend:function()
        {
            var io = function(o)
            {
                for (var m in o) {
                    this[m] = o[m];
                }
            };
            var oc = Object.prototype.constructor;
            return function(sb, sp, overrides)
            {
                if (typeof sp == "object") {
                    overrides = sp;
                    sp = sb;
                    sb = overrides.constructor != oc ? overrides.constructor : function()
                    {
                        sp.apply(this, arguments);
                    };
                }
                var F = function()
                {
                },sbp,spp = sp.prototype;
                F.prototype = spp;
                sbp = sb.prototype = new F();
                sbp.constructor = sb;
                sb.superclass = spp;
                if (spp.constructor == oc) {
                    spp.constructor = sp;
                }
                sb.override = function(o)
                {
                    RC.override(sb, o);
                };
                sbp.override = io;
                RC.override(sb, overrides);
                sb.extend = function(o)
                {
                    RC.extend(sb, o);
                };
                return sb;
            };
        }(),
        /**
         * Adds a list of functions to the prototype of an existing class, overwriting any existing methods with the same name.
         * @param {Object} origclass The class to override
         * @param {Object} overrides The list of functions to add to origClass. This should be specified as an object literal containing one or more meth
         */
        override:function(origclass, overrides)
        {
            if (overrides) {
                var p = origclass.prototype;
                for (var method in overrides) {
                    p[method] = overrides[method];
                }
                if (Browser.name === "ie" && overrides.toString != origclass.toString) {
                    p.toString = overrides.toString;
                }
            }
        }});
})();


/**
 * @class
 * @name RC.Console
 * Facade for Firebug's console object. See {@link http://getfirebug.com/logging} for details.
 * @singleton
 */
RC.Console = (function(){

    var consoleAvailableCookie = 'RCDEBUG';
    var rawCookie = 'RCLIBX_DEBUG';
    var disableListProgressiveRenderingCookie = 'RCLIBX_DISABLE_LIST_PROGRESSIVE_RENDERING';

    /**
     * Checks, if console is available
     * @return {Boolean}
     * @private
     */
    var isAvailable = function(){

        // Check if cookie is set
        return (Cookie.read(consoleAvailableCookie) == 1);

    };

    var call = function(name, args){

        if (!isAvailable()) return; // Check that console is allowed
        if (typeof console == 'undefined' || !('warn' in console)) return; // Check that console exists and is functional
        if (!(name in console) || typeof console[name] == 'undefined') { // Check that console has proper method
            console.warn('Function "' + name + '" is not implemented.');
            return;
        }

        if (Browser.name === "ie") {

            var callString = [];

            for (var i = 0; i < args.length; i++) {

                callString.push('args[' + i + ']');

            }
            eval('console[name](' + callString.join(', ') + ');');

        } else {

            console[name].apply(console, args);

        }

    };

    /**
     * Uses Firebug syntax  arguments can be:
     *   2. RC.Console(Var1, Var2,)  as many arguments as you want and they will be joined together in a row
     *   1. RC.Console(Object)  pass any kind of object and it will be displayed as a hyperlink (elements, functions, arrays, plain ol' objects, etc.)
     *   3. RC.Console(StringFormat, Var1, Var2,)  format strings in the great tradition of printf
     * @private
     */
    var self = function(){
        call('log', arguments);        
    };

    self.log = function(){
        self.apply(self, arguments);
    };
    
    self.warn = function(){
        call('warn', arguments);
    };

    self.info = function(){
        call('info', arguments);        
    };

    self.error = function(){
        call('error', arguments);        
    };

    /**
     * Log an interactive listing of an object's properties, like a miniature version of the DOM tab
     * @param {Object} object
     */
    self.dir = function(object){
        call('dir', arguments);
    };

    /**
     * Print a lovely XML outline, like a miniature version of the HTML tab.  
     * @param {Object} element HTML or XML element
     */
    self.dirxml = function(element){
        call('dirxml', arguments);
    };

    /**
     * Firebug will write a very informative stack trace to the console
     */
    self.trace = function(){
        call('trace', arguments);
    };

    var lastTime = '';
    var lastProfile = '';
    var lastGroup = '';

    /**
     * Starts timing
     * @param {String} name
     */
    self.time = function(name){
        lastTime = name;
        call('time', arguments);        
    };

    /**
     * Finishes timing
     * @param {String} name If omitted - last started timing is used
     */
    self.timeEnd = function(name){
        if (!name) arguments = [lastTime];
        call('timeEnd', arguments);        
    };

    /**
     * Starts profiling
     * @param {String} name
     */
    self.profile = function(name){
        lastProfile = name;
        call('profile', arguments);
    };

    /**
     * Finishes profiling
     * @param {String} name If omitted - last started profiling is used
     */
    self.profileEnd = function(name){
        if (!name) arguments = [lastProfile];
        call('profileEnd', arguments);        
    };

    /**
     * Start a new indentation block
     * @param {String} name
     */
    self.group = function(name){
        lastGroup = name;
        call('group', arguments);        
    };

    /**
     * Close an indentation block
     * @param {String} name If omitted - last started group is used
     */
    self.groupEnd = function(name){
        if (!name) arguments = [lastGroup];
        call('groupEnd', arguments);
    };

    self.enable = function(days){
        
        days = (days == undefined) ? 365 : days;
        Cookie.write(consoleAvailableCookie, 1, {duration: days});

    };

    self.disable = function(){

        Cookie.dispose(consoleAvailableCookie);

    };

    self.enableRaw = function(days){

        days = (days == undefined) ? 365 : days;
        Cookie.write(rawCookie, 2, {duration: days});

    };

    self.disableRaw = function(){

        Cookie.dispose(rawCookie);

    };

    self.isProgressiveRenderingDisabled = function(){

        return (Cookie.read(disableListProgressiveRenderingCookie) == 1);

    };

    self.disableListProgressiveRendering = function(days){

        days = (days == undefined) ? 365 : days;
        Cookie.write(disableListProgressiveRenderingCookie, 1, {duration: days});

    };

    self.enableListProgressiveRendering = function(){

        Cookie.dispose(disableListProgressiveRenderingCookie);

    };

    return self;

})();

/**
 * Base class that provides a common interface for publishing events.
 * Subclasses are expected to have a property "listeners" with configured listeners defined.
 *
 * @class
 * @name RC.utils.Observable
 * @constructor
 * @param {Object} config The config object
 */
RC.utils.Observable = function(config) {
    /**
     * @cfg {Array} listeners
     * A config object containing one or more event handlers to be added to this object during initialization.
     * This should be a valid listeners config object as specified in the addListener example for attaching multiple handlers at once.
     */
    this._listeners = {};
    this._disposableListeners = {};
    this._disposableListenersArguments = {};

    if (!RC.isEmpty(config.listeners)) {
        for (var item in config.listeners) {
            this.addListener(item, config.listeners[item]);
        }
    }
    // register component
    RC.ComponentMgr.register(this);
};

RC.utils.Observable.prototype = {
    /**
     * Adds the specified events to the list of events which this Observable may fire.
     * @param {Object|String} o Either an object with event names as properties with a value of true
     * or the first event name string if multiple event names are being passed as separate parameters.
     * @param {String} name1 (optional) Event name if multiple event names are being passed as separate parameters.
     * @param {String} name2 (optional) Event name if multiple event names are being passed as separate parameters.
     * Usage:

     this.addEvents('storeloaded', 'storecleared');

     */
    addEvents : function(o) {
        var me = this;
        me.events = me.events || {};
        if (typeof o == 'string') {
            var i = arguments.length;
            while (i--) {
                me.events[arguments[i]] = me.events[arguments[i]] || true;
            }
        } else {
            RC.applyIf(me.events, o);
        }

    },
    /**
     *
     * @param {String} name Event name
     * @param {Function} fn Callback function
     * @param {Object} [scope] Scope of a listener, this object will become "this" inside listener
     * (default Observable object itself)
     */
    addListener : function(name, fn, scope) {
        //this.removeListener(name);
        this._listeners = this._listeners || {};
        this._listeners[name] = this._listeners[name] || [];
        scope = scope || this;
        this._listeners[name].push({
            'event'     : name,
            'fireFn'    : fn,
            'scope'     : scope
        });
        if (this.isDisposableListenerFired(name)) { // Fire listener immediately if is inited already
            RC.Console.log('RC.utils.Observable.addListener(%s): Disposable listener has been fired already', name);
            fn.apply(scope, this.getDisposableListenerArgumens(name));
        }
    },
    /**
     * Alias to addListener
     * @param {String} name Event name
     * @param {function} fn Callback function
     */
    on: function(name, fn) {
        this.addListener(name, fn);
    },
    /**
     * Checks to see if this object has any listeners for a specified event
     * @param {String} eventName Event name
     * @return {Boolean} True if the event is being listened for, else false
     */
    hasListener : function(eventName) {
        return (this._listeners && (eventName in this._listeners) && this._listeners[eventName].length > 0);
    },
    /**
     * Iterate through attached listeners
     * If listener returns false  it breaks the chain and no more listener get executed and "false" is returned as a return value
     * If listener does not return any value (no return calls or "return;" statement)  nothing happens to return value
     * If listener returns anything  this overrides previous return value
     * @param {String} name Event name
     * @return {Object} Return listener return value if at least one of listener returned anything, null otherwise
     */
    fireListener : function(name) {

        if (this.isDisposableListenerFired(name)) { // Do not fire listeners if is inited already
            RC.Console.warn('RC.utils.Observable.fireListener(%s): Disposable listener has been fired already', name);
            return null;
        }

        var res = null;
        var listeners = this.getListeners(name);
        var args = Array.prototype.slice.call(arguments, 0);
        args.splice(0, 1);

        if (this.isDisposableListener(name)) {
            this.setDisposableListenerFired(name);
            this.setDisposableListenerArgumens(name, args); // Remember init arguments
        }

        if (listeners != null) {

            var canContinue = true;

            // Iterate through attached listeners
            listeners.each(function(listener) {

                if (!listener) return; // continue execution if listener has been removed

                // Fire listener
                if (canContinue && RC.isFunc(listener.fireFn)){

                    var r = listener.fireFn.apply(listener.scope, args);

                //If listener returned false  break the cycle
                if (r === false) canContinue = false;

                    // If listener returned anything  assign it to return, be aware that other listener may overwrite it
                if (r !== undefined) res = r;

                }

            });

            this._listeners[name] = listeners.clean(); // clean potentially deleted listeners
        }

        

        return res;
    },
    /**
     * Alias to fireListener
     * @param {String} name Event name
     */
    emit: function(name, params) {
        this.fireListener(name, params);
    },
    /**
     * Remove listener, can remove all at once or only one if specified
     * @param {String} name Event name
     * @param {Function} listener (optional) Listener to remove
     */
    removeListener : function(name, listener) {
        var self = this;
        if (this.hasListener(name)) {
            //this._listeners.splice(this.getIndexOf(name), 1);
            if (!listener) {
                // Delete all
                delete this._listeners[name];
            } else {
                this._listeners[name].each(function(r, i) {
                    // Delete specified function
                    // UIA-16218 or ask KK
                    // We are not deleting listener via self._listeners[name].splice(i, 1); because in this case listeners array will change for example during running fireListener
                    if (r.fireFn == listener) delete self._listeners[name][i];
                });
            }
        }
    },

    /**
     * Clear all listeners
     */
    clearListeners: function() {
        this._listeners = {};
        this._disposableListeners = {};
        this._disposableListenersArguments = {};
    },

    /**
     * Returns last listener for a given event name  as in obsolete behavior
     * @param {String} name Event name
     */
    getListener : function(name) {
        RC.Console.warn('This method is deprecated, use getListeners() instead to get all listeners.');
        //return this._listeners[this.getIndexOf(name)];
        return (this.hasListener(name)) ? this._listeners[name][this._listeners[name].length - 1] : null;
    },
    /**
     * Returns listeners for a given event name
     * @param {String} name Event name
     */
    getListeners : function(name) {
        return (this.hasListener(name)) ? this._listeners[name] : null;
    },
    /**
     * Assumes, that a named listener is disposable, which means, that is can be fired only once and all listeners,
     * that would be added after it's first exec would be executed immediately
     * @param name
     */
    addDisposableListener: function(name) {
        this._disposableListeners[name] = false;
        this._disposableListenersArguments[name] = [];
    },
    isDisposableListener: function(name) {
        return (name in this._disposableListeners);
    },
    isDisposableListenerFired: function(name) {
        if (!this.isDisposableListener(name)) return false;
        return (this._disposableListeners[name]);
    },
    setDisposableListenerFired: function(name) {
        this._disposableListeners[name] = true;
    },
    setDisposableListenerArgumens: function(name, args) {
        //args = [].concat(args);
        this._disposableListenersArguments[name] = args;
    },
    getDisposableListenerArgumens: function(name) {
        return this._disposableListenersArguments[name];
    }
};


/**
 * Data provider for AJAX Wrapper
 * <p/>
 * Created by Ivan Soloviev, ivans@dins.ru
 * <p/>
 * Copyright (c) 2011 RingCentral, Inc.
 * All rights reserved.
 *
 * @class
 * @name Wrapper
 * @singleton
 */
var Wrapper = (function () {
    return {
        /**
         * Gets information about wrapper's version
         * @type String
         */
        version : "5.0.3 / Sprint 4",
        /**
         * Use this flag if you want to work with non-company rule
         * @type Boolean
         */
        IS_NOT_COMPANY : false,
        /**
         * Use this flag if you want to work with company rule
         * @type Boolean
         */
        IS_COMPANY : true,

        /**
         * Gets list of registered methods
         * @static
         */
        discover : function()
        {

        },

        /**
         * Sends command to AJAX Wrapper
         * <br/><br/>
         * Do not use it directly
         * @param {String} cmd
         * @param {Array/Object} params
         * @param {Function} [onSuccess] (optional)
         * @param {Function} [onError] (optional)
         * @param {Boolean} [async] (optional)
         * @param {Boolean} [skipLoader] (optional)
         * @private
         */
        send: function(cmd, params, onSuccess, onError, async, skipLoader, urlEncoded)
        {
            var onComplete = null;
            if (!skipLoader) {
                RC.Loader.show({});
                onComplete = function (){
                    RC.Loader.hide();
                };
            }

            var isAsync = RC.isDefined(async) ? (async===true) : true;
            if (!isAsync) RC.Console.warn('Warning! Sync AJAX call!', cmd);

            (new RC.Ajax).send({
                async      : isAsync,
                useWrapper : true,
                cmd        : cmd,
                params     : params,
                urlEncoded: urlEncoded,
                onSuccess  : function(response)
                {
                    if (RC.isFunc(onSuccess)) {
                        onSuccess.call(this, response);
                    }
                },
                onError    : RC.isFunc(onError) ? onError : null,
                onComplete : onComplete
            });
        },
        sendSync: function(cmd, params, fn, onError, skipLoader){
            this.send(cmd, params, fn, onError, false, skipLoader);
        }
    }
})();

/**
 * @namespace
 * @name Wrapper.Config
 */
Wrapper.Config = {

    /**
     * @public
     * @function
     * @name Wrapper.Config.getParameters
     * @param {number} brandId
     * @param {function} [fn]
     * @param {function} [err]
     * @param {boolean} [skipLoader]
     * @rturn {void}
     */
    getParameters : function(brandId, fn, err, skipLoader) {
        this.send("config.getParameters", {
            brandId: brandId || null
        }, fn, err, true, skipLoader);
    },

    /**
     * Gets the list of available language for specific brandId.
     * @param {String} brandId
     * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
     * <ul>
     *     <li><b>response</b> : {@link Wrapper.Responses.ListAvailableLocales}
     * </ul>
     * @param {Function} onError (optional) The function to be called. It will be passed the following parameters:
     * @param {Boolean} skipLoader
     */
    getAllLanguages: function (brandId, fn, onError, skipLoader) {
        this.send("config.listAvailableLocales", {
            brandId: brandId || null
        }, fn, onError, true, skipLoader);
    }
};


RC.apply(Wrapper.Config, Wrapper);

/**
 * Works with rules, greetings and etc.
 * <br/><br/>
 * Alias for namespace: <b>rules</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=rules.listHoursRules&...
 * </pre>
 *
 * @class
 * @name Wrapper.Rules
 * @extends Wrapper
 * @singleton
 */
Wrapper.Rules = (function() {
    return {
        /**
         * Gets the list of hours rules.
         * <br/><br/>
         * <i>Note: If After Hours rule is not exists it will be present with zero id</i>
         *
         * @param {Number} mid
         * @param {Boolean} isCompany Defaults to <tt>false</tt>
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListAnsweringRulesResponse}
         * </ul>
         */
        listHoursRules : function(mid, isCompany, fn)
        {
            this.send("rules.listHoursRules", {
                mid : mid,
                isCompany : isCompany
            }, fn);
        },

        /**
         * Gets list of custom greetings
         * @param {Wrapper.Requests.GreetingsRequest} request The instance of {@link Wrapper.Requests.GreetingsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListGreetingsResponse}
         * </ul>
         */
        listGreetings : function(request, fn)
        {
            this.send("rules.listGreetings",
                request.serialize(), fn);
        },

        /**
         * Using only for advanced users with enabled agent profile rule
         * @param {MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.AgentProfileResponse}               ,
         * </ul>
         */
        getAgentProfile : function(request, fn)
        {
            this.send("rules.getAgentProfile", {
                mid : request.mid
            }, fn);
        },

        /**
         * Using only for advanced users with enabled agent profile rule
         * @param {SetAgentProfileRequest} request The instance of {@link Wrapper.Requests.SetAgentProfileRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}               ,
         * </ul>
         */
        setAgentProfile : function(request, fn)
        {
            this.send("rules.setAgentProfile", {
                mid : request.mid
            }, fn);
        },

        /**
         * Gets information about custom greeting
         * @param {GreetingsRequest} request The instance of {@link Wrapper.Requests.GreetingsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.GreetingDataResponse}
         * </ul>
         */
        getGreeting : function(request, fn)
        {
            this.send("rules.getGreeting", request.serialize(), fn);
        },

        /**
         * Sets information about greeting
         * @param {GreetingsRequest} request The instance of {@link Wrapper.Requests.GreetingsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        setGreeting : function(request, fn)
        {
            this.send("rules.setGreeting", request.serialize(), fn);
        },

        /**
         * Deletes custom greeting
            * @param {GreetingsRequest} request The instance of {@link Wrapper.Requests.GreetingsRequest}      * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        deleteGreeting : function(request, fn)
        {
            this.send("rules.deleteGreeting", request, fn);
        },

        /**
         * Gets list of custom rules on mailbox
         * @param {Number} mid
         * @param {Boolean} isCompany Defaults to <tt>false</tt>
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListAnsweringRulesResponse}
         * </ul>
         */
        listCustomRules : function(mid, isCompany, fn)
        {
            this.send("rules.listCustomRules", {
                mid : mid,
                isCompany : isCompany
            }, fn);
        },

        /**
         * Gets custom rule information by id
         * @param {AnsweringRuleRequest} request The instance of {@link Wrapper.Requests.AnsweringRuleRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.AnsweringRuleInfoResponse}
         * </ul>
         */
        getCustomRule : function(request, fn)
        {
            this.send("rules.getCustomRule", request.serialize(), fn);
        },

        /**
         * Sets custom rule to mailbox
         * @param {AnsweringRuleInfoRequest} request The instance of {@link Wrapper.Requests.AnsweringRuleInfoRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        setCustomRule : function(request, fn)
        {
            this.send("rules.setCustomRule", request.serialize(), fn);
        },

        /**
         * Deletes custom rule form mailbox
         * @param {Object} request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.AnsweringRuleInfoResponse}
         * </ul>
         */
        deleteCustomRule : function(request, fn)
        {
            this.send("rules.deleteCustomRule", request, fn);
        },

        /**
         * Gets rule from mailbox by type
         * @param {AnsweringRuleRequest} request The instance of {@link Wrapper.Requests.AnsweringRuleRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.AnsweringRuleInfoResponse}
         * </ul>
         */
        getHoursRule : function(request, fn)
        {
            this.send("rules.getHoursRule", request.serialize(), fn);
        },

        /**
         * Sets hours rule to mailbox
         * @param {Object} params.
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setHoursRule : function(params, onSuccess, onError) {
            this.send("rules.setHoursRule", params, onSuccess, onError);
        },

        /**
         * Deletes after hours rule form mailbox.
         * @param {Number} mid
         * @param {Boolean} isCompany Defaults to <tt>false</tt>
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        deleteAfterHoursRule : function(mid, isCompany, fn)
        {
            this.send("rules.deleteHoursRule", {
                mid : mid,
                isCompany : isCompany
            }, fn);
        },

        /**
         * Determines ability to show condition mode option
         * @param {Number} mid
         * @param {Boolean} isCompany Defaults to <tt>false</tt>
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isConditionModeAllowed : function(mid, isCompany, fn)
        {
            this.send("rules.isConditionModeAllowed", {
                mid : mid,
                isCompany : isCompany
            }, fn);
        },

        /**
         * Gets mailbox's DND status
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.DNDStatusResponse}
         * </ul>
         */
        getDNDStatus : function(request, fn)
        {
            this.send("rules.getDNDStatus", request.serialize(), fn);
        },

        /**
         * Sets mailbox's DND status
         * @param {Wrapper.Requests.DNDStatusRequest} request The instance of {@link Wrapper.Requests.DNDStatusRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setDNDStatus : function(request, fn)
        {
            this.send("rules.setDNDStatus", request.serialize(), fn);
        },

        /**
         * Returns <tt>true</tt> if dept has at least one of answering rule with active simultaneously order
         *
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isSimultaneouslyRuleExist : function(request, fn)
        {
            this.send("rules.isSimultaneouslyRuleExist", request, fn);
        },

        /**
         * Sets settings of operator extension
         *
         * @param request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setOperatorSettings : function(request, fn)
        {
            this.send("rules.setOperatorSettings", request, fn);
        },

        /**
         * Gets settings of operator extension
         *
         * @param request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.OperatorSettingsResponse}
         * </ul>
         */
        getOperatorSettings : function(request, fn)
        {
            this.send("rules.getOperatorSettings", request.serialize(), fn);
        },

        /**
         * Gets intervals for business hours rule
         *
         * @param request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BusinessHoursIntervalResponse}
         * </ul>
         */
        getBusinessHoursIntervals : function(request, fn)
        {
            this.sendSync("rules.getBusinessHoursIntervals", request, fn);
        },

        /**
         * Sets intervals for business hours rule
         *
         * @param request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setBusinessHoursIntervals : function(request, fn)
        {
            this.send("rules.setBusinessHoursIntervals", request.serialize(), fn);
        },


        /**
         * @deprecated
         */
        checkNumberPortability : function(number, fn)
        {
            this.send("rules.checkNumberPortability", {number: number}, fn);
        },

        getOnHoldMusic : function(mid, fn)
        {
            this.send("rules.getOnHoldMusic", {mid: mid}, fn);
        },

        setOnHoldMusic : function(mid, presetType, greetingId, fn)
        {
            this.send("rules.setOnHoldMusic", {mid: mid, presetType: presetType, greetingId: greetingId}, fn);
        }    }
})();

RC.apply(Wrapper.Rules, Wrapper);

/**
 * Needs to login to account/partner
 * <br/><br/>
 * Alias for namespace: <b>authenticator</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=authenticator.partnerLogin&...
 * </pre>
 *
 * @class
 * @name Wrapper.Authenticator
 * @extends Wrapper
 * @singleton
 */
Wrapper.Authenticator = (function() {
    return {
        /**
         * Authenticates partner in system.
         * @param {String} username Partner's login name
         * @param {String} userpassword Partner's password
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.PartnerSessionKeyResponse}
         * </ul>
         */
        partnerLogin : function(username, userpassword, fn)
        {
            this.send("authenticator.authenticator", {
                username : username,
                userpassword : userpassword
            }, fn);
        },
        /**
         * Normalizes phone number
         * @param {String} phoneNumber
         * @param {Function} fn
         */
        normalizePhoneNumber: function(phoneNumber, fn) {
            this.send("authenticator.normalizePhoneNumber", {
                phoneNumber : phoneNumber
            }, fn);
        }
    }
})();

RC.apply(Wrapper.Authenticator, Wrapper);

/**
 * Used for validation actions
 * <br/><br/>
 * Alias for namespace: <b>validation</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=validation.validateExtensionPin&...
 * </pre>
 *
 * @class
 * @name Wrapper.Validation
 * @extends Wrapper
 * @singleton
 */
Wrapper.Validation = (function() {
    return {
        /**
         * Checks extension number.
         * @param {Wrapper.Requests.ValidateExtensionPinRequest} request The instance of {@link Wrapper.Requests.ValidateExtensionPinRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        validateExtensionPin : function(request, fn, onError)
        {
            this.sendSync("validation.validateExtensionPin",
                request.serialize(), fn, onError);
        },

        /**
         * Checks phone number.
         * @param {String} number
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkInternationalNumber : function(number, fn, err)
        {
            this.sendSync("validation.checkInternationalNumber", {
                number : number
            }, fn, err);
        },

        /**
         * Checks if given number in our pool
         *
         * @param {String} phoneNumber
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkIsRingCentralNumber : function(phoneNumber, fn)
        {
            this.send("validation.checkIsRingCentralNumber", {
                phoneNumber : phoneNumber
            }, fn);
        },

        /**
         * Checks if given number in our pool
         * Numbers with status in (5, 6, 7, 8, 9) doesn't consider as RC numbers during check (see RC-40375)
         * @deprecated
         * @param {String} phoneNumber
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkIsRingCentralNumberPorting : function(phoneNumber, fn)
        {
            this.send("validation.checkIsRingCentralNumberPorting", {
                phoneNumber : phoneNumber
            }, fn);
        },

        /**
         * Checks if given number is toll free
         *
         * @param {String} phoneNumber
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkIsTollFreeNumber : function(phoneNumber, fn)
        {
            this.send("validation.checkIsTollFreeNumber", {
                phoneNumber : phoneNumber
            }, fn);
        },

        /**
         * Checks if given zip code is valid for US
         *
         * @param {String} zipCode
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkIsUSZipCode : function(zipCode, fn)
        {
            //in case of non-digit param - response will contain success false && errorCode: INVALID_PARAMETER
            this.sendSync("validation.checkIsUSZipCode", {
                zipCode : zipCode
            }, fn, fn);
        },

        /**
         * Checks if the given address is a P.O. box (P.O. boxes are not allowed as e911 addresses, for example)
         *
         * @param {String} address
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkPOBox : function(address, fn)
        {
            this.send("validation.checkPOBox", {
                address : address
            }, fn);
        },

        /**
         * Checks if Neustar system is available
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkNeustarAvailability : function(fn)
        {
            this.send("validation.checkNeustarAvailability", {}, fn);
        },

        /**
         * Checks number in forwarding list
         *
         * @param {String} number
         * @param {Number} mailboxId
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.IntegerResponse}
         * </ul>
         */
        checkForwadingPhone : function(number, mailboxId, fn)
        {
            this.sendSync("validation.checkForwadingPhone", {
                number : number
            }, fn);
        },

        /**
         * Checks numbers in forwarding list
         *
         * @param {Array} numbers
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.IntegerResponse}
         * </ul>
         */
        checkForwardingPhones : function(numbers, fn)
        {
            this.sendSync("validation.checkForwardingPhones", {
                numbers : JSON.encode(numbers)
            }, function(result){

                var ret = [];
                Array.each(result.list, function(res){

                    ret.push({
                        phone: res.first,
                        result: res.second.result == 0
                    });

                });

                fn(ret);

            });
        },

        checkPhoneNumberForRingOutAndRingMe : function(number, fn, skipLoader)
        {
            this.send("validation.checkPhoneNumberForRingOutAndRingMe", {
                number : number
            }, fn, fn, false, skipLoader);
        }
    }
})();

RC.apply(Wrapper.Validation, Wrapper);

/**
 * Used for numbers actions
 * <br/><br/>
 * Alias for namespace: <b>numbers</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=numbers.parsePhoneNumber&...
 * </pre>
 *
 * @class
 * @name Wrapper.Numbers
 * @extends Wrapper
 * @singleton
 */
Wrapper.Numbers = (function() {
    return {
        /**
         * Sets attachements for ported number request.
         * @param {Wrapper.Requests.AvailableNumbersTypesRequest} request The instance of {@link Wrapper.Requests.AvailableNumbersTypesRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        getAvailableNumbersTypes : function(request, fn)
        {
            this.send("numbers.getAvailableNumbersTypes",
                request.serialize(), fn);
        },

        /**
         * Parses phone number.
         * @param {String} number
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ParsedPhoneNumberResponse}
         * </ul>
         */
        parsePhoneNumber : function(number, fn, err)
        {
            this.sendSync("numbers.parsePhoneNumber", {
                number : number
            }, fn, err);
        },

        /**
         * Parses phone number with given parameters.
         * @param {Object} params
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ParsedPhoneNumberResponse}
         * </ul>
         */
        parsePhoneNumberWithParams : function(params, fn, err)
        {
            this.sendSync("numbers.parsePhoneNumber", params, fn, err);
        },

        /**
         * Gets information about cellular provider by number.
         * @param {String} number Phone number.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CellProviderInfoResponse}
         * </ul>
         */
        getCellProvider : function(number, fn)
        {
            /**@placeholder*/
            /*var cellProviderInfo = new Wrapper.Models.CellProviderInfo();
             cellProviderInfo.id = 2;
             cellProviderInfo.name = "AT&T Wireless";
             cellProviderInfo.domain = "txt.att.com";
             cellProviderInfo.countryId = 1;
             cellProviderInfo.numberFormat = null;
             cellProviderInfo.forwardActivate = "*21*";
             cellProviderInfo.digitsNumber = 10;
             cellProviderInfo.forwardDeactivate = "#002#";

             fn(new Wrapper.Responses.DetectCellProviderResponse(new Wrapper.Models.RequestStatus(), cellProviderInfo));*/

            var errorStatus = new Wrapper.Models.RequestStatus();
            errorStatus.success = false;
            errorStatus.code = 10000;
            errorStatus.message = RC.Lang.Common.CANT_LOAD_PROVIDERS;

            fn(new Wrapper.Responses.StatusedResponse(errorStatus));

        },

        /**
         * Gets the list of available cellular providers.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListCellProvidersResponse}
         * </ul>
         */
        listCellProviders : function(fn)
        {
            this.send("numbers.listCellProviders", {}, fn);
        },

        /**
         * Gets the list of local numbers.
         * @param {String} prefix
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.NumbersResponse}
         * </ul>
         */
        getNumbers : function(prefix, fn)
        {
            this.send("numbers.getNumbers", {
                prefix : prefix
            }, fn);
        },

        /**
         * Gets the list of countries
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListCountriesResponse}
         * </ul>
         */
        listCountries : function(fn) {
            this.send("numbers.listCountries", {
            }, fn);
        },

        /**
         * Gets the list of states in passed country
         * @param {Number} id The country id taken from {@link #listCountries}.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListStatesResponse}
         * </ul>
         */
        listStates : function(id, fn)
        {
            this.send("numbers.getStates", {
                countryId : id
            }, fn);
        },

        /**
         * Gets the list of vanity numbers
         * @param {VanityNumbersRequest} request The instance of {@link Wrapper.Requests.VanityNumbersRequest}.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.VanityNumbersResponse}
         * </ul>
         */
        getVanityNumbers : function(request, fn)
        {
            this.send("numbers.getVanityNumbers",
                request.serialize(), fn);
        },

        /**
         * Adds number to extension. TODO: Should it be moved to Extensions?
         * @param {AddNumberRequest} request The instance of {@link Wrapper.Requests.AddNumberRequest}.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        addNumber : function(request, fn)
        {
            this.send("numbers.addNumber",
                request.serialize(), fn);
        },

        /**
         * Adds forwarded number to extension. TODO:  Should it be moved to Extensions?
         * @param {String} number String presentation of the number.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.AddForwardedNumberResponse}
         * </ul>
         */
        addForwardedNumber : function(number, fn)
        {
            this.send("numbers.addForwardedNumber", {
                number : number
            }, fn);
        },

        /**
         * Deletes forwarded number from extension.
         * @param {String} number String presentation of the number.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        deleteForwardedNumber : function(number, fn)
        {
            this.send("numbers.deleteForwardedNumber", {
                number : number
            }, fn);
        },

        getNumbersCounts : function(fn)
        {
            this.send("numbers.getNumbersCounts", {}, fn);
        }

    }
})();

RC.apply(Wrapper.Numbers, Wrapper);

/**
 * Used for system actions
 * <br/><br/>
 * Alias for namespace: <b>system</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=system.getCounters&...
 * </pre>
 *
 * @class
 * @name Wrapper.System
 * @extends Wrapper
 * @singleton
 */
Wrapper.System = (function() {
    return {
        /**
         * Gets info whether DigitalUsers exit on ATT acc
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isDigitalUsersExist : function(fn){
            this.send("system.isDigitalUsersExist", {}, fn);
        },

        /**
         * Gets common information about service configuration
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CountersResponse}
         * </ul>
         */
        getCounters : function(fn)
        {
            this.send("system.getCounters", {}, fn);
        },

        /**
         * Initialize verification call
         *
         * @param {VerificationCallRequest} request The instance of {@link Wrapper.Responses.VerificationCallRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.VerificationCallResponse}
         * </ul>
         */
        makeCall : function(request, fn)
        {
            this.send("system.makeCall", request.serialize(), fn);
        },

        /**
         * Invalidates current session. User will be unloggined also.
         */
        invalidateSession: function() {
            this.send("system.invalidateSession", {}, null);
        },

        /**
         * Checks phone number
         *
         * @param {String} number
         * @param {Number} type
         * <b>1</b> - if you validate contact number<br/>
         * <b>2</b> - if you validate international number<br/>
         * <b>3</b> - if you validate ported number<br/>
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        checkPhoneNumber : function(number, type, fn)
        {
            if (RC.isFunc(arguments[3])) {
                this.sendSync("system.checkPhoneNumber", {
                    number : number,
                    type : type
                }, fn, arguments[3]);
            } else {
                this.sendSync("system.checkPhoneNumber", {
                    number : number,
                    type : type
                }, fn);
            }
        },

        /**
         * Checks ability to add new user to system
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li>
         *          <b>response</b> : {@link Wrapper.Responses.StringResponse}
         *          <p style="margin-left: 30px;">
         *              <b>Free</b> - you have option to add a free user<br/>
         *              <b>Upgrade</b> - you need to upgrade to add new user<br/>
         *              <b>Paid</b> - you need add new user through billing<br/>
         *              <b>No</b> - you haven't option to add a new user
         *          </p>
         *     </li>
         * </ul>
         */
        canAddUserExtension : function(fn)
        {
            this.send("system.canAddUserExtension", {}, fn);
        },

        /**
         * Makes call to record greeting via phone
         *
         * @param {MakeClickToCallbackCallRequest} request The instance of {@link Wrapper.Requests.MakeClickToCallbackCallRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        makeClickToCallbackCall : function(request, fn)
        {
            this.send("system.makeClickToCallbackCall", request, fn);
        },

        /**
         * Gets status of the call
         *
         * @param {String} sessionId
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.RingMeStatusResponse}
         * </ul>
         */
        getClickToCallbackStatus : function(sessionId, fn)
        {
            this.send("system.getClickToCallbackStatus", {
                sessionId : sessionId
            }, fn);
        },

        /**
         * Cancels call by given session id
         *
         * @param {String} sessionId
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        cancelClickToCallbackCall : function(sessionId, fn)
        {
            this.send("system.cancelClickToCallbackCall", {
                sessionId : sessionId
            }, fn);
        },

        /**
         * Gets setting of given parameter.
         *
         * @param {Object} object
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StringResponse}
         * </ul>
         */
        getAccountSetting : function(object, fn)
        {
            this.send("system.getAccountSetting", {}, fn);
        },

        /**
         * Gets information about availability of self cancellation
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isSelfCancellationAvailable : function(fn)
        {
            this.send("system.isSelfCancellationAvailable", {}, fn);
        },

        /**
         * Gets information about availability of show cancellation message which only display phoneNumber to customer
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isShowCancellationMessage : function(fn)
        {
            this.send("system.isShowCancellationMessage", {}, fn);
        },

        /**
         * Cancels current service.<br/>
         * Note: be careful, you will not login to account anymore
         *
         * @param {Wrapper.Requests.CancelAccountRequest} request The instance of {@link Wrapper.Requests.CancelAccountRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        doCancelService : function(request, fn)
        {
            this.send("system.doCancelService", request.serialize(), fn);
        },

        /**
         * Gets the list of available applications
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListApplicationsResponse}
         * </ul>
         */
        listApplications : function(fn)
        {
            this.send("system.listApplications", {}, fn);
        },

        /**
         * Gets status of the DigitalUser (SysUser or not)
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListApplicationsResponse}
         * </ul>
         */
        isSystemUserDigital : function(fn)
        {
            this.send("system.isSystemUserDigital", {}, fn);
        },

        /**
         * Sends the feedback to support
         *
         * @param {Wrapper.Requests.FeedbackRequest} request The instance of {@link Wrapper.Requests.FeedbackRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        sendFeedback : function (request, fn)
        {
            this.send("system.sendFeedback", request.serialize(), fn);
        },

        /**
         * Sends fax to user
         *
         * @param request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        sendFax : function (request, fn, onError)
        {
            this.send("system.sendFax", request, fn, onError);
        },

        resendFax : function (request, fn, onError) {
            this.send("system.resendFax", request, fn, onError);
        },

        /**
         * Gets marketing campaigns for current mailbox
         *
         * @param {Wrapper.Enums.MarketingMessageType} marketingMsgType Marketing message type
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.MarketingMessagesInfoResponse}
         * </ul>
         */
        getMarketingMessages: function (marketingMsgType, fn){
            this.send("system.getMarketingMessages", {messageType : marketingMsgType}, fn);
        },

        /**
         * Hides marketing message from user
         * @param request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        hideMarketingMessage: function (messageId, fn){
            this.send("system.hideMarketingMessage", {messageId: messageId}, fn);
        },

	/**
         * Checks extension addition availability
         *
         * @param type Type of extension
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        canAddExtension : function (type, fn)
        {
            this.send("system.canAddExtension", {
                extensionType : type
            }, fn);
        },

        /**
         * Unsubscribes user from spam emails
         *
         * @param request
         * @param fn
         * @param onError
         */
        unsubscribeEmail: function(request, fn, onError)
        {
            this.send("unsubscribe.unsubscribe", request, fn, onError);
        },
	    getSSOSettings: function(fn){
            this.send("system.getSSOSettings", {
            }, fn);
        },
	
        setSSOSettings: function (enabled, idp, idpType, onSuccess, onError) {
            this.send("system.setSSOSettings", {
                value: JSON.encode({
                    enabled: enabled,
                    IDP: idp,
                    idpType: idpType
                })
            }, onSuccess, onError);
        },

        /**
         *
         * @param {String} key
         * @param {String} data
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setCustomData: function(key, data, onSuccess, onError) {
            this.send("system.setCustomData", {
                key: key,
                data: data
            }, onSuccess, onError);
        },

        /**
         *
         * @param {String} key
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        getCustomData: function(key, onSuccess, onError) {
            this.send("system.getCustomData", {
                key: key
            }, onSuccess, onError);
        }
    };
})();

RC.apply(Wrapper.System, Wrapper);

/**
 * Used for validate access to page
 * <br/><br/>
 * Alias for namespace: <b>access</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=access.checkAccess&...
 * </pre>
 *
 * @class
 * @name Wrapper.Access
 * @extends Wrapper
 * @singleton
 */
Wrapper.Access = (function() {
    return {
        checkAccess: function (fn) {
            this.send("access.checkAccess", {}, fn);
        },
        checkAccessToService: function (fn) {
            this.send("access.checkAccessToService", {}, fn, fn); // treat server error as denied access (UIA-39175)
        },
        checkAccessToReports: function (fn) {
            this.send("access.checkAccessToReports", {}, fn);
        },
        checkAllowManualLogin: function (fn) {
            this.send("access.checkAllowManualLogin", {}, fn);
        },
        checkAllowManualSignup: function (fn) {
            this.send("access.checkAllowManualSignup", {}, fn);
        },
        checkAllowAccountValidation: function (fn) {
            this.send("access.checkAllowAccountValidation", {}, fn);
        },
        isFaxTier: function (fn) {
            this.send("access.isFaxTier", {}, fn);
        },
        checkRingMeAccess: function (fn) {
            this.send("access.checkRingMeAccess", {}, fn);
        },
        checkIsMultiExtensionsMode: function (fn) {
            this.send("access.checkIsMultiExtensionsMode", {}, fn);
        },
        checkDownloadAccess: function (fn) {
            this.send("access.checkDownloadAccess", {}, fn);
        },
        checkDirectoryAssistanceAccess: function (fn) {
            this.send("access.checkDirectoryAssistanceAccess", {}, fn);
        },
        checkIVRAccess: function (fn) {
            this.send("access.checkIVRAccess", {}, fn);
        },
        checkInternationalCallingAccess: function (fn) {
            this.send("access.checkInternationalCallingAccess", {}, fn);
        },
        checkIVREditorAccess: function (fn) {
            this.send("access.checkIVREditorAccess", {}, fn);
        },
        checkAccessToTellAFriend: function (fn) {
            this.send("access.checkAccessToTellAFriend", {}, fn);
        },
        checkAccessToSalesforceApp: function (fn) {
            this.send("access.checkAccessToSalesforceApp", {}, fn);
        },
        checkAccessToZendeskApp: function (fn) {
            this.send("access.checkAccessToZendeskApp", {}, fn);
        },
        checkAccessToBilling: function (fn) {
            this.send("access.checkAccessToBilling", {}, fn);
        },
        checkAccessToTemplates: function (fn) {
            this.send("access.checkAccessToTemplates", {}, fn);
        },
        checkAccessToMeetingsApp: function (fn) {
            this.send("access.checkAccessToMeetingsApp", {}, fn);
        },
        checkSSO: function (fn) {
            this.send("access.checkSSO", {}, fn);
        },
        checkBrandHipaaAllowed: function (fn) {
            this.send("access.checkBrandHipaaAllowed", {}, fn);
        }
    }
})();

RC.apply(Wrapper.Access, Wrapper);

/**
 * Used for signup actions
 * <br/><br/>
 * Alias for namespace: <b>signup</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=signup.getMainSignupNumber&...
 * </pre>
 *
 * @class
 * @name Wrapper.Signup
 * @extends Wrapper
 * @singleton
 */
Wrapper.Signup = (function() {
    return {
        /**
         * Creates account.
         *
         * @param {CreateAccountRequest} request The instance of {@link Wrapper.Requests.CreateAccountRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CreateAccountResponse}
         * </ul>
         */
        createAccount : function(request, fn)
        {
            this.send("signup.createAccount",
                request.serialize(), fn);
        },

        /**
         * Activates account after creation.
         *
         * @param {Number} userId
         * @param {String} signupCookie
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ActivateAccountResponse}
         * </ul>
         */
        activateAccount : function(userId, signupCookie, fn)
        {
            this.send("signup.activateAccount", {
                userId : userId,
                signupCookie : signupCookie
            }, fn);
        },

        /**
         * Gets main number during signup.
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Models.PhoneNumber}
         * </ul>
         */
        getMainSignupNumber : function(fn)
        {
            this.send("signup.getMainSignupNumber", {}, fn);
        }
    }
})();

RC.apply(Wrapper.Signup, Wrapper);

/**
 * Used for call log actions
 * <br/><br/>
 * <i style="color: red;">TODO: Its must be moved to extensions ASAP.</i>
 * <br/><br/>
 * Alias for namespace: <b>callLog</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=calllog.listCalls&...
 * </pre>
 *
 * @class
 * @name Wrapper.CallLog
 * @extends Wrapper
 * @singleton
 */
Wrapper.CallLog = (function() {
    return {

        /**
         * Gets list of the calls.
         *
         * @param {ListCallsRequest} request The instance of {@link Wrapper.Requests.ListCallsRequest}
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CallLogResponse}
         * </ul>
         */
        listCalls : function(request, fn)
        {
            this.send("callLog.listCalls", request.hasOwnProperty("serialize") ? request.serialize() : request, fn, null, true, true);
        },

        /**
         * Gets list of the recorded calls.
         *
         * @param {ListCallsRequest} request The instance of {@link Wrapper.Requests.ListCallsRequest}
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CallLogResponse}
         * </ul>
         * @param {Function} onError (optional) On error callback
         */
        listRecordedCalls : function(request, onSuccess, onError) {
            this.send("callLog.listRecordedCalls", request, onSuccess, onError);
        },

        /**
         * Clears calls.
         *
         * @param {MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        purgeCalls : function(request, fn) {
            this.send("callLog.purgeCalls",
                request.serialize(), fn);
        },

        /**
         * Gets settings of delivery functionality.
         *
         * @param {MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CallLogDeliverySettingsResponse}
         * </ul>
         */
        getDeliverySettings : function(request, fn) {
            this.send("callLog.getDeliverySettings",
                request.serialize(), fn);
        },

        /**
         * Sets information of calls delivery.
         *
         * @param {DeliverySettingsRequest} request The instance of {@link Wrapper.Requests.DeliverySettingsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setDeliverySettings : function(request, fn) {
            this.send("callLog.setDeliverySettings",
                request.serialize(), fn);
        },

        /**
         * Downloads the list of calls.
         *
         * @param {ListCallsRequest} request The instance of {@link Wrapper.Requests.ListCallsRequest}
         */
        downloadLog : function(request) {
            this.send("callLog.downloadLog",
                request.serialize(), null);
        },

        /**
         * Deletes the range of calls.
         * @param {Array} items The array of long values
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        deleteRecords : function(items, fn) {
            this.send("callLog.deleteRecords", {
                mode : 'calls',
                items : items
            }, fn);
        }
    }
})();

RC.apply(Wrapper.CallLog, Wrapper);


/**
 * Used for message management
 * <br/>
 * Alias for namespace: <b>messages</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=messages.list&...
 * </pre>
 *
 * @class
 * @name Wrapper.Messages
 * @extends Wrapper
 * @singleton
 */
Wrapper.Messages = (function() {
    return {

        /**
         * Gets list of the messages.
         *
         * @param {object} request Request parameters
         * @param {Function} onSuccess (optional) The function to be called.
         * @param {Function} onError (optional) On error callback
         */
        list: function(request, onSuccess, onError) {
            this.send("messages.list", request, onSuccess, onError);
        }
    }
})();

RC.apply(Wrapper.Messages, Wrapper);

/**
 * Uses for actions with account/extension
 * <br/><br/>
 * Alias for namespace: <b>extensions</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=extensions.listExtensions&...
 * </pre>
 *
 * @class
 * @name Wrapper.Extensions
 * @extends Wrapper
 * @singleton
 */
Wrapper.Extensions = (function() {
    return {

        isActiveBTContract: function (fn) {
            "use strict";
            this.send("extensions.isActiveBTContract", null, function (response) {
                if (typeof fn === "function") {
                    fn(!!response.result);
                }
            });
        },

        /**
         * Sets attachements for ported number request.
         * @deprecated
         * @param { phoneId } todo - special request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        getPortedNumberInfo : function(request, fn)
        {
            this.send("extensions.getPortedNumberInfo",
                request, fn);
        },

        listGroupedExtensions: function(request, onSuccess) {
            this.send("extensions.listGroupedExtensions", request, onSuccess);
        },

        /**
         * Changes feature plan
         * @param { phoneId } todo - special request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        changeFeaturePlans : function(params, fn, onError)
        {
            this.send("extensions.changeFeaturePlans",
                params, fn, onError);
        },
        /**
         * Sets attachements for ported number request.
         * @deprecated
         * @param {Wrapper.Requests.SavePortedNumberAttachmentInfoRequest} request The instance of {@link Wrapper.Requests.SavePortedNumberAttachmentInfoRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         */
        savePortedNumberAttachmentInfo : function(request, fn)
        {
            this.sendSync("extensions.savePortedNumberAttachmentInfo",
                request.serialize(), fn);
        },


        /**
         * Sets information for extension. If you want to create extension, just send <tt>mid = 0</tt>.
         * @param {Object} params.
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setExtension : function(params, onSuccess, onError)
        {
            this.send("extensions.setExtension", params, onSuccess, onError);
        },

        /**
         *
         * @param {Integer} mid
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        canDeleteExtension: function (mid, onSuccess, onError) {
            this.send('extensions.canDeleteExtension', {
                mid: mid
            }, onSuccess, onError);
        },

        /**
         * Gets extension's information.
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.MailboxInfoResponse}
         * </ul>
         */
        getExtension : function(request, fn)
        {
            this.sendSync("extensions.getExtension",
                request.serialize(), fn);
        },

        /**
         * Gets following extension's information:
         * <ul>
         *     <li>user full name</li>
         *     <li>company name</li>
         * </ul>
         * @param request mailbox request
         * @param fn callback function
         */
        getStrictExtensionInfo : function(request, fn) {
            this.sendSync("extensions.getExtension",
                request.serialize(), fn);
        },

        /**
         * Deletes extension.
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * @param {Function} onError (optional) The function to be called when the api call is fail.
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        deleteExtension : function(request, onSuccess, onError) {
            this.send("extensions.deleteExtension", request, onSuccess, onError);
        },

        /**
         * Gets the list of extensions.
         * @param {Wrapper.Requests.ListExtensionsRequest} request The instance of {@link Wrapper.Requests.ListExtensionsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListExtensionsResponse}
         * </ul>
         */
        listExtensions : function(request, fn)
        {
            this.send("extensions.listExtensionsForServiceSite",
                request.serialize(), fn);
        },
        /**
         * Gets the list of extensions.
         * @param {Wrapper.Requests.ListExtensionsRequest} request The instance of {@link Wrapper.Requests.ListExtensionsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListExtensionsResponse}
         * </ul>
         */
        listExtensionsBrief : function(request, fn)
        {
            this.send("extensions.listExtensionsForServiceSiteBrief",
                request.serialize(), fn);
        },

        /**
         * Gets the list of department members.
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListExtensionsResponse}
         * </ul>
         */
        listDepartmentMembers : function(fn)
        {
            this.send("extensions.listDepartmentMembers", {}, fn);
        },

        /**
         * Gets the list of extensions.
         * @param {Wrapper.Requests.ListExtensionsRequest} request The instance of {@link Wrapper.Requests.ListExtensionsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListExtensionsResponse}
         * </ul>
         */
        listVoicemailRecipients : function(fn)
        {
            this.send("extensions.listVoicemailRecipients", {}, fn);
        },

        listCallDestinationRecipients : function(fn)
        {
            this.send("extensions.listCallDestinationRecipients", {}, fn);
        },

        /**
         * Gets version information of SoftPhone, Mobile Apps.
         * @param {Wrapper.Requests.SoftwareVersionRequest} request The instance of {@link Wrapper.Requests.SoftwareVersionRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.SoftwareVersionInfoResponse}
         * </ul>
         */
        getSoftwareVersion : function(request, fn)
        {
            this.send("extensions.getSoftwareVersion",
                request.serialize(), fn);
        },

        /**
         * Gets numbers from account by their usage type.
         * @param {Wrapper.Requests.GetAccountNumberRequest} request The instance of {@link Wrapper.Requests.GetAccountNumberRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.AccountNumberResponse}
         * </ul>
         */
        getAccountNumber : function(request, fn)
        {
            this.send("extensions.getAccountNumber",
                request.serialize(), fn);
        },

        /**
         * Gets account-level information
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.UserInfoResponse}
         * </ul>
         */
        getAccountInfo : function(fn)
        {
            this.send("extensions.getAccountInfo",
                {}, fn);
        },

        /**
         * Reset mailbox cache
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        resetMailboxCache : function(fn)
        {
            this.send("extensions.resetMailboxCache",
                {}, fn);
        },

         /**
         * Refresh user data cache
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        refreshUserData : function(fn)
        {
            this.send("extensions.refreshUserData",
                {}, fn);
        },

        /**
         * Check account status
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isUserTrial : function(fn)
        {
            this.send("extensions.isUserTrial",
                {}, fn);
        },

        /**
         * Gets list of numbers on account
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListPhoneNumbersResponse}
         * </ul>
         */
        defaultMailboxRuleExist : function(mid, fn)
        {
            this.sendSync("extensions.defaultMailboxRuleExist",
                mid, fn);
        },

        /**
         * Gets list of numbers on account
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListPhoneNumbersResponse}
         * </ul>
         */
        listPhoneNumbers : function(fn)
        {
            this.send("extensions.listPhoneNumbers",
                null, fn);
        },

        /**
         * Gets list of numbers on account
         * @deprecated Added only for backwards compatibility
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListPhoneNumbersResponse}
         * </ul>
         */
        listPhoneNumbersSync : function(fn)
        {
            this.sendSync("extensions.listPhoneNumbers",
                null, fn);
        },

        /**
         * Gets list of ported numbers on account
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListPortedNumbersResponse}
         * </ul>
         */
        listPortedNumbers : function(fn)
        {
            this.send("extensions.listPortedNumbers",
                null, fn);
        },

        /**
         * Adds ported number
         * @deprecated
         * @param {Object} request //TODO Wrapper.Requests.SetPhoneNumberRequest
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        addPortedNumber : function(request, fn, onError)
        {
            this.send("extensions.addPortedNumber",
                request, fn, onError);
        },

        /**
         * Edit ported number
         * @deprecated
         * @param {Object} request //TODO Wrapper.Requests.SetPhoneNumberRequest
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        editPortedNumber : function(request, fn)
        {
            this.send("extensions.editPortedNumber",
                request, fn);
        },

        /**
         * Sets phone number settings
         * @param {Wrapper.Requests.SetPhoneNumberRequest} request The instance of {@link Wrapper.Requests.SetPhoneNumberRequest}
         * @param {Function} onSuccess (optional) The function to be called when the api call is success. It will be passed the following parameters:
         * @param {Function} onError (optional) The function to be called when the api call is fail. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setPhoneNumber : function(request, onSuccess,onError)
        {
            this.send("extensions.setPhoneNumber",
                request.serialize(), onSuccess,onError);
        },

        /**
         * Deletes number from account
         * @param {Wrapper.Requests.DeletePhoneNumberRequest} request The instance of {@link Wrapper.Requests.DeletePhoneNumberRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        deletePhoneNumber : function(request, fn)
        {
            this.send("extensions.deletePhoneNumber",
                request.serialize(), fn);
        },

        /**
         * Gets notification settings
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.NotificationsInfoResponse}
         * </ul>
         */
        getNotifications : function(request, fn)
        {
            this.send("extensions.getNotifications",
                request.serialize(), fn);
        },

        /**
         * Sets notification settings
         * @param {Wrapper.Requests.SetNotificationsRequest} request The list of instance of {@link Wrapper.Requests.SetNotificationsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setNotifications : function(request, fn)
        {
            this.send("extensions.setNotifications",
                request.serialize(), fn);
        },

        /**
         * Gets current time zone for mailbox
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.TimeZoneResponse}
         * </ul>
         */
        getTimeZone : function(request, fn)
        {
            this.send("extensions.getTimeZone",
                request.serialize(), fn);
        },

        /**
         * Gets current regional settings for mailbox
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.TimeZoneResponse}
         * </ul>
         */
        getRegionalSettings : function(request, fn)
        {
            this.send("extensions.getRegionalSettings",
                request.serialize(), fn);
        },

        /**
         * set current regional settings for mailbox
         * @param {Number} mailboxId
         * @param {Boolean} companyLevel
         * @param {String} timeZoneId
         * @param {String} locationCountryId
         * @param {String} timeFormat
         * @param {String} textLanguage
         * @param {String} localeLanguage
         * @param {String} voiceLanguage
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setRegionalSettings : function(mailboxId, companyLevel, timeZoneId, locationCountryId, timeFormat, textLanguage, localeLanguage, voiceLanguage, onSuccess, onError) {
            this.send("extensions.setRegionalSettings", {
                mid: mailboxId,
                companyLevel: companyLevel,
                timeZoneId: timeZoneId,
                locationCountryId: locationCountryId,
                timeFormat: timeFormat,
                textLanguage: textLanguage,
                localeLanguage: localeLanguage,
                voiceLanguage: voiceLanguage
            }, onSuccess, onError);
        },

        /**
         * List of available time zones
         * @todo Move to correspond response object. Don't use JSONObject at all.
         * @param {JSONObject} request The instance of {@link JSONObject}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : JSONObject
         * </ul>
         */
        listTimeZones : function(request, fn)
        {
            this.send("extensions.listTimeZones",
                request.serialize(), fn);
        },

        /**
         * Gets the current state of express setup wizard
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StringResponse}
         * </ul>
         */
        getSetupWizardState : function(request, fn)
        {
            this.send("extensions.getSetupWizardState",
                request.serialize(), fn);
        },

        /**
         * Sets state of express setup wizard
         *
         * @param {String} state The state of wizard
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setSetupWizardState : function(state, fn)
        {
            this.send("extensions.setExtension",
                {
                    state: state
                }, fn);
        },

        /**
         * Finishes setup of extension
         *
         * @param {Function} [onSuccess] (optional) The callback function to be called in case of success
         * @param {Function} [onError] (optional) The callback function to be called in case of failure
         */
        setSetupStateToComplete: function(onSuccess, onError) {
            this.send("extensions.setSetupStateToComplete", {}, onSuccess, onError);
        },

        /**
         * Determines ability of adding additional numbers into account
         * @param {Wrapper.Requests.IsNumberAdditionAllowed} request The instance of {@link Wrapper.Requests.IsNumberAdditionAllowed}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StringResponse}
         * </ul>
         */
        isNumberAdditionAllowed : function(request, fn, onError)
        {
            this.send("extensions.isNumberAdditionAllowed",
                request, fn, onError);
        },

        /**
         * Gets list of available secret questions
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListSecretQuestionsResponse}
         * </ul>
         */
        listSecretQuestions : function(request, fn)
        {
            this.send("extensions.listSecretQuestions",
                request.serialize(), fn);
        },

        /**
         * Sends welcome email. Is using only for newly created extension.
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        sendWelcomeEmail : function(request, fn)
        {
            this.send("extensions.sendWelcomeEmail",
                request.serialize(), fn);
        },

        /**
         * Sets list of blocked numbers
         * @param {Wrapper.Requests.BlockedNumbersRequest} request The instance of {@link Wrapper.Requests.BlockedNumbersRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setBlockedNumbers : function(request, fn)
        {
            this.send("extensions.setBlockedNumbers",
                request.serialize(), fn);
        },

        /**
         * Gets blocked numbers settings
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListBlockedNumbersResponse}
         * </ul>
         */
        getBlockedNumbers : function(request, fn)
        {
            this.send("extensions.getBlockedNumbers",
                request.serialize(), fn);
        },

        /**
         * Changes password for extension
         * @param {Wrapper.Requests.ResetPasswordRequest} request The instance of {@link  Wrapper.Requests.ResetPasswordRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        resetPassword : function(request, fn)
        {
            this.send("extensions.resetPassword",
                request.serialize(), fn);
        },

        /**
         * Sets company caller id name
         * @param {Wrapper.Requests.CallerIdNameRequest} request The instance of {@link Wrapper.Requests.CallerIdNameRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setCallerIdName : function(request, fn)
        {
            this.send("extensions.setCallerIdName",
                request.serialize(), fn);
        },

        /**
         * Gets company caller id name
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StringResponse}
         * </ul>
         */
        getCallerIdName : function(options) {
            options = options || {};
            this.send("extensions.getCallerIdName",
                {}, options.onSuccess, options.onError, true);
        },

        /**
         * Sets call recording enabling
         * @param {Wrapper.Requests.CallRecordingRequest} request The instance of {@link Wrapper.Requests.CallRecordingRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setCallRecording : function(request, fn)
        {
            this.send("extensions.setCallRecordingForServiceSite",
                request.serialize(), fn);
        },

        /**
         * Gets status of call recording
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        getCallRecording : function(request, fn)
        {
            this.send("extensions.getCallRecordingForServiceSite",
                request.serialize(), fn);
        },

        /**
         * Sets list of permissions to extension
         * @param {Wrapper.Requests.SetExtensionPermissionsRequest} request The instance of {@link Wrapper.Requests.SetExtensionPermissionsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setExtensionPermissions : function(request, fn)
        {
            this.send("extensions.setExtensionPermissions",
                request.serialize(), fn);
        },

        /**
         * Gets list of permissions on mailbox
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ExtensionPermissionsResponse}
         * </ul>
         */
        getExtensionPermissions : function(request, fn)
        {
            this.send("extensions.getExtensionPermissions",
                request.serialize(), fn);
        },

        /**
         * Gets settings of dial by name directory
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        getDialByNameSettings : function(request, onSuccess, onError)
        {
            this.send("extensions.getDialByNameSettings", request, onSuccess, onError);
        },

        /**
         * Sets dial by name directory configuration
         * @param {Object} request
         * @param {Function} onSuccess The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of errors.
         */
        setDialByNameSettings : function(request, onSuccess, onError)
        {
            this.send("extensions.setDialByNameSettings", request, onSuccess, onError);
        },

        /**
         * Sets list of users included in Dial-By-Name directory.
         * @param {Object} request
         * @param {Function} onSuccess The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of errors.
         */
        setDialByNameIncludedExtensions : function(request, onSuccess, onError)
        {
            this.send("extensions.setDialByNameIncludedExtensions", request, onSuccess, onError);
        },

        /**
         * Bulk setting one permission on multiple mailboxes
         * @param {Wrapper.Requests.ExtensionsByPermissionRequest} request The instance of {@link Wrapper.Requests.ExtensionsByPermissionRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setExtensionsByPermission : function(request, fn)
        {
            this.send("extensions.setExtensionsByPermission",
                request.serialize(), fn);
        },

        /**
         * Gets mailbox ids by passed permission (which is enabled)
         * @param {Wrapper.Requests.GetExtensionsByPermissionRequest} request The instance of {@link Wrapper.Requests.GetExtensionsByPermissionRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.PermissionForMailboxesResponse}
         * </ul>
         */
        getExtensionsByPermission : function(request, fn)
        {
            this.send("extensions.getExtensionsByPermission",
                request.serialize(), fn);
        },

        /**
         * List of numbers which can be added to called numbers mode
         */
        getNumbersForCalledCondition : function(request, fn)
        {
            this.send("extensions.setExtension",
                request.serialize(), fn);
        },

        /**
         * Set notifications for mailbox
         * @param {String} mid
         * @param {Boolean} isBasicMode
         * @param {String} basicModeEmail
         * @param {String} basicModePhoneAddresses
         * @param {Array} itemsInfo
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setNotificationSettings : function(mid, isBasicMode, basicModeEmail, basicModePhoneAddresses, itemsInfo, onSuccess, onError) {
            var notificationSettings = {
                basicMode: isBasicMode,
                itemsInfo: itemsInfo
            };

            !RC.isEmpty(basicModeEmail) && (notificationSettings.basicModeEmail = basicModeEmail);
            !RC.isEmpty(basicModePhoneAddresses) && (notificationSettings.basicModePhoneAddresses = basicModePhoneAddresses);

            this.send("extensions.setNotificationSettings", {
                mid: mid,
                notificationSettings: JSON.stringify(notificationSettings)
            }, onSuccess, onError);
        },

        /**
         * Get the list of notifications settings
         * @param {String} mid
         */
        getNotificationSettings : function(mid, onSuccess, onError)
        {
            this.send("extensions.getNotificationSettings", {
                mid: mid
            }, onSuccess, onError);
        },

        setIdentityValidation : function(request, fn)
        {
            this.send("extensions.setExtension",
                request.serialize(), fn);
        },


        getIdentityValidation : function(request, fn)
        {
            this.send("extensions.setExtension",
                request.serialize(), fn);
        },

        tellAFriendStatistic : function(request, fn)
        {
            this.send("extensions.setExtension",
                request.serialize(), fn);
        },

        sendTellAFriend : function(request, fn)
        {
            this.send("extensions.setExtension",
                request.serialize(), fn);
        },

        listDefaultCoverPages : function(request, fn)
        {
            this.send("extensions.setExtension",
                request.serialize(), fn);
        },

        setFaxSettings : function(request, fn)
        {
            this.send("extensions.setExtension",
                request.serialize(), fn);
        },

        getFaxSettings : function(request, fn)
        {
            this.send("extensions.getFaxSettings",
                request, fn);
        },

        /**
         * Gets the list of forwarding numbers on extension.
         * @todo Need to change response.
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link  Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link JSONObject}
         * </ul>
         */
        getListForwardingNumbers : function(request, fn)
        {
            this.send("extensions.getListForwardingNumbers", request.hasOwnProperty("serialize") ? request.serialize() : request, fn, null, true, true);
        },

        /**
         * Gets the list of available caller ids includes additional numbers, digital lines
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link  Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CallerIdPNListResponse}
         * </ul>
         */
        listCallerIds : function(request, fn)
        {
            this.send("extensions.listCallerIds",
                request.serialize(), fn);
        },

        /**
         * Gets list of selected caller ids
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link  Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.CallerIdResponse}
         * </ul>
         */
        getCallerIdSettings : function(request, fn)
        {
            this.send("extensions.getCallerIdSettings",
                request.serialize(), fn);
        },

        /**
         * Sets caller ids to extension
         * @param {Wrapper.Requests.SaveCallerIdSettingsRequest} request The instance of {@link  Wrapper.Requests.SaveCallerIdSettingsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        saveCallerIdSettings : function(request, fn)
        {
            request = request || {};
            request.callerIds = JSON.encode(request.callerIds);
            request.digitalLineCallerIds = JSON.encode(request.digitalLineCallerIds);

            this.send("extensions.saveCallerIdSettings",
                request, fn);
        },

        /**
         * Gets the list of agents into department
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link  Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListQueueAgentsResponse}
         * </ul>
         */
        listQueueAgents : function(request, fn)
        {
            this.send("extensions.listQueueAgents",
                request.serialize(), fn);
        },

        /**
         * Gets pin number which can be used during creation by default
         *
         * @param {Wrapper.Requests.AvailableExtensionNumberRequest} request The instance of {@link  Wrapper.Requests.AvailableExtensionNumberRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StringResponse}
         * </ul>
         */
        getAvailableExtensionNumber : function(request, fn)
        {
            this.send("extensions.getAvailableExtensionNumber",
                request.serialize(), fn);
        },

        //TODO Move to another class
        getMailboxTransitioningWizardState: function(fn) {
            this.send("extensions.getMailboxTransitioningWizardState",
                {}, fn);

        },

        //TODO Move to another class
        setMailboxTransitioningWizardState : function(request, fn)
        {
            this.send("extensions.setMailboxTransitioningWizardState",
                request, fn);
        },

        //TODO Move to another class
        getUserTransitioningWizardState: function(fn) {
            this.send("extensions.getUserTransitioningWizardState",
                {}, fn);

        },

        //TODO Move to another class
        setUserTransitioningWizardState : function(request, fn)
        {
            this.send("extensions.setUserTransitioningWizardState",
                request, fn);
        },

        setCallFlipSettings : function(request, fn)
        {
            this.send("extensions.setCallFlipSettings",
                request, fn);
        },

        getDefaultShippingAddress: function(fn){
            this.send("extensions.getDefaultShippingAddress",
                {}, fn);
        },

        publishCompanyInfo:function (options) {
            options = options || {};
            this.send("extensions.publishCompanyInfo", {publishCompanyInfo:JSON.encode(options.request)}, options.onSuccess, options.onError);
        },

        unpublishCompanyInfo:function(options){
            options = options || {};
            this.send("extensions.unpublishCompanyInfo", {}, options.onSuccess, options.onError);
        },

        getCompanyInfo: function(options){
            options = options || {};
            this.send("extensions.getCompanyInfo", {}, options.onSuccess, options.onError);
        },

        emailUsersTemplate: function(options) {
            options = options || {};
            this.send("extensions.emailUsersTemplate", {email: options.email, fmt: 'xls'}, options.onSuccess, options.onError);
        },

        validateUsersTemplate: function(options) {
            options = options || {};
            this.send("extensions.validateUsersTemplate", {file: JSON.encode(options.fileObj)}, options.onSuccess, options.onError);
        },

        emailValidatedTemplate: function(options) {
            options = options || {};
            this.send("extensions.emailValidatedTemplate", {file: JSON.encode(options.fileObj), email: options.email}, options.onSuccess, options.onError);
        },

        submitUsersTemplate: function(options) {
            options = options || {};
            var request = {file: JSON.encode(options.fileObj)};
            !RC.isEmpty(options.email) && (request['email'] = options.email);
            this.send("extensions.submitUsersTemplate", request, options.onSuccess, options.onError);
        },

        isBulkBuyOperationInProgress: function(options) {
            options = options || {};
            this.send("extensions.isBulkBuyOperationInProgress", {}, options.onSuccess, options.onError);
        },

        isBulkApplyTemplateInProgress: function(options) {
            options = options || {};
            this.send("templates.isBulkApplyTemplateInProgress", {}, options.onSuccess, options.onError);
        },

        isContactsImportInProgress: function(options) {
            options = options || {};
            this.send("contacts.isImportInProgress", {}, options.onSuccess, options.onError, true, true);
        },

        getConferencingInfo: function(mailboxId, fn){
            this.send('extensions.getConferencingInfo', {mailboxId: mailboxId}, fn);
        },

        setDefaultFccDialInNumber: function(mailboxId, defaultFccDialInNumber, fn){
            this.send('extensions.setDefaultFccDialInNumber', {mailboxId: mailboxId, defaultFccDialInNumber: defaultFccDialInNumber}, fn);
        },

        validateAddress:function(options){
            options = options || {};
            this.send("extensions.validateAddress", options.request, options.onSuccess, options.onError);
        },

        getSLGCallerId : function(mid, fn){
            this.send("extensions.getSLGCallerId", {mid : mid}, fn);
        },

        activateUnassignedExtension:function(options){
            options = options || {};
            this.send("extensions.activateUnassignedExtension", options.request, options.onSuccess, options.onError);
        },

        /**
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        getAutoCallRecordingSettingsForExtensions: function(onSuccess, onError) {
            this.send("extensions.getAutoCallRecordingSettingsForExtensions", {}, onSuccess, onError);
        },

        /**
         * @param {String} extensions Encoded JSON array
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setAutoCallRecordingSettingsForExtensions: function(extensions, onSuccess, onError) {
            this.send("extensions.setAutoCallRecordingSettingsForExtensions", {
                extensions: extensions
            }, onSuccess, onError);
        },

        /**
         * @param {Object} params
         * @param {Function} onSuccess
         * @param {Function} [onError]
         */
        setAutoCallRecording: function(params, onSuccess, onError) {
            this.send("extensions.setAutoCallRecording", params, onSuccess, onError);
        },

        /**
         * @param {String} mailboxState
         * can be:
         *   Enabled : 'Enabled',
         *   Disabled : 'Disabled',
         *   Freezed : 'Freezed',
         *   NotActivated : 'NotActivated'
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setMailboxState: function(mid, mailboxState, onSuccess, onError) {
            this.send("extensions.setMailboxState", {
                mid: mid,
                mailboxState: mailboxState
            }, onSuccess, onError);
        },
        /**
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        getExtensionsWithPermissions: function(onSuccess, onError) {
            this.send("extensions.getExtensionsWithPermissions", {}, onSuccess, onError);
        },

        /**
         * @param {String} extensions Encoded JSON array
         * format: [{
         *      "mailboxId": 400129731008,
         *      "permissions": {
         *          "admin": true,
         *          "internationalEnabled": true
         *      }
         *  },
         *  {
         *      "mailboxId": 400129798008,
         *      "permissions": {
         *          "admin": true,
         *          "internationalEnabled": true
         *      }
         *  }]
         * @param {Function} onSuccess
         * @param {Function} [onError]
         */
        savePermissions: function(extensions, onSuccess, onError) {
            this.send("extensions.savePermissions", {
                extensions: extensions
            }, onSuccess, onError);
        },

        /**
         * @param [mid] Can be null
         * @param {function} fn
         * @param {function} [fail]
         */
        hasAlphaNumericPassword: function (mid, fn, fail) {
            this.send("extensions.hasAlphaNumericPassword", {mid: mid}, fn, fail);
        },

        /**
         * delete selected extension and numbers
         * @param {Number} mailBoxId
         * @param {Array} numberId list of need to remove
         * @param {Function} onSuccess
         * @param {Function} OnError
         */
        deleteSelectedNumbersAndExtension: function(mailBoxId, numbersToDelete, onSuccess, OnError){
            this.send("extensions.deleteSelectedNumbersAndExtension", {
                mailboxId: mailBoxId,
                numbersToDelete: JSON.encode(numbersToDelete)
            }, onSuccess, OnError);
        },


        /**
         * Checks if this mailbox is eligible to have free softphone
         * @param {(String|Number)} params.mid mailboxId using for phones addition
         * @param {Number} params.alreadyAddedPhonesCount  Number of chosen phones in the Add Phone wizard
         * @param {Function} [fn] The function to be called (optional). It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isMailboxEligibleToAddFreeSPDL: function(params, fn)
        {
            this.send("extensions.isMailboxEligibleToAddFreeSPDL",
                params, fn);
        },

        /**
         * Adds extension
         * @param {Object} params
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * @param {Function} onError (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        addExtension: function(params, onSuccess, onError) {
            this.send("extensions.addExtension", params, onSuccess, onError);
        },

        /**
         * Set agents to department
         * @param {String} mailboxId
         * @param {Array} agents
         * @param {Function} onSuccess
        */
        setAgentsToDepartment: function(mailboxId, agents, onSuccess) {
            this.send("extensions.setAgentsToDepartment", {
                mailboxId: mailboxId,
                agents: JSON.encode(agents)
            }, onSuccess);
        },

        /**
         * Set appearance
         * Used to set custom logo on page.
         * The logo loaded from a user's computer.
         * @param {String} multipartFileData e.g. ' "contentType":"image/jpeg","id":"tmp-14847047","name":"img.jpg","size":2015 '
         * @param {String} imgLinkUrl URL to load when user clicks on logo
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setAppearance: function(multipartFileData, imgLinkUrl, onSuccess, onError) {
            this.send("extensions.setAppearance", {
                image: multipartFileData,
                url: imgLinkUrl
            }, onSuccess, onError);
        },

        /**
         * Clear(reset) appearance
         * @param {Function} onSuccess
         */
        clearAppearance: function(onSuccess) {
            this.send("extensions.clearAppearance", {}, onSuccess);
        },

        /**
         * Set application id for mailbox
         * @param req
         * @param onSuccess
         */
        setTapApplicationForMailbox: function(req, onSuccess) {
            this.send("extensions.setTapApplicationForMailbox", req, onSuccess);
        },

        /**
         * Get application id from mailbox
         * @param req
         * @param onSuccess
         */
        getTapApplicationForMailbox: function(req, onSuccess) {
            this.send("extensions.getTapApplicationForMailbox", req, onSuccess);
        },

	    listMailboxDirectNumbers: function (mailboxId, onSuccess) {
            this.send("extensions.listMailboxDirectNumbers", {
                mailboxId: mailboxId
            }, onSuccess);
        },

        /**
         * Gets list of Annual Contrcts
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListMenusResponse}
         * </ul>
         */
        listContracts: function(onSuccess){
            this.send("extensions.listContracts", {}, onSuccess);
        },

	    /**
         * Get user level caller ID Settings
         * Used to getting user level numbers for assigning as outbound caller ID
         * @param {Function} onSuccess
         */
        getUserLevelCallerIdSettings: function(onSuccess) {
            this.send("extensions.getUserLevelCallerIdSettings", {}, onSuccess);
        },

	    /**
         * Gets current contract information
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         */
        getCurrentATTBillingContract: function(onSuccess){
            this.send("billing.getCurrentATTBillingContract", {}, onSuccess);
        },

        listPhoneNumbersForMailbox: function(mid, onSuccess, onError){
            this.send("extensions.listPhoneNumbersForMailbox", {mid: mid}, onSuccess, onError);
        },

        /**
         * Set joinBeforeHost for ConferenceInfo
         *
         * @param {String} mailboxId
         * @param {Boolean} joinBeforeHost
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        updateConferenceInfo: function(mailboxId, joinBeforeHost, onSuccess, onError) {
            this.send("extensions.updateConferenceInfo", {
                mid: mailboxId,
                joinBeforeHost: joinBeforeHost
            }, onSuccess, onError);
        }
    };
})();

RC.apply(Wrapper.Extensions, Wrapper);

/**
 * Uses for IVR Create and edit
 * <br/><br/>
 * Alias for namespace: <b>ivr</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=ivr.createMenu&...
 * </pre>
 *
 * @class
 * @name Wrapper.IVR
 * @extends Wrapper
 * @singleton
 */
Wrapper.IVR = (function () {
    return {
        /**
         * create ivr menu to user
         * @param pin
         * @param name
         * @param fn
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        createMenu: function (pin, name, onSuccess, onError) {
            this.send("ivr.createMenu", {
                    pin: pin,
                    name: name
                },
                onSuccess,onError);
        },
        /**
         * Gets ivr menu
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListMenusResponse}
         * </ul>
         */
        listMenus: function(onSuccess) {
            this.send("ivr.listMenus", {}, onSuccess);
        },
        /**
         * Edit IVR menu
         * @param value
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * @param {Function} onError (optional) The function to be called when the api call is fail.*
         */
        editMenu: function (value, onSuccess, onError) {
            this.send("ivr.editMenu", {
                value: JSON.encode(value)
            }, onSuccess, onError);
        },
        /**
         * Retrieve Menu Info
         * @param {Integer} menuId
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        getMenuInfo: function(menuId, onSuccess, onError) {
            this.send("ivr.getMenuInfo", {
                menuId: menuId
            }, onSuccess, onError);
        },

        /**
         * Validate XML File
         * @param {String} fileId
         * @param {String} fileName
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        validateXMLFromFile: function(fileId, fileName, onSuccess, onError) {
            this.send("ivr.validateXMLFromFile", {
                id: fileId,
                name: fileName
            }, onSuccess, onError);
        },
        /**
         * Validate XML File
         * @param {params} request params
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        validateXML: function(params, onSuccess, onError)
        {
            this.send("ivr.validateXML", params, onSuccess, onError, true, false, false);
        },

        /**
         * importXML XML File
         * @param {Boolean} ignoreWarnings
         * @param {params} request params
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        importXML: function(ignoreWarnings, params, onSuccess, onError)
        {
            var url = 'ivr.importXML&ignoreWarnings=' + ignoreWarnings;
            this.send(url, params, onSuccess, onError, true, false, false);
        },

        /**
         * Import XML From temp file
         * @param {String} fileId
         * @param {String} fileName
         * @param {Boolean} ignoreWarnings
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        importXMLFromFile: function(fileId, fileName, ignoreWarnings, onSuccess, onError) {
            this.send("ivr.importXMLFromFile", {
                id: fileId,
                name: fileName,
                ignoreWarnings: ignoreWarnings
            }, onSuccess, onError);
        },

        /**
         * Validate Account IVR Configurations
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        validateConfiguration: function(onSuccess, onError) {
            this.send("ivr.validateConfiguration", {}, onSuccess, onError);
        },

        /**
         * Remove one prompt from account prompt library
         * @param {Integer} greetingId
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        deletePrompt: function(greetingId, onSuccess, onError) {
            this.send("ivr.deletePrompt", {
                greetingId: greetingId
            }, onSuccess, onError);
        },
        /**
         * callToRecordPrompt
         * @param number
         * @param name
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        callToRecordPrompt: function(number,name,onSuccess,onError) {
            this.send("ivr.callToRecordPrompt", {
                number: number,
                name: name
            }, onSuccess,onError);
        },

        /**
         * Edit one prompt info
         * @param {Integer} greetingId
         * @param {String} greetingName
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        editPrompt: function(greetingId, greetingName, onSuccess, onError) {
            this.send("ivr.editPrompt", {
                greetingId: greetingId,
                name: greetingName
            }, onSuccess, onError);
        },

        /**
         * Create single prompt
         * @param {Object} greetingFile
         * @param {String} greetingName
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        createPrompt: function(greetingFile, greetingName, onSuccess, onError) {
            this.send("ivr.createPrompt", {
                file: greetingFile,
                name: greetingName
            }, onSuccess, onError);
        },

        /**
         * List account prompts
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        listPrompts: function(onSuccess, onError) {
            this.send("ivr.listPrompts", {}, onSuccess, onError);
        },
        /**
         * get general IVR settings
         * @param onSuccess
         * @param onError
         */
        getDefaultSettings: function (onSuccess, onError) {
            this.send("ivr.getDefaultSettings", null, onSuccess, onError);
        },
        /**
         * set general IVR settings
         * @param settings
         * @param onSuccess
         * @param onError
         */
        setDefaultSettings: function (settings, onSuccess, onError) {
            this.send("ivr.setDefaultSettings", {
                value: JSON.encode(settings)
            }, onSuccess, onError);
        },

        /**
         * add a specific key action
         * @param {Object} settings
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setMenuAction: function(settings, onSuccess, onError) {
            this.send("ivr.setMenuAction", {
                value: JSON.encode(settings)
            }, onSuccess, onError);
        },

        /**
         * remove a specific key action
         * @param {Object} settings
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        removeMenuAction: function(settings, onSuccess, onError) {
            this.send("ivr.removeMenuAction", {
                value: JSON.encode(settings)
            }, onSuccess, onError);
        },

        /**
         * set general settings of a IVR Menu
         * @param {Object} settings
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setMenuGeneralActions: function(settings, onSuccess, onError) {
            this.send("ivr.setMenuGeneralActions", {
                value: JSON.encode(settings)
            }, onSuccess, onError);
        },

        /**
         * @param {Integer} menuId
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        canDeleteMenu: function (menuId, onSuccess, onError) {
            this.send('ivr.canDeleteMenu', {
                menuId: menuId
            }, onSuccess, onError);
        },

        /**
         * @param {Integer} menuId
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        deleteMenu: function (menuId, onSuccess, onError) {
            this.send('ivr.deleteMenu', {
                menuId: menuId
            }, onSuccess, onError);
        }
    };
})();

RC.apply(Wrapper.IVR, Wrapper);


/**
 * Uses for Media Create and edit
 * <br/><br/>
 * Alias for namespace: <b>mediaResources</b>
 * <br/><br/>
 *
 * @class
 * @name Wrapper.MediaResources
 * @extends Wrapper
 * @singleton
 */
Wrapper.MediaResources = (function () {
    return {
        /**
         * upload greeting
         * @param ruleId
         * @param mailboxId
         * @param greetingType
         * @param file
         * @param fn
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        uploadGreeting: function (ruleId, mailboxId, greetingType, file,onSuccess,onError) {
            this.send("mediaResources.uploadGreeting", {
                    ruleId: ruleId,
                    mailboxId: mailboxId,
                    greetingType: greetingType,
                    file: file
                },
                onSuccess,onError);
        },
        /**
         * get general IVR settings
         * @param onSuccess
         * @param onError
         */
        getDefaultSettings: function (onSuccess, onError) {
            this.send("ivr.getDefaultSettings", null, onSuccess, onError);
        },
        /**
         * set general IVR settings
         * @param settings
         * @param onSuccess
         * @param onError
         */
        setDefaultSettings: function (settings, onSuccess, onError) {
            this.send("ivr.setDefaultSettings", {
                value: JSON.encode(settings)
            }, onSuccess, onError);
        }
    }
})();

RC.apply(Wrapper.MediaResources, Wrapper);

/**
 * Uses for actions with digital lines & devices
 * <br/><br/>
 * Alias for namespace: <b>digitalLine</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=digitalLine.listAvailableDevicesForOffer&...
 * </pre>
 *
 * @class
 * @name Wrapper.DigitalLine
 * @extends Wrapper
 * @singleton
 */
Wrapper.DigitalLine = (function() {
    return {

        /**
         * Get provisioning info
         * @param {Wrapper.Requests.GetProvisioningInfoRequest} request The instance of {@link Wrapper.Requests.GetProvisioningInfoRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         */
        getProvisioningInfo : function(request, fn, onError)
        {
            this.send("digitalLine.getProvisioningInfo",
                request.serialize(), fn, onError);
        },

        /**
         * Get extensions (groups) assigned to paging device
         * @param {Wrapper.Requests.InstanceRequest} request The instance of {@link Wrapper.Requests.InstanceRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         */
        getPagingDeviceAssignedExtensions : function(request, fn, onError)
        {
            this.send("digitalLine.getPagingDeviceAssignedExtensions",
                request.serialize(), fn, onError);
        },

        /**
        * Purchasing unassigned phones
        * @param {Wrapper.Requests.PurchasePhonesRequest} request The instance of {@link Wrapper.Requests.PurchasePhonesRequest}
        * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
        * <ul>
            *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
        * </ul>
        * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
        */
        purchaseUnassignedPhones : function(request, fn, onError)
        {
            this.send("digitalLine.purchaseUnassignedPhones",
                request.serialize(), fn, onError);
        },

        /**
         * Gets the list of available devices for purchase
         * @param {Wrapper.Requests.ListAvailableDevicesForOfferRequest} request The instance of {@link Wrapper.Requests.ListAvailableDevicesForOfferRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListAvailableDevicesForOfferResponse}
         * </ul>
         */
        listAvailableDevicesForOffer : function(request, fn)
        {
            this.send("digitalLine.listAvailableDevicesForOffer",
                request.serialize(), fn);
        },

        /**
         * Gets the list of users available to page to this group
         * @param {Integer|String} mid
         * @param {Function} fn
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        getPagingGroupWhiteList : function(mid, fn)
        {
            this.send("digitalLine.getPagingGroupWhiteList",
                {
                    mid : mid
                }, fn);
        },

        /**
         * Gets the list of users available to page to this group
         * @param {Array.<Integer|String>} mailboxIds of users to add to paging group white list
         * @param {Integer} mid paging group
         * @param {Function} fn
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setPagingGroupUsersToWhiteList : function(mailboxIds, mid, fn)
        {
            this.send("digitalLine.setPagingGroupUsersToWhiteList", {
                    mailboxIds : mailboxIds,
                    mid : mid
                },
                fn);
        },

        /**
         * Adds new lines to existing Shared Line Group
         * @param {Wrapper.Requests.PurchaseLinesRequest} request The instance of {@link Wrapper.Requests.PurchaseLinesRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         */
        addDigitalLinesToSLG : function(request, fn, onError)
        {
            this.send("digitalLine.addDigitalLinesToSLG",
                request.serialize(), fn, onError);
        },

        /**
         * Gets the list of available calling plans for purchase
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListAvailableCallingPlansForOfferResponse}
         * </ul>
         */
        listAvailableCallingPlansForOffer : function(request, fn)
        {
            this.send("digitalLine.listAvailableCallingPlansForOffer",
                request.serialize(), fn);
        },

        /**
         * Gets the list of available calling plans for purchase os SLG group
         * @param {Wrapper.Requests.MailboxRequest} request The instance of {@link Wrapper.Requests.MailboxRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListAvailableCallingPlansForOfferResponse}
         * </ul>
         */
        listAvailableCallingPlansForSLGOffer : function(request, fn)
        {
            this.send("digitalLine.listAvailableCallingPlansForSLGOffer",
                request.serialize(), fn);
        },

        /**
         * Gets the list of available shipping options
         * @param {Wrapper.Requests.ListShippingOptionsRequest} request The instance of {@link Wrapper.Requests.ListShippingOptionsRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListShippingOptionsResponse}
         * </ul>
         */
        listShippingOptions : function(request, fn)
        {
            this.send("digitalLine.listShippingOptions",
                request.serialize(), fn);
        },

        /**
         * Purchases device/line
         * @param {Wrapper.Requests.PurchasePhonesRequest} request The instance of {@link Wrapper.Requests.PurchasePhonesRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.PurchasePhonesResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of errors. It will be passed the following parameters:
         */
        purchasePhones : function(request, fn, onError)
        {
            this.send("digitalLine.purchasePhones",
                request.serialize(), fn, onError);
        },

        /**
         * Gets billing statement
         * @param {Wrapper.Requests.PurchasePhonesRequest} request The instance of {@link Wrapper.Requests.PurchasePhonesRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getStatementForPhonesPurchase : function(request, fn)
        {
            this.send("digitalLine.getStatementForPhonesPurchase",
                request.serialize(), fn);
        },

        /**
         * Gets billing statement
         * @param {Wrapper.Requests.ChangePhoneLinePlanRequest} request The instance of {@link Wrapper.Requests.ChangePhoneLinePlanRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getStatementForPhoneLinePlanChange : function(request, fn)
        {
            this.send("digitalLine.getStatementForPhoneLineNumberChange",
                request.serialize(), fn);
        },

        /**
         * Purchases device without line
         * @param {Wrapper.Requests.ChangePhoneLinePlanRequest} request The instance of {@link Wrapper.Requests.ChangePhoneLinePlanRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.PurchaseResponse}
         * </ul>
         */
        changePhoneLinePlan : function(request, fn)
        {
            this.send("digitalLine.changePhoneLinePlan",
                request.serialize(), fn);
        },

        /**
         * Provides ability to change phone line between devices
         * @param {Wrapper.Requests.ChangePhoneLineDeviceRequest} request The instance of {@link Wrapper.Requests.ChangePhoneLineDeviceRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        changePhoneLineDevice : function(request, fn)
        {
            this.send("digitalLine.changePhoneLineDevice",
                request.serialize(), fn);
        },

        /**
         * Determines ability to ship device by zip code
         * @param {Wrapper.Requests.IsShippingAllowedRequest} request The instance of {@link Wrapper.Requests.IsShippingAllowedRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isShippingAllowed : function(request, fn)
        {
            this.send("digitalLine.isShippingAllowed",
                request.serialize(), fn);
        },

        /**
         * Gets billing statement for unassign phone procedure
         * @param {Wrapper.Requests.UnassignPhoneRequest} request The instance of {@link Wrapper.Requests.UnassignPhoneRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getStatementForPhoneUnassignment : function(request, fn)
        {
            this.send("digitalLine.getStatementForPhoneUnassignment",
                request.serialize(), fn);
        },

        /**
         * Unassign phone
         * @param {Number} instanceId
         * @param {Boolean} keepNumber
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.PurchaseResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        unassignPhone : function(instanceId, keepNumber, onSuccess, onError)
        {
            this.send("digitalLine.unassignPhone",{instanceId:instanceId, keepNumber:keepNumber}, onSuccess, onError);
        },


        /**
         * Forgets softphone with given instanceId
         * @param {Object} instanceId
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        removeSPRegistration : function(instanceId, fn, onError)
        {
            this.send("digitalLine.removeSPRegistration", instanceId, fn, onError);
        },

        /**
         * Gets information about order in ABP
         * @param {Number} instanceId
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.OrderInfoResponse}
         * </ul>
         */
        getOrderInfo : function(instanceId, fn)
        {
            this.send("digitalLine.getOrderInfo",
                { instanceId : instanceId }, fn);
        },

        /**
         * Deletes unassigned device & softphone from account
         * @param {Number} instanceId
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        deletePhoneDevice : function(instanceId, fn)
        {
            this.send("digitalLine.deletePhoneDevice",
                { instanceId : instanceId }, fn);
        },

        /**
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        canPurchaseHardPhones : function(fn, onError)
        {
            this.sendSync("digitalLine.canPurchaseHardPhones",
                {}, fn, onError);
        },

        listOtherUsersPhones : function(mailboxId, fn)
        {
            this.send("digitalLine.listPhones", {mid: mailboxId}, fn);
        },

        listBLFPhones : function(mailboxId, fn)
        {
            this.send("digitalLine.listBLFPhones", {mid: mailboxId}, fn);
        },

        /**
         * Lists mailboxes that are permitted for intercom for a specific mailbox
         * @param {Number} mailboxId
         */
        listAllowedMailboxesForIntercom: function(mailboxId, fn)
        {
            this.send("digitalLine.listAllowedMailboxesForIntercom", {mailboxId: mailboxId}, fn);
        },

        /**
         * Saving permission (white) list for intercom for a specific mailbox
         * @param {Number} mailboxId
         * @param {Array} intercomList
         */
        configureListMailboxesForIntercom: function(mailboxId, intercomList, fn)
        {
            this.send("digitalLine.configureListMailboxesForIntercom",
                {
                    mailboxId: mailboxId,
                    allowedMailboxIds: JSON.encode(intercomList)
                }, fn);
        },

        /**
         * Get intercom phones list
         * @param {Number} mailboxId
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListIntercomPhonesResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        listIntercomPhones: function(mailboxId, onSuccess, onError)
        {
            this.send("digitalLine.listIntercomPhones", {mailboxId: mailboxId}, onSuccess, onError);
        },

        /**
         * Get phone count of mailbox
         * @param {params} request params
         * @param {*} params.mid mailboxId where to count lines
         * @param {Boolean} [params.excludeFreeSP] whether free softphone lines should be counted, or not
         * @param {Function} [onSuccess] The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         * @param {Function} [onError] The function to be called in case of error. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        countPhonesForMailbox: function(params, onSuccess, onError)
        {
            this.send("digitalLine.countPhonesForMailbox", params, onSuccess, onError);
        },

        /**
         * Get phoneLine count of SLG
         * @param {Number} mailboxId
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.LongResponse}
         * </ul>
         * @param {Function} [onError] (optional) The function to be called in case of error. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        countPhoneLinesForMailbox: function(mailboxId, excludeFreeSP, onSuccess, onError)
        {
            this.send("digitalLine.countPhoneLinesForMailbox", {mid: mailboxId, excludeFreeSP: excludeFreeSP}, onSuccess, onError);
        },

        /**
         * Set intercom phone for a specific mailbox
         * @param {Number} mailboxId
         */
        setIntercomPhone: function(mailboxId, phoneLineId, fn)
        {
            this.send("digitalLine.setIntercomPhoneLine",
                {
                    mailboxId: mailboxId,
                    phoneLineId: phoneLineId
                }, fn);
        },

        hasDigitalLineSlots : function(fn){
            this.sendSync("digitalLine.hasDigitalLineSlots", {}, fn);
        },

        getE911Address: function(options){
            options = options || {};
            this.send("digitalLine.getE911Address", options.request, options.onSuccess, options.onError);
        },

        listPhoneLinesForMailbox: function (mailboxId, fn) {
            this.send("digitalLine.listPhoneLinesForMailbox",
                {
                    mid: mailboxId
                }, fn);
        },

        updateSLGConfiguration: function (request, fn) {
            request = request || {};
            request.lines = JSON.encode(request.lines);
            this.send("digitalLine.updateSLGConfiguration", request, fn);
        },

        /**
         * Get emergency location for mailbox
         * @param {Number} mailboxId
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         */
        getEmergencyInfoLocationForMailbox: function (mailboxId, onSuccess) {
            this.send("digitalLine.getEmergencyInfoLocationForMailbox", {
                mailboxId: mailboxId
            }, onSuccess);
        },

        /**
         * Set emergency location for mailbox
         * @param {Number} mailboxId
         * @param {Object} address
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         */
        setEmergencyInfoLocationForMailbox: function (mailboxId, address, onSuccess) {
            this.send("digitalLine.setEmergencyInfoLocationForMailbox", {
                mailboxId: mailboxId,
                address: address
            }, onSuccess);
        },

        /**
         * @param {Object} request
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         */
        addPagingGroupDevices: function (request, onSuccess) {
            this.send("digitalLine.addPagingGroupDevices", request, onSuccess);
        },

        /**
         * @param {Number} mid
         * @param {Function} onSuccess (optional) The function to be called. It will be passed the following parameters:
         */
        listPagingGroupDevices: function (mid, fn) {
            this.send("digitalLine.listPagingGroupDevices", {
                mid : mid
            }, fn);
        },

        /**
         * Set digitalLine info
         * @param {Number} areaCode
         * @param {Number} phoneLineId
         * @param {Number} instanceId
         * @param {Function} onSuccess (optional) The function to be called when the api call is success. It will be passed the following parameters:
         * @param {Function} onError (optional) The function to be called when the api call is fail. It will be passed the following parameters:
         */
        setDigitalLineInfo: function (defaultAreaCode, phoneLineId, instanceId, onSuccess, onError) {
            this.send("digitalLine.setDigitalLineInfo", {
                defaultAreaCode: defaultAreaCode,
                phoneLineId: phoneLineId,
                instanceId: instanceId
            }, onSuccess, onError);
        },

        /**
         * remove digital line of SLG
         * @param {Number} lineId
         * @param {Boolean} keepNumber
         * @param {Function} onSuccess
         */
        removeDigitalLineFromSLG: function(lineId, keepNumber, onSuccess) {
            this.send("digitalLine.removeDigitalLineFromSLG", {
                lineId: lineId,
                keepNumber: keepNumber
            }, onSuccess);
        },

        validateE911Address : function(options) {
            this.send("digitalLine.validateE911Address", options.params, options.onSuccess, options.onError);
        },

        /**
         * Sets provisioning for Polycom Phone
         * @param {params} request params
         * @param {Number} params.deviceId Phone device ID
         * @param {Number} params.instanceId Phone instanceID
         * @param {String} params.serial Phone MAC-address
         * @param {Function} fn
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        provisionPolycomPhone : function(params, fn)
        {
            this.send("digitalLine.provisionPolycomPhone", params, fn);
        },

	    getWebPhoneProvisioningInfo: function(params, fn) {
            this.send("digitalLine.getWebPhoneProvisioningInfo", params, fn);
        },

        listPhonesForMailbox: function (mid, onSuccess) {
            this.send("digitalLine.listPhonesForMailbox", {
                mid: mid
            }, onSuccess);
        }

    }
})();

RC.apply(Wrapper.DigitalLine, Wrapper);


/**
 * Uses for actions with billing (change billing cycle, change service plan and etc.)
 * <br/><br/>
 * Alias for namespace: <b>billing</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=billing.isChangeServicePlanAllowed&...
 * </pre>
 *
 * @class
 * @name Wrapper.Billing
 * @extends Wrapper
 * @singleton
 */
Wrapper.Billing = (function() {
    return {
        /**
         * Gets billing statement for adding new line to existing shared line group
         * @param {Wrapper.Requests.PurchaseLinesRequest} request The instance of {@link Wrapper.Requests.PurchaseLinesRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getBillingStatementForAddDigitalLinesToSLG : function(request, fn)
        {
            this.send("billing.getBillingStatementForAddDigitalLinesToSLG",
                request.serialize(), fn);
        },

        /**
         * Gets billing statement
         * @param {Wrapper.Requests.PurchaseExtensionAndPhoneRequest} request The instance of {@link Wrapper.Requests.PurchaseExtensionAndPhoneRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getBillingStatementForExtension : function(request, fn)
        {
            this.send("billing.getBillingStatementForExtension",
                request.serialize(), fn);
        },

        /**
         * Purchasing extension with phones, for example Shared Line Group
         * @param {Wrapper.Requests.PurchaseExtensionAndPhoneRequest} request The instance of {@link Wrapper.Requests.PurchaseExtensionAndPhoneRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         */
        purchaseExtensionAndPhone : function(request, fn, onError)
        {
            this.send("billing.purchaseExtensionAndPhone",
                request.serialize(), fn, onError);
        },

        /**
         * Purchasing extension
         * @param {Wrapper.Requests.PurchaseExtensionRequest} request The instance of {@link Wrapper.Requests.PurchaseExtensionRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         * @param {Function} onError (optional) The function to be called in case of error. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        purchaseExtension : function(request, fn, onError)
        {
            this.send("billing.purchaseExtension",
                request.serialize(), fn, onError);
        },

        /**
         * Gets billing statement
         * @param {Wrapper.Requests.UnassignPhoneRequest} request The instance of {@link Wrapper.Requests.UnassignPhoneRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getStatementForPhoneNumberDelete : function(request, fn)
        {
            this.send("billing.getStatementForPhoneNumberDelete",
                request.serialize(), fn);
        },

        /**
         * Returns tollFree minutes bundles
         *
         * @param {Wrapper.Requests.SetTollFreeMinuteBundleRequest} request  The instance of {@link Wrapper.Requests.SetTollFreeMinuteBundleRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.SetTollFreeMinutesBundleResponse}
         * </ul>
         */
        setTollFreeMinutesBundle : function(request, fn)
        {
            this.send("billing.setTollFreeMinutesBundle",
                request.serialize(), fn);
        },

        /**
         * Returns billing statement for tollFree minutes bundles
         *
         * @param {Wrapper.Requests.GetStatementForTollFreeBundlePurchase} request  The instance of {@link Wrapper.Requests.GetStatementForTollFreeBundlePurchase}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getStatementForTollFreeBundlePurchase : function(request, fn)
        {
            this.send("billing.getStatementForTollFreeBundlePurchase",
                request.serialize(), fn);
        },

        /**
         *
         * @public
         * @function
         * @name Wrapper.Billing.getStatementForInternationalBundlePurchase
         * @param {Wrapper.Requests.GetStatementForInternationalBundlePurchase} request The instance of {@link Wrapper.Requests.GetStatementForInternationalBundlePurchase}.
         * @param {Function} [fn] The function to be called.
         * @return {void}
         */
        getStatementForInternationalBundlePurchase : function(request, fn)
        {
            this.send("billing.getStatementForInternationalBundlePurchase", request.serialize(), fn);
        },

        /**
         * Returns tollFree minutes bundles
         *
         * @param {Wrapper.Requests.TierRequest} request  The instance of {@link Wrapper.Requests.TierRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListTollFreeMinutesBundleResponse}
         * </ul>
         */
        listTollFreeMinutesBundles : function(request, fn)
        {
            this.send("billing.listTollFreeMinutesBundles",
                request, fn);
        },

        /**
         * Returns international minutes bundles.
         *
         * @public
         * @function
         * @name Wrapper.Billing.listInternationalBundles
         * @param {Wrapper.Requests.TierRequest} request The instance of {@link Wrapper.Requests.TierRequest}.
         * @param {Function} [fn] The function to be called.
         * @return {void}
         */
        listInternationalBundles : function (request, fn) {
            this.send("billing.listInternationalBundles", request, fn);
        },

        /**
         * Determines ability to change service plan
         *
         * @param {Wrapper.Requests.TierRequest} request  The instance of {@link Wrapper.Requests.TierRequest}
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BooleanResponse}
         * </ul>
         */
        isChangeServicePlanAllowed : function(request, fn)
        {
            this.send("billing.isChangeServicePlanAllowed",
                request.serialize(), fn);
        },

        /**
         * Gets information about services on account
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ServicePlanInfoResponse}
         * </ul>
         */
        getServicePlanInfo : function(fn)
        {
            this.send("billing.getServicePlanInfo",
                {}, fn);
        },

        /**
         * Gets information about services on account
         *
         * @param {Function} fn (optional) The function to be called.
         */
        getUserLimits : function(fn) {
            this.send("billing.getUserLimits", {}, fn);
        },

        /**
         * Gets information about additional services on account
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.WAvailableAdditionalServicesResponse}
         * </ul>
         */
        getAvailableAdditionalServices : function(fn)
        {
            this.send("billing.getAvailableAdditionalServices",
                {}, fn);
        },

        /**
         * Gets information about available calling credits packages
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.WListAutoPurchasePackagesResponse}
         * </ul>
         */
        listAutoPurchasePackages : function(fn)
        {
            this.send("billing.listAutoPurchasePackages",
                {}, fn);
        },

        /**
         * Gets information about packages settings
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingSettingsResponse}
         * </ul>
         */
        getBillingSettings : function(fn)
        {
            this.send("billing.getBillingSettings",
                {}, fn);
        },

        /**
         * Gets information about packages settings
         *
         * @param {Wrapper.Requests.BillingSettingsRequest} request
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        setBillingSettings : function(request, fn)
        {
            this.sendSync("billing.setBillingSettings",
                request.serialize(), fn);
        },

        /**
         * Provides information about credit card
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.WCreditCardInfoResponse}
         * </ul>
         * @param {Function} failure (optional) The function to be called if an exception will be occurred. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        getCCInfo : function(fn, failure)
        {
            this.send("billing.getCCInfo",
                {}, fn, failure);
        },

        /**
         * Gets information about transaction
         * @param {Number} transactionId
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.BillingStatementResponse}
         * </ul>
         */
        getTransactionInfo : function(transactionId, isRefund, fn)
        {
            this.send("billing.getBillingTransactionInfo",
                { transactionId : transactionId, isRefund : isRefund }, fn);
        },

        getCreditCardStorageOptions : function(fn)
        {

            this.send("billing.getCreditCardStorageOptions",{}, fn);

        },
        saveLogs : function(params)
        {
            this.send("billing.saveComment", { description : params });
        },
        /**
         * Saves information aboujt credit card
         * @param {Object} o Hash of cc info
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         * @param {Function} failure (optional) The function to be called if an exception will be occurred. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        saveCCInfo : function(o, fn, failure)
        {

            var self = this;

            self.getCreditCardStorageOptions(function(storageOptions){

                var strategy = storageOptions.tokenizationRequired ? mesStrategy : transparentStrategy;

                strategy(storageOptions.tokenizationServiceUrl);

            });

            function transparentStrategy(url){

                RC.Console.log('Wrapper.Billing.saveCCInfo(): Transparent strategy');
                self.send("billing.saveCCInfo", o, fn, failure);

            }

            function mesStrategy(url){

                RC.Console.log('Wrapper.Billing.saveCCInfo(): MES strategy');

                RC.ComponentMgr.load('billing/mes.js', function(){

                    var mes = new RC.UI.Billing.MES(o.number, o.cvv, o.expirationMonth, o.expirationYear, url);
                    mes.onReady(function() {

                        o.token = mes.getToken();
                        o.number = mes.getNumber();

                        self.send("billing.saveCCInfo", o, fn, failure);

                    });

                    mes.onError(function(){
                        failure({
                            status: {
                                success: false,
                                code: 9000 + mes.getCode(),
                                message: RC.Lang.Common.MES_ERROR.PAYMENT_GATEWAY_ERROR + mes.getText()
                            }
                        });
                    });
                });

            }

        },

        /**
         * Gets information about current status of feature plan and gets the list of available ext types with their plans
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.StatusedResponse}
         * </ul>
         */
        getFeaturePlanStatus : function(fn)
        {
            this.send("billing.getFeaturePlanStatus",
                {}, fn);
        },

        getFeatureNumberPlanInfo: function(mailboxId, tierId, retrieveAllNextFeaturePlans, fn) {

            this.send("billing.getFeatureNumberPlanInfo", {
                mid: mailboxId,
                tierId: tierId,
                retrieveAllNextFeaturePlans: retrieveAllNextFeaturePlans            }, fn);

        },

        getFeatureUserPlanInfo: function(tierId, extensionType, fn) {

            this.send("billing.getFeatureUserPlanInfo", {
                tierId: tierId,
                extensionType: extensionType
            }, fn);

        },

        checkNumbersAvailabilityForOrder : function(allocations, options){
            options = options || {};
            this.send("billing.checkNumbersAvailabilityForOrder", {
                allocations: allocations
            },options.onSuccess, options.onError);
        },

        placeOrder : function(order, options){
            options = options || {};
            this.send("billing.placeOrder", {
                order : JSON.encode(order)
            },options.onSuccess, options.onError);
        },

        getStatementForOrder : function(order, options){
            options = options || {};
            this.send("billing.getStatementForOrder", {
                order : JSON.encode(order)
            },options.onSuccess, options.onError);
        },

        /**
         * get billing statement for removing DL from SLG
         * @param {Number} lineId
         * @param {Boolean} keepNumber
         * @param {Boolean} calculateNumberPrice
         * @param {Function} onSuccess
         */
        getBillingStatementForRemoveDigitalLineFromSLG: function(lineId, keepNumber, calculateNumberPrice, onSuccess) {
            this.send("billing.getBillingStatementForRemoveDigitalLineFromSLG", {
                lineId: lineId,
                keepNumber: keepNumber,
                calculateNumberPrice: calculateNumberPrice
            }, onSuccess);
        },

        /**
         * get billing statement for removing DL from SLG
         * @param {Number} lineId
         * @param {Boolean} keepNumber
         * @param {Boolean} calculateNumberPrice
         * @param {Function} onSuccess
         */
        getBillingStatementForChangeFeaturePlans: function(params, onSuccess) {
            this.send("billing.getBillingStatementForChangeFeaturePlans", params, onSuccess);
        },

        /**
         * get billing statement for delete extension and numbers
         * @param {Number} mailBoxId
         * @param {Array} numberId list of need to remove
         * @param {Function} onSuccess
         * @param {Function} OnError
         */
        getBillingStatementForDeleteNumbersAndExtension: function(mailBoxId, numbersToDelete, onSuccess, OnError){
            this.send("billing.getBillingStatementForDeleteNumbersAndExtension", {
                mailboxId: mailBoxId,
                numbersToDelete: JSON.encode(numbersToDelete)
            }, onSuccess, OnError);
        },

        /**
         * @param {Number} planId
         * @param {Number} tierId
         * @param {Function} onSuccess
         * @param {Function} OnError
         */
        performTransition: function(planId, tierId, onSuccess, onError) {
            this.send("billing.performTransition", {
                planId: planId,
                tierId: tierId
            }, onSuccess, onError);
        },

        /**
         * Gets list of Annual Contrcts
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ListMenusResponse}
         * </ul>
         */
        listContracts: function(onSuccess){
            this.send("billing.getATTBillingContracts", {}, onSuccess);
        },

        /**
         * Gets current contract information
         *
         * @param {Function} fn (optional) The function to be called. It will be passed the following parameters:
         */
        getCurrentATTBillingContract: function(onSuccess){
            this.send("billing.getCurrentATTBillingContract", {}, onSuccess);
        },

        /**
         * Change international calling status of destination.
         * @param {Number} destinationId
         * @param {Boolean} disabled
         * @param {String} direction Inbound or Outbound
         * @param {Boolean} skipLoader
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        changeCallingDestinationStatus: function(destinationId, disabled, direction, skipLoader, onSuccess, onError) {
            this.send("billing.changeCallingDestinationStatus", {
                destinationId: destinationId,
                disabled: disabled,
                direction: direction
            }, onSuccess, onError, true, skipLoader);
        }

    };
})();

RC.apply(Wrapper.Billing, Wrapper);

Wrapper.Contacts = (function() {
    return {
        listContacts: function(fn, options) {

            var self = this;
            var page = 0;
            var data = [];

            function requestNextPage(callback) {

                page++;

                options.pageNumber = page;
                self.send("contacts.listContacts", options, function(response) {

                    if (response.contacts && response.contacts.length > 0) {

                        data = data.concat(response.contacts);
                        requestNextPage(callback);

                    } else {

                        callback();

                    }

                });

            }

            requestNextPage(function(){

                fn(data);

            });

        },
        listGroups: function (onSuccess, onError) {
            this.send("contacts.listGroups",{}, onSuccess, onError);
        },
        listCompanyContacts: function (fieldsTofetch, sortOptions, onSuccess, onError) {
            this.send("contacts.listCompanyContacts",{
                fieldsTofetch: fieldsTofetch,
                sortOptions: sortOptions
            }, onSuccess, onError);
        }
    }
})();

RC.apply(Wrapper.Contacts, Wrapper);

Wrapper.PasswordRecovery = (function() {
    return {
        /**
         * Validates captcha provided on the /login/password.html page.
         * @param captcha
         * @param fn
         * @param fail
         */
        validateCaptcha: function(captcha, fn, fail) {

            this.send("pwd_recovery.validateCaptcha",{
                captcha: captcha
            }, fn, fail);

        },
        /**
         * Returns the secret question for the validated mailbox.
         * @param fn
         * @param fail
         */
        getSecretQuestion: function(fn, fail) {

            this.send("pwd_recovery.getSecretQuestion",{}, fn, fail);

        },
        /**
         * Sends a password recovery link to the validated mailbox email.
         * Returns the obfuscated email address.
         * @param fn
         */
        emailRecoveryLink: function(fn) {

            this.send("pwd_recovery.emailRecoveryLink",{}, fn);

        },
        /**
         * Validates the secret answer for the validated mailbox number.
         * Returns Boolean.
         * @param answer
         * @param fn
         * @param fail
         */
        validateSecretAnswer: function(answer, fn, fail) {

            this.send("pwd_recovery.validateSecretAnswer",{
                answer: answer
            }, fn, fail);

        },
        /**
         * Returns Boolean.
         * @param link
         * @param fn
         * @param fail
         */
        validateLink: function(link, fn, fail) {

            this.send("pwd_recovery.validateLink",{
                link: link
            }, fn, fail);

        },
        /**
         * Sets the new password. The number must be validated, the secret question must be answered.
         * Returns Boolean.
         * @param password
         * @param ivrPin
         * @param fn
         * @param fail
         */
        changePassword: function(password, ivrPin, fn, fail) {

            this.send("pwd_recovery.changePassword",{
                password: password,
                ivrPin: ivrPin
            }, fn, fail);

        }
    }
})();

RC.apply(Wrapper.PasswordRecovery, Wrapper);

/**
 * @namespace
 * @name Wrapper.Templates
 */
Wrapper.Templates = (function () {

    return {

        /**
         * Get templates list.
         *
         * @public
         * @function
         * @name Wrapper.Templates.listTemplates
         * @param {Function} callback
         * @return {void}
         */
        listTemplates: function (callback) {
            "use strict";
            this.send("templates.listTemplates", null, callback);
        },

        /**
         * Remove template.
         *
         * @public
         * @function
         * @name Wrapper.Templates.deleteTemplate
         * @param {Number} templateId Template identifier.
         * @param {Function} callback
         * @return {void}
         */
        deleteTemplate: function (templateId, callback) {
            "use strict";
            this.send("templates.deleteTemplate", {templateId: templateId}, callback);
        },

        /**
         * Validate template name.
         *
         * @public
         * @function
         * @name Wrapper.Templates.validateTemplateName
         * @param {String} templateName
         * @param {Function} callback
         * @return {void}
         */
        validateTemplateName: function (templateName, callback) {
            "use strict";
            this.send(
                "templates.validateTemplateName",
                {templateName: String(templateName || "")},
                callback
            );
        },

        /**
         * Create new empty template.
         *
         * @public
         * @function
         * @deprecated
         * @name Wrapper.Templates.createTemplate
         * @param {String} templateName
         * @param {Function} callback
         * @return {void}
         */
        createTemplate: function (templateName, callback) {
            "use strict";
            this.send(
                "templates.createTemplate",
                {templateName: String(templateName || "")},
                callback
            );
        },

        /**
         * Get template information.
         *
         * @public
         * @function
         * @name Wrapper.Templates.getTemplateInfo
         * @param {Number} templateId
         * @param {Function} callback
         * @return {void}
         */
        getTemplateInfo: function (templateId, callback) {
            "use strict";
            this.send(
                "templates.getTemplateInfo",
                {templateId: templateId},
                callback
            );
        },

        /**
         * Validate template before apply
         *
         * @public
         * @function
         * @name Wrapper.Templates.validateTemplateBeforeApply
         * @param {Number} templateId
         * @param {Function} callback
         * @return {void}
         */
        validateTemplateBeforeApply: function (templateId, callback) {
            "use strict";
            this.send(
                "templates.validateTemplateBeforeApply",
                {
                    templateId: templateId
                },
                callback
            );
        },

        /**
         * Validate template before apply
         *
         * @public
         * @function
         * @name Wrapper.Templates.validateTemplateBeforeApplyToOneUser
         * @param {Number} templateId
         * @param {Function} callback
         * @return {void}
         */
        validateTemplateBeforeApplyToOneUser: function (templateId, callback) {
            "use strict";
            this.send(
                "templates.validateTemplateBeforeApply",
                {
                    templateId: templateId,
                    applyImmediately: true
                },
                callback
            );
        },

        validateRuleTemplateBeforeApply: function (templateId, callback) {
            "use strict";
            this.send(
                "templates.validateRuleTemplateBeforeApply",
                {
                    templateId: templateId
                },
                callback
            );
        },

        validateRuleTemplateBeforeApplyToOneUser: function (templateId, callback) {
            "use strict";
            this.send(
                "templates.validateRuleTemplateBeforeApply",
                {
                    templateId: templateId,
                    applyImmediately: true
                },
                callback
            );
        },

        /**
         * Save template data.
         *
         * @public
         * @function
         * @name Wrapper.Templates.saveTemplate
         * @param {Number} templateId
         * @param {String} templateName
         * @param {Object} data
         * @param {Function} callback
         * @return {void}
         */
        saveTemplate: function (templateId, templateName, data, callback) {
            "use strict";
            this.send(
                "templates.saveTemplate",
                {
                    isCopy      : false,
                    templateId    : templateId,
                    templateName  : templateName,
                    structureInfo : JSON.stringify(data)
                },
                callback,
                callback
            );
        },

        /**
         * Copy template data.
         *
         * @public
         * @function
         * @deprecated
         * @name Wrapper.Templates.copyTemplate
         * @param {Number} templateId
         * @param {String} templateName
         * @param {Object} data
         * @param {Function} callback
         * @return {void}
         */
        copyTemplate: function (templateId, templateName, data, callback) {
            "use strict";
            this.send(
                "templates.saveTemplate",
                {
                    isCopy      : true,
                    templateId    : templateId,
                    templateName  : templateName,
                    structureInfo : JSON.stringify(data)
                },
                callback
            );
        },

        /**
         * Apply template.
         *
         * @public
         * @function
         * @name Wrapper.Templates.applyTemplate
         * @param templateId
         * @param usersList
         * @param emailsList
         * @param {Boolean} notifyUsers
         * @param callback
         * @param {Function} error
         * @return {void}
         */
        applyTemplate: function (templateId, usersList, emailsList, notifyUsers, callback, error) {
            "use strict";
            this.send(
                "templates.applyTemplate",
                {
                    templateId: templateId,
                    mailboxList: JSON.stringify(usersList),
                    emailsList: JSON.stringify(emailsList),
                    notifyUsers: JSON.stringify(notifyUsers)
                },
                callback, error
            );
        },

        /**
         * Apply template.
         *
         * @public
         * @function
         * @name Wrapper.Templates.applyTemplateToOneUser
         * @param {String} templateId
         * @param {Number} userId
         * @param {Boolean} notifyUsers
         * @param {Function} callback
         * @param {Function} error
         * @return {void}
         */
        applyTemplateToOneUser: function (templateId, userId, notifyUsers, callback, error) {
            "use strict";
            this.send(
                "templates.applyTemplate",
                {
                    templateId: templateId,
                    mailboxList: JSON.stringify([userId]),
                    emailsList: JSON.stringify([]),
                    applyImmediately: true,
                    notifyUsers: JSON.stringify(notifyUsers)
                },
                callback, error
            );
        },

        // applyImmediately

        /**
         * Save advanced rule template.
         *
         * @public
         * @function
         * @name Wrapper.Templates.saveTemplateRule
         * @param templateId
         * @param {String} templateName
         * @param {Object} structureInfo
         * @param {Function} callback
         * @return {void}
         */
        saveTemplateRule: function (templateId, templateName, structureInfo, callback, onError) {
            this.send(
                "templates.saveTemplateRule",
                {
                    isCopy: false,
                    templateId: templateId,
                    templateName: templateName,
                    structureInfo: JSON.stringify(structureInfo)
                },
                callback,
                onError
            )
        },

        /**
         * Copy advanced rule template data.
         *
         * @public
         * @function
         * @name Wrapper.Templates.copyTemplateRule
         * @param {Number} templateId
         * @param {String} templateName
         * @param {Object} structureInfo
         * @param {Function} callback
         * @return {void}
         */
        copyTemplateRule: function (templateId, templateName, structureInfo, callback, onError) {
            "use strict";
            this.send(
                "templates.saveTemplateRule",
                {
                    isCopy: true,
                    templateId: templateId,
                    templateName: templateName,
                    structureInfo: JSON.stringify(structureInfo)
                },
                callback,
                onError
            );
        },

        /**
         * Give advanced rule template info.
         *
         * @public
         * @function
         * @name Wrapper.Templates.saveTemplateRule
         * @param templateId
         * @param {Function} callback
         * @return {void}
         */
        getTemplateRuleInfo: function (templateId, callback) {
            this.send(
                "templates.getTemplateRuleInfo",
                {
                    templateId: templateId
                },
                callback
            )
        },

        /**
         * Get defaults for advanced rule template.
         *
         * @public
         * @function
         * @name Wrapper.Templates.getDefaultsRule
         * @param callback
         * @return {void}
         */
        getDefaultsRule: function (callback) {
            this.send(
                "templates.getDefaultsRule",
                null,
                callback
            )
        },

        /**
         * Upload greeting.
         *
         * @param file
         * @param {Number} userId
         * @param {Function} [onSuccess]
         * @param {Function} [onError]
         */
        uploadGreeting: function (file, userId, onSuccess, onError) {
            this.send(
                "mediaResources.uploadGreeting",
                {
                    greetingType : "TemplateRelated",
                    mailboxId    : userId,
                    file         : file
                },
                onSuccess,
                onError
            );
        }
    }

}());

RC.apply(Wrapper.Templates, Wrapper);

Wrapper.Confirmation = (function() {
    return {
        sendActivationCode: function(fn) {

            this.send("confirmation.sendActivationCode",{}, fn);

        },
        validateActivationCode: function(code, fn, fail) {

            this.send("confirmation.validateActivationCode",{
                code: code
            }, fn, fail);

        }
    }
})();

RC.apply(Wrapper.Confirmation, Wrapper);

Wrapper.Login = (function() {
    return {
        autoLogin: function(noAutoLogin, fn) {

            this.send("login.autologin",{
                noAutoLogin: !!noAutoLogin
            }, fn);

        },
        logout: function(fn, fail) {

            this.send("login.logout",{}, fn, fail);

        }
    }
})();

RC.apply(Wrapper.Login, Wrapper);

Wrapper.MailboxActivation = (function() {
    return {
        activate: function(password, question, answer, pin, fn, fail) {

            this.send("mailbox_activation.activate",{
                password: password,
                question: question,
                answer: answer,
                ivrPin: pin
            }, fn, fail);

        }
    }
})();

RC.apply(Wrapper.MailboxActivation, Wrapper);

Wrapper.Cloud = (function() {
    return {
        getOAuthUrl: function(request, onSuccess, onError) {
            this.send("cloud.getOAuthUrl", request, onSuccess, onError, false);
        },
        removeOAuth: function(request, onSuccess, onError) {
            this.send("cloud.removeOAuth", request, onSuccess, onError);
        },
        listFiles: function(request, onSuccess, onError) {
            this.send("cloud.listFiles", request, onSuccess, onError);
        },
        fetchFiles: function(request, onSuccess, onError) {
            this.send("cloud.fetchFiles", request, onSuccess, onError);
        },
        /**
         * List file's information by providing file ids
         * <br><br>
         * @param {Object} request
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        listFilesById: function(request, onSuccess, onError) {
            this.send("cloud.listFilesById", request, onSuccess, onError);
        }
    };
})();
RC.apply(Wrapper.Cloud, Wrapper);

Wrapper.NumberPorting = (function(){
    return {

        savePortedOrderAttachmentInfo : function(options) {
            this.send("numberporting.savePortedOrderAttachmentInfo",
                options.request.serialize(), options.onSuccess, options.onError);
        },

        listInProgressPortedOrders:function (options) {
            options = options || {};
            this.send("numberporting.listInProgressPortedOrders", null, options.onSuccess, options.onError);
        },

        listInProgressPortedOrdersExtended:function (options) {
            options = options || {};
            this.send("numberporting.listInProgressPortedOrdersExtended", null, options.onSuccess, options.onError);
        },

        getPortedOrderInfo:function(options){
            options = options || {};
            this.send("numberporting.getPortedOrderInfo", {orderId:options.orderId}, options.onSuccess, options.onError);
        },

        reSubmitPortedOrder:function(options){
            options = options || {};
            this.send("numberporting.reSubmitPortedOrder", options.request, options.onSuccess, options.onError);
        },


        submitPortedOrder : function(options) {
            this.send("numberporting.submitPortingOrder",
                options.request, options.onSuccess, options.onError);
        },


        editPortedOrder : function(options) {
            this.send("numberporting.editPortedOrder",
                options.request, options.onSuccess, options.onError);
        },

        validatePortedNumber:function(options){
            options = options || {};
            this.send("numberporting.checkNumberToBePorted", options.request, options.onSuccess, options.onError);
        },
        /**
         * Get the information about porting numbers
         * @param {function} fn   callback function
         */
        getInprogressPortingNumberInfo: function(fn) {
            this.send("numberporting.getInprogressPortingNumberInfo", {}, fn);
        },
        /**
         * Get the information about if an order support supplementalOrder
         * @param {Number} orderId
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        isSupportedSupplementalOrder: function(orderId, onSuccess, onError) {
            this.send("numberporting.isSupportedSupplementalOrder", {orderId: orderId}, onSuccess, onError);
        },
        getLosingProviders: function(options) {
            options = options || {};
            this.send("numberporting.getLosingProviders", options.request, options.onSuccess, options.onError);
        },

        /**
         * @param {string} phoneNumber   The RingCentral phone number which is being replaced
         * @param {function} onSuccess   The function to be called. It will be passed the following parameters:
         * <ul>
         *     <li><b>response</b> : {@link Wrapper.Responses.ReplacedNumberInfoResponse}
         * </ul>
         */
        getReplacedNumberInfo: function(phoneNumber, onSuccess) {
            this.send("numberporting.getReplacedNumberInfo", {
                phoneNumber: phoneNumber
            }, onSuccess);
        }

    }
})();

RC.apply(Wrapper.NumberPorting, Wrapper);

Wrapper.RingMe = (function(){
    return {
        /**
         * Generate html code for Ring Me
         * @param {Object} request
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        generateCode : function(request, onSuccess, onError) {
            this.send("ringme.generateCode", request, onSuccess, onError);
        },
        /**
         * List buttons for Ring Me
         * @param {Object} request
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        listButtons : function(request, onSuccess, onError) {
            this.send("ringme.listButtons", request, onSuccess, onError);
        },
        /**
         * Get Ring Me Settings
         * @param {Object} request
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        getRingMeSettings : function(request, onSuccess, onError) {
            this.send("ringme.getRingMeSettings", request, onSuccess, onError);
        },
        /**
         * Set Ring Me Settings
         * @param {Object} request
         * @param {Function} onSuccess
         * @param {Function} onError
         */
        setRingMeSettings : function(request, onSuccess, onError) {
            this.send("ringme.setRingMeSettings", request, onSuccess, onError);
        }
    };
})();

RC.apply(Wrapper.RingMe, Wrapper);


Wrapper.Reporting = (function(){
    return {
        getLink : function(fn, err) {
            this.send("reports.getLink", {}, fn, err);
        }
    }
})();

RC.apply(Wrapper.Reporting, Wrapper);



Wrapper.Supervision = (function() {
    return {
        createGroup : function(name, supervisors, supervised, cb, eb) {
            this.send("supervision.createGroup", {
                value: JSON.stringify({
                    name : name,
                    supervisors : supervisors,
                    supervised: supervised
                })
            }, cb, eb);
        },
        listGroups: function(fn) {
            this.send("supervision.listGroups", null, fn);
        },
        getGroupInfo: function(id, fn) {
            this.send("supervision.getGroupInfo", {
                groupId: id
            }, fn);  
        },
        setGroupInfo: function(id, name, canMonitor, canBeMonitored, fn) {
            var val = {
                groupId: id,
                name : name
            };

            if (canMonitor && canMonitor.length) {
                val.supervisors = canMonitor;
            }

            if (canBeMonitored && canBeMonitored.length) {
                val.supervised = canBeMonitored;
            }

            this.send("supervision.setGroupInfo", {
                value: JSON.stringify(val)
            }, fn);  
        },
        deleteGroup: function(id, fn) {
            this.send("supervision.deleteGroup", {
                groupId: id
            }, fn);  
        }
    };

})();

RC.apply(Wrapper.Supervision, Wrapper);


/**
 * @class Wrapper.SessionTimeout
 * @extends Wrapper
 * Manage session timeout related information.
 * <br/><br/>
 * Alias for namespace: <b>timeout</b>
 * <br/><br/>
 * Usage:
 * <pre>
 * https://ip/mobile/api/proxy.html?cmd=timeout.getCurrentValue...
 * </pre>
 * @singleton
 */
Wrapper.SessionTimeout = (function() {
    return {
        /**
         * Get available timeout values.
         * @param userId user ID
         * @param cb success callback.
         * @param eb error callback.
         */
        getAvailableValues : function(userId, cb, eb) {
            this.send("timeout.getAvailableValues", {
                uid : userId
            }, cb, eb);
        },
        /**
         * Get session timeout value for specified user.
         * @param userId  user ID
         * @param cb success callback.
         * @param eb error callback.
         */
        getCurrentValue: function(userId,  cb, eb) {
            this.send("timeout.getCurrentValue", {
                uid: userId
            }, cb, eb);
        },
        /**
         * Set new session timeout value. Only system, and admin users are permitted to perform this operation.
         * @param userId user ID
         * @param mailboxId mailbox ID.
         * @param newValue New timeout value in minutes
         * @param cb success callback.
         * @param eb error callback.
         */
        setCurrentValue: function(userId, mailboxId, newValue, cb, eb) {
            this.send("timeout.setCurrentValue", {
                uid: userId,
                mid : mailboxId,
                newValue: newValue
            }, cb, eb);
        }
    };

})();

RC.apply(Wrapper.SessionTimeout, Wrapper);

/*jslint */
/*global RC, Wrapper */

RC.ns(
    "Wrapper.Enums",
    "Wrapper.Enums.AnsweringRuleType",
    "Wrapper.Enums.GreetingType"
);

/**
 * Created by Ivan Soloviev, ivans@dins.ru
 * <p/>
 * Copyright (c) 2011 RingCentral, Inc.
 * All rights reserved.
 *
 */


/**
 * The types of rule
 *
 * @class
 * @name Wrapper.Enums.AnsweringRuleType
 */
Wrapper.Enums.AnsweringRuleType = {
    /**
     * not used on the web
     * @type Number
     */
    Transfer : 2,
    /**
     * afterHours=MailboxDefault if BusinessHours is not null
     * @type Number
     */
    MailboxDefault: 3,
    /**
     * @type Number
     */
    BusinessHours : 4,
    /**
     * custom rules. if rule.getAnswering() == AgentProfile - is rule for agent
     * @type Number
     */
    Mailbox : 5,
    /**
     * built in rule. cannot be deleted
     * @type Number
     */
    FollowMe : 6,
    /**
     * built in rule. cannot be deleted
     * @type Number
     */
    DND : 7,

    /**
     * FollowMe and DND rules
     * @type Number
     */
    BuiltIn : 100,
    /**
     * BussinesHours and MailboxDefault (AfterHours) rules
     * @type Number
     */
    Hours : 101,
    /**
     * @type Number
     */
    Custom : 102
};

/**
 * The types of greeting
 *
 * @class
 * @name Wrapper.Enums.GreetingType
 */
Wrapper.Enums.GreetingType = {
    /**
     * Company greeting on calling to account's main number
     * @type Number
     */
    Master : 0,
    /**
     * Voicemail greeting
     * @type Number
     */
    Voicemail : 1,
    /**
     * Introductory greeting on extension level
     * @type Number
     */
    Introductory : 2,
    /**
     * MusicOnHold
     * @type Number
     */
    MOH : 3,
    /**
     * Announcement greeting  : in accouncements-only mode)
     * @type Number
     */
    Announcement : 4,
    /**
     * Unavailable greeting
     * @type Number
     */
    Unavailable : 5,
    /**
     * TextToSpeech generated  : from First and Last Names) greeting
     * @type Number
     */
    VoiceName : 6,
    /**
     * Interrupt prompt
     * @type Number
     */
    InterruptPrompt : 7,
    /**
     * Fax On Demand prompt
     * @type Number
     */
    FaxOnDemand : 8,
    /**
     * Call Screaning greeting
     * @type Number
     */
    CallScreening : 9,
    /**
     * Agent Queue Keep Waiting message
     * @type Number
     */
    AQKeepWaiting : 11,
    /**
     * Connect prompt
     * @type Number
     */
    ConnectPrompt : 13,
    /**
     * @type Number
     */
    CallRecOnDemandStart : 14,
    /**
     * @type Number
     */
    CallRecOnDemandStop : 15,
    /**
     * @type Number
     */
    CallRecAutoStart : 16,
    /**
     * @type Number
     */
    RingTo : 17
};

/**
 * The types of rule
 *
 * @class
 * @name Wrapper.Enums.DNDStatus
 */
Wrapper.Enums.DNDStatus = {
    /**
     * @type String
     */
    TakeAllCalls : "TakeAllCalls",
    /**
     * @type String
     */
    DoNotAcceptDepartmentCalls : "DoNotAcceptDepartmentCalls",
    /**
     * @type String
     */
    TakeDepartmentCallsOnly : "TakeDepartmentCallsOnly",
    /**
     * @type String
     */
    DoNotAcceptAnyCalls : "DoNotAcceptAnyCalls"
};

/**
 * The status codes of billing transaction
 *
 * @class
 * @name Wrapper.Enums.StatusCode
 */
Wrapper.Enums.StatusCode = {

    /**
     * Everything is OK
     */
    Success : 0,
    /**
     * Code 7 means the same
     */
    Declined : 3,
    /**
     * The same as code 3. It is not used by BS now
     */
    DeclinedObsolete : 7,
    /**
     * Internal BS error
     */
    Error : 9,
    /**
     * It was used earlier. Now, codes 12 and 13 are used instead
     */
    Declined_CVV2_AVS : 11,
    /**
     * CVV2 verification failed
     */
    Declined_CVV2 : 12,
    /**
     * AVS verification failed
     */
    Declined_AVS : 13,
    /**
     * CC is in the black list
     */
    Declined_Blacklist : 14,
    /**
     * Too many accounts with this CC
     */
    Declined_TooManyAccounts : 15,
    /**
     * Contact phone # ZIP isn't the same as CC ZIP
     */
    Declined_DifferentCCAndPhoneZIP : 16,
    /**
     * CC should be verified
     */
    Declined_ShouldBeVerified : 17,
    /**
     * CC declined. CC # trying attempts
     */
    Declined_TooManyNumberAttempts : 18,
    /**
     * CC declined. Address or ZIP trying attempts
     */
    Declined_TooManyAddressOrZIPAttempts : 19,
    /**
     * CC declined. RC rules disallow creating a new transaction
     */
    Declined_TransactionBlocked : 20,
    /**
     * Too many transactions with this CC
     */
    Declined_TooManyTransactions : 21,
    /**
     * Amount Limit has been reached
     */
    Declined_AmountLimitReached : 22,
    /**
     * New CC exists in the system but with different CC info
     */
    Declined_NewCCWithDifferentInfoExists : 23,
    /**
     * Too many mailbox purchases during the month
     */
    Failed_TooManyMailboxPurchasesInMonth : 24,
    /**
     * Too many additional number purchases during the month
     */
    Failed_TooManyNumberPurchasesInMonth : 25,

    /**
     * No free threads on billing server
     */
    Failed_NoFreeThreads : 100,

    /**
     * Custom error codes  : not generated by the billing server)<br/>
     * Invalid referral code
     */
    Failed_InvalidReferralCode : 1001,
    /**
     * Custom error codes  : not generated by the billing server)<br/>
     * Too many accounts per brand per CC - generated by
     * FraudEvaluationBillingCheck before passing to BS
     */
    Failed_TooManyAccountsPerBrandPerCC : 1002

};

/**
 * The types of phone number
 *
 * @class
 * @name Wrapper.Enums.PhoneType
 */
Wrapper.Enums.PhoneType = {

    /**
     * Voice & Fax
     */
    VoiceFax : 2,
    /**
     * Dedicated Fax
     */
    DedicatedFax : 3,
    /**
     * Fax Only
     */
    FaxOnly : 4,
    /**
     * Voice Only
     */
    VoiceOnly : 5,
    /**
     * Additional Company
     */
    AdditionalCompany : 6

};

/**
 * The types of message
 *
 * @class
 * @name Wrapper.Enums.MessageType
 */
Wrapper.Enums.MessageType = {
    messageEMail : 0,
    messageVoice : 1,
    messageFax : 2,
    messageText : 3
};

/**
 * Marketing message types
 *
 * @class
 * @name Wrapper.Enums.MarketingMessageType
 */
Wrapper.Enums.MarketingMessageType = {
    ExistingMarketingMessage: 1,
    LeaderBoard: 2,
    PostLoginBlocker: 3
};


RC.ns("Wrapper.Models");

/**
 * Provides structure of short information about rule in the list
 *
 * @class
 * @name Wrapper.Models.AnsweringRuleListInfo
 * @member RC apply
 */
Wrapper.Models.AnsweringRuleListInfo = function()
{

};

Wrapper.Models.AnsweringRuleListInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    AnsweringRuleListInfo : function()
    {

    },
    /**
     * The id of the rule. If After Hours rule is not exist it will have "0" value.
     * @type Number
     * @property id
     */
    id : null,
    /**
     * The name of the rule
     * @type String
     * @property name
     */
    name : null,
    /**
     * Enum:
     * <ul>
     *      <li><b>BusinessHours</b> : Business hours rule</li>
     *      <li><b>MailboxDefault</b> : After hours rule</li>
     *      <li><b>Mailbox</b> : Custom rule</li>
     * </ul>
     * @type AnsweringRuleType
     * @property type
     */
    type : null,
    /**
     * Enum:
     * <ul>
     *      <li><b>Inactive</b></li>
     *      <li><b>Active</b></li>
     *      <li><b>Disabled</b></li>
     * </ul>
     * @type AnswerRuleStatus
     * @property status
     */
    status : null,
    /**
     * Enum:
     * <ul>
     *      <li><b>Inactive</b></li>
     *      <li><b>Active</b></li>
     *      <li><b>Disabled</b></li>
     * </ul>
     * @type AnswerIntervalType
     * @property intervalType
     */
    intervalType : null,
    /**
     * Will be <tt>true</tt> if rule is agent profile
     * @type Boolean
     * @property agentProfileRule
     */
    agentProfileRule : false
};

/**
 * @class
 * @name Wrapper.Models.AnsweringRuleInfo
 * Provides structure of information about rule
 * @member RC apply
 */
Wrapper.Models.AnsweringRuleInfo = function()
{

};

Wrapper.Models.AnsweringRuleInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    AnsweringRuleInfo : function()
    {

    },

    /**
     * @type Number
     */
    id : null,

    /**
     * @type Number
     */
    sourceRuleId : null,
    /**
     * @type String
     */
    ruleName : "My Rule X",
    /**
     * @type AnswerRuleStatus
     */
    status : null,
    /**
     * shouldn't be used during safe. Only info object
     * @type AnsweringRuleType
     */
    ruleType : "Mailbox",
    /**
     * The list of AnsweringRuleInterval
     * @type Array
     */
    intervals : [],
    /**
     * The list of ForwardPhoneInfo
     * @type Array
     */
    phones : [],
    /**
     * @type AnsweringOption
     */
    answering : null,
    /**
     * @type ReceiveSetting
     */
    receiveSetting : null,
    /**
     * @type PhoneReadOrder
     */
    readPhoneOrder : null,// aka enum PhoneReadOrder
    /**
     * @type AgentNotifyType
     */
    agentNotify : null,
    /**
     * @type CallerOption
     */
    callerPrompt : null,

    /**
     * @type Number
     */
    ringDelay : null,

    /**
     * @type Number
     */
    toMailboxId : null,
    /**
     * @type String
     */
    toMailboxName : null,
    /**
     * @type String
     */
    toMailboxPin : null,

    /**
     * shouldn't be used during save. Only info object
     * @todo remove after rules re-factoring
     * @type Object
     */
    extension : {
        id : null,
        name : null,
        pin : null
    },

    /**
     * shouldn't be used during save. Only info object
     * @todo remove after rules re-factoring
     * @type Object
     */
    extension : {
        id : null,
        name : null,
        pin : null
    },

    /**
     * @type Object
     */
    ownerExtension : {
        id : null,
        name : null,
        pin : null
    },

    /**
     * @type Boolean
     */
    isMaster : false,
    /**
     * @type MasterMenuAction
     */
    masterMenuAction : null,
    /**
     * @type Number
     */
    interruptSeconds : null,
    /**
     * @type Number
     */
    agentWaitTime : null,
    /**
     * @type Number
     */
    wrapUpTime : null,
    /**
     * @type Number
     */
    maxCallers : null,
    /**
     * @type Number
     */
    maxCallersVM : null,
    /**
     * The list of QueueAgentInfo
     * @type Array
     */
    agents : [],
    /**
     * @type Boolean
     */
    agentUnavailable : false,
    /**
     * @type Number
     */
    voiceMailTime : null,
    /**
     * @type Number
     */
    askToSkipToVMInterval : null,
    /**
     * The list of AnsweringRuleCaller
     * @type Array
     */
    callers : [],
    /**
     * The list of CalledNumberInfo
     * @type Array
     */
    calledNumbers : [],
    /**
     * @type String
     */
    ringToPhone : null,
    /**
     * Should be <tt>ReadPhoneOrder</tt> by default
     * @type CallForwardingType
     */
    callForwardingType : "ReadPhoneOrder",

    /**
     * is using only for custom rule
     * and only for non-advanced user
     * for advanced user it will be CUSTOM always
     * @type AnswerIntervalType
     */
    intervalType : 'Custom',

    /**
     * @type PresetGreetingType
     */
    voicemailGreetingPreset : null,
    /**
     * @type Number
     */
    voicemailGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    introductoryGreetingPreset : null,
    /**
     * @type Number
     */
    introductoryGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    mohGreetingPreset : null,
    /**
     * @type Number
     */
    mohGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    announcementGreetingPreset : null,
    /**
     * @type Number
     */
    announcementGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    unavailableGreetingPreset : null,
    /**
     * @type Number
     */
    unavailableGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    interruptPromptPreset : null,
    /**
     * @type Number
     */
    interruptPromptCustomId : null,

    /**
     * @type PresetGreetingType
     */
    connectPromptPreset : null,
    /**
     * @type Number
     */
    connectPromptCustomId : null,

    /**
     * @type PresetGreetingType
     */
    askToSkipToVMPromptPreset : null,
    /**
     * @type Number
     */
    askToSkipToVMPromptCustomId : null,

    /**
     * @type PresetGreetingType
     */
    callScreeningGreetingPreset : null,
    /**
     * @type Number
     */
    callScreeningGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    faxOnDemandGreetingPreset : null,
    /**
     * @type Number
     */
    faxOnDemandGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    companyGreetingPreset : null,
    /**
     * @type Number
     */
    companyGreetingCustomId : null,

    /**
     * @type PresetGreetingType
     */
    ringToGreetingPreset : null,
    /**
     * @type Number
     */
    ringToGreetingCustomId : null
};

/**
 * @class
 * @name Wrapper.Models.RequestStatus
 * This is a status of a method execution.
 */
Wrapper.Models.RequestStatus = function(success, code, message)
{
};

Wrapper.Models.RequestStatus.prototype = {
    /**
     * Creates a new object
     * @constructor
     * @param {Boolean} success Represents a status of a method execution, true in case a method execution was successful, false otherwise.
     * @param {Number} code Contains a code of an error in case of success == false, and 0 in case success == true.
     * @param {String} message Contains an error message in case of success == false, and null in case success == true.
     */
    RequestStatus : function(success, code, message)
    {

    },
    /**
     * Represents a status of a method execution, true in case a method execution was successful, false otherwise.
     * @type Boolean
     */
    success : true,
    /**
     * Contains an error message in case of success == false, and null in case success == true.
     * @type Number
     */
    code : 0,
    /**
     * Contains an error message in case of success == false, and null in case success == true.
     * @type String
     */
    message : null
};

/**
 * @class
 * @name Wrapper.Models.MarketingMessageInfo
 * Provides structure of information about marketing message
 * @member RC apply
 */
Wrapper.Models.MarketingMessageInfo = function()
{

};

Wrapper.Models.MarketingMessageInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    MarketingMessageInfo : function()
    {

    },
    marketingMessageId: null,
    htmlContent: null,
    /**
     * @type Wrapper.Enums.MarketingMessageType
     */
    messageType: null,
    link: null
};

/**
 * @class
 * @name Wrapper.Models.CellProviderInfo
 * Provides structure of information about cell provider
 * @member RC apply
 */
Wrapper.Models.CellProviderInfo = function()
{

};

Wrapper.Models.CellProviderInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    CellProviderInfo : function()
    {

    },
    id : null,
    name : null,
    domain : null,
    countryId : null,
    numberFormat : null,
    forwardActivate : null,
    digitsNumber : null,
    forwardDeactivate : null

};

/**
 * @class
 * @name Wrapper.Models.ParsedNumber
 * Provides structure of parsed number object
 * @member RC apply
 */
Wrapper.Models.ParsedNumber = function()
{

};

Wrapper.Models.ParsedNumber.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    ParsedNumber : function()
    {

    },
    /**
     * The number in local format. For example: (866) 555-22-33.
     * @type String
     */
    localCanonical : null,
    /**
     * The code of number's country.
     * @type String
     */
    countryCode : null,
    /**
     * Number's area code.
     * @type String
     */
    areaCode : null,
    /**
     * The number without country and area codes.
     * @type String
     */
    number : null,
    /**
     * Full phone number in numeric format.
     * @type String
     */
    numRow : null
};

/**
 * @class
 * @name Wrapper.Models.ForwardedNumberInfo
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.ForwardedNumberInfo = function()
{

};
Wrapper.Models.ForwardedNumberInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    ForwardedNumberInfo : function()
    {
    },
    /**
     * Id of provider.
     * @type Number
     */
    cellProviderId : null,
    /**
     * Phone number.
     * @type String
     */
    number         : null,
    /**
     * Id of mapped mailbox.
     * @type Number
     */
    mappedMailboxId : null
};

/**
 * @class
 * @name Wrapper.Models.PhoneNumber
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.PhoneNumber = function()
{

};

Wrapper.Models.PhoneNumber.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    PhoneNumber : function()
    {
    },
    /**
     * Phone number.
     * @type String
     */
    number : null,
    /**
     * Local canonical number, whatever it means.
     * @type String
     */
    formattedNumber : null,
    /**
     * Phone address name.
     * @type String
     */
    name : null,
    /**
     * If the number is not in the original area but in a neighbour one.
     * @type Boolean
     */
    alternate : null
};

/**
 * @class
 * @name Wrapper.Models.MailboxInfo
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.MailboxInfo = function()
{

};

Wrapper.Models.MailboxInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    MailboxInfo : function()
    {
    },

    /**
     * Readonly. Mailbox (extension) type - not editable.
     * @type ExtensionType
     */
    type : "User",

    /**
     * @type String
     */
    pin : null,
    /**
     * @type String
     */
    firstName : null,
    /**
     * @type String
     */
    email : null,
    /**
     * Map<PhoneAddressType, String>
     * @type Object
     */
    phoneAddresses : {},
    /**
     * Optional. The title like Mr., Ms. etc.
     * @type String
     */
    prefix : null,
    /**
     * Optional.
     * @type String
     */
    lastName : null,
    /**
     * Optional.
     * @type String
     */
    companyName : null,
    /**
     * Optional.
     * @type String
     */
    password : null,
    /**
     * Optional.
     * @type MailboxState
     */
    mailboxState : null,
    /**
     * Optional.
     * @type SecretRequest
     */
    secretRequest : {},
    /**
     * Optional. Normal, Queue or Agent.
     * @type QueueState
     */
    queueState : null,
    /**
     * Optional. Admin, User, View
     * @type AccessLevel
     */
    accessLevel : null,
    /**
     * Optional. The flag allows to include this extension in company directory.
     * @type Boolean
     */
    includeInCompany : false,
    /**
     * Optional.
     * @type TimeZoneInfo
     */
    timeZone : {},
    /**
     * Optional. Not usinging anymore
     * @type QueuePriorities
     * @deprecated
     */
    queuePriority : null,
    /**
     * Optional. The type of compression for voicemail audio files (MP3 / WAV).
     * @type CompressionType
     */
    compressionType : "MP3",
    /**
     * Pronounce name which will be used by TTS. Equals to First Name and Last Name by default.
     * @type String
     */
    voiceName : null,
    /**
     * The state of account which indicate passed setup wizard.
     * @type SetupWizardState
     */
    setupWizardState : "Completed",

    /**
     * Post address information
     * @type PostAddressInfo
     */
    address : {},

    /**
     * Caller ID
     * @type CallerIDInfo[]
     */
    callerIds : [],

    /**
     * List of available permissions.
     * The instance of {@link Wrapper.Models.ExtensionPermissions}.
     * @type ExtensionPermissions
     */
    permissions : {},

    /**
     * Uses for response. The flag of system extension.
     * @type Boolean
     */
    systemMailbox : false,
    /**
     * Uses for response. The flag of operator extension.
     * @type Boolean
     */
    operatorMailbox : false,
    /**
     * The status of agent (Online, Offline)
     * @type AgentStatus
     */
    agentStatus : "Online"
};

/**
 * @class
 * @name Wrapper.Models.ExtensionPermissions
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.ExtensionPermissions = function()
{

};

Wrapper.Models.ExtensionPermissions.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    ExtensionPermissions : function()
    {
    },
    /**
     * @type Boolean
     */
    admin : false,
    /**
     * @type Boolean
     */
    viewExtensionsEnabled : false,
    /**
     * @type Boolean
     */
    internationalEnabled : false,
    /**
     * @type Boolean
     */
    ringOutEnabled : false,
    /**
     * @type Boolean
     */
    ringMeEnabled : false,
    /**
     * @type Boolean
     */
    sendFaxEnabled : false,
    /**
     * @type Boolean
     */
    callerIdEnabled : false,
    /**
     * @type Boolean
     */
    alterAgentProfileEnabled : false,
    /**
     * @type Boolean
     */
    regionalSettingsEnabled : false
};

/**
 * @class
 * @name Wrapper.Models.ExtensionInfo
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.ExtensionInfo = function()
{

};

Wrapper.Models.ExtensionInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    ExtensionInfo : function()
    {
    },
    /**
     * @type Number
     */
    id : null,
    /**
     * @type String
     */
    firstName : null,
    /**
     * @type String
     */
    lastName : null,
    /**
     * @type String
     */
    pin : null,
    /**
     * @type ExtensionType
     */
    type : null,
    /**
     * @type String
     */
    email : null,
    /**
     * @type Number
     */
    toMailbox : null,
    /**
     * @type Boolean
     */
    includedInCD : null,
    /**
     * @type Boolean
     */
    admin : null,
    /**
     * @type Boolean
     */
    system : null,
    /**
     * @type Wrapper.Models.AgentInfo[]
     */
    agents : null,
    /**
     * @type QueueState
     */
    queueState : null,
    /**
     * @type String
     */
    contactNumber : null,
    /**
     * @type String
     */
    formattedContactNumber : null,
    /**
     * @type String
     */
    companyName : null
};

/**
 * @class
 * @name Wrapper.Models.AgentInfo
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.AgentInfo = function()
{

};

Wrapper.Models.AgentInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    AgentInfo : function()
    {
    },
    /**
     * @type Number
     */
    id : null,
    /**
     * @type AgentStatus
     */
    agentStatus : null
};

/**
 * @class
 * @name Wrapper.Models.SoftwareVersionInfo
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.SoftwareVersionInfo = function()
{

};

Wrapper.Models.SoftwareVersionInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    SoftwareVersionInfo : function()
    {
    },
    /**
     * @type Number
     */
    edition : null,
    /**
     * @type String
     */
    lastVersion : null,
    /**
     * @type String
     */
    url : null,
    /**
     * @type Date
     */
    releaseDate : new Date()
};

/**
 * @class
 * @name Wrapper.Models.UserInfo
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.UserInfo = function()
{

};

Wrapper.Models.UserInfo.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    UserInfo : function()
    {
    },
    /**
     * @type Number
     */
    tierId : null,
    /**
     * @type Number
     */
    privilegeId : null,
    /**
     * @type Number
     */
    targetTierId : null,
    /**
     * The id of operator extension.
     * @type Number
     */
    operatorMailboxId : null,
    /**
     * Indicates single ext mode.
     * @type Boolean
     */
    multiExtensionMode : null,
    /**
     * @type Number
     */
    shippingMethodId : null,
    /**
     * @type Boolean
     */
    readCompleteList : null,
    /**
     * @type Number
     */
    letterNumber : null,
    /**
     * @type String
     */
    directoryExtension : null,
    /**
     * @type DirSearchType
     */
    dirSearchType : null,
    /**
     *@type DirStartSearchType
     */
    dirStartSearchType : null,
    /**
     * @type Boolean
     */
    directoryOn : null,
    /**
     * @type Boolean
     */
    includeExtensionsInDirectory : null,
    /**
     * Setup (initial configuration) wizard state
     * @type SetupWizardState
     */
    setupWizardState : null,
    /**
     * @type String
     */
    cnamName : null,
    /**
     * @type Boolean
     */
    cnamSupported : null,
    /**
     * @type Number
     */
    serviceVersion : null,
    /**
     * Enum: UserBased, Regular
     * @type TierType
     */
    tierType : null,

    /**
     * The flag of enabled international calling option.
     * @type Boolean
     */
    internationalCalling : null,

    /**
     * The flag of enabled call recording option.
     * @type Boolean
     */
    onDemandCallRecordingEnabled : null,

    /**
     * UI depends on these parameters (e.g. new/old users, avanced/simple view)
     * @type UserWebOptions
     */
    webOptions : null,
    /**
     * User identity validation option.
     * @type Boolean
     */
    identityValidation : null
};


/**
 * @class
 * @name Wrapper.Models.UserInfo
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.PhoneOrder = function()
{

};

Wrapper.Models.PhoneOrder.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    PhoneOrder : function()
    {
    },

    /**
     * Order items - phones with or without lines & numbers
     * @type Array
     */
    orderItems : [],

    /**
     * Shipping address for this order
     * @type PostAddressInfo
     */
    shippingAddress : {},

    /**
     * Requested order delivery method
     * @type ShippingMethodInfo
     */
    shippingMethod : {}
};

/**
 * @class
 * @name Wrapper.Models.ExtensionPermissions
 * Provides structure of object
 * @member RC apply
 */
Wrapper.Models.ExtensionPermissions = function()
{

};

Wrapper.Models.ExtensionPermissions.prototype = {
    /**
     * Creates a new object
     * @constructor
     */
    ExtensionPermissions : function()
    {
    },
    /**
     * @type Boolean
     */
    admin : false,
    /**
     * @type Boolean
     */
    viewExtensionsEnabled : false,
    /**
     * @type Boolean
     */
    internationalEnabled : false,
    /**
     * @type Boolean
     */
    ringOutEnabled : false,
    /**
     * @type Boolean
     */
    ringMeEnabled : false,
    /**
     * @type Boolean
     */
    sendFaxEnabled : false,
    /**
     * @type Boolean
     */
    callerIdEnabled : false,
    /**
     * @type Boolean
     */
    alterAgentProfileEnabled : false,
    /**
     * @type Boolean
     */
    regionalSettingsEnabled : false
};


/*jslint */
/*global RC, Wrapper */

RC.ns("Wrapper.Requests");

/**
 * This is a basic request for all methods which operates with mailbox id.
 *
 * @class
 * @name Wrapper.Requests.MailboxRequest
 */
Wrapper.Requests.MailboxRequest = function (mid) {
    this.mid = mid;
};

Wrapper.Requests.MailboxRequest.prototype = {
    /**
     * Creates a new MailboxRequest object
     * @param {Number} mid Extension's id
     */
    MailboxRequest : function(mid)
    {
        this.mid = mid;
    },
    /**
     * Id of extension
     * @type {Number}
     * @property mid
     */
    mid : this.mid,

    /**
     * Serialize object
     * @return {Object} object
     */
    serialize : function()
    {
        var params = {};
        for (var i in this) {
            if (!RC.isFunc(this[i])) {
                params[i] = this[i];
            }
        }
        return params;
    }
};

/**
 * Creates a new ListGreetingsRequest object
 * Uses by {@link Wrapper.Rules#listGreetings}, {@link Wrapper.Rules#getGreeting}
 *
 * @class
 * @name Wrapper.Requests.GreetingsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid Extension's id
 */
Wrapper.Requests.GreetingsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        /**
         * The type of the greeting.
         * @type {Wrapper.Enums.GreetingType}
         */
        this.gType = null;
        /**
         * The type of the rule. Use it if you don't know rule id.
         * @type {Wrapper.Enums.AnsweringRuleType}
         */
        this.rType = null;
        /**
         * The id of the rule in which greeting will be placed.
         * @type {Number}
         */
        this.ruleId = null;
        /**
         * The name of the greeting.
         * @type {String}
         */
        this.name = null;
        /**
         * The id of the greeting.
         * @type {Number}
         */
        this.gid = null;

        Wrapper.Requests.GreetingsRequest.superclass.constructor.call(this, mid, status);
    }
});

/**
 * Creates a new SetAgentProfileRequest object
 * Uses by {@link Wrapper.Rules#setAgentProfile}
 *
 * @class
 * @name Wrapper.Requests.SetAgentProfileRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Array} phones List of ForwardPhoneInfo
 * @param {Boolean} enabled
 */
Wrapper.Requests.SetAgentProfileRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, phones, enabled)
    {
        /**
         * List of ForwardPhoneInfo
         * @type Array
         */
        this.phones = phones;

        /**
         * @type Boolean
         */
        this.enabled = enabled;

        Wrapper.Requests.SetAgentProfileRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new SetTollFreeMinutesBundles object
 * Uses by {@link Wrapper.Billing#setTollFreeMinuteBundles}
 *
 * @class
 * @name Wrapper.Requests.SetTollFreeMinuteBundleRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Integer} tollFreeBundleId
 */
Wrapper.Requests.SetTollFreeMinuteBundleRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(tollFreeBundleId)
    {
        /**
         * @type Integer
         */
        this.tollFreeBundleId = tollFreeBundleId;

        Wrapper.Requests.SetTollFreeMinuteBundleRequest.superclass.constructor.call(this);
    }
});

/**
 * Creates a new GetProvisioningInfoRequest object
 * Uses by {@link Wrapper.DigitalLine#GetProvisioningInfoRequest}
 *
 * @class
 * @name Wrapper.Requests.GetProvisioningInfoRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Integer} instanceId
 */
Wrapper.Requests.GetProvisioningInfoRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(instanceId)
    {
        /**
         * @type Integer
         */
        this.instanceId = instanceId;

        Wrapper.Requests.GetProvisioningInfoRequest.superclass.constructor.call(this);
    }
});

/**
 * Creates a new InstanceRequest object
 * Uses by {@link Wrapper.DigitalLine#getPagingDeviceAssignedExtensions}
 *
 * @class
 * @name Wrapper.Requests.InstanceRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Integer} instanceId
 */
Wrapper.Requests.InstanceRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(instanceId)
    {
        /**
         * @type Integer
         */
        this.instanceId = instanceId;

        Wrapper.Requests.InstanceRequest.superclass.constructor.call(this);
    }
});

/**
 * Creates a new GetStatementForTollFreeBundlePurchase object
 * Uses by {@link Wrapper.Billing#setStatementForTollFreeBundlePurchase}
 *
 * @class
 * @name Wrapper.Requests.GetStatementForTollFreeBundlePurchase
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {String} tollFreeBundle
 */
Wrapper.Requests.GetStatementForTollFreeBundlePurchase = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(tollFreeBundle)
    {
        /**
         * @type String
         */
        this.tollFreeBundle = tollFreeBundle;

        Wrapper.Requests.GetStatementForTollFreeBundlePurchase.superclass.constructor.call(this);
    }
});

/**
 * Creates a new GetStatementForInternationalBundlePurchase object.
 *
 * @class
 * @name Wrapper.Requests.GetStatementForInternationalBundlePurchase
 * @extends Wrapper.Requests.MailboxRequest
 */
Wrapper.Requests.GetStatementForInternationalBundlePurchase = RC.extend(Wrapper.Requests.MailboxRequest, {

    /**
     * @public
     * @function
     * @name Wrapper.Requests.GetStatementForInternationalBundlePurchase#constructor
     * @param {Number} internationalBundle
     * @return {void}
     */
    constructor : function(internationalBundle)
    {
        /**
         * @public
         * @field
         * @name Wrapper.Requests.GetStatementForInternationalBundlePurchase#internationalBundle
         * @type {String}
         */
        this.internationalBundle = internationalBundle;
        Wrapper.Requests.GetStatementForInternationalBundlePurchase.superclass.constructor.call(this);
    }
});

/**
 * Creates a new AnsweringRuleRequest object
 * Uses by {@link Wrapper.Rules#getCustomRule}
 *
 * @class
 * @name Wrapper.Requests.AnsweringRuleRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} rid
 */
Wrapper.Requests.AnsweringRuleRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, rid)
    {
        /**
         * The id of the rule.
         * @type Number
         */
        this.rid = rid;

        Wrapper.Requests.AnsweringRuleRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new AnsweringRuleInfoRequest object
 * Uses by {@link Wrapper.Rules#setCustomRule}
 *
 * @class
 * @name Wrapper.Requests.AnsweringRuleInfoRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Wrapper.Models.AnsweringRuleInfo} ruleInfo The instance of {@link Wrapper.Models.AnsweringRuleInfo}
 */
Wrapper.Requests.AnsweringRuleInfoRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, ruleInfo)
    {
        /**
         * The instance of {@link Wrapper.Models.AnsweringRuleInfo}
         * @type Wrapper.Models.AnsweringRuleInfo
         */
        this.ruleInfo = ruleInfo;

        Wrapper.Requests.AnsweringRuleInfoRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new DNDStatusRequest object
 * Uses by {@link Wrapper.Rules#setDNDStatus}
 *
 * @class
 * @name Wrapper.Requests.DNDStatusRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Wrapper.Enums.DNDStatus} dndStatus
 */
Wrapper.Requests.DNDStatusRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, dndStatus)
    {
        /**
         * The status of extension. See {@link Wrapper.Enums.DNDStatus} for details.
         * @type Wrapper.Enums.DNDStatus
         */
        this.dndStatus = dndStatus;

        Wrapper.Requests.DNDStatusRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new MakeClickToCallbackCallRequest object
 * Uses by {@link Wrapper.System#makeClickToCallbackCall}
 *
 * @class
 * @name Wrapper.Requests.MakeClickToCallbackCallRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {String} number
 * @param {Wrapper.Enums.GreetingType} greetingType
 * @param {Number} answeringRuleId
 *
 */
Wrapper.Requests.MakeClickToCallbackCallRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, number, greetingType, answeringRuleId)
    {
        /**
         * @type String
         */
        this.number = number;
        /**
         * @type Wrapper.Enums.GreetingType
         */
        this.greetingType = greetingType;
        /**
         * @type Number
         */
        this.answeringRuleId = answeringRuleId;

        Wrapper.Requests.MakeClickToCallbackCallRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new SavePortedNumberAttachmentInfoRequest object
 * Uses by {@link Wrapper.Extensions#savePortedNumberAttachmentInfo}
 *
 * @class
 * @name Wrapper.Requests.SavePortedNumberAttachmentInfoRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} forwardedNumberId
 * @param {Object} portedNumberAttachment
 */
Wrapper.Requests.SavePortedNumberAttachmentInfoRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(forwardedNumberId, portedNumberAttachment)
    {
        /**
         * @type Number
         */
        this.forwardedNumberId = forwardedNumberId;

        /**
         * @type Object
         */
        this.portedNumberAttachment = portedNumberAttachment;

        Wrapper.Requests.SavePortedNumberAttachmentInfoRequest.superclass.constructor.call(this);
    }
});


/**
 * Creates a new SavePortedOrderAttachmentInfoRequest object
 * Uses by {@link Wrapper.Extensions#savePortedOrderAttachmentInfo}
 *
 * @class
 * @name Wrapper.Requests.SavePortedOrderAttachmentInfoRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} orderId
 * @param {Object} portedNumberAttachment
 * @param {Boolean} isSupportedSupplementalOrder
 * @param {String} desiredDueDate
 */
Wrapper.Requests.SavePortedOrderAttachmentInfoRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(orderId, portedNumberAttachment, isSupportedSupplementalOrder, desiredDueDate)
    {
        /**
         * @type Number
         */
        this.orderId = orderId;

        /**
         * @type Object
         */
        this.portedNumberAttachment = portedNumberAttachment;
        RC.isDefined(isSupportedSupplementalOrder) && (this.isSupportedSupplementalOrder = isSupportedSupplementalOrder);
        RC.isDefined(desiredDueDate) && (this.desiredDueDate = desiredDueDate);

        Wrapper.Requests.SavePortedOrderAttachmentInfoRequest.superclass.constructor.call(this);
    }
});

/**
 * Creates a new AvailableNumbersTypesRequest object
 * Uses by {@link Wrapper.Extensions#getAvailableNumbersTypes}
 *
 * @class
 * @name Wrapper.Requests.AvailableNumbersTypesRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {String} phoneNumberActionType
 * @param {Number} phoneNumberActionType
 */
Wrapper.Requests.AvailableNumbersTypesRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(phoneNumberActionType, mailboxId)
    {
        /**
         * @type String
         */
        this.phoneNumberActionType = phoneNumberActionType;

        /**
         * @type Number
         */
        this.mailboxId = mailboxId;

        Wrapper.Requests.AvailableNumbersTypesRequest.superclass.constructor.call(this);
    }
});

/**
 * Creates a new SetExtensionRequest object
 * Uses by {@link Wrapper.Extensions#setExtension}
 *
 * @class
 * @name Wrapper.Requests.SetExtensionRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.SetExtensionRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        /**
         * @type String
         */
        this.firstName = null;
        /**
         * @type String
         */
        this.lastName = null;
        /**
         * @type String
         */
        this.companyName = null;
        /**
         * @type String
         */
        this.email = null;
        /**
         * @type Number
         */
        this.pin = null;
        /**
         * @type Number
         */
        this.password = null;
        /**
         * @type Boolean
         */
        this.includedInCD = null;
        /**
         * Uses only for system extension. For others it can be null.
         * @type String
         */
        this.contactNumber = null;
        /**
         * @type String
         */
        this.tz = null;
        /**
         * @type Number
         */
        this.tzid = null;
        /**
         * @type String
         */
        this.bias = null;
        /**
         * @type String
         */
        this.secretAnswer = null;
        /**
         * @type Number
         */
        this.secretQuestionId = null;
        /**
         * The array of agent's ids.
         * @type Number[]
         */
        this.agents = null;

        Wrapper.Requests.SetExtensionRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new SetExtensionPermissionsRequest object
 * Uses by {@link Wrapper.Extensions#setExtensionPermissions}
 *
 * @class
 * @name Wrapper.Requests.SetExtensionPermissionsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.SetExtensionPermissionsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, permissions)
    {
        /**
         * The instance of {@link Wrapper.Models.ExtensionPermissions}
         * @type Wrapper.Models.ExtensionPermissions
         */
        this.permissions = permissions;

        Wrapper.Requests.SetExtensionPermissionsRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#listExtensions}
 *
 * @class
 * @name Wrapper.Requests.ListExtensionsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Wrapper.Models.ExtensionType} type
 */
Wrapper.Requests.ListExtensionsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, type)
    {
        /**
         * @type Wrapper.Models.ExtensionType
         */
        this.type = type;

        Wrapper.Requests.ListExtensionsRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#listExtensions}
 *
 * @class
 * @name Wrapper.Requests.SoftwareVersionRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} OSType
 */
Wrapper.Requests.SoftwareVersionRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, OSType)
    {
        /**
         * @type Number
         */
        this.OSType = OSType;

        Wrapper.Requests.SoftwareVersionRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getAccountNumber}
 *
 * @class
 * @name Wrapper.Requests.GetAccountNumberRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {String} type
 */
Wrapper.Requests.GetAccountNumberRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, type)
    {
        /**
         * Could be: MainNumber, AdditionalCompany, DedicatedFax, DigitalLine,
         * DirectLine, MappedToMailbox, Forwarded, Standalone
         * @type String
         */
        this.type = type;

        Wrapper.Requests.GetAccountNumberRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#setPhoneNumber}
 *
 * @class
 * @name Wrapper.Requests.SetPhoneNumberRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} phoneId
 * @param {String} ringType
 * @param {Number} toMailbox
 * @param {String} phoneType
 */
Wrapper.Requests.SetPhoneNumberRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, phoneId, ringType, toMailbox, phoneType)
    {
        this.phoneId = phoneId;
        this.ringType = ringType;
        this.toMailbox = toMailbox || 0;
        this.phoneType = phoneType || null;
        Wrapper.Requests.SetPhoneNumberRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#deletePhoneNumber}
 *
 * @class
 * @name Wrapper.Requests.DeletePhoneNumberRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.DeletePhoneNumberRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.DeletePhoneNumberRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#setNotifications}
 *
 * @class
 * @name Wrapper.Requests.SetNotificationsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.SetNotificationsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.SetNotificationsRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#isNumberAdditionAllowed}
 *
 * @class
 * @name Wrapper.Requests.IsNumberAdditionAllowed
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {String} type
 * @param {Number} calculatedNumbersCount
 */
Wrapper.Requests.IsNumberAdditionAllowed = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(type, calculatedNumbersCount)
    {
        /**
         * @type String
         */
        this.type = type;

        /**
         * @type Number
         */
        this.calculatedNumbersCount = calculatedNumbersCount;

        Wrapper.Requests.IsNumberAdditionAllowed.superclass.constructor.call(this);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#resetPassword}
 *
 * @class
 * @name Wrapper.Requests.ResetPasswordRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.ResetPasswordRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.ResetPasswordRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#setBlockedNumbers}
 *
 * @class
 * @name Wrapper.Requests.BlockedNumbersRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.BlockedNumbersRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.BlockedNumbersRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#setCallerIdName}
 *
 * @class
 * @name Wrapper.Requests.CallerIdNameRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.CallerIdNameRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.CallerIdNameRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#setDialByNameSettings}
 *
 * @class
 * @name Wrapper.Requests.DialByNameSettingsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.DialByNameSettingsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.DialByNameSettingsRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#setCallRecording}
 *
 * @class
 * @name Wrapper.Requests.CallRecordingRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Boolean} enabled
 */
Wrapper.Requests.CallRecordingRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, enabled)
    {
        /**
         * @type Boolean
         */
        this.enabled = enabled;

        Wrapper.Requests.CallRecordingRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#setExtensionsByPermission}
 *
 * @class
 * @name Wrapper.Requests.ExtensionsByPermissionRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.ExtensionsByPermissionRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.ExtensionsByPermissionRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getExtensionsByPermission}
 *
 * @class
 * @name Wrapper.Requests.GetExtensionsByPermissionRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.GetExtensionsByPermissionRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.GetExtensionsByPermissionRequest.superclass.constructor.call(this, mid);
    }
});


/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#listShippingOptions}
 *
 * @class
 * @name Wrapper.Requests.ListShippingOptionsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.ListShippingOptionsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.ListShippingOptionsRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#listAvailableCallingPlansForOffer}
 *
 * @class
 * @name Wrapper.Requests.PhoneDeviceIdRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 */
Wrapper.Requests.PhoneDeviceIdRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid)
    {
        Wrapper.Requests.PhoneDeviceIdRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#purchasePhones}, {@link Wrapper.DigitalLine#getStatementForPhonesPurchase}
 *
 * @class
 * @name Wrapper.Requests.PurchasePhonesRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Wrapper.Models.PhoneOrder} phoneOrder The instance of {@link Wrapper.Models.PhoneOrder}
 */
Wrapper.Requests.PurchasePhonesRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, phoneOrder, shortForm)
    {
        /**
         * The instance of {@link Wrapper.Models.PhoneOrder}
         * @type Wrapper.Models.PhoneOrder
         */
        this.phoneOrder = phoneOrder;

        /**
         * @private
         * @field
         * @name Wrapper.Requests.PurchasePhonesRequest#shortForm
         * @type {boolean}
         */
        this.shortForm = !!shortForm;

        Wrapper.Requests.PurchasePhonesRequest.superclass.constructor.call(this, mid);
    },

    /**
     * @public
     * @function
     * @name Wrapper.Requests.PurchasePhonesRequest#setShortForm
     * @param {boolean} value
     * @return {void}
     */
    setShortForm: function (value) {
        "use strict";
        this.shortForm = !!value;
    },

    /**
     * @public
     * @function
     * @name Wrapper.Requests.PurchasePhonesRequest#isShortForm
     * @return {boolean}
     */
    isShortForm: function () {
        "use strict";
        return !!this.shortForm;
    }

});
/**
 * Creates a new object
 * Uses by {@link Wrapper.Billing#purchaseExtensionAndPhone}
 *
 * @class
 * @name Wrapper.Requests.PurchaseExtensionAndPhoneRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Wrapper.Models.PhoneOrder} phoneOrder The instance of {@link Wrapper.Models.PhoneOrder}
 * @param {Number} pin
 * @param {String} firstName
 * @param {String} email
 * @param {String} type
 */
Wrapper.Requests.PurchaseExtensionAndPhoneRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, phoneOrder, pin, firstName, email, type, shortForm)
    {
        /**
         * The instance of {@link Wrapper.Models.PhoneOrder}
         * @type Wrapper.Models.PhoneOrder
         */
        this.phoneOrder = phoneOrder;

        /**
         * @type Number
         */
        this.pin = pin;

        /**
         * @type String
         */
        this.firstName = firstName;

        /**
         * @type String
         */
        this.email = email;

        /**
         * @type String
         */
        this.type = type;

        /**
         * @private
         * @field
         * @name Wrapper.Requests.PurchaseExtensionAndPhoneRequest#shortForm
         * @type {boolean}
         */
        this.shortForm = !!shortForm;

        Wrapper.Requests.PurchasePhonesRequest.superclass.constructor.call(this, mid);
    },

    /**
     * @public
     * @function
     * @name Wrapper.Requests.PurchaseExtensionAndPhoneRequest#setShortForm
     * @param {boolean} value
     * @return {void}
     */
    setShortForm: function (value) {
        "use strict";
        this.shortForm = !!value;
    },

    /**
     * @public
     * @function
     * @name Wrapper.Requests.PurchaseExtensionAndPhoneRequest#isShortForm
     * @return {boolean}
     */
    isShortForm: function () {
        "use strict";
        return !!this.shortForm;
    }

});


/**
 * Creates a new object
 * Uses by {@link Wrapper.Billing#purchaseExtension}
 *
 * @class
 * @name Wrapper.Requests.PurchaseExtensionRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Boolean} welcEmail
 * @param {Number} pin
 * @param {String} firstName
 * @param {String} lastName
 * @param {String} email
 * @param {String} type
 * @param {String} number
 */
Wrapper.Requests.PurchaseExtensionRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, welcEmail, pin, firstName, lastName, email, type, number)
    {

        /**
         * @type Boolean
         */
        this.welcEmail = welcEmail;

        /**
         * @type Number
         */
        this.pin = pin;

        /**
         * @type String
         */
        this.firstName = firstName;

        /**
         * @type String
         */
        this.lastName = lastName;

        /**
         * @type String
         */
        this.email = email;

        /**
         * @type String
         */
        this.type = type;

        /**
         * @type String
         */
        this.number = number;


        Wrapper.Requests.PurchaseExtensionRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Billing#getBillingStatementForAddDigitalLinesToSLG}
 *
 * @class
 * @name Wrapper.Requests.PurchaseLinesRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {RC.Model.PhoneLine.Line} lines Array of {@link RC.Model.PhoneLine.Line}
 */
Wrapper.Requests.PurchaseLinesRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, lines, shortForm)
    {
        /**
         * The instance of {@link Wrapper.Models.PhoneOrder}
         * @type Wrapper.Models.PhoneOrder
         */
        this.lines = lines;

        /**
         * @private
         * @field
         * @name Wrapper.Requests.PurchaseLinesRequest#shortForm
         * @type {boolean}
         */
        this.shortForm = !!shortForm;

        Wrapper.Requests.PurchaseLinesRequest.superclass.constructor.call(this, mid);
    },

    /**
     * @public
     * @function
     * @name Wrapper.Requests.PurchaseLinesRequest#setShortForm
     * @param value
     */
    setShortForm: function (value) {
        "use strict";
        this.shortForm = !!value;
    },

    /**
     * @public
     * @function
     * @name Wrapper.Requests.PurchaseLinesRequest#isShortForm
     * @return {boolean}
     */
    isShortForm: function () {
        "use strict";
        return !!this.shortForm;
    }

});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#listAvailableDevicesForOffer}, {@link Wrapper.DigitalLine#listStandaloneDevicesForOffer}
 *
 * @class
 * @name Wrapper.Requests.ListAvailableDevicesForOfferRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} linePlanId
 * @param {Boolean} blaSupport
 * @param {Boolean} includeLeasingDevices
 * @param {Boolean} includeRefurbishedDevices
 */
Wrapper.Requests.ListAvailableDevicesForOfferRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, linePlanId, blaSupport, includeLeasingDevices, includeRefurbishedDevices)
    {
        /**
         * @type Number
         */
        this.linePlanId = linePlanId;

        /**
         * @type Boolean
         */
        this.blaSupport = blaSupport;
        /**
         * @type Boolean
         */
        this.includeLeasingDevices = includeLeasingDevices;
        /**
         * @type Boolean
         */
        this.includeRefurbishedDevices = includeRefurbishedDevices;

        Wrapper.Requests.ListAvailableDevicesForOfferRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#getStatementForPhoneLinePlanChange}, {@link Wrapper.DigitalLine#changePhoneLinePlan}
 *
 * @class
 * @name Wrapper.Requests.ChangePhoneLinePlanRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} phoneLineId
 * @param {Number} planId
 */
Wrapper.Requests.ChangePhoneLinePlanRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, phoneLineId, planId)
    {
        /**
         * @type Number
         */
        this.phoneLineId = phoneLineId;

        /**
         * @type Number
         */
        this.planId = planId;

        Wrapper.Requests.ChangePhoneLinePlanRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#changePhoneLineDevice}
 *
 * @class
 * @name Wrapper.Requests.ChangePhoneLineDeviceRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} phoneLineId
 * @param {Number} planId
 */
Wrapper.Requests.ChangePhoneLineDeviceRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, sourceDeviceId, destDeviceId, phoneLineId)
    {
        /**
         * @type Number
         */
        this.sourceDeviceId = sourceDeviceId;

        /**
         * @type Number
         */
        this.destDeviceId = destDeviceId;

        /**
         * @type Number
         */
        this.phoneLineId = phoneLineId;

        Wrapper.Requests.ChangePhoneLineDeviceRequest.superclass.constructor.call(this, mid);
    }
});


/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#isShippingAllowed}
 *
 * @class
 * @name Wrapper.Requests.IsShippingAllowedRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Boolean} checkHardPhone
 */
Wrapper.Requests.IsShippingAllowedRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, checkHardPhone)
    {
        /**
         * @type Boolean
         */
        this.checkHardPhone = checkHardPhone;

        Wrapper.Requests.IsShippingAllowedRequest.superclass.constructor.call(this, mid);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#getStatementForPhoneUnassignment}, {@link Wrapper.DigitalLine#unassignPhone}
 *
 * @class
 * @name Wrapper.Requests.UnassignPhoneRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} phoneLineId
 * @param {Boolean} keepNumber
 */
Wrapper.Requests.UnassignPhoneRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, phoneLineId, keepNumber)
    {
        /**
         * @type Number
         */
        this.phoneLineId = phoneLineId;

        /**
         * @type Boolean
         */
        this.keepNumber = keepNumber;

        Wrapper.Requests.UnassignPhoneRequest.superclass.constructor.call(this, mid);
    }
});
/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#getStatementForPhoneUnassignment}, {@link Wrapper.DigitalLine#unassignPhone}
 *
 * @class
 * @name Wrapper.Requests.PhoneNumberDeleteRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Number} phoneLineId
 * @param {Boolean} keepNumber
 */
Wrapper.Requests.PhoneNumberDeleteRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(phoneId, shortForm)
    {
        /**
         * @type Number
         */
        this.phoneId = phoneId;

        /**
         * @type {boolean}
         */
        this.shortForm = !!shortForm;

        Wrapper.Requests.PhoneNumberDeleteRequest.superclass.constructor.call(this);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.System#doCancelService}
 *
 * @class
 * @name Wrapper.Requests.CancelAccountRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} reasonId
 * @param {String} comment
 */
Wrapper.Requests.CancelAccountRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(reasonId, comment)
    {
        /**
         * @type Number
         */
        this.reasonId = reasonId;

        /**
         * @type String
         */
        this.comment = comment;

        Wrapper.Requests.CancelAccountRequest.superclass.constructor.call(this, null);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getAvailableExtensionNumber}
 *
 * @class
 * @name Wrapper.Requests.AvailableExtensionNumberRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {String} type
 */
Wrapper.Requests.AvailableExtensionNumberRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(type)
    {
        /**
         * @type String
         */
        this.type = type;

        Wrapper.Requests.AvailableExtensionNumberRequest.superclass.constructor.call(this, {});
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Billing#isChangeServicePlanAllowed}
 *
 * @class
 * @name Wrapper.Requests.TierRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} tierId
 */
Wrapper.Requests.TierRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(tierId)
    {
        /**
         * @type Number
         */
        this.tierId = tierId;

        Wrapper.Requests.TierRequest.superclass.constructor.call(this, {});
    }
});


/**
 * Creates a new object
 * Uses by {@link Wrapper.Validation#validateExtensionPin}
 *
 * @class
 * @name Wrapper.Requests.ValidateExtensionPinRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} pin
 */
Wrapper.Requests.ValidateExtensionPinRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(pin, directoryExtension)
    {
        /**
         * @type Number
         */
        this.pin = pin;

        /**
         * Set to <tt>true</tt> if you want validate pin for dial by name directory
         * @type Boolean
         */
        this.directoryExtension = directoryExtension;

        /**
         * Set to <tt>true</tt> if you want to skip check for current mailbox
         * @type Boolean
         */
        this.m = null;

        Wrapper.Requests.ValidateExtensionPinRequest.superclass.constructor.call(this, {});
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.System#sendFeedback}
 *
 * @class
 * @name Wrapper.Requests.FeedbackRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {String} message
 */
Wrapper.Requests.FeedbackRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(message)
    {
        /**
         * @type String
         */
        this.message = message;

        Wrapper.Requests.FeedbackRequest.superclass.constructor.call(this, {});
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Billing#setBillingSettings}
 *
 * @class
 * @name Wrapper.Requests.BillingSettingsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {String} message
 */
Wrapper.Requests.BillingSettingsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(autoPurchaseBlockNo)
    {
        /**
         * @type Integer
         */
        this.autoPurchaseBlockNo = autoPurchaseBlockNo;

        /**
         * @type Boolean
         */
        this.sendReports = null;

        Wrapper.Requests.BillingSettingsRequest.superclass.constructor.call(this, {});
    }
});

/**
 * Creates a new GetRegionalSettingsRequest object
 * Uses by {@link Wrapper.Extensions#getRegionalSettings}
 *
 * @class
 * @name Wrapper.Requests.GetRegionalSettingsRequest
 * @extends Wrapper.Requests.MailboxRequest
 * @member RC apply
 * @param {Number} mid
 * @param {Boolean} companyLevel
 */
Wrapper.Requests.GetRegionalSettingsRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, companyLevel)
    {
        /**
         * @type Boolean
         */
        this.companyLevel = companyLevel;

        Wrapper.Requests.GetRegionalSettingsRequest.superclass.constructor.call(this, mid);
    }
});

Wrapper.Requests.GetUserLanguagesRequest = RC.extend(Wrapper.Requests.MailboxRequest, {
    constructor : function(mid, companyLevel)
    {
        /**
         * @type Boolean
         */
        this.companyLevel = companyLevel;

    }
});




RC.ns("Wrapper.Responses");

/**
 * This is a basic response for all methods which return a status of its execution.
 *
 * @class
 * @name Wrapper.Responses.StatusedResponse
 * @see {@link Wrapper.Models.RequestStatus}
 */
Wrapper.Responses.StatusedResponse = function(status) {
    /**
     * Is a status of a method execution.
     * @type Wrapper.Models.RequestStatus
     * @property status
     */
    this.status = status;
    /**
     * Calculates time (in millis) of a method execution.
     * @type Number
     * @property spent
     */
    this.spent = 0;
};


/**
 * Creates a new LongResponse object
 * Uses by {@link Wrapper.Rules#setGreeting}, {@link Wrapper.Rules#setCustomRule}
 *
 * @class
 * @name Wrapper.Responses.LongResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Number} result
 */
Wrapper.Responses.LongResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, result)
        {
            /**
             * @type Number
             */
            this.result = result;

            Wrapper.Responses.LongResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new LongResponse object
 * Uses by {@link Wrapper.Rules#isConditionModeAllowed}
 *
 * @class
 * @name Wrapper.Responses.BooleanResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Boolean} result
 */
Wrapper.Responses.BooleanResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, result)
        {
            /**
             * @type Boolean
             */
            this.result = result;

            Wrapper.Responses.BooleanResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new StringResponse object
 *
 * @class
 * @name Wrapper.Responses.StringResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {String} result
 */
Wrapper.Responses.StringResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, result)
        {
            /**
             * @type String
             */
            this.result = result;

            Wrapper.Responses.StringResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new ListAnsweringRulesResponse object
 * Uses by {@link Wrapper.Rules#listHoursRules}
 *
 * @class
 * @name Wrapper.Responses.ListAnsweringRulesResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Array} rules List of {@link Wrapper.Models.AnsweringRuleListInfo}.
 */
Wrapper.Responses.ListAnsweringRulesResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, rules)
        {
            /**
             * List of {@link Wrapper.Models.AnsweringRuleListInfo}.
             * @type Array
             * @property rules
             */
            this.rules = RC.toArray(rules);

            Wrapper.Responses.ListAnsweringRulesResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new AnsweringRuleInfoResponse object
 * Uses by {@link Wrapper.Rules#getCustomRule}
 *
 * @class
 * @name Wrapper.Responses.AnsweringRuleInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.AnsweringRuleInfo} rule The instance of {@link Wrapper.Models.AnsweringRuleInfo}.
 */
Wrapper.Responses.AnsweringRuleInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, rule)
        {
            /**
             * The instance of {@link Wrapper.Models.AnsweringRuleInfo}.
         * @type Wrapper.Models.AnsweringRuleInfo
             */
            this.rule = rule;

            Wrapper.Responses.ListAnsweringRulesResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new AnsweringRuleInfoResponse object
 * Uses by {@link Wrapper.Rules#getDNDStatus}
 *
 * @class
 * @name Wrapper.Responses.DNDStatusResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Enums.DNDStatus} dndStatus
 */
Wrapper.Responses.DNDStatusResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, dndStatus)
        {
            /**
         * The status of extension. See {@link Wrapper.Enums.DNDStatus} for details.
         * @type Wrapper.Enums.DNDStatus
             */
            this.dndStatus = dndStatus;

            Wrapper.Responses.DNDStatusResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new ParsedPhoneNumberResponse object
 * Uses by {@link Wrapper.Numbers#parsePhoneNumber}
 *
 * @class
 * @name Wrapper.Responses.ParsedPhoneNumberResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {ParsedNumber} number The instance of {@link Wrapper.Models.ParsedNumber}
 */
Wrapper.Responses.ParsedPhoneNumberResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, number)
        {
            /**
             * The instance of {@link Wrapper.Models.ParsedNumber}
             * @type ParsedNumber
             */
            this.number = number;

            Wrapper.Responses.ParsedPhoneNumberResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new CellProviderInfoResponse object
 * Uses by {@link Wrapper.Numbers#getCellProvider}
 *
 * @class
 * @name Wrapper.Responses.CellProviderInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.CellProviderInfo} rule The instance of {@link Wrapper.Models.CellProviderInfo}.
 */
Wrapper.Responses.CellProviderInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, cellProviderInfo)
        {
            /**
             * The instance of {@link Wrapper.Models.CellProviderInfo}.
             * @type Wrapper.Models.CellProviderInfo
             */
            this.cellProviderInfo = cellProviderInfo;

            Wrapper.Responses.CellProviderInfoResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new MarketingMessagesInfoResponse object
 * Uses by {@link Wrapper.System#getMarketingMessages}
 *
 * @class
 * @name Wrapper.Responses.MarketingMessagesInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.MarketingMessageInfo} rule The instance of {@link Wrapper.Models.MarketingMessageInfo}.
 */
Wrapper.Responses.MarketingMessagesInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor: function(status, marketingMessages){
        /**
         * The instance of {@link Wrapper.Models.MarketingMessageInfo}.
         * @type {Array}
         */
        this.marketingMessages  = marketingMessages;

        Wrapper.Responses.MarketingMessagesInfoResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new ListCellProvidersResponse object
 *
 * @class
 * @name Wrapper.Responses.ListCellProvidersResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Array} cellProviders The list of instance of {@link Wrapper.Models.CellProviderInfo}.
 */
Wrapper.Responses.ListCellProvidersResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, cellProviders)
        {
            /**
             * The instance of {@link Wrapper.Models.CellProviderInfo}.
             * @type {Array}
             */
            this.cellProviders = cellProviders;

            Wrapper.Responses.ListCellProvidersResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new MailboxInfoResponse object
 * Uses by {@link Wrapper.Extensions#getExtension}
 *
 * @class
 * @name Wrapper.Responses.MailboxInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Number} mailboxId Id of the extension.
 * @param {Wrapper.Models.MailboxInfo} mailboxInfo The list of instance of {@link Wrapper.Models.MailboxInfo}.
 * @param {Number[]} phoneNumberIds
 */
Wrapper.Responses.MailboxInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, mailboxId, mailboxInfo, phoneNumberIds)
        {
            /**
             * The instance of {@link Wrapper.Models.MailboxInfo}.
         * @type Wrapper.Models.MailboxInfo
             */
            this.mailboxInfo = mailboxInfo;
            /**
             * @type Number
             */
            this.mailboxId = mailboxId;
            /**
             * @type Number[]
             */
            this.phoneNumberIds = phoneNumberIds;

            Wrapper.Responses.MailboxInfoResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new NumbersResponse object
 * Uses by {@link Wrapper.Numbers#getNumbers}
 *
 * @class
 * @name Wrapper.Responses.NumbersResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Array} numbers The list of instance of {@link Wrapper.Models.PhoneNumber}.
 */
Wrapper.Responses.NumbersResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, numbers)
        {
            /**
             * The instance of {@link Wrapper.Models.PhoneNumber}.
             * @type Array
             */
            this.numbers = numbers;

            Wrapper.Responses.NumbersResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new NumbersResponse object
 * Uses by {@link Wrapper.Extensions#getExtensionPermissions}
 *
 * @class
 * @name Wrapper.Responses.ExtensionPermissionsResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.ExtensionPermissions} permissions The instance of {@link Wrapper.Models.ExtensionPermissions}.
 */
Wrapper.Responses.ExtensionPermissionsResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, permissions)
        {
            /**
             * The instance of {@link Wrapper.Models.ExtensionPermissions}.
             * @type Wrapper.Models.ExtensionPermissions
             */
            this.permissions = permissions;

            Wrapper.Responses.ExtensionPermissionsResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new NumbersResponse object
 * Uses by {@link Wrapper.Extensions#listExtensions}
 *
 * @class
 * @name Wrapper.Responses.ListExtensionsResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.ExtensionInfo[]} extensions The list of instances of {@link Wrapper.Models.ExtensionInfo}.
 */
Wrapper.Responses.ListExtensionsResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, extensions)
        {
            /**
             * The list of instances of {@link Wrapper.Models.ExtensionPermissions}.
             * @type Wrapper.Models.ExtensionInfo[]
             */
            this.extensions = extensions;

            Wrapper.Responses.ListExtensionsResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getSoftwareVersion}
 *
 * @class
 * @name Wrapper.Responses.SoftwareVersionInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.SoftwareVersionInfo} softwareVersionInfo The instance of {@link Wrapper.Models.SoftwareVersionInfo}.
 */
Wrapper.Responses.SoftwareVersionInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, softwareVersionInfo)
        {
            /**
             * The instance of {@link Wrapper.Models.SoftwareVersionInfo}.
             * @type Wrapper.Models.SoftwareVersionInfo
             */
            this.softwareVersionInfo = softwareVersionInfo;

            Wrapper.Responses.SoftwareVersionInfoResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getAccountNumber}
 *
 * @class
 * @name Wrapper.Responses.AccountNumberResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.PhoneNumber} softwareVersionInfo The list of instances of {@link Wrapper.Models.PhoneNumber}.
 */
Wrapper.Responses.AccountNumberResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, numbers)
        {
            /**
             * The list of instances of {@link Wrapper.Models.PhoneNumber}.
             * @type Wrapper.Models.PhoneNumber
             */
            this.numbers = numbers;

            Wrapper.Responses.AccountNumberResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getAccountInfo}
 *
 * @class
 * @name Wrapper.Responses.UserInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 * @param {Wrapper.Models.UserInfo} userInfo The instance of {@link Wrapper.Models.UserInfo}.
 */
Wrapper.Responses.UserInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status, userInfo)
        {
            /**
             * The instance of {@link Wrapper.Models.UserInfo}.
             * @type Wrapper.Models.UserInfo
             */
            this.userInfo = userInfo;

            Wrapper.Responses.UserInfoResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#listPhoneNumbers}
 *
 * @class
 * @name Wrapper.Responses.ListPhoneNumbersResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListPhoneNumbersResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.ListPhoneNumbersResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#listPortedNumbers}
 *
 * @class
 * @name Wrapper.Responses.ListPortedNumbersResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListPortedNumbersResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.ListPortedNumbersResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getNotifications}
 *
 * @class
 * @name Wrapper.Responses.NotificationsInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.NotificationsInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.NotificationsInfoResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getTimeZone}
 *
 * @class
 * @name Wrapper.Responses.TimeZoneResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.TimeZoneResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.TimeZoneResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#listSecretQuestions}
 *
 * @class
 * @name Wrapper.Responses.ListSecretQuestionsResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListSecretQuestionsResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.ListSecretQuestionsResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getBlockedNumbers}
 *
 * @class
 * @name Wrapper.Responses.ListBlockedNumbersResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListBlockedNumbersResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.ListBlockedNumbersResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 *
 * @class
 * @name Wrapper.Responses.DialByNameSettingsResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.DialByNameSettingsResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.DialByNameSettingsResponse.superclass.constructor.call(this, status);
        }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Extensions#getExtensionsByPermission}
 *
 * @class
 * @name Wrapper.Responses.PermissionForMailboxesResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.PermissionForMailboxesResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
        constructor : function(status)
        {
            Wrapper.Responses.PermissionForMailboxesResponse.superclass.constructor.call(this, status);
        }
});


/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#listAvailableDevicesForOffer}
 *
 * @class
 * @name Wrapper.Responses.ListAvailableDevicesForOfferResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListAvailableDevicesForOfferResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.ListAvailableDevicesForOfferResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#listShippingOptions}
 *
 * @class
 * @name Wrapper.Responses.ListShippingOptionsResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListShippingOptionsResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.ListShippingOptionsResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#listAvailableCallingPlansForOffer}
 *
 * @class
 * @name Wrapper.Responses.ListAvailableCallingPlansForOfferResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListAvailableCallingPlansForOfferResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.ListAvailableCallingPlansForOfferResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#getStatementForPhonesPurchase}
 *
 * @class
 * @name Wrapper.Responses.BillingStatementResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.BillingStatementResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.BillingStatementResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#purchasePhones}
 *
 * @class
 * @name Wrapper.Responses.PurchasePhonesResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.PurchasePhonesResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.PurchasePhonesResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#changePhoneLinePlan}
 *
 * @class
 * @name Wrapper.Responses.PurchaseResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.PurchaseResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {

        /**
         * @type Wrapper.Enums.StatusCode
         */
        this.billingStatus = null;

        /**
         * @type String
         */
        this.billingTransactionId = null;

        Wrapper.Responses.PurchaseResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#changePhoneLinePlan}
 *
 * @class
 * @name Wrapper.Responses.AddForwardedNumberResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.AddForwardedNumberResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {

        /**
         * @type Wrapper.Enums.PhoneType
         */
        this.phoneType = null;


        Wrapper.Responses.AddForwardedNumberResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.DigitalLine#getOrderInfo}
 *
 * @class
 * @name Wrapper.Responses.OrderInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.OrderInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.OrderInfoResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.System#listApplications}
 *
 * @class
 * @name Wrapper.Responses.ListApplicationsResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ListApplicationsResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.ListApplicationsResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Billing#getServicePlanInfo}
 *
 * @class
 * @name Wrapper.Responses.ServicePlanInfoResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.ServicePlanInfoResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.ServicePlanInfoResponse.superclass.constructor.call(this, status);
    }
});

/**
 * Creates a new object
 * Uses by {@link Wrapper.Billing#getAvailableAdditionalServices}
 *
 * @class
 * @name Wrapper.Responses.WAvailableAdditionalServicesResponse
 * @extends Wrapper.Responses.StatusedResponse
 * @member RC apply
 * @param {Wrapper.Models.RequestStatus} status Is a status of a method execution.
 */
Wrapper.Responses.WAvailableAdditionalServicesResponse = RC.extend(Wrapper.Responses.StatusedResponse, {
    constructor : function(status)
    {
        Wrapper.Responses.WAvailableAdditionalServicesResponse.superclass.constructor.call(this, status);
    }
});


/**
 * Base class for all RCLibX components. All subclasses of Component may participate in the automated Ext component lifecycle of creation,
 * rendering and destruction which is provided by the Container class. Components may be added to a Container through the items config option
 * at the time the Container is created, or they may be added dynamically via the add method.
 *
 * @todo 1. Check usages of these properties in other components and remove duplicates
 * @todo 2. Try to remove usages of deprecated properties
 *
 * @class
 * @name RC.Element
 * @extends RC.utils.Observable
 * @constructor
 * @param {Object} config The config object
 */
RC.Element = function(config)
{
    /**
     * @var string Style for body of the component
     */
    this.bodyStyles = RC.isEmpty(config.bodyStyles) ? null : config.bodyStyles;
    /**
     * @var string Extra class of the component
     */
    this.extraClass = RC.isEmpty(config.extraClass) ? null : config.extraClass;
    /**
     * Use extraStyles object instead of text definition
     * @deprecated
     */
    this.extraStyle = RC.isEmpty(config.extraStyle) ? null : config.extraStyle;
    /**
     * @example
     * object.extraStyles = {
     *      'color'     : '#fff',
     *      'font-size' : '20px'
     * }
     * @var object Style definitions
     */
    this.extraStyles = RC.isEmpty(config.extraStyles) ? null : config.extraStyles;
    /**
     * Items to insert in this container
     * @var array items
     */
    this.items = (config.items !== undefined && config.items.length > 0 ? config.items : []);
    /**
     * Id of component. If not defined will be generated automatically
     * @var mixed id
     */
    this.id = RC.isEmpty(config.id) ? RC.genId() : config.id;
    /**
     * Buttons to insert to the bottom of  this container
     * @var array items
     */
    this.buttons = (config.buttons != null && config.buttons.length > 0 ? config.buttons : []);
    // length of value
    /**
     * @todo remove it at all
     */
    this.overflow = RC.isEmpty(config.overflow) ? null : config.overflow;
    /**
     * @var string Extra class of the buttons
     */
    this.buttonsExtraClass = RC.isEmpty(config.buttonsExtraClass) ? null : config.buttonsExtraClass;
    /**
     * Use buttonsExtraStyles object instead of text definition
     * @deprecated
     */
    this.buttonsExtraStyle = RC.isEmpty(config.buttonsExtraStyle) ? null : config.buttonsExtraStyle;
    /**
     * @example
     * object.buttonsExtraStyles = {
     *      'color'     : '#fff',
     *      'font-size' : '20px'
     * }
     * @var object Style definitions
     */
    this.buttonsExtraStyles = RC.isEmpty(config.buttonsExtraStyles) ? null : config.buttonsExtraStyles;
    /**
     * Use buttonsAlign object instead
     * @deprecated
     */
    this.buttonsPosition = RC.isEmpty(config.buttonsPosition) ? 'bottom' : config.buttonsPosition;
    /**
     * Alignment of the buttons
     * @var string Should be: left, right, top, bottom, center, middle
     */
    this.buttonsAlign = RC.isEmpty(config.buttonsAlign) ? null : config.buttonsAlign;
    this.buttonsCentered = RC.isTrue(config.buttonsCentered);
    /**
     * Shows state of component
     * @private
     * @cfg {Boolean} displayed
     */
    this.displayed = false;
    /**
     * If you don't want to fire Ajax request immediately set to true
     * @private
     * @cfg {Boolean} doNotFireQueue
     */
    this.doNotFireQueue = false;
    /**
     * @cfg {Boolean} visible Visiblity of the component
     */
    this.visible = !RC.isFalse(config.visible);
    /**
     * @cfg {String/Object} renderTo
     * Specify the id of the element, a DOM element or an existing Element that this component
     * will be rendered into.
     */
    this.renderTo = !RC.isEmpty(config.renderTo) ? $(config.renderTo) : null;

    // remove xtype at all
    config._xtype = config.xtype;
    config.xtype = null;

    // call parent superclass
    RC.Element.superclass.constructor.call(this, config);

    this._xtype = config._xtype;

    this.addEvents(
        /**
         * @event render
         * Fires after the component markup is rendered.
         * @param {RC.Element} this
         */
            'render',
        /**
         * @event show
         * Fires after the component is shown when calling the show method.
         * @param {RC.Element} this
         */
            'show',
        /**
         * @event hide
         * Fires after the component is hidden when calling the hide method.
         * @param {RC.Element} this
         */
            'hide',
        /**
         * @event removed
         * Fires when a component is removed from a DOM
         * @param {RC.Element} this
         */
            'removed',
        /**
         * @event beforeremove
         * Fires before a component will be removed from a DOM. Return FALSE to cancel action.
         * @param {RC.Element} this
         */
            'beforeremove',
        /**
         * @event display
         * Fires when a component is displayed
         * @param {RC.Element} this
         */
            'display',
       /**
         * @event change
         * Fires when a component is changed
         * @param {RC.Element} this
         */
            'change'
            );
};

RC.extend(RC.Element, RC.utils.Observable, {
    _renderedCanvas: null,
    /**
     * Compile the element and include into given container.
     * @param {Object|String} [container] ID or HTMLObject of container which will be used for including of generated element.
     * @return {Object} Generated HTMLObject
     */
    compile : function(container)
    {
        var parent = $(container);
        var canvas = null;
        var self = this;

        // try to detect child nodes for some xtypes
        if (this.items.length > 0 && this.items[0] != null) {
            if (this.items[0].compile === undefined &&
                    this.items[0].xtype === undefined &&
                    this.items[0] != '-') {
                canvas = this.render(this.items);
                this.items = [];
            }
        }

        if (canvas == null) {
            canvas = this.render();
        }

        // apply extra class settings
        if (this.extraClass != null) {
            canvas.addClass(this.extraClass);
        }
        // apply extra styles settings
        if (this.extraStyles != null) {
            canvas.setStyles(this.extraStyles);
        }

        var coCanvas = canvas;

        if (this instanceof RC.panel.BasePanel ||
                this instanceof RC.panel.Panel2) {
            // create local canvas to insert data
            coCanvas = canvas.getElement('td[id=' + this.id + '-content]');
            if (coCanvas == null) {
                coCanvas = canvas.getElements('div')[0];
            }
            if (this.bodyStyles != null) {
                coCanvas.setStyles(this.bodyStyles);
            }
        } else if(this instanceof RC.ScrollBox) {
            coCanvas = canvas.getElement('#' + this.id + '-content');
            if (this.bodyStyles != null) {
                coCanvas.setStyles(this.bodyStyles);
            }
        }

        // we aren't parsing some components
        if (!(this instanceof RC.Holder) && !(this instanceof RC.form.FormPanel)) {

            // parse and render all childs
            this.items.each(function(item)
            {
                self.addItem(item, coCanvas);
            });

        }

        // parse buttons if need
        if (this.buttons != null && this.buttons.length > 0) {
            var btnCanvas = new Element('table', {
                'id'     : this.id + '-buttons',
                'cellspacing' : 0,
                'cellpadding' : 0,
                'class'  : 'x-buttons-area' + (this.buttonsCentered ? ' x-buttons-area-centered' : ''),
                'html'   : '<tbody><tr></tr></tbody>'
            });
            if (this.buttonsExtraClass != null) {
                btnCanvas.addClass(this.buttonsExtraClass);
            }
            if (this.buttonsExtraStyles != null) {
                btnCanvas.setStyles(this.buttonsExtraStyles);
            }
            // todo remove it
            if (this.buttonsExtraStyle != null)
                btnCanvas.set('style', btnCanvas.get('style') + ';' + this.buttonsExtraStyle);
            var insHTML = btnCanvas.getElement('tr');
            var isSeparated = false;
            this.buttons.each(function(item)
            {
                if (item == '->') {
                    new Element('table', {
                        'cellspacing' : 0,
                        'cellpadding' : 0,
                        html : '<tbody><tr></tr></tbody>'
                    }).inject(
                            new Element('td', {
                                'width' : '100%',
                                'align' : 'right'
                            }).inject(btnCanvas.getElement('tr'), 'bottom'));
                    insHTML = btnCanvas.getElements('tr').getLast();
                    isSeparated = true;
                } else if (item == '-') {
                    var colspan = insHTML.getChildren('td').length;
                    var tr = new Element("tr", {
                        'height' : '20px'
                    });
                    var td = new Element("td", {
                        'width'   : '100%',
                        'style'   : 'margin: auto; padding: 10px 3px;',
                        'colspan' : colspan,
                        'html'    : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>'
                    });
                    td.inject(tr);
                    tr.inject(btnCanvas.getElement('tbody'));
                    insHTML = new Element("tr");
                    insHTML.inject(btnCanvas.getElement('tbody'));
                } else {

                    var isMultiple = item.items !== undefined && item.items.length > 0;

                    var o = null;
                    switch (item.xtype) {
                        case 'combo':
                            o = (new RC.form.Combobox(item)).render();
                            o.formId = self.id;
                            break;
                        default:
                            var itemId = RC.genPrefixedId({
                                id: item.id,
                                idFromText: item.idSuffix || item.text, //TODO remove item.text usage. It is not correct for non English languages
                                prefix: self.id,
                                item: item});
                            if (item.width) item.width = undefined; // In legacy implementation width is passed as a HTML property
                            o = RC.Button.createButton(item, itemId, function(){

                                if (!isMultiple && item.handler != null) item.handler();

                            }).compile();
                    }
                    if (o != null) {
                        if (item.width !== undefined) {
                            if(!(Browser.name === "ie" && item.width == "auto")){
                                o.width = item.width;
                            }
                        }
                        var buttonTd = new Element('td');
                        if (item.extraStyle !== undefined) {
                            buttonTd.set('style', buttonTd.get('style') + ';' + item.extraStyle);
                        }
                        if (item.colspan !== undefined) {
                            buttonTd.set('colspan', item.colspan);
                        }
                        o.inject(buttonTd.inject(insHTML));
                    }
                }
            });
            if (isSeparated)
                btnCanvas.set('width', '100%');
            if (this.buttonsPosition == 'bottom')
                btnCanvas.inject(coCanvas);
            else
                btnCanvas.inject(coCanvas, 'top');
        }

        if (parent != null) {
            parent.grab(canvas);
        }

        // fire RENDER event
        if (self.hasListener('render')) {
            canvas.addEvent('domready', function(e)
            {
                self.fireListener('render', canvas);
            });
        }

        if (parent != null) {
            parent.addEvent('domready', function(e)
            {
                self.fireListener('domready', canvas, parent);
            });
        }

        this._renderedCanvas = canvas;

        // execute queue
        if (!this.doNotFireQueue) {
            RC.Ajax.Queue.fire();
        }

        return canvas;
    },

    getRenderedCanvas: function(){
        if (!this._renderedCanvas) RC.Console.warn('RC.Element.getRenderedCanvas(): Trying to access unrendered canvas %s[%s]', this.id);
        return this._renderedCanvas;
    },

    /**
     * Render the component
     * @abstract
     */
    render : function()
    {

    },

     /**
     * Displays element and fires a {@link #display} event. All subitems will be rendered and included also.
     * @param container
     */
    display : function(container)
    {
        this.compile(container);
        this.displayed = true;
        if (this.items.length > 0) {
            for(var i = 0; i < this.items.length; i++){
                if(this.items[i] instanceof RC.utils.Observable) {
                    this.items[i].fireListener('display');
                }
            }
        }
        this.fireListener('display');
    },

    /**
     * Displays element and fires a {@link #display} event.
     * @return {Boolean} Result of action
     */
    destroy : function()
    {
        var result = this.fireListener('beforeremove');
        if (result === false) {
            return false;
        }
        if ($(this.id) != null) {
            $(this.id).destroy();
        }
        RC.ComponentMgr.unregister(this);
        this.fireListener('removed');
        return true;
    },

    /**
     * TODO: Move it into UTILS
     * @param {String} text
     * @param {Number} length
     * @return {Object}
     */
    cutText : function(text, length)
    {
        text = RC.strFromURLEnc(text);

        // try to cut unnecessary symbols
        if (text !== undefined && length != null && text.length > length)
            return {
                title : text,
                text  : text.substr(0, length) + "..."
            };
        else
            return {
                title : null,
                text  : text
            };
    },

    /**
     * Adds item to panel
     * @param {Object} item The config object
     * @param {Object} canvas The container
     * @param {String} where Direction for inject
     */
    addItem : function(item, canvas, where)
    {
        if (item == null) {
            return null;
        }
        if (item == '-' || (item !== undefined && item.xtype == 'spacer')) {
            if (item == '-')
                item = {
                    xtype : 'item'
                };
            new Element('div', {
                'id'     : RC.genId(item),
                'html'   : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>',
                'class'   : 'spacer'
            }).inject(canvas);
            RC.ComponentMgr.register(item);
        } else if (!RC.isEmpty(item)) {
            var oItem = RC.createComponent(item);
            if (oItem != null) {
                if (!RC.isEmpty(where))
                    oItem.compile().inject(canvas, where);
                else
                    oItem.compile(canvas);
            } else {
                RC.Console.error('RC.Element.addItem(): Type `' + item.xtype + '` not found');
            }
        }
    },

    /**
     * Hides component and fires {@link #hide} event
     */
    hide : function()
    {
        $(this.id).addClass('x-hidden').setStyle('display', 'none');
        this.visible = false;
        this.fireListener('hide');
    },

    /**
     * Shows component and fires {@link #show} event
     */
    show : function()
    {
        $(this.id).removeClass('x-hidden').setStyle('display', '');

        this.visible = true;
        this.fireListener('show');
    },

    /**
     * Returns HTML object of the component
     * @return {Object} HTMLObject of the component
     */
    getDom : function()
    {
        return $(this.id);
    },

    /**
     * Says - is visible
     * @return {Boolean}
     */
    isVisible : function()
    {
        var w = this.getDom().offsetWidth, h = this.getDom().offsetHeight;
        return (w === 0 && h === 0) ? false : (w > 0 && h > 0) ? true : this.getDom().getStyle('display') !== 'none';
    }

});

/**
 * Horizontal rule
 * TODO: Change all usages of 'spacer' and '-' to this
 * @param params
 */
RC.Spacer = function(params)
{

    params = params || {};
    this.extraStyles = RC.isEmpty(params.extraStyles) ? null : params.extraStyles;
    // create superclass
    RC.Spacer.superclass.constructor.call(this, params);
};

RC.extend(RC.Spacer, RC.Element, {
    render : function()
    {

        return new Element('div', {
                'id'     : this.id,
                'html'   : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>',
                'class'   : 'spacer',
                'styles'    : RC.isEmpty(this.extraStyles) ? '' : this.extraStyles
            });

    }
});




/**
 * @class
 * @name RC
 * @member RC apply
 */
RC.apply(RC, {
    /**
     * Clones a given object
     * <br/>
     * @param {Object} o The object which will be cloned
     * @return {Function} object The cloned object
     */
    clone : function(o)
    {
        if (!o || "object" !== typeof o) {
            return o;
        }
        var c = "function" === typeof o.pop ? [] : {};
        var p, v;
        for (p in o) {
            try {
                if (o.hasOwnProperty(p)) {
                    v = o[p];
                    if (v && "object" === typeof v) {
                        c[p] = RC.clone(v);
                    }
                    else {
                        c[p] = v;
                    }
                }
            } catch(e) {
            }
        }
        return c;
    },
    /**
     * Checks valid of phone number.
     * @param {String} number
     * @param {String} numberType
     * @return {Object} status
     */
    checkPhoneNumber :function(number, numberType)
    {
        var status;
        Wrapper.System.checkPhoneNumber(number, numberType, function(o)
            {
                status = o;
            },
            function(o)
            {
                var errorNotSetCode = 1000;
                status = o;
                if (status.status.code == errorNotSetCode) {
                    status.status.message = RC.Lang.Common.INVALID_PHONE_NUMBER;
                    status.status.localizedMessage = RC.Lang.Common.INVALID_PHONE_NUMBER;
                }
            });
        return status;
    },

    /**
     * Checks valid of international number.
     * @param {String} phone
     * @param {Boolean} international
     * @param {Number} mailboxID
     * @return {Boolean} result
     */
    checkInternationalPhoneNumber : function (phone, international, mailboxID, callback, sb)
    {
        var p = phone.replace(/(ext |ext.|\*|X |X.)/gi, "*");
        p = p.replace(/[^0-9a-z\+\*]/gi, "");
        var langCommon = RC.Lang.Common;

        if (p.length < 1) {
            new RC.WindowAlert(langCommon.INVALID_PHONE_NUMBER);
            if (callback) callback();
            return false;
        }
        if (international) {
            if (p.length < 7) {
                new RC.WindowAlert(langCommon.INVALID_PHONE_NUMBER);
                if (callback) callback();
                return false;
            } else {
                if (sb) sb();
            }
        } else {
            var isInternational;
            isInternational = false;

            var res;

            Wrapper.Validation.checkInternationalNumber(p, function(o)
            {
                res = o;
                if (!RC.isEmpty(res.status.message)) {
                    res.status.message = res.status.message.replace("Invalid phone number [", "");
                    res.status.message = res.status.message.replace("]", "");
                }
            }, function(o) {
                res = o;
            });

            isInternational = res.result;

            if (isInternational) {
                // Please enter only US or Canadian phone numbers.
                var contactTarget = '';
                var isAdmin = (RC.Config.isMailboxSystem || RC.Config.isMailboxIsAdmin);
                if (isAdmin) {
                    if (RC.Config.supportNumber) {
                        contactTarget = RC.UI.Message(langCommon.CUSTOMER_SERVICE_WITH_NUMBER, RC.Config.displayName, RC.utils.Common.getSupportNumber());
                    }else {
                        contactTarget = RC.UI.Message(langCommon.CUSTOMER_SERVICE, RC.Config.displayName);
                    }
                } else {
                    contactTarget = langCommon.YOUR_ACCOUNT_ADMINISTRATOR;
                }
                var msg = RC.UI.Message(langCommon.INTERNATIONAL_CALLS_DISABLED, contactTarget);
                new RC.WindowAlert(msg, null, callback);
                return false;
            }

        }
        if (sb) sb();
        return true;
    }
    ,

    /**
     * Checks valid of international number (Extended check).
     * @param {String} phone
     * @param {Boolean} isInternational
     * @param {Number} mailboxID
     * @param {Boolean} checkLength
     * @return {Boolean} result
     */
    checkInternationalPhoneNumberEx : function (phone, isInternational, mailboxID, checkLength, callback, sb)
    {
        if (phone.match(/^\s*\S+@[^\s@]+\.[^\s@]+\s*$/)) {
            sb && sb();
            return true;
        }

        if (RC.isTrue(checkLength)) {
            var p = phone.replace(/(ext\.?|\*| X )/gi, " x ");
            p = p.replace(/[^0-9]/g, "");
            if (p.length > 0 && p.length < 5) {
                new RC.WindowAlert(RC.Lang.Common.INVALID_PHONE_NUMBER, null, callback);
                return false;
            }
        }

        return !(phone != "" && !this.checkInternationalPhoneNumber(phone, isInternational, mailboxID, callback, sb));
    }
    ,

    /**
     * Checks that number contains only valid symbols
     * @param {String} number
     * @return {Boolean} result
     */
    checkPhoneNumberContains : function(number, excludeExts){
        var phoneMask;
        if (!RC.isTrue(excludeExts))
            phoneMask = /^[a-z0-9\+\(\)\s\-\*\#\.]*$/i;
        else
            phoneMask = /^[a-z0-9\+\(\)\s\-]*$/i;
        return phoneMask.test(number);
    },

    /**
     * Sends number to server and check its valid
     * @param {String} phone
     * @param {Number} iFormat
     * @return {Object} result
     */
    parsePhoneNumber : function(phone, iFormat)
    {
        var res;
        (new RC.Ajax).send({
            cmd : 'utils.checkInternationalNumberEx',
            params : {
                number  : phone,
                iFormat : RC.isEmpty(iFormat) ? "" : iFormat
            },
            async : false,
            callback : function(o)
            {
                res = o;
            }});

        return res;
    }
    ,

    /**
     * Checks valid of forward phone which is using in section "Forwarding Phones".
     * @param {Number} mailboxId
     * @param {String} phone
     * @return {Boolean} result
     */
    checkForwardPhone : function(mailboxId, phone, callback)
    {
        var result;
        var langCommon = RC.Lang.Common;
        Wrapper.Validation.checkForwadingPhone(phone, mailboxId, function(o)
        {
            result = o.result;
        });
        if (result == 1) {
            new RC.WindowAlert(langCommon.CHECK_FORWARD_PHONE_ALERT1, null, callback);
            return false;
        } else if (result == 2) {
            new RC.WindowAlert(langCommon.CHECK_FORWARD_PHONE_ALERT2, null, callback);
            return false;
        } else {
            return true;
        }
    }
    ,

    /**
     * Shortcut of {@link RC.Console}
     * @param {Object/String/Array} status
     */
    Log : function(status)
    {
        if (typeof status == 'object')
            RC.Console("Error " + status.code + ": " + status.message);
        else {
            RC.Console.apply(RC.Console, arguments);
        }
    }
    ,
    /**
     * Adopted from QUnit
     */
    objectType: function(obj)
    {
        if (typeof obj === "undefined") {
            return "undefined";

            // consider: typeof null === object
        }
        if (obj === null) {
            return "null";
        }

        var type = Object.prototype.toString.call(obj)
            .match(/^\[object\s(.*)\]$/)[1] || '';

        switch (type) {
            case 'Number':
                if (isNaN(obj)) {
                    return "nan";
                } else {
                    return "number";
                }
            case 'String':
            case 'Boolean':
            case 'Array':
            case 'Date':
            case 'RegExp':
            case 'Function':
                return type.toLowerCase();
        }
        if (typeof obj === "object") {
            return "object";
        }
        return undefined;
    },
    /**
     * Adopted from QUnit
     */
    equiv: function ()
    {

        var innerEquiv; // the real equiv function
        var callers = []; // stack to decide between skip/abort functions
        var parents = []; // stack to avoiding loops from circular referencing

        // Call the o related callback with the given arguments.
        function bindCallbacks(o, callbacks, args)
        {
            var prop = RC.objectType(o);
            if (prop) {
                if (RC.objectType(callbacks[prop]) === "function") {
                    return callbacks[prop].apply(callbacks, args);
                } else {
                    return callbacks[prop]; // or undefined
                }
            }
        }

        var callbacks = function ()
        {

            // for string, boolean, number and null
            function useStrictEquality(b, a)
            {
                if (b instanceof a.constructor || a instanceof b.constructor) {
                    // to catch short annotaion VS 'new' annotation of a declaration
                    // e.g. var i = 1;
                    //      var j = new Number(1);
                    return a == b;
                } else {
                    return a === b;
                }
            }

            return {
                "string": useStrictEquality,
                "boolean": useStrictEquality,
                "number": useStrictEquality,
                "null": useStrictEquality,
                "undefined": useStrictEquality,

                "nan": function (b)
                {
                    return isNaN(b);
                },

                "date": function (b, a)
                {
                    return RC.objectType(b) === "date" && a.valueOf() === b.valueOf();
                },

                "regexp": function (b, a)
                {
                    return RC.objectType(b) === "regexp" &&
                        a.source === b.source && // the regex itself
                        a.global === b.global && // and its modifers (gmi) ...
                        a.ignoreCase === b.ignoreCase &&
                        a.multiline === b.multiline;
                },

                // - skip when the property is a method of an instance (OOP)
                // - abort otherwise,
                //   initial === would have catch identical references anyway
                "function": function ()
                {
                    var caller = callers[callers.length - 1];
                    return caller !== Object &&
                        typeof caller !== "undefined";
                },

                "array": function (b, a)
                {
                    var i, j, loop;
                    var len;

                    // b could be an object literal here
                    if (! (RC.objectType(b) === "array")) {
                        return false;
                    }

                    len = a.length;
                    if (len !== b.length) { // safe and faster
                        return false;
                    }

                    //track reference to avoid circular references
                    parents.push(a);
                    for (i = 0; i < len; i++) {
                        loop = false;
                        for (j = 0; j < parents.length; j++) {
                            if (parents[j] === a[i]) {
                                loop = true;//dont rewalk array
                            }
                        }
                        if (!loop && ! innerEquiv(a[i], b[i])) {
                            parents.pop();
                            return false;
                        }
                    }
                    parents.pop();
                    return true;
                },

                "object": function (b, a)
                {
                    var i, j, loop;
                    var eq = true; // unless we can proove it
                    var aProperties = [], bProperties = []; // collection of strings

                    // comparing constructors is more strict than using instanceof
                    if (a.constructor !== b.constructor) {
                        return false;
                    }

                    // stack constructor before traversing properties
                    callers.push(a.constructor);
                    //track reference to avoid circular references
                    parents.push(a);

                    for (i in a) { // be strict: don't ensures hasOwnProperty and go deep
                        loop = false;
                        for (j = 0; j < parents.length; j++) {
                            if (parents[j] === a[i])
                                loop = true; //don't go down the same path twice
                        }
                        aProperties.push(i); // collect a's properties

                        if (!loop && ! innerEquiv(a[i], b[i])) {
                            eq = false;
                            break;
                        }
                    }

                    callers.pop(); // unstack, we are done
                    parents.pop();

                    for (i in b) {
                        bProperties.push(i); // collect b's properties
                    }

                    // Ensures identical properties name
                    return eq && innerEquiv(aProperties.sort(), bProperties.sort());
                }
            };
        }();

        innerEquiv = function ()
        { // can take multiple arguments
            var args = Array.prototype.slice.apply(arguments);
            if (args.length < 2) {
                return true; // end transition
            }

            return (function (a, b)
            {
                if (a === b) {
                    return true; // catch the most you can
                } else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || RC.objectType(a) !== RC.objectType(b)) {
                    return false; // don't lose time with error prone cases
                } else {
                    return bindCallbacks(a, callbacks, [b, a]);
                }

                // apply transition with (1..n) arguments
            })(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length - 1));
        };

        return innerEquiv;

    }()

});

RC.onReadyHandlers = [];

RC._isDomReady = !/in/.test(document.readyState);
window.addEvent('domready', function(){
    RC._isDomReady = true;
    if (RC._isDomReady && RC._isConfigured) {
        while (RC.onReadyHandlers.length) {
            RC.onReadyHandlers.pop()();
        }
    }
});


RC.onReady = function(cb){
    if (RC._isDomReady && RC._isConfigured) {
        cb(); // execute immediately
    } else {
        RC.onReadyHandlers.push(cb);
    }
};

/**
 * A Collection class that maintains both numeric indexes and keys and exposes events.
 *
 * @class
 * @name RC.MixedCollection
 */

RC.MixedCollection = function()
{
    this.map = [];
    this.items = [];
    this.keys = [];
    this.length = 0;
};

RC.MixedCollection.prototype = {
    allowFunctions : false,

    /**
     * Adds an item to the collection. Fires the add event when complete.
     * @param {String} key
     * @param {Object} o
     * @return {Object}
     */
    add : function(key, o)
    {
        if (arguments.length == 1) {
            o = arguments[0];
            key = this.getKey(o);
        }
        if (typeof key == "undefined" || key === null) {
            this.length++;
            this.items.push(o);
            this.keys.push(null);
        } else {
            var old = this.map[key];
            if (old) {
                return this.replace(key, o);
            }
            this.length++;
            this.items.push(o);
            this.map[key] = o;
            this.keys.push(key);
        }
        return o;
    },

    /**
     * MixedCollection has a generic way to fetch keys if you implement getKey.
     * The default implementation simply returns <tt>item.id</tt>.
     * @param {Object} o
     * @return {Object}
     */
    getKey : function(o)
    {
        return o.id;
    },

    /**
     * Replaces an item in the collection. Fires the replace event when complete.
     * @param {String} key The key associated with the item to replace, or the replacement item.
     * If you supplied a {@link #getKey} implementation for this MixedCollection, or if the key of your stored items is in a property called <tt><b>id</b></tt>,
     * then the MixedCollection will be able to derive the key of the replacement item. If you want to replace an item with one having the same key value,
     * then just pass the replacement item in this parameter.
     * @param {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
     * @return {Object} The new item.
     */
    replace : function(key, o)
    {
        if (arguments.length == 1) {
            o = arguments[0];
            key = this.getKey(o);
        }
        var old = this.get(key);
        if (typeof key == "undefined" || key === null || typeof old == "undefined") {
            return this.add(key, o);
        }
        var index = this.indexOfKey(key);
        this.items[index] = o;
        this.map[key] = o;
        return o;
    },

    /**
     * Adds all elements of an Array or an Object to the collection.
     * @param {Object/Array} objs
     */
    addAll : function(objs)
    {
        if (arguments.length > 1 || RC.isArray(objs)) {
            var args = arguments.length > 1 ? arguments : objs;
            for (var i = 0, len = args.length; i < len; i++) {
                this.add(args[i]);
            }
        } else {
            for (var key in objs) {
                if (this.allowFunctions || typeof objs[key] != "function") {
                    this.add(key, objs[key]);
                }
            }
        }
    },


    each : function(fn, scope)
    {
        var items = [].concat(this.items); // each safe for removal
        for (var i = 0, len = items.length; i < len; i++) {
            if (fn.call(scope || items[i], items[i], i, len) === false) {
                break;
            }
        }
    },


    eachKey : function(fn, scope)
    {
        for (var i = 0, len = this.keys.length; i < len; i++) {
            fn.call(scope || window, this.keys[i], this.items[i], i, len);
        }
    },


    find : function(fn, scope)
    {
        for (var i = 0, len = this.items.length; i < len; i++) {
            if (fn.call(scope || window, this.items[i], this.keys[i])) {
                return this.items[i];
            }
        }
        return null;
    },


    insert : function(index, key, o)
    {
        if (arguments.length == 2) {
            o = arguments[1];
            key = this.getKey(o);
        }
        if (index >= this.length) {
            return this.add(key, o);
        }
        this.length++;
        this.items.splice(index, 0, o);
        if (typeof key != "undefined" && key != null) {
            this.map[key] = o;
        }
        this.keys.splice(index, 0, key);
        return o;
    },


    remove : function(o)
    {
        return this.removeAt(this.indexOf(o));
    },


    removeAt : function(index)
    {
        if (index < this.length && index >= 0) {
            this.length--;
            var o = this.items[index];
            this.items.splice(index, 1);
            var key = this.keys[index];
            if (typeof key != "undefined") {
                delete this.map[key];
            }
            this.keys.splice(index, 1);
            return o;
        }
        return false;
    },


    removeKey : function(key)
    {
        return this.removeAt(this.indexOfKey(key));
    },


    getCount : function()
    {
        return this.length;
    },


    indexOf : function(o)
    {
        return this.items.indexOf(o);
    },


    indexOfKey : function(key)
    {
        return this.keys.indexOf(key);
    },


    get : function(key)
    {
        var item = typeof this.map[key] != "undefined" ? this.map[key] : this.items[key];
        return typeof item != 'function' || this.allowFunctions ? item : null; // for prototype!
    },


    itemAt : function(index)
    {
        return this.items[index];
    },


    key : function(key)
    {
        return this.map[key];
    },


    contains : function(o)
    {
        return this.indexOf(o) != -1;
    },


    containsKey : function(key)
    {
        return typeof this.map[key] != "undefined";
    },


    clear : function()
    {
        this.length = 0;
        this.items = [];
        this.keys = [];
        this.map = {};
    },


    first : function()
    {
        return this.items[0];
    },


    last : function()
    {
        return this.items[this.length - 1];
    },

    // private
    _sort : function(property, dir, fn)
    {
        var dsc = String(dir).toUpperCase() == "DESC" ? -1 : 1;
        fn = fn || function(a, b)
        {
            return a - b;
        };
        var c = [], k = this.keys, items = this.items;
        for (var i = 0, len = items.length; i < len; i++) {
            c[c.length] = {key: k[i], value: items[i], index: i};
        }
        c.sort(function(a, b)
        {
            var v = fn(a[property], b[property]) * dsc;
            if (v == 0) {
                v = (a.index < b.index ? -1 : 1);
            }
            return v;
        });
        for (var i = 0, len = c.length; i < len; i++) {
            items[i] = c[i].value;
            k[i] = c[i].key;
        }
    },


    sort : function(dir, fn)
    {
        this._sort("value", dir, fn);
    },


    keySort : function(dir, fn)
    {
        this._sort("key", dir, fn || function(a, b)
        {
            var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
        });
    },


    getRange : function(start, end)
    {
        var items = this.items;
        if (items.length < 1) {
            return [];
        }
        start = start || 0;
        end = Math.min(typeof end == "undefined" ? this.length - 1 : end, this.length - 1);
        var r = [];
        if (start <= end) {
            for (var i = start; i <= end; i++) {
                r[r.length] = items[i];
            }
        } else {
            for (var i = start; i >= end; i--) {
                r[r.length] = items[i];
            }
        }
        return r;
    },


    filter : function(property, value, anyMatch, caseSensitive)
    {
        if (RC.isEmpty(value, false)) {
            return this.clone();
        }
        value = this.createValueMatcher(value, anyMatch, caseSensitive);
        return this.filterBy(function(o)
        {
            return o && value.test(o[property]);
        });
    },


    filterBy : function(fn, scope)
    {
        var r = new RC.MixedCollection();
        r.getKey = this.getKey;
        var k = this.keys, it = this.items;
        for (var i = 0, len = it.length; i < len; i++) {
            if (fn.call(scope || this, it[i], k[i])) {
                r.add(k[i], it[i]);
            }
        }
        return r;
    },


    findIndex : function(property, value, start, anyMatch, caseSensitive)
    {
        if (RC.isEmpty(value, false)) {
            return -1;
        }
        value = this.createValueMatcher(value, anyMatch, caseSensitive);
        return this.findIndexBy(function(o)
        {
            return o && value.test(o[property]);
        }, null, start);
    },


    findIndexBy : function(fn, scope, start)
    {
        var k = this.keys, it = this.items;
        for (var i = (start || 0), len = it.length; i < len; i++) {
            if (fn.call(scope || this, it[i], k[i])) {
                return i;
            }
        }
        if (typeof start == 'number' && start > 0) {
            for (var i = 0; i < start; i++) {
                if (fn.call(scope || this, it[i], k[i])) {
                    return i;
                }
            }
        }
        return -1;
    },

    // private
    createValueMatcher : function(value, anyMatch, caseSensitive)
    {
        if (!value.exec) { // not a regex
            value = String(value);
            value = new RegExp((anyMatch === true ? '' : '^') + RC.escapeRe(value), caseSensitive ? '' : 'i');
        }
        return value;
    },


    clone : function()
    {
        var r = new RC.MixedCollection();
        var k = this.keys, it = this.items;
        for (var i = 0, len = it.length; i < len; i++) {
            r.add(k[i], it[i]);
        }
        r.getKey = this.getKey;
        return r;
    }
};

/**
 * Provides a registry of all Components (instances of {@link RC.Element} or any subclass
 * thereof) on a page so that they can be easily accessed by {@link RC.Element component}
 * {@link RC.Element#id id} (see {@link #get}, or the convenience method {@link RC#getCmp RC.getCmp}).
 *
 * @class
 * @name RC.ComponentMgr
 * @singleton
 */
RC.ComponentMgr = function()
{
    var all = new RC.MixedCollection();

    var types = {};

    return {

        /**
         * Registers a component.
         * @param {String} cmpName
         * @param {RC.Element} cmp (optional)
         */
        register : function(cmpName, cmp)
        {
            if (RC.isEmpty(cmp)) {
                all.add(cmpName);
            } else {
                all.add(cmpName, cmp);
            }
        },

        /**
         * Unregisters a component.
         * @param {RC.Element} c
         */
        unregister : function(c)
        {
            all.remove(c);
        },

        /**
         * Returns a component by id. For additional details see Ext.util.MixedCollection.get.
         * @param {String} id The component id
         * @return {RC.Element} The Component, <tt>undefined</tt> if not found, or <tt>null</tt> if a Class was found.
         */
        get : function(id)
        {
            return all.get(id);
        },

        /**
         * Registers a function that will be called when a Component with the specified id is added to ComponentMgr. This will happen on instantiation.
         * @param {String} id The component id
         * @param {Function} fn The callback function
         * @param {Object} scope The scope (this reference) in which the callback is executed. Defaults to the Component.
         */
        onAvailable : function(id, fn, scope)
        {
            all.on("add", function(index, o)
            {
                if (o.id == id) {
                    fn.call(scope || o, o);
                    all.un("add", fn, scope);
                }
            });
        },


        /**
         * The MixedCollection used internally for the component cache. An example usage may be subscribing to events on the MixedCollection to monitor addition or removal. Read-only.
         * @type {RC.MixedCollection}
         */
        all : all,

        /**
         * Register xtype of the component
         * @param {String} xtype
         * @param {Object} cls
         */
        registerType : function(xtype, cls)
        {
            types[xtype] = cls;
            cls.xtype = xtype;
        },

        /**
         * Creates config by xtype
         * @param {Object} config The config object
         * @param {String} defaultType (optional)
         */
        create : function(config, defaultType)
        {
            return new types[config.xtype || defaultType](config);
        },

        /**
         * Reloads component from server. Shorthand of {@link #load} method.
         * @param {String} cmpName  Name of the component
         * @param {Function} callback (optional) The callback function will be called after loading will be completed
         */
        reload : function(cmpName, callback)
        {
            this.load(cmpName, callback);
        },

        /**
         * Synchronous loading of a component
         * @param cmpName
         */
        loadSync : function(cmpName, noCache)
        {

            var globalEval = function (src)
            {
                if (window.execScript) {
                    window.execScript(src);
                    return;
                }
                var fn = function()
                {
                    window.eval.call(window, src);
                };
                fn();
            };

            /**
             * This is a temprorary workaround for handling old synchronously loaded components in a new JS way
             * Please get rid of such calls as soon as possible and use RC.ComponentMgr.load with callbacks to achieve
             * proper component loading.
             */
            if (cmpName.indexOf('.js') > -1) {

                if (!RC.isEmpty(RC.ComponentMgr.get(cmpName)) && RC.ComponentMgr.get(cmpName).toString() == cmpName) {
                    RC.Console.log('RC.ComponentMgr.loadSync(): ' + cmpName + " - SYNCHRONOUS JS model has been loaded already");
                } else {
                    RC.Console.log('RC.ComponentMgr.loadSync(): ' + cmpName + " - SYNCHRONOUS JS model is using");
                    if(window === window.top){
                        RC.Loader.show({});
                    }
                    new Request({
                        url         : RC.configuration.componentsDir + this.getBrandedVersionedComponentUrl(cmpName),
                        noCache     : noCache === true,
                        evalResponse: false,
                        async       : false,
                        onSuccess   : function(responseText, responseXML)
                        {

                            RC.ComponentMgr.register(cmpName, cmpName);
                            RC.Loader.hide();
                            globalEval(responseText);

                        }
                    }).get();
                }

                return;

            }

            throw 'Obsolete component loader!';

        },

        getBrandedComponentUrl: function(url) {
            var brandId = RC.configuration.brandId;
            var locale = RC.configuration.locale;
            var brandedURL = url.replace(/\.(js|css|html)/, '-' + brandId + '-' + locale + '.$1');
            return brandedURL;
        },

        getBrandedVersionedComponentUrl: function(url) {
            var version = RC.configuration.version;
            return this.getBrandedComponentUrl(url) + (version? '?v=' + version : '');
        },

        /**
         * Loads component from server and execute it.
         * @param {String} cmpName Name of the component
         * @param {Function} [callback] The callback function will be called after loading will be completed (optional)
         * @param {Boolean} [skipLocalize] Flag for skipping localize/brandize (optional)
         */
        load : function(cmpName, callback, skipLocalize)
        {
            if (RC.isEmpty(cmpName)) throw 'RC.ComponentMgr.load(): You must define the component!';

            var cmpPath;
            var version = RC.configuration.version;
            if (skipLocalize) {
                cmpPath = RC.configuration.componentsDir + cmpName + (version ? "?v=" + version : '');
            }
            else {
                cmpPath = RC.configuration.componentsDir + this.getBrandedVersionedComponentUrl(cmpName);
            }


            var beforeCallback = function(){
                RC.Loader.show({});
            };

            var finalCallback = function(){
                RC.Loader.hide();
                if (RC.isFunc(callback)) {
                    var _arguments = arguments;
                    setTimeout(function () {
                        callback.apply(this, _arguments);
                    }, 0);
                }
            };

            if (cmpName.indexOf(".js") > 0) {

                beforeCallback();

                if (!RC.isEmpty(RC.ComponentMgr.get(cmpName)) && RC.ComponentMgr.get(cmpName).toString() == cmpName) {

                    RC.Console.log('RC.ComponentMgr.load(): ' + cmpName + " - JS model has been loaded already");
                    finalCallback();

                } else {

                    RC.Console.log('RC.ComponentMgr.load(): ' + cmpName + " - JS model is using");
                    Asset.javascript(cmpPath, {
                        onLoad : function()
                        {
                            RC.ComponentMgr.register(cmpName, cmpName);
                            finalCallback();
                        }
                    });

                }

                return;

            } else if (cmpName.indexOf(".css") > 0) {

                RC.Console.log('RC.ComponentMgr.load(): ' + cmpName + " - CSS stylesheet is loading");
                cmpPath = cmpPath.replace(/\/js\//, "/css/");
                Asset.css(cmpPath);

                return;

            } else if (cmpName.indexOf(".html") > 0) {

                beforeCallback();
                cmpPath = cmpPath.replace(/\/js\//, "/html/");
                RC.Console.log('RC.ComponentMgr.load(): ' + cmpName + " - HTML template is loading");
                var request = new Request({
                    method : 'get',
                    url: cmpPath,
                    onSuccess: function(responseText, responseXML)
                    {
                        //RC.Console.log('responseText: %o, responseXML: %o', responseText, responseXML);
                        finalCallback(responseText);
                        }
                });

                request.send();

                return;

                    }

            throw 'RC.ComponentMgr.load(): Obsolete component loader!';

        },
        batchLoad: function(components, callback, options)
        {

            options = options || {};

            var totalComponents = components.length;
            var loadedComponentsCount = 0;
            var loadedComponents = {};

            RC.Loader.show({});

            function loadComponent(componentPath)
            {

                RC.ComponentMgr.load(componentPath, function(Component)
                {

                    loadedComponentsCount++;
                    loadedComponents[componentPath] = Component;

                    if (loadedComponentsCount == totalComponents) {

                        RC.Loader.hide();
                        callback(loadedComponents);

                    } else {

                        loadComponent(components[loadedComponentsCount]);

                    }

                });

            }

            loadComponent(components[0]);

        }
    };
}();

/**
 * Shows loader indicator
 *
 * @class
 * @name RC.Loader
 * @singleton
 */
RC.Loader = new (function()
{
    var obj;
    var hideIt = true;
    var count = 0;
    return {

        /**
         * Loader will be rendered inside the passed object
         * @type {String/Object}
         */
        render : null,
        /**
         * The text which will be displayed on the loader
         * @type {String}
         */
        text   : null,
        /**
         * The callback function which will be called after loader shown
         * @type {Function}
         */
        handler : function() {},

        /**
         * Returns true if loading in progress
         * @return {Boolean}
         */
        isBusy : function()
        {
            return $('x-loader') != null;
        },

        /**
         * Shows loader. Example usage:
         * <pre><code>
         {
         {@link #render} : 'div1',
         {@link #text} : 'Loading...',
         {@link #handler} : function() {
         alert('Hi!');
         }
         }
         * </code></pre>
         * @param {Object} o The config object
         */
        show : function(o)
        {
            //o = o || {};
            if (o == undefined) RC.Console.warn('RC.Loader.show(): Call without arguments');
            count++;
            //RC.Console.log('Loader show(%o)', count);
            if ($('x-loader-background') != null || count > 1) {
                if (typeof o.handler == 'function')
                    setTimeout(function()
                    {
                        o.handler();
                    }, 1); // fork to new flow
                return;
            }
            obj = $(o.render);
            if (obj == null) {
                hideIt = false;
                //create background
                new Element('div', {
                    'id'        : 'x-loader-background',
                    'class'     : 'x-window-background-transparent',
                    'styles'    : {
                        'display'   : 'block'
                    }
                }).inject(document.body, 'top');
                obj = new Element('div', {
                    'id'     : 'x-loader',
                    'class'  : 'x-loader-static',
                    'html'   : '<div class="x-loader-static-panel"><img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/loader_blue.gif') + '" alt="" /><div>' + RC.Lang.Common.LOADING + '</div></div><div class="x-loader-fix"></div>'
                }).inject(document.body);
            } else {
                hideIt = true;
                obj.setStyle('display', 'none');
            }
            if (hideIt) {
                var loaderCanvas = new Element('table', {
                    'id'     : 'x-loader',
                    'align'  : 'center',
                    'html'   : '<tr><td><img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/loader_blue.gif') + '" alt="" width="16" height="16" /></td><td>' + (o.text || RC.Lang.Common.RCLOAD_WAIT ) + '</td></tr>',
                    'styles' : {
                        'text-align' : 'center'
                    }
                });
                loaderCanvas.setStyles({
                    'margin-top' : obj.getStyle('margin-top') ? '10px' : '',
                    'margin-bottom' : obj.getStyle('margin-bottom') ? '16px' : ''
                });
                loaderCanvas.inject(obj, 'after');
                if (o.extraStyles !== undefined)
                    loaderCanvas.setStyles(o.extraStyles);
            }

            if (typeof o.handler == 'function')
                setTimeout(function()
                {
                    o.handler();
                }, 1); // fork to new flow
        },

        /**
         * Hides loader component
         */
        hide : function()
        {
            count--;
            //RC.Console.log('Loader hide(%o)', count);
            if (count <= 0) {
                count = 0;
                if ($('x-loader') == null)
                    return;
                if (hideIt) {
                    $('x-loader').dispose();
                    obj.setStyle('display', '');
                } else {
                    $('x-loader-background').dispose();
                    $('x-loader').dispose();
                }
            }
        } ,

        /**
         * Resets counters
         */
        reset : function()
        {
            count = 0;
        }
    };
});

// todo WILL BE REMOVED
RC.Subscriber = function()
{

    this._observers = Array();

    this.on = function(eventName, callBack)
    {
        if (!this._observers[eventName]) {
            this._observers[eventName] = Array();
        }

        this._observers[eventName].push(callBack);

        return this;
    }


    this.removeEvent = function(ev)
    {
        if (this._observers[ev]) {
            this._observers[ev] = Array();
        }

    }

    this.fireEvent = function(eventName)
    {
        var arg = [];

        for (var i = 1; i < arguments.length; i++) {
            arg.push(arguments[i]);
        }

        if (this._observers[eventName]) {
            for (var i = 0; i < this._observers[eventName].length; i++) {
                if (this._observers[eventName][i]) {
                    if (arg.length) {
                        this._observers[eventName][i].apply(this, arg);
                    }
                    else {
                        this._observers[eventName][i]();
                    }

                }

            }

        }

    }

}

// TODO It needs?
RC.preventSelection = function (rb, el)
{
    var element = el || document;

    element.selectable = function()
    {
        return !(rb != undefined && !rb);
    };

    var preventSelection = false;

    function addHandler(element, event, handler)
    {
        if (element.attachEvent)
            element.attachEvent('on' + event, handler);
        else
        if (element.addEventListener)
            element.addEventListener(event, handler, false);
    }

    function removeSelection()
    {
        if (!element.selectable())
            return;
        if (window.getSelection) {
            window.getSelection().removeAllRanges();
        }
        else if (document.selection && document.selection.clear)
            document.selection.clear();
    }

    function killCtrlA(event)
    {
        if (!element.selectable())
            return;

        var event = event || window.event;
        var sender = event.target || event.srcElement;

        if (sender.tagName.match(/INPUT|TEXTAREA/i))
            return;

        var key = event.keyCode || event.which;
        if (event.ctrlKey && key == 'A'.charCodeAt(0))  // 'A'.charCodeAt(0) ????? ???????? ?? 65
        {
            removeSelection();

            if (event.preventDefault)
                event.preventDefault();
            else
                event.returnValue = false;
        }
    }

    addHandler(element, 'mousemove', function()
    {
        if (preventSelection)
            removeSelection();
    });
    addHandler(element, 'mousedown', function(event)
    {
        var event = event || window.event;
        var sender = event.target || event.srcElement;
        preventSelection = !sender.tagName.match(/INPUT|TEXTAREA/i);
    });

    addHandler(element, 'mouseup', function()
    {
        if (preventSelection)
            removeSelection();
        preventSelection = false;
    });

    addHandler(element, 'keydown', killCtrlA);
    addHandler(element, 'keyup', killCtrlA);
};


RC.BatchMode = function(config)
{
    config = config || [];

    var flgNeedStop = false;

    var obj = new RC.utils.Observable({});
    obj.onReady = function(fn)
    {
        this.addListener("onReady", fn);
        return this;
    };
    obj.onError = function(fn)
    {
        this.addListener("onError", fn);
        return this;
    };

    var cnt = config.length;
    var check = function()
    {
        if (!--cnt) setTimeout(function()
        {
            obj.fireListener("onReady");
        }, 100);
    };

    config.each(function(item)
    {
        var fn = item.fn;
        delete item.fn;
        item.onSuccess = item.onSuccess || function() {};
        item.onError = item.onError || function() {};
        var hash = {};
        $each(item, function(callBackFn, callBackName)
        {
            if (RC.isFunc(callBackFn))
                hash[callBackName] = function()
                {
                    if (flgNeedStop) return;
                    check();
                    var returnedObj = callBackFn.apply(this, arguments);
                    if (returnedObj instanceof RC.BatchMode.Error) {
                        flgNeedStop = true;
                        setTimeout(function()
                        {
                            obj.fireListener("onError", returnedObj);
                        }, 100);
                    }
                };
            else
                hash[callBackName] = callBackFn;
        }, this);

        fn != null ? fn(hash) : check();

    });
    return obj;
};
RC.BatchMode.Error = RC.extend(RC.utils.Observable, {
    code : null,
    message : null,
    constructor : function(message, code)
    {
        this.message = message;
        this.code = code;
    }
});

// TODO Check where it's using and refactor it
var selectionConstructor = function ()
{
    var oSelectedObject;
    this.selectObject = function (objectToSelect)
    {
        oSelectedObject = objectToSelect;
    };
    this.getSelectedObject = function ()
    {
        return oSelectedObject;
    };
    this.clearSelection = function()
    {
        oSelectedObject = null;
    };
};

RC.Selection = new selectionConstructor();

document.onkeydown = function (e)
{
    var oSelectedObject = RC.Selection.getSelectedObject();
    if (oSelectedObject) {
        if (typeof oSelectedObject.onkeydown == 'function') {
            var oEvent; //browser independent event object
            if (e) {
                oEvent = e;
            } else if (event) {
                oEvent = event;
            }
            if (oEvent) {
                oSelectedObject.onkeydown(oEvent);
            }
        }
    }
};

RC.Config = {};

RC.loadLang = function loadLang(langDir, locale, brand, doneCb) {
    var href = langDir + 'lang-' + brand + '-' + locale + '.js?v=' + this.configuration.version;
    Asset.javascript(href, {
        onLoad : function() {
            doneCb();
        }
    });
};

RC.loadTheme = function loadTheme(cssDir, locale, brand, doneCb) {
	var filenameParts = ['refresh'];
	brand && filenameParts.push(brand);
	//locale && filenameParts.push(locale);
	var href = cssDir + filenameParts.join('-') + '.css?v=' + this.configuration.version;
    Asset.css(href, {
        onLoad : function() {
            doneCb();
        }
    });
};

RC.configuration = {};
RC.Configure = function(params) {
    RC.configuration = params;

    function _onReady() {
        RC._isConfigured = true;

        if (RC._isDomReady && RC._isConfigured) {
            while (RC.onReadyHandlers.length) {
                RC.onReadyHandlers.pop()();
            }
        }        
    }

    function _getSkinNameByBrandId(brandId) {
        var skinName,
            brand2Skin = {
            1210: 'default',
            1270: 'extreme-fax',
            3420: 'att',
            3710: 'default',
            7310: 'telus',
			7710: 'bt',
            8510: 'tmobile'
        };

        if (brand2Skin.hasOwnProperty(brandId)) {
            skinName = brand2Skin[brandId];
        }
        else {
            RC.Console.warn('Unknown brand ' + brandId + '; default skin to be used');
            skinName = 'default';
        }

        return skinName;
    }

    params = params || {};
    /**
     * TODO: insert validation here
     */
    this.brandId = params.brandId;

    this.skinName = _getSkinNameByBrandId(this.brandId);

    // Load theme and lang file
    function async(cmd, dir) {
        cmd.call(RC, dir, params.locale, params.brandId, function() {
            if (++async.counter >= 2) {
                _onReady();
            }
        });
    }
    async.counter = 0;

    async(RC.loadTheme, params.cssDir);
    async(RC.loadLang, params.langDir);
};


/**
 * @class
 * @name RC.data.proxy.Ajax
 * @implements RC.data.proxy.Transport
 * The global Ajax request class that provides a simple way to make Ajax requests with maximum flexibility.
 *
 * Since RC.data.proxy.Ajax is a singleton, you can set common properties/events for it once and override them at the request function level only if necessary.
 * @singleton
 */

RC.data.proxy.Ajax = function()
{
    this._url = "/api/proxy.html";
    this._cmd = null;
    this._onSuccess = null;
    this._onError = null;
    this._onComplete = null;
    this._async = true;
    this._urlEncoded = true;

    /**
     * @cfg {String} cmd The command which will be send to server.
     */
    /**
     * @cfg {Array} params The array of additional parameters which will be send to the server.
     */
    /**
     * @cfg {Function} onSuccess The callback function which will be called when request will be completed.
     */
    /**
     * @cfg {Boolean} async (optional) False if you want to run th request in synchronized mode.
     */
    /**
     * @cfg {Function} onError (optional) The callback function which will be called when request will occur an exception. If not set, default handler will be used.
     */
    /**
     * @cfg {Boolean} useWrapper (optional) Set to <tt>true</tt> if you want to pass request to new implementation of the Wrapper.
     */
};

RC.data.proxy.Ajax.prototype = {
    /**
     * Sets the root url.
     * @param {String} address
     */
    setRootUrl : function(address)
    {
        this._url = address;
    },

    /**
     * todo replace from service value
     */
    getUrlToWrapper : function()
    {
        return "/mobile/";
    },

    /**
     * Sets the command.
     * @param {String} cmd
     */
    setCmd : function(cmd)
    {
        this._cmd = cmd;
    },

    /**
     * Returns defined url.
     * @return {String}
     */
    getRootUrl : function()
    {
        return this._url;
    },

    /**
     * Loads data from the server.
     * @private
     * @param {Object} params
     */
    load : function(params)
    {
        if (this._cmd == null)
            throw ("RC.Ajax: You must define the command!");

        var self = this;
        if (params == null)
            params = {};
        //params.cmd = this._cmd;

        //used to save stack trace before sending async ajax
        var error = new Error();

        new Request.JSON({
            url       : this._url + '?cmd=' + this._cmd,
            async     : this._async,
            noCache   : true,
            urlEncoded: this._urlEncoded,
            headers   : { 'CSRFTOKEN' : Cookie.read('CSRFTOKEN') },
            onSuccess : function(response)
            {
                if (response && response.status && response.status.code == 10008) { // Not logged in or session timeout
                    RC.handleSessionTimeout();
                    return;
                }

                if (!RC.isEmpty(response) && RC.isTrue(response.reloadLocation)) {
                    RC.reloadLocation();
                    return;
                }

                // todo All responses should have status field!!!
                function logError() {
                    self.logError(self._cmd, params, response, error);
                }

                if (response != null && response.status !== undefined && !response.status.success && self._onError == null) {
                    RC.Loader.hide();
                    self.showErrorMessage(response, false);
                    logError();
                } else {
                    if (response != null && response.status !== undefined && !response.status.success && self._onError != null) {
                        response.status.localizedMessage = RC.utils.Common.getErrorMessage(response);
			            logError();
                        self._onError(response);
                    } else {
                        if (self._onSuccess != null) {
                            if(response.JSESSIONID && window.location.href.match(/;jsessionid=/)) RC.Ajax.setJSessionIdStatic(response.JSESSIONID);
                            self._onSuccess(response);
                        }
                    }
                }
            },
            onFailure : function(xhr) {
                var gatewayTimeoutFailure = 504;
                if (xhr.status == gatewayTimeoutFailure) {
                    RC.Loader.reset();
                    RC.Loader.hide();
                    self.showErrorMessage(xhr, true);
                } else {
                    if (this._onError != null) {
                        this._onError(xhr);
                    }
                }
            },
            onComplete : this._onComplete
        }).post(params);
    },

    /*
     * Logs error details to console
     * @param {String} cmd send to server
     * @param {Object} params send to server
     * @param {Object} response got from server
     * @param {Error} error with stack trace before ajax call
     */
    logError: function (cmd, params, response, error) {
        RC.Console.error("RPC fault on command:", cmd);
        RC.Console.error('request.params:', params);
        RC.Console.error('response:', response);
        RC.Console.error('error.stack:', error && error.stack ? error.stack : 'no error stack');
    },


    /*
     * Show unhandled error message
     * @param {Object} response got from server
     */
    showErrorMessage : function(response, isNetworkError){
        var self = this;
        if (RC.getCmp('CommonErrorWindow') == null) {
            var htmlContent = '';
            if (!isNetworkError) {
                var statusCode = response.status ? response.status.code + '. ' : '';
                htmlContent = '<div style="margin-bottom:30px;">' +
                    '<img src="' + RC.getSkinnedRCLibXImageUrl('img/common/icon-exclamation.gif') + '" alt="" style="float:left;margin:5px 30px 10px 10px;"/>' +
                    statusCode + RC.Lang.Common.REQUEST_NOT_COMPLETED + '</div>';
            } else {
                var supportText = RC.isEmpty(RC.Config.contactSupportURL) ? RC.Lang.Common.CONTACT_SUPPORT : RC.utils.Text.link(RC.Config.contactSupportURL, RC.Lang.Common.CONTACT_SUPPORT, '_blank');
                var errorText = RC.UI.Message(RC.Lang.Common.NETWORK_ERROR[response.status], supportText);
                htmlContent = '<div style="margin-bottom:30px;">' + errorText + '</div>';
            }
            var win = new RC.Window({
                'id'        : 'CommonErrorWindow',
                title       : RC.Lang.Common.ERROR,
                width       : 400,
                html        : htmlContent,
                modal       : true,
                closable    : true,
                buttons     : [
                    {
                        text    : RC.Lang.Common.CLOSE,
                        idSuffix: 'close',
                        handler : function ()
                        {
                            win.close();
                        }
                    }
                ]
            });
            win.show();
        }
    },


    /**
     * Sends an HTTP request to remote server.
     * @param {Object} config The config object
     */
    send : function(config)
    {
        if (config.async !== undefined) this._async = RC.isTrue(config.async);

        if (typeof config.urlEncoded !== 'undefined') this._urlEncoded = RC.isTrue(config.urlEncoded);

        RC.Console.info("RC.Ajax: request will send to new implementation of wrapper.");
        this.setRootUrl("/mobile/api/proxy.html" + RC.Ajax.getJSessionIdStaticFormatted());

        this.setCmd(config.cmd);
        if (config.callback !== undefined) {
            RC.Console.info("RC.Ajax: callback property is deprecated. Use onSuccess, onError to handle response.");
            config.onSuccess = config.callback;
        }
        if (typeof config.onSuccess == 'function') {
            this._onSuccess = config.onSuccess;
        }
        if (typeof config.onError == 'function') {
            this._onError = config.onError;
        }
        if (typeof config.onComplete == 'function') {
            this._onComplete = config.onComplete;
        }
        this.load(config.params === undefined ? null : config.params);
    }
};
(function() {
    var jSessionId = null;
    RC.data.proxy.Ajax.setJSessionIdStatic = function(id) { jSessionId = id; };
    RC.data.proxy.Ajax.getJSessionIdStatic = function() { return jSessionId; };
    RC.data.proxy.Ajax.getJSessionIdStaticFormatted = function() { return jSessionId ? ";jsessionid=" + jSessionId : ""; };
})();

/**
 * @class
 * @name RC.Ajax.Queue
 * Queue of the postponed calls
 * @singleton
 */
RC.data.proxy.Ajax.Queue = {
    /**
     * @ignore
     */
    _items : [],
    /**
     * Adds store to the queue
     * @param {RC.data.Store} store
     * @param {Object} sender
     */
    add : function (store, sender)
    {
        this._items.include({
            store   : store,
            sender  : sender
        });
    },
    /**
     * Fires the queue.
     */
    fire  : function()
    {
        if (this._items.length == 0)
            return;
        for (var i = 0; i < this._items.length; i++) {
            this._items[i].store.load();
        }
        this.clean();
    },
    /**
     * Cleans the queue.
     */
    clean : function()
    {
        this._items = [];
    }
};

// backward compatibility
RC.Ajax = RC.data.proxy.Ajax;


/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?"ActiveX":"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();

/**
 * @class
 * @name RC.data.proxy.Socket
 * @implements RC.Transport
 * The global Ajax request class that provides a simple way to make Ajax requests via web sockets protocol with maximum flexibility.
 *
 * Since RC.data.proxy.Socket is a singleton, you can set common properties/events for it once and override them at the request function level only if necessary.
 * @singleton
 */
RC.data.proxy.Socket = (function ()
{
    var containerId = RC.genId();
    var sSWFObjectID = containerId + "-object";

    var getFlashAddress = function (useFlashUI)
    {
    	var brandName = RC.Config.brandDisplayName;
		if(brandName.indexOf("&") > -1) {
			brandName = brandName.replace("&","amp;"); 
		}
        return '/RCLibX/Socket.swf?ui=' +
            useFlashUI + '&cust=' +
            (RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST || RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST_FLASH_UI) + '&' +
            'host=' + RC.data.proxy.Socket.host + '&' +
            'port=' + RC.data.proxy.Socket.port + '&' +
            'secure=' + RC.data.proxy.Socket.secure + '&' +
            'brandName=' + brandName + '&' +
            'brandId=' + RC.Config.brandId + '&' +
            'locale=' + RC.utils.Lang.getLocaleFromCookie() + '&' +
            'callRecordingAvailable=' + RC.Config.isCallRecordingAvailable;
    };

    var renderSwf = function ()
    {
        var oldProxy = $(sSWFObjectID + '-div');
        if (oldProxy != null) {
            oldProxy.destroy();
        }

        if (!RC.utils.Flash.validateFlashVersion(function() {
            RC.Loader.hide();
        })) {
            return;
        }

        var canvas = new Element('div', {
            'id':containerId
        });
        var widthMovie, heightMovie;
        widthMovie = 97;
        heightMovie = 21;
        var sAlign = "middle";

        new Element('div', {
            id:sSWFObjectID + '-div',
            styles:{
                'position':'absolute',
                'z-index':100500
            }
        }).adopt(canvas).inject(document.body, 'top');

        var oSWFParams = {
            'allowScriptAccess':'always',
            'quality':'high',
            'scale':'noscale',
            'salign':'lt',
            'bgcolor':'#ff0000',
            'menu':'false',
            'wMode':'transparent',
            'pluginspage':RC.utils.Flash.PLUGIN_PAGE
        };

        if (Browser.name === "ie") {
            new Swiff(getFlashAddress(false), {
                'id':sSWFObjectID,
                'width':widthMovie,
                'height':heightMovie,
                'align':sAlign,
                'params':oSWFParams,
                'container':canvas,
                'properties':{
                    'codebase':'http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=11,0,0,0',
                    'name':sSWFObjectID
                }
            });
        } else {
            swfobject.embedSWF(getFlashAddress(false), containerId, "97", "21", "11.0.0", null, {}, oSWFParams, { id:sSWFObjectID });
        }
    };

    var getProxy = function ()
    {
        return $(sSWFObjectID);
    };

    var log = function (message)
    {
        RC.Console.log('RC.data.proxy.Socket: ' + message);
    };

    var onDataArrivedHandler, onExtInterfaceReady, onConnectHandler = null;
    var progressBar, downloadingWin = null;
    var moveIntervalId;
    var totalSizeBytes, downloadedSizeBytes = 0;

    var lastRequest;
    var ioFailCounter = 0;

    var showProgressBar = function ()
    {
        progressBar = new RC.ProgressBar({
            loading:true
        });

        downloadingWin = new RC.MessageBox({
            title: RC.Lang.Common.DOWNLOADING_IN_PROGRESS,
            width:350,
            closeable:true,
            items:[
                progressBar
            ],
            noButtons:true,
            listeners:{
                'close':function ()
                {
                    RC.data.proxy.Socket.close();
                }
            }
        });
    };

    var securityExceptionHandled = false;

    var instance = {

        host:"localhost",
        port:9797,
        secure:true,

        baseNs:'com.ringcentral.web.mobile.api',

        isConnected:false,
        isConnectionBusy:false,
        requestQueue:[],
        connectionQueue:[],

        /**
         * Connects to web socket / renders swf object
         */
        connect:function (fn)
        {
            if (instance.isConnected) {
                fn();
                return;
            } else if (instance.isConnectionBusy) {
                instance.connectionQueue.push(fn);
            }

            onDataArrivedHandler = null;

            onConnectHandler = function ()
            {
                log('Connection has been established');
                instance.isConnected = true;
                instance.isConnectionBusy = false;
                fn();

                for (var i = 0; i < instance.connectionQueue.length; i++) {
                    var callback = instance.connectionQueue[i];
                    callback();
                }
                instance.connectionQueue = [];
            };

            onExtInterfaceReady = function ()
            {
                var proxyHost, proxyPort, policyPort = null;
                if (Cookie.read("WEB_SOCKET_PROXY_HOST") != null) {
                    proxyHost = Cookie.read("WEB_SOCKET_PROXY_HOST");
                }
                if (Cookie.read("WEB_SOCKET_PROXY_PORT") != null) {
                    proxyPort = Cookie.read("WEB_SOCKET_PROXY_PORT");
                }
                if (Cookie.read("WEB_SOCKET_POLICY_PORT") != null) {
                    policyPort = Cookie.read("WEB_SOCKET_POLICY_PORT");
                }
                getProxy().connect(null, policyPort, proxyHost, proxyPort);
                instance.isConnectionBusy = true;
            };

            if ($(containerId) != null) {
                onExtInterfaceReady();
                return;
            }
            renderSwf();
        },

        releaseConnection:function () {
            onDataArrivedHandler = null;
            instance.isConnected = false;
            instance.isConnectionBusy = false;
        },

        /**
         * Call it if you want to close current connection
         */
        close:function ()
        {
            if (instance.isConnected) {
                instance.releaseConnection();
                getProxy().close(false);

                log('Connection has been closed');
            } else {
                throw ('RC.data.proxy.Socket: Connection is not active. You should open connection before using this method.');
            }
        },

        /**
         * Sends command to server via web socket
         * @param params
         */
        send:function (params)
        {
            if (instance.isConnectionBusy) {
                this.requestQueue.push(params);
                return;
            } else {
                instance.isConnectionBusy = true;
            }

            lastRequest = Object.clone(params);
            if (!instance.isConnected) {
                throw ('RC.data.proxy.Socket: Connection is not active. You should call .connect() before using this method.');
            }

            if (params.ns === undefined) {
                throw ('RC.data.proxy.Socket: Namespace is not defined');
            }

            if (params.type === undefined) {
                throw ('RC.data.proxy.Socket: Field type is not defined');
            }

            if (params.request === undefined) {
                throw ('RC.data.proxy.Socket: Field request is not defined');
            }

            var callback = params.callback;
            if (RC.isFunc(callback)) {
                log('Callback function has been assigned');
                onDataArrivedHandler = function (response)
                {
                    ioFailCounter = 0;
                    callback(response);
                    nextRequest();
                }
            } else {
                var closureParams = params;
                onDataArrivedHandler = function (response)
                {
                    ioFailCounter = 0;
                    if (RC.isFunc(closureParams.onSuccess) && response.status.success) {
                        lastRequest = undefined;
                        closureParams.onSuccess(response);
                    }
                    if (RC.isFunc(closureParams.onError) && !response.status.success) {
                        closureParams.onError(response);
                    }
                    nextRequest();
                };
            }

            //params.type = params.cmd;
            params.ns = instance.baseNs + '.' + params.ns;

            delete params.cmd;
            delete params.callback;

            var encodedParams = JSON.encode(params);

            try {
                // send command
                RC.Console.log('Request: %o', encodedParams);
                getProxy().send(encodedParams);
            } catch (E) {
                log(encodedParams);
                log('Cannot send command: ' + E);
            }

            return;
            function nextRequest()
            {
                instance.isConnectionBusy = false;
                if (instance.requestQueue.length != 0) {
                    var req = instance.requestQueue.shift();
                    instance.send(req);
                }
            }
        },

        /**
         * Plays audio file
         * @param messageId
         */
        play:function (messageId, mailboxId, ext)
        {

            var $do = new RC.data.AsyncContext();
            $do(connect);
            $do(send);

            function connect(cb)
            {
                RC.Transport.connect(cb);
            }

            function send()
            {
                getProxy().playSound(JSON.encode({
                    ns:instance.baseNs + '.messages',
                    type:'getMessage',
                    request:{
                        messageIds:[ "" + messageId + "" ],
                        mailboxId:mailboxId
                    }
                }), "message-" + messageId + "." + ext);
            }
        },

        /**
         * Stops playing
         */
        stop:function ()
        {
            getProxy().stopSound();
            instance.close();
        },

        /**
         * Saves file to disk
         * @param {Object} msg
         * @param {Number} mailboxId
         */
        save:function (msg, mailboxId)
        {
            log("Saving file to disk: " + msg.messageId);
            // No queue when saving file to disk, just block multiple simultaneous save attemptes
            if (instance.isConnectionBusy) return;
            instance.isConnectionBusy = true;
            showProgressBar();

            var $do = new RC.data.AsyncContext();
            $do(connect);
            $do(send);

            function connect(cb)
            {
                RC.Transport.connect(cb);
            }

            function send()
            {
                onDataArrivedHandler = function (r)
                {
                    instance.isConnectionBusy = false;
                    if (!r.status.success) {
                        downloadingWin.close();
                        RC.Msg.alert(RC.Lang.Common.Error, RC.Lang.Common.DOWNLOAD_FAILED_MSG);
                        log('Error: ' + r.status.message);
                        return;
                    }
                    progressBar.maxValue = r.lengthInBytes;
                    totalSizeBytes = r.lengthInBytes;
                    var isFax = (msg.type == "messageFax" || msg.type == "Fax");
                    var isText = msg.type == "messageText";
                    var msgExt = r.realExtension || (isText ? "txt" : (isFax ? "tiff" : 'mp3'));
                    getProxy().saveToDisk(JSON.encode({
                        ns:instance.baseNs + '.messages',
                        type:'getMessage',
                        request:{
                            messageIds:[ "" + msg['messageId'] + "" ],
                            mailboxId:mailboxId,
                            saveMsg: true
                        }
                    }), "message-" + RC.utils.Date.formatFileNameTimestamp(r.receivedDate) + "." + msgExt);
                };

                getProxy().send(JSON.encode({
                    ns:instance.baseNs + '.messages',
                    type:'getMessageInfo',
                    request:{
                        messageId:msg['messageId'],
                        type:Wrapper.Enums.MessageType[msg['type']],
                        mailboxId:mailboxId
                    }
                }));
            }
        },
        getDownloadCalllogErrors: function(){
            return {
                CALLLOG_ATTACHMENT_TOO_LARGE : {
                    title : RC.Lang.Common.TOO_MANY_RECORDED_CALLS_TITLE,
                    html : RC.Lang.Common.TOO_MANY_RECORDED_CALLS_TEXT
                },
                DOWNLOAD_TOOK_TOO_MUCH_TIME : {
                    title : RC.Lang.Common.TOO_MANY_RECORDED_CALLS_TITLE,
                    html : RC.Lang.Common.TOO_MANY_RECORDED_CALLS_TEXT
                },
                RECORDING_ABSENCE : {
                    title : RC.Lang.Common.NOTIFICATION,
                    html : RC.Lang.Common.NO_RECORDED_TEXT
                },
                DEFAULT : {
                    title : RC.Lang.Common.NOTIFICATION,
                    width : 400,
                    html : RC.Lang.Common.ERROR_UNDEFINED
                }
            };
        },
        saveCallLog:function (params)
        {
            var downloadRecordings = RC.isTrue(params.recordedCallsDownload);

            showProgressBar();

            var $do = new RC.data.AsyncContext();
            $do(connect);
            $do(send);

            function connect(cb)
            {
                RC.Transport.connect(cb);
            }

            function send()
            {
                if (downloadRecordings){
                    onDataArrivedHandler = function (r) {
                        downloadingWin.close();
                        var downloadErrors = RC.data.proxy.Socket.getDownloadCalllogErrors();
                        var errorOptions = downloadErrors[r.status.errorCode] || downloadErrors.DEFAULT;
                        new RC.WindowAlert(errorOptions.html, errorOptions);
                        log('Error: ' + r.status.message);
                        return;
                    };
                    getProxy().saveToDisk(JSON.encode({
                        ns:instance.baseNs + '.callLog',
                        type:'downloadLogWithRecordings',
                        request:params
                    }), "call-log-" + (new Date()).getTime() + ".zip");

                } else {
                    params.mailboxId = RC.Config.loggedMailboxId;
                    getProxy().saveToDisk(JSON.encode({
                        ns:instance.baseNs + '.callLog',
                        type:'downloadLog',
                        request:params
                    }), "call-log-" + (new Date()).getTime() + ".csv");
                }
            }
        },

        saveGreetings:function (params)
        {

            showProgressBar();

            var $do = new RC.data.AsyncContext();
            $do(connect);
            $do(send);

            function connect(cb)
            {
                RC.Transport.connect(cb);
            }

            function send()
            {
                getProxy().saveToDisk(JSON.encode({
                    ns:instance.baseNs + '.extensions',
                    type:'downloadGreetings',
                    request:params
                }), "Greetings_archive.zip");
            }
        },

        /**
         * Event will be called by falsh side
         */
        onExternalEnterfaceReady:function ()
        {
            if (RC.isFunc(onExtInterfaceReady)) {
                onExtInterfaceReady();
            }
        },

        /**
         * Event will be called when response is ready
         */
        onConnect:function ()
        {
            if (RC.isFunc(onConnectHandler)) {
                onDataArrivedHandler = null;
                onConnectHandler();
            }
        },

        /**
         * Event will be called when response is ready
         * @param o
         */
        onDataArrival:function (o)
        {
            log('Data arrived');
            if (RC.isFunc(onDataArrivedHandler)) {
                var r = JSON.decode(unescape(o));
                RC.Console.log('Response: %o', r.response);
                onDataArrivedHandler(r.response);
            }
        },

        onBinaryDataArrival:function ()
        {
            log((new Date()).toLocaleTimeString() + ' Binary Data arrived');
        },


        SaveToDiskProgress:function (o)
        {
            progressBar.setLoading(false);
            progressBar.setValue(o);
            downloadedSizeBytes = progressBar.getValue();
        },

        SaveToDiskCompleted:function ()
        {
            if (downloadedSizeBytes < totalSizeBytes) {
                return;
            }
            downloadingWin.close();

            RC.Msg.show({
                id:'dlMessage',
                title: RC.Lang.Common.DOWNLOAD_COMPLETED_TITLE,
                closable: true,
                msg: RC.UI.Message(RC.Lang.Common.DOWNLOAD_COMPLETED_TEXT, RC.Lang.Common.SAVE_TO_DISK),
                buttons:[
                    {
                        text: RC.Lang.Common.CANCEL,
                        idSuffix: 'cancel',
                        width:80
                    },
                    {
                        text: RC.Lang.Common.SAVE_TO_DISK,
                        width:80
                    }
                ],
                callback:function ()
                {
                    if (!RC.isEmpty(moveIntervalId))
                    {
                        clearInterval(moveIntervalId);
                    }
                    $(sSWFObjectID + '-div').setStyle('top', '0px');
                    $(sSWFObjectID + '-div').setStyle('left', '0px');
                }
            });
            setTimeout(function () {
                moveIntervalId = setInterval(function ()
            {
                var clone = $(sSWFObjectID + '-div');
                var e = $('dlMessage').getElement('.x-button').getCoordinates();
                clone.setStyle('top', e.top);
                clone.setStyle('left', e.left + 90);
                }, 500);
            }, 200);
        },

        onError:function (o)
        {
            var err = decodeURIComponent(o);
            log("Error: " + err);
            if (securityExceptionHandled) {
                return;
            }
            if (err.indexOf('SecurityError') > 0) {
                securityExceptionHandled = true;
                (new RC.data.proxy.Ajax).send({
                    cmd:'system.switchToFlashUI',
                    useWrapper:true,
                    onSuccess:function ()
                    {
                        document.location.href = '/overview.html';
                    }
                });
                return;
            }
            if (err.indexOf("IOError") != -1) {
                instance.releaseConnection();

                RC.Loader.hide();
                ioFailCounter++;
                if (ioFailCounter == 1) {
                    instance.connect(function ()
                    {
                        instance.send(lastRequest);
                    });
                } else {
                    log("Exceeded number of io failures");
                }
            } else {
                instance.close();
                log("Unknown error occured. You should not see this text.");
            }


            //RC.Msg.alert('Connection failure', 'Cannot connect to server: ' + RC.data.proxy.Socket.host);
        },

        onUserSaveFileStart:function ()
        {
            if (!RC.isEmpty(moveIntervalId))
            {
                clearInterval(moveIntervalId);
            }
            RC.getCmp('dlMessage').close();
            RC.Loader.show({});
        },

        onUserSaveFileComplete:function ()
        {
            if (!RC.isEmpty(moveIntervalId))
            {
                clearInterval(moveIntervalId);
            }
            RC.Loader.hide();
            RC.getCmp('dlMessage').close();
        },

        onUserSaveFileIOError:function (o)
        {
            RC.Loader.hide();
            RC.Msg.alert(RC.Lang.Common.SAVE_FILE_FAILED_MSG, escape(o));
        },

        onUserSaveFileCancel:function ()
        {
            RC.Loader.hide();
        },

        onClose:function ()
        {
            instance.releaseConnection();
        },

        previewFax : function(messageId){
            var dt = new Date();
            window.open(prepareMsgDownloadUrl() +
                    '&msgid=' + messageId +
                    '&type=2' +
                    '&ac=' + dt.getTime() +
                    '&download=2&saveMsg=1', 'previewFaxWindow', 'width=1020,height='+ (window.screen.height-100) +',location=yes,resizable=yes,top=0');
        },
        
        updatePopupTitle: function(popupWin, title){
            function updateDocTitle(){
                if (popupWin && popupWin.document && popupWin.document.readyState === 'complete' && popupWin.location.href !== 'about:blank') {
                    popupWin.document.title = title;
                } else{
                    setTimeout(updateDocTitle, 100);
                }
            }
            try{
            updateDocTitle();
            }catch (e){
                RC.Console.log('updatePopupTitle error.');
            }
        },

        displayMessages:function ()
        {
            var w = window.open(instance.getMessagesSwf(), 'messages', 'width=1020,height=695,location=no,resizable=yes');
            w.onload = function ()
            {
                w.resizeTo(1020, 695);
            };
            
            this.updatePopupTitle(w, RC.Lang.Common.MESSAGES);
            return w;
        },

        getMessagesSwf:function (mailboxId)
        {
            if (RC.Transport.utils.isFlashUI()) {
                instance.host = document.location.host;
                instance.port = 80;
                instance.secure = false;
            }
            var messagesUrl = getFlashAddress(true) + '&folder=0';
            if (!RC.isEmpty(mailboxId)) {
                messagesUrl += '&mailboxId=' + mailboxId;
            }
            return messagesUrl;
        }

    };

    return (instance);
})();

var FlashProxy = RC.data.proxy.Socket;


/**
 * @class
 * @name RC.Button
 * @extends RC.Element
 * @param {Object} config The config object
 * @constructor
 */
RC.Button = function(config) {
    /**
     * @cfg {String} text The text of the button.
     */
    this.text = RC.isEmpty(config.text) ? null : config.text;
    /**
     * @cfg {String} iconLeft The path to icon which will be placed on the button.
     */
    this.iconLeft = RC.isEmpty(config.iconLeft) ? null : config.iconLeft;
    /**
     * @cfg {String} iconLeftDisabled The path to icon which will be placed on the button.
     */
    this.iconLeftDisabled = RC.isEmpty(config.iconLeftDisabled) ? null : config.iconLeftDisabled;
    /**
     * @cfg {String} iconRight The path to icon which will be placed on the button to the rightmost (0 pixels from border) position.
     */
    this.iconRight = RC.isEmpty(config.iconRight) ? null : config.iconRight;
    /**
     * @cfg {String} iconRightDisabled The path to icon which will be placed on the button.
     */
    this.iconRightDisabled = RC.isEmpty(config.iconRightDisabled) ? null : config.iconRightDisabled;
    /**
     * @deprecated
     * @cfg {String} img The path to icon which will be placed on the button.
     */
    this.img = RC.isEmpty(config.img) ? null : config.img;
    if (this.img && !this.iconLeft) this.iconLeft = this.img;
    /**
     * @cfg {Function} handler The callback function which will be called on click.
     */
    this.handler = (typeof config.handler == 'function' ? config.handler : null);
    /**
     * @cfg {Boolean} isSimple Is the button regular or is it used from the other spot like RC.form.Button or Buttons Area
     */
    this.isSimple = RC.isDefined(config.isSimple) ? RC.isTrue(config.isSimple) : true;
    /**
     * @cfg {Boolean} disabled Is the button disabled
     */
    this.disabled = RC.isTrue(config.disabled);
    /**
     * @cfg {Boolean} disabled Is the button disabled
     */
    this.spanValue = RC.isTrue(config.spanValue);
    /**
     * @cfg {Number} width The width of the button.
     */
    this.width = RC.isEmpty(config.width) ? (this.isSimple ? '100%' : '') : config.width;
    /**
     * @cfg {String} withoutSpecialStyle Not allow to apply special styles for SAVE, SUBMIT, etc. buttons
     */
    this.withoutTextBasedStyles = RC.isEmpty(config.withoutTextBasedStyles) ? false : config.withoutTextBasedStyles;

    this.tabindex = config.tabindex || 1;

    this.link = RC.isTrue(config.link);
    this.href = config.href;

    if (this.href) {

        this.handler = function(){

            RC.changeLocation(this.href);

        }.bind(this);

    }

    /**
     * DOM elements
     * @type {Object}
     */
    this.domElements = {
        canvas: null,
        content: null,
        container: null
    };

    // create superclass
    RC.Button.superclass.constructor.call(this, config);

};

RC.extend(RC.Button, RC.Element, {
    _updateimgs: function() {

        this.domElements.canvas.toggleClass('x-button-disabled', this.disabled);

        if (this.iconLeft) {
            this.domElements.canvas.addClass('x-button-iconLeft');
            this.domElements.container.setStyles({'background-image': 'url(' + (this.disabled ? this.iconLeftDisabled : this.iconLeft) + ')'});
        }

        if (this.iconRight) {
            this.domElements.canvas.addClass('x-button-iconRight');
            this.domElements.container.setStyles({'background-image': 'url(' + (this.disabled ? this.iconRightDisabled : this.iconRight) + ')'});
        }

    },
    disable: function() {
        this.disabled = true;
        this._updateimgs();
    },
    enable: function() {
        this.disabled = false;
        this._updateimgs();
    },
    isDisabled: function(){
        return (this.disabled || this.domElements.canvas.hasClass('x-button-disabled'));
    },
    /**
     * Renders element
     * @return {Object} Generated HTMLObject. Also you can use {@link #getDom} to get it.
     */
    render: function() {
        var self = this;

        //TODO Refactor!!!
        switch (this.text) {
            case 'Next >':
            case 'Next &gt;':
            case 'Next &amp;gt;':
                this.text = 'Next';
                break;
            case '< Back':
            case '&amp;lt; Back':
            case '&lt; Back':
                this.text = 'Back';
                break;
        }

        this.domElements.canvas = new Element('table', {
            'id': this.id,
            'cellspacing': 0,
            'cellpadding': 0,
            'tabindex': this.tabindex,
            'styles': {
                'width': this.width
            },
            'html': '<tr><td class="x-button-left"></td>' +
                    '<td id="' + this.id + '-content" class="x-button-fill' + (this.isSimple ? ' x-button-simple-fill' : '') + '">' +
                    (this.isSimple ? '<div><span id="' + this.id + '-simple-content">' + this.text + '</span></div>' : (this.spanValue ? '<span id="' + this.id + '-span-content">' + this.text + '</span>' : this.text)) +
                    '</td>' +
                    '<td class="x-button-right"></td></tr>',
            'class': 'x-button' +
                     (this.isSimple ? ' x-button-simple' : '') +
                     (this.disabled ? ' x-button-disabled' : '') +
                     (this.extraClass ? ' ' + this.extraClass : ''),
            'events': {
                'click': function(e){
                    this.blur();
                    if (self.isDisabled()) return;
                    if (self.handler != null) self.handler.call(self);
                },
                'keyup': function(e){
                    if (e.key == 'enter' || e.key == 'space') {
                        e.stop();
                        this.fireEvent('click', e);
                        return false;
                    }
                }
            }
        });

        this.domElements.container = this.domElements.canvas.getElement('td.x-button-fill');
        this.domElements.content = this.domElements.canvas.getElement(this.isSimple || this.spanValue ? 'td.x-button-fill span' : 'td.x-button-fill');

        if (this.withoutTextBasedStyles === false) {
            var LANG = RC.Lang.Common;

            switch (this.text) {
                case LANG.SAVE:
                case LANG.NEXT:
                case LANG.CONFIRM:
                case LANG.SUBMIT:
                    this.domElements.canvas.addClass('x-btn-gt');
                    break;
                case LANG.BACK:
                    this.domElements.canvas.addClass('x-btn-lt');
                    break;
            }
        }

        if (this.extraStyles) this.domElements.canvas.setStyles(this.extraStyles);
        if (this.link) this.domElements.canvas.addClass('x-button-link');
        if (this.pullLeft) this.domElements.canvas.addClass('x-button-pullLeft');

        if (!this.visible) this.domElements.canvas.setStyle('display', 'none');

        this._updateimgs();

        return this.domElements.canvas;
    },

    /**
     * Sets visibility of the element.
     * @param {Boolean} mode False if you want to hide.
     */
    setVisible: function(mode) {
        if (RC.isTrue(mode))
            this.show();
        else
            this.hide();
    },
    set: function(value, hiddenValue) {
        this.setText(value);
    },
    setText: function(text){
        this.domElements.content.set('html', text);
    }
});

RC.Button.createButton = function(item, id, handler){

    if (item instanceof RC.form.Button || item instanceof RC.Button) return item;

    return new RC.Button({
        id: id,
        text: RC.isDefined(item.value) ? item.value : item.text,
        width: item.width,
        disabled: item.disabled,
        iconLeft: item.iconLeft,
        iconLeftDisabled: item.iconLeftDisabled,
        iconRight: item.iconRight,
        iconRightDisabled: item.iconRightDisabled,
        extraStyle: item.extraStyle,
        extraClass: item.extraClass,
        isSimple: false,
        spanValue: item.spanValue,
        link: item.link,
        href: item.href,
        visible: item.visible,
        tabindex: item.tabindex,
        handler: function(){

            handler.apply(this);

        }
    });

};

RC.reg('button', RC.Button);

/**
 * Non-form equivalent of RC.form.GroupButton
 * Does not require any form be defined before usage
 * @param params
 */
RC.GroupButton = function(params) {

    this.text = params.text || '';
    this.value = params.value || '';
    this.hiddenValue = params.hiddenValue || '';
    this.enabled = RC.isEmpty(params.enabled)?true:params.enabled;
    this.handler = RC.isFunc(params.handler) ? params.handler : function() {};
    this._showArrow = ('showArrow' in params) ? RC.isTrue(params.showArrow) : true; // show arrow by default

    // Whether to use html or text to display values
    this.htmlValues = RC.isTrue(params.htmlValues);

    this.tabindex = params.tabindex || 1;

    // create superclass
    RC.GroupButton.superclass.constructor.call(this, params);

    this.addListener('afterSetValue', function(value) {
        //TODO waiting for remove
        this.domElements.text.toggleClass('x-form-uniformgroup-text-no-value', RC.isEmpty(value));
        this.domElements.value.toggleClass('x-form-uniformgroup-value-empty', RC.isEmpty(value));
    });

};

RC.extend(RC.GroupButton, RC.Element, {
    showArrow: function(show) {
        this.domElements.arrow.setStyle('display', RC.isTrue(show) ? '' : 'none');
    },
    select: function() {
        RC.GroupButton.deselectHelper(this.domElements.canvas);
        if (!this.domElements) return;
        this.domElements.canvas.addClass('x-form-uniformgroup-selected');
    },
    unselect: function() {
        this.domElements.canvas.removeClass('x-form-uniformgroup-selected');
    },
    callHandler: function() {
        return this.handler.apply(this, [this.getValue()]);
    },
    click: function() {
        if (this.domElements.canvas.hasClass('x-form-uniformgroup-disabled')) return false;
        this.select();
        return this.callHandler();
    },
    render: function() {

        var self = this;
        this.domElements = {};

        var canvas = new Element('div', {
            'id': this.id,
            'class': 'x-group-item x-form-uniformgroup ' + (this.extraClass ? this.extraClass : ''),
            'html': function() {

                var html = [];

                html.push('<input type="hidden" id="' + self.id + '-value-hidden" name="' + (self.name || self.id) + '" value="' + (RC.isEmpty(self.hiddenValue) ? '' : self.hiddenValue) + '" />');
                html.push('<div class="x-form-uniformgroup-wrap" tabindex="' + self.tabindex + '">');
                html.push('    <div class="x-form-uniformgroup-cn x-form-uniformgroup-tl">'); //TODO Remove this div
                html.push('        <table class="x-form-uniformgroup-table">');
                html.push('            <tr>');
                html.push('              <td class="x-form-uniformgroup-table-td">');
                html.push('                  <div class="x-form-uniformgroup-value">%value%</div>');
                html.push('                  <div id="' + self.id + '-' + self.name + '-text" class="x-form-uniformgroup-text x-btn-text">%text%</div>');
                html.push('              </td>');
                html.push('            </tr>');
                html.push('        </table>');
                html.push('    </div>');
                html.push('    <div class="x-form-uniformgroup-arrow"></div>');
                html.push('</div>');
                return html.join('');

            }()
        });

        this.domElements.canvas = canvas;
        this.domElements.text = canvas.getElement('div.x-form-uniformgroup-text');
        this.domElements.value = canvas.getElement('div.x-form-uniformgroup-value');
        this.domElements.hiddenValue = canvas.getElement('input[id=' + this.id + '-value-hidden]');
        this.domElements.arrow = canvas.getElement('div.x-form-uniformgroup-arrow');
        this.domElements.wrap = canvas.getElement('div.x-form-uniformgroup-wrap');
        this.domElements.text.set('html', this.text ? this.text : '&nbsp;');
        
        RC.utils.Text.showTitle(this.domElements.text, canvas);
        RC.utils.Text.showTitle(this.domElements.value, canvas);

        canvas.addEvent('click', function(e) {

            self.click();

        });

        this.domElements.wrap.addEvent('keyup', function(e) {
            if (e.key == 'enter' || e.key == 'space') {
                e.stop();
                canvas.fireEvent('click', e);
                return false;
            }
        });

        if (!RC.isEmpty(this.extraStyle))
            canvas.set('style', canvas.get('style') + ';' + this.extraStyle);

        if (!RC.isEmpty(this.extraStyles))
            canvas.setStyles(this.extraStyles);

        if (!RC.isEmpty(this.enabled)) {
            (!this.enabled) && canvas.addClass('x-form-uniformgroup-disabled');
        }

        this.setValue(this.value, this.hiddenValue);
        this.showArrow(this._showArrow);

        if (this.visible !== undefined && !RC.isTrue(this.visible)) {
            canvas.setStyle('display', 'none');
        }

        return canvas;

    },
    getValue: function() {
        if (!this.domElements) return null;
        return this.domElements.hiddenValue.get('value');
    },
    setValue: function(value, hiddenValue) {

        if (!this.domElements) return null;

        if (this.htmlValues) {

            this.domElements.value.set('html', value).set('title', '');

        } else {

            var text = this.cutText(value, this.overflow);

            this.domElements.value.set('text', text.text).set('title', '');

            if (text.title != null) {
                this.domElements.value.set('title', text.title);
            }

        }

        if (!RC.isEmpty(hiddenValue)) {
            this.domElements.hiddenValue.set('value', hiddenValue);
        }

        RC.utils.Text.showTitle(this.domElements.value);

        this.fireListener('afterSetValue', value, hiddenValue);

    },
    setText: function(value) {

        if (!this.domElements) return null;

        this.domElements.text.set('text', value);

        RC.utils.Text.showTitle(this.domElements.text);
    },
    setVisible: function(isVisible) {
        this.domElements.canvas && this.domElements.canvas.setStyle('display', isVisible ? '' : 'none');
    },
    disable: function() {
        this.setEnable(false);
    },
    enable: function() {
        this.setEnable(true);
    },
    setEnable: function(flag) {
        this.domElements.canvas.toggleClass('x-form-uniformgroup-disabled', !flag);
    }
});

/**
 * Removes all known selection classes from GroupButtons or similar
 * TODO This function must be considered as a temporary solution while all 3 similar types of GroupButton exists
 * @param {Element} object Object to track parent panel
 */
RC.GroupButton.deselectHelper = function(object) {

    if (!object) return;
    var panel = object.getParent('.x-panel-canvas, .x-window, .x-panel-helpPanel, .x-collapsable');
    if (!panel) return;

    var selectedClasses = [
        'x-form-uniformgroup-selected',
        'x-group-item-selected',
        'x-form-list-selected',
        'x-form-list-selected-top',
        'x-form-list-selected-bottom'
    ];

    selectedClasses.each(function(className) {
        panel.getElements('.' + className).removeClass(className);
    });

};

RC.reg('x-groupbutton', RC.GroupButton);

/**
 * Implements rendering of div's html object
 *
 * @class
 * @name RC.Div
 * @extends RC.Element
 * @constructor
 * @param {Object} config The config object
 */
RC.Div = function(config)
{
    /**
     * @cfg {String} html
     * Content of the element
     */
    RC.apply(this, config);
    this.html = config.html;
    //node in div
    // todo rename/refactor? it's not node, it's child
    /**
     * @cfg {Object} node
     * Element which will be inserted into this DIV 
     */
    this.node = config.node && config.node.nodeName ? config.node : null;
    /**
     * @cfg {String} aBackground
     * @todo Move to activeStyle definition
     */
    this.aBackground = RC.isEmpty(config.aBackground) ? null : config.aBackground;

    this.isAssistance =  !RC.isEmpty(config.isAssistance) ? !!config.isAssistance : false;

    this.items = !RC.isEmpty(config.items) ? config.items : [];

    this.id = RC.genPrefixedId({id: config.id, idFromText: 'div'});
    // calling parent constructor
    RC.Div.superclass.constructor.call(this, config);

    /**
     * @cfg {String} hintText
     * Content of the tool tip aka (i)
     */
    this.hintText = config.hintText || "";

    /**
     * @cfg {String} hintText
     * Content of the tool tip aka (i)
     */
    this.isError = !!config.isError;

    this.canvas = null;

    this.addEvents('click');
};

RC.extend(RC.Div, RC.Element, {
    render : function()
    {
        var self = this;

        var html = this.html;

        // todo what is it?
        if (this.img != null) {
            var imageHtml = '<img src="' + this.img + '" alt=""/>';
            var imageStyle = "margin: auto; vertical-align: middle;";
            var textStyle = '';
            for (var s in this.bodyStyle) {
                if (s.indexOf('padding') == -1) {
                    textStyle += s + ': ' + this.bodyStyle[s] + ';';
                }
            }
            if (this.img_align == "left") {
                html = '<table><tr><td style="' + imageStyle + '">' + imageHtml + '</td><td style="' + textStyle + '">' + html + '</td></tr></table>';
            } else {
                html = '<table><tr><td style="' + textStyle + '">' + html + '</td><td style="' + imageStyle + '">' + imageHtml + '</td></tr></table>';
            }
        }
        var canvas = new Element('div', {
            'id'    : this.id,
            'class' : 'userDetailsPane ' +
                      (self.extraClass ? self.extraClass : '') +
                      (self.isAssistance ? ' x-div-assistanceText' : '') +
                      (self.isError ? ' x-div-error' : ''),
            'html'  : !RC.isMooElement(html) ? html : '',
            'styles' : this.extraStyles,
            'events' : {
                'click': function(e)
                {
                    if (self.hasListener('click')) {
                        var res = self.fireListener('click', e);
                        if (res !== false && self.aBackground != null) {
                            $$('div.userDetailsPane').each(function(item)
                            {
                                RC.getCmp(item.id) && RC.getCmp(item.id).highlight(false);
                            });
                            self.highlight(true);
                        }
                    }
                }
            }
        });

        this.canvas = canvas;

        this.setVisible(this.visible);

        if(this.hintText){
            new RC.form.ToolTip({
                render  : canvas,
                text    : this.hintText,
                id : this.id + '-toolTip'
            });
        }

        if (!RC.isEmpty(this.extraStyle)) {
           canvas.set('style', canvas.get('style') + ';' + this.extraStyle);
        }

        // todo remove it
        if (this.node) {
            this.node.inject(canvas);
        }

        if (RC.isMooElement(html)) {
            html.inject(canvas);
        }

        var img = null;
        // preload background image for active state
        if (this.aBackground) {
            img = new Image();
            img.src = this.aBackground;
        }

        return canvas;
    },

    setText : function(text) {
        var self = this,
            canvas = $(self.id) || self.canvas,
            hintEl;
        if(canvas) {
            hintEl = canvas.getElement('#' + self.id + '-toolTip');
            canvas.set('html', text);
            hintEl && canvas.adopt(hintEl);
        }
    },

    /**
     * true/false
     * @param isActive
     */
    highlight : function(isActive)
    {
        var fxEffect = new Fx.Tween(this.id);
        if (isActive) {
            if (this.aBackground != null) {
                $(this.id).addClass('x-custom-left-panel-text-active');
                fxEffect.set('background', 'url(' + this.aBackground + ') left top no-repeat');
            }
        } else {
            if (this.extraStyles != null && this.extraStyles.background !== undefined) {
                $(this.id).removeClass('x-custom-left-panel-text-active');
                fxEffect.set('background', this.extraStyles.background);
            }
        }
    },
    setVisible: function(isVisible){
        this.canvas.toggleClass('x-div-hidden', !isVisible);
    }
});

RC.reg('div', RC.Div);


/**
 * @class
 * @name RC.Title
 * @extends RC.Div
 * @constructor
 * @param {Object} config The config object
 */
RC.Title = function(config)
{
    config.extraClass = 'x-div-title ' + (config.extraClass ? config.extraClass : '');
    if (config.smallHtml && typeof config.html == 'string') config.html += '<br><small class="x-div-title">' + config.smallHtml + '</small>';
    RC.Title.superclass.constructor.call(this, config);
};

RC.extend(RC.Title, RC.Div, {});
RC.reg('title', RC.Title);


/**
 * A specialized panel intended for use as an application window.
 *
 * @class
 * @name RC.Window
 * @extends RC.utils.Observable
 * @constructor
 * @param config The config object
 * @xtype window
 */
RC.Window = function(config)
{
    /**
     * @cfg {String} title
     * Title of the window
     */
    this.title = RC.isEmpty(config.title) ? null : config.title;
    this.showTitle = RC.isEmpty(config.showTitle) ? true : !!config.showTitle;

    // data-attribure for QA
    this['data-titlewindow'] = RC.isEmpty(config['data-titlewindow']) ? null : config['data-titlewindow'];

    // items which will be placed in this container
    var bEmptyItems = config.items === undefined || config.items.length == 0;

    this.noVerticalPadding = !!config.noVerticalPadding || false;
    this.noHorizontalPadding = !!config.noHorizontalPadding || false;

    /**
     * @cfg {Array} items
     * Array of item which will be rendered inside the window
     */
    this.items = (bEmptyItems ? [] : config.items);
    if (bEmptyItems) {
        // cards with items ()
        if (config.cards === undefined || config.cards.length == 0) {
            this.cards = null;
        } /*
         We can have only 1 card (without breadcrumbs) with many items
         else if (config.cards.length == 1) {
         this.cards = null;
         this.items = config.cards[0].items;
         } */
        else {
            this.cards = config.cards;
            this.selectedCard = 0;
            this.title = this.cards[0].caption;
        }
    }
    /**
     * @cfg {Array} buttons
     * Buttons which will be placed in this container
     */
    this.buttons = (config.buttons !== undefined && config.buttons.length > 0 ? config.buttons : []);
    /**
     * @cfg {String} id
     * ID of the component
     */
    this.id = RC.genPrefixedId({id: config.id, idFromText: this.title});

    //modal
    this.modal = config.modal === undefined ? true : config.modal;
    //draggable
    this.draggable = config.draggable === undefined ? false : config.draggable;
    // width
    this.width = config.width === undefined ? 400 : config.width;
    // height
    this.height = config.height === undefined ? 50 : config.height;
    // navigation controls
    this.navigation = config.navigation === undefined ? null : config.navigation;
    // window status
    this.status = 0;
    // window subheader
    this.subheader = config.subheader === undefined ? null : config.subheader;

    this.top = config.top === undefined ? (RC.Config.userSeparationUIEnabled ? 142 : 148) : config.top;
    this.left = config.left;
    this.right = config.right;

    this.learnMore = config.learnMore || null;
    this.buttonsCentered = RC.isTrue(config.buttonsCentered);
    this.buttonsVisible = RC.isEmpty(config.buttonsVisible)?true:config.buttonsVisible;
    /**
     * @cfg {String} closeAction
     * The action to take when the close header tool is clicked:
     * 'close' : Default
     remove the window from the DOM and destroy it and all descendant Components. The window will not be available to be redisplayed via the show method.
     * 'hide' :
     hide the window by setting visibility to hidden and applying negative offsets. The window will be available to be redisplayed via the show method.
     *  Note: This setting does not affect the close method which will always destroy the window. To programatically hide a window, call hide.
     */
    this.closeAction = 'close';

    // html content
    this.html = config.html === undefined ? null : config.html;
    this.extraBodyStyle = config.extraBodyStyle === undefined ? null : config.extraBodyStyle;
    this.closable = RC.isTrue(config.closable);
    this.onClose = typeof config.onClose == 'function' ? config.onClose : null;
    this.extraClass = config.extraClass || "";
    RC.Window.zIndex += 3; // window and background
    this.zIndex = RC.Window.zIndex;
    RC.Window.superclass.constructor.call(this, config);

    this._historyStackOfMultiItems = [];

    // store of the DOM
    this._dom = null;
    this.domElements = {};

    // possible events
    this.addEvents(
        /**
         * @event show
         * Fires after the component is shown when calling the show method.
         * @param {RC.Window} this
         */
        'show',
        /**
         * @event hide
         * Fires after the component is hidden
         * @param {RC.Window} this
         */
        'hide',
        /**
         * @event render
         * Fires after the component markup is rendered.
         * @param {RC.Element} this
         */
        'render',

        'onChangedCard'
    );

    this.previousActiveElement = null;

    this.addListener('show', function(){
        this.previousActiveElement = document.activeElement;
        var isDocumentBody = this.previousActiveElement == document.body;
        if (!isDocumentBody && this.previousActiveElement && this.previousActiveElement.blur) this.previousActiveElement.blur();
    });

    this.addListener('hide', function(){
        if (this.previousActiveElement && this.previousActiveElement.focus) this.previousActiveElement.focus();
    });

};

RC.Window.zIndex = 100;
RC.Window.lastId = '';

RC.extend(RC.Window, RC.utils.Observable, {
    hideBreadcrumbs: function()
    {
        $(this.id + '-cardslayout').setStyle('display', 'none');
    },
    showBreadcrumbs: function()
    {
        $(this.id + '-cardslayout').setStyle('display', 'block');
    },
    /**
     * Returns {@link #title} of the window
     * @return {String}
     */
    getTitle : function()
    {
        var titleObj = $(this.id + '-title-label');
        if (RC.isEmpty(titleObj)) {
            titleObj = $(this.id + '-title');
        }
        return titleObj.get('html');
    },
    /**
     * Set {@link #title} of the window
     * @param {String} title
     */
    setTitle : function(title)
    {
        var titleObj = $(this.id + '-title-label');
        if (RC.isEmpty(titleObj)) {
            titleObj = $(this.id + '-title');
        }
        if (titleObj) titleObj.set('html', title);
    },
    /**
     * Returns the {@link #id} of this component.
     * @return {String}
     */
    getItemId : function()
    {
        return this.id;
    },
    removeLearnMore: function(){
        this.setLearnMore(null);
    },
    setLearnMore: function(handler){

        var self = this;
        self.learnMore = handler;

        self.itemLearnMore.empty();

        if (self.learnMore) {
            new Element('a', {
                id    : this.id + '-learnMore',
                'class': 'x-learnMore',
                html: RC.Lang.Common.WINDOW_LEARMORE,
                href: '#',
                events: {
                    click: function(e)
                    {
                        e.stop();
                        self.learnMore();
                        return false;
                    }
                }
            }).inject(self.itemLearnMore);
        }

    },

    setZIndex: function(zIndex) {
        this.zIndex = zIndex;
        this.domElements.canvas && this.domElements.canvas.setStyles({zIndex: zIndex});
        this.domElements.background && this.domElements.background.setStyles({zIndex: zIndex - 2});
        this.domElements.cards && this.domElements.cards.setStyles({zIndex: zIndex - 1});
    },

    /**
     * Renders the window
     * @return {Object} HTML object of generated component
     */
    render : function()
    {
        var parent = document.body;

        var canvas = new Element('div', {
            'id'      : this.id,
            'data-titlewindow': this['data-titlewindow'],
            'class'   : 'x-window ' + (this.draggable ? 'x-window-draggable ' : '') + this.extraClass,
            'styles': {
                'width' : this.width + 'px',
                'z-index': this.zIndex
            }
        });

        RC.Window.lastId = this.id;

        var self = this;

        if (this.navigation != null) {
            var navi = new Element('table', {
                cellspacing : 0,
                cellpadding : 0,
                align       : 'center',
                html : '<tbody></tbody>'});
            var naviTr = new Element('tr');
            if (this.navigation.backward !== undefined && RC.isTrue(this.navigation.backward.visible)) {
                new Element('td', {
                    'html'  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/navigate-left-arrow.gif') + '" alt="" />',
                    'class': 'x-window-navigation-backward',
                    events : {
                        'click' : function()
                        {
                            if (typeof self.navigation.backward.handler == 'function')
                                self.navigation.backward.handler();
                        }
                    }
                }).inject(naviTr);
            }


            if (self.showTitle) {
                new Element('td', {
                    'id': self.id + '-title-label',
                    'html': self.title,
                    'class': 'x-window-title-label'
                }).inject(naviTr);
            } else {
                new Element('td', {
                    width: "100%",
                    html: '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/empty.png') + '" alt="" />',
                    'class': 'x-window-top'
                }).inject(naviTr);
            }

            if (this.navigation.forward !== undefined && RC.isTrue(this.navigation.forward.visible)) {
                new Element('td', {
                    'html'  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/navigate-right-arrow.gif') + '" alt="" />',
                    'class': 'x-window-navigation-forward',
                    events : {
                        'click' : function()
                        {
                            if (typeof self.navigation.forward.handler == 'function')
                                self.navigation.forward.handler();
                        }
                    }
                }).inject(naviTr);
            }

            naviTr.inject(navi.getElement('tbody'));
        }

        var myDrag = undefined;

        var table = new Element('table', {
            cellspacing : 0,
            cellpadding : 0,
            width       : '100%',
            //html : '<tbody></tbody>'});
            html : '<tbody></tbody>',
            events: {
                mousedown: function (t) {

                    //TODO Make it better
                    if (self.id !== RC.Window.lastId && (self.draggable || !self.modal)) {

                        var lastWindow = RC.getCmp(RC.Window.lastId);

                        if (lastWindow) {

                            var currentZIndex = self.zIndex,
                                topZIndex = lastWindow.zIndex;

                            self.setZIndex(topZIndex);
                            lastWindow.setZIndex(currentZIndex);

                            RC.Window.lastId = self.id;

                        }

                    }

                    if (myDrag !== undefined && allowDrag(t)) {
                        myDrag.attach();
                    }
                },
                mouseup: function (t) {
                    if (myDrag !== undefined && allowDrag(t)) {
                        myDrag.detach();
                    }
                }
            }
        });

        function allowDrag(t) {
            var node = String.toUpperCase(t.target.nodeName);
            return ['TEXTAREA', 'INPUT', 'SELECT', 'BUTTON'].indexOf(node) == -1;
        }

        var oTitle = '<div id="' + self.id + '-title-label" class="x-window-title-caption">' + (RC.isEmpty(self.title) ? '&nbsp;' : self.title) + '</div>';

        var titleBlock = new Element('td', {
            id: this.id + '-title',
            'class': 'x-window-title',
            style: self.showTitle ? undefined : 'display:none',
            width: "100%",
            html: (this.navigation == null ? oTitle : '')
        });


        var topBlock = new Element('td', {
            width: "100%",
            style: self.showTitle ? 'display:none': undefined,
            html: '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/empty.png') + '" alt="" />',
            'class': 'x-window-top'
        });


        var tr = new Element('tr');
        new Element('td').adopt(
            new Element('table', {
                cellspacing : 0,
                cellpadding : 0,
                width        : "100%"
            }).adopt(new Element('tbody').adopt(new Element('tr').adopt(new Element('td', {}), titleBlock, topBlock, new Element('td', {}))))
        ).inject(tr);
        tr.inject(table.getElement('tbody'));

        var titleTD = tr.getElement('.x-window-title');

        new Element('div', {
            id    : this.id + '-learnMore-container',
            'class': 'x-window-learnMore-container',
            'html': ''
        }).inject(titleTD, 'top');

        if (self.closable) {

            new Element('div', {
                'class': 'x-window-close',
                'id': self.id + '-close-but',
                'html': '&#160;',
                'events': {
                    'click': function(e) {
                        e.stop();
                        self.close();
                    }
                }
            }).inject(titleTD, 'top');

        }

        self.itemLearnMore = titleTD.getElement('div.x-window-learnMore-container');
        self.setLearnMore(self.learnMore);

        // insert navigation bar
        if (this.navigation != null) {
            navi.inject(table.getElements('td[id=' + this.id + '-title]')[0]);
        }

        tr = new Element('tr');
        var content = new Element('td', {
            id    : this.id + '-content',
            'class': 'x-window-content',
            styles : {
                'height': this.height + 'px'
            }
        }).inject(tr);
        this.domElements.content = content;
        this.domElements.canvas = canvas;
        tr.inject(table.getElement('tbody'));

        if (this.noVerticalPadding || this.noHorizontalPadding) {

            var className = '';
            if (this.noVerticalPadding) className += ' x-window-noVerticalPadding';
            if (this.noHorizontalPadding) className += ' x-window-noHorizontalPadding';

            canvas.addClass(className);

        }

        if (this.extraBodyStyle != null)
            content.set('style', content.get('style') + ';' + this.extraBodyStyle);

        table.inject(canvas);

        if (this.modal === undefined || this.modal) {
            //create background
            var backgroundDiv = new Element('div', {
                'id'        : this.id + '-background',
                'class'     : 'x-window-background',
                'styles': {
                    'z-index': this.zIndex - 2
                }
            }).inject(parent, 'top');

            if (Browser.ie8) {
                new Element('iframe', {
                    'scrolling': 'no',
                    'frameborder': 'no',
                    'class': 'x-window-background-iframe'
                }).inject(backgroundDiv, 'top');
            }
            self.domElements.background = backgroundDiv;
        }

        //create cards if any
        this.redrawBreadCrumbs();

        canvas.inject(parent, 'top');

        var spacerIdx = 0;

        if (!RC.isEmpty(this.html)) {
            new Element('div', {
                html : this.html
            }).inject(content);
        }

        // parse and render all child
        if (this.cards == null) {
            this.items.each(function(item)
            {
                if (!item) {
                    return;
                }
                if (item == '-' || item.xtype == 'spacer') {
                    if (item == '-') {
                        item = {
                            id    : 'wsp' + spacerIdx,
                            xtype : 'spacer'
                        }
                        spacerIdx++;
                    }
                    new Element('div', {
                        'id'     : RC.genId(item),
                        'html'   : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>',
                        'styles' : {
                            'margin': '15px 4px'
                        }
                    }).inject(content);
                    RC.ComponentMgr.register(item);
                } else {
                    var o = RC.createComponent(item);
                    if (o != null)
                        o.display(content);
                }
            });
        } else {
            try {
                for (var iCardIndex = 0; iCardIndex < this.cards.length; iCardIndex++) {
                    var bSelected = this.selectedCard == iCardIndex;
                    var cardPane = new Element('div', {
                            'id'    : self.id + '-card' + iCardIndex,
                            styles : {
                                'display': (bSelected ? 'block' : 'none')
                            }
                        }
                    ).inject(content);
                    if (!this.cards[iCardIndex].multiItems) {
                        this.cards[iCardIndex].items.each(function(item)
                        {
                            if (item == '-' || item.xtype == 'spacer') {
                                if (item == '-') {
                                    item = {
                                        id    : 'wsp' + spacerIdx,
                                        xtype : 'spacer'
                                    };
                                    spacerIdx++;
                                }
                                new Element('div', {
                                    'id'     : RC.genId(item),
                                    'html'   : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>',
                                    'styles' : {
                                        'margin': '15px 4px'
                                    }
                                }).inject(cardPane);
                                RC.ComponentMgr.register(item);
                            } else {
                                var o = RC.createComponent(item);
                                if (o != null)
                                    o.display(cardPane);
                            }
                        });
                    } else {
                        this.cards[iCardIndex].multiItems.each(function(multiItem, multiItemIndex)
                        {
                            self.renderMultiItem(iCardIndex, multiItemIndex, multiItem).inject(cardPane);
                        });
                    }
                }
            } catch(e) {
                RC.Console.warn(e)
            }
        }

        // parse buttons if need
        if (this.buttons != null && this.buttons.length > 0) {
            var btnCanvas = new Element('table', {
                'id'     : this.id + '-buttons',
                'class'  : 'x-buttons-area' + (this.buttonsCentered ? ' x-buttons-area-centered' : ''),
                'style'  : RC.isFalse(this.buttonsVisible)?'display:none':'',
                'html'   : '<tr><td class="x-buttons-area-container"></td></tr>'
            });
            var coHTML = btnCanvas.getElement('td');
            this.buttons.each(function(item)
            {
                var o;
                var extraClass = typeof item.extraClass == 'string' ? " " + item.extraClass : "";
                var isVisible = RC.isEmpty(item.visible) ? true : RC.isTrue(item.visible);
                if (item.xtype == 'space') {
                    o = new Element('table', {
                        'width' : item.width,
                        'cellspacing' : 0,
                        'cellpadding' : 0,
                        'styles' : {
                            'float' : 'left'
                        },
                        html : '<tbody><tr><td>&#160;</td></tr></tbody>'
                    });
                } else if (item.xtype == 'link') {
                    o = new Element('a', {
                        'id' : RC.genPrefixedId({id: item.id, idFromText: item.text, prefix: self.id}),
                        'href' : 'javascript:',
                        'html' : item.text,
                        'styles' : {
                            'float'  : 'left',
                            'width'  : item.width
                        },
                        'events': {
                            'click': function()
                            {
                                if (item.handler != null)
                                    item.handler(self);
                            }
                        }
                    });
                } else {
                    if (item.width) item.width = undefined; // In legacy implementation width is passed as a HTML property
                    o = RC.Button.createButton(item,
                                               RC.genPrefixedId({
                                                   //id: item.id ? item.id : item.idSuffix,
                                                   id: item.id ,
                                                   idFromText: item.text,
                                                   prefix: self.id
                                               }), function() {
                                                    if (item.handler != null) item.handler.call(this, self);
                                                }
                    ).compile();
                }
                if (item.width !== undefined) {
                    o.width = item.width;
                }
                if (!isVisible) {
                    o.addClass('x-hidden');
                }
                o.inject(coHTML);
            });
            btnCanvas.inject(self.id + '-content');
        }

        this._dom = parent;

        if(this.draggable) {
            myDrag = new Drag(this.id);
            myDrag.detach();
        }

        this.fireListener('render');
    },

    renderMultiItem : function(iCardIndex, multiItemIndex, multiItem)
    {

        var multiItemPanel = new Element('div', {
            'id'    : this.id + '-card' + iCardIndex + '-multiItem' + multiItemIndex,
            styles : {
                'display': (!multiItemIndex ? 'block' : 'none')
            }
        });
        $each(multiItem, function(item)
        {
            var o = RC.createComponent(item);
            if (o != null)
                o.display(multiItemPanel);
        });
        return multiItemPanel;

    },
    _resizeEvent: null,
    show : function(nobackground)
    {
        var self = this;
        if (this.status == 0) {
            // check render status
            if ($(this.id + '-background') == null)
                this.render();

            if (nobackground === undefined || !nobackground) {
                if ($(this.id + '-background'))
                    $(this.id + '-background').setStyle('display', 'block');
            }

            if ($(this.id)) $(this.id).setStyle('display', 'block');

            if (this.cards != null) {
                $(this.id + '-cardslayout').setStyle('display', 'block');
            }

            this.status = 1;

            this.doAlign('top');
            this._resizeEvent = function(){
                self.updateOnResize();
            };

            if(!this.draggable) {
                window.addEvent('resize', this._resizeEvent);
            }

            this.fireListener('show');
        }
    },

    close : function()
    {
        if (this.onClose != null){
            var continueClosing = this.onClose.apply(this, arguments);
            if (continueClosing === false){
                return;
            };
        }
        this.destroy();
        this.fireListener('hide');
        this.fireListener('close');
    },

    //DT
    displayWin : function(flg, nobackground, silent)
    {
        if ($(this.id) != null) {
            $(this.id).setStyle('display', RC.isTrue(flg) ? 'block' : 'none');
            if ($(this.id + '-background')) $(this.id + '-background').setStyle('display', RC.isTrue(flg && !nobackground) ? 'block' : 'none');
            if ($(this.id + '-cardslayout')) $(this.id + '-cardslayout').setStyle('display', RC.isTrue(flg) ? 'block' : 'none');
            if (!silent) this.fireListener(flg ? 'show' : 'hide');
        }
    },


    setCloseButtonVisible : function(flg)
    {
        var node = $(this.id + "-close-but");
        if (node) {
            node.setStyle("visibility", !!flg ? "visible" : "hidden");
        }
    },


    isVisible : function()
    {
        return $(this.id) && $(this.id).getStyle('display') == 'block'
    },

    setVisible : function(visible)
    {
        var node = $(this.id);
        if (node){
            node.setStyle('display', RC.isTrue(visible) ? 'block' : 'none');
        }
    },


    /**
     * Hides the window. Will be removed. Use {@link #close} instead of.
     */
    hide : function()
    {
        this.close();
    },

    /**
     * Destroys object from the DOM and unregister them.
     */
    destroy : function()
    {
        if ($(this.id + '-background')) $(this.id + '-background').destroy();
        if ($(this.id)) $(this.id).destroy();
        if (this.cards != null && $(this.id + '-cardslayout')) {
            $(this.id + '-cardslayout').destroy();
        }
        window.removeEvent('resize', this._resizeEvent);
        this.fireListener('destroy');
        RC.ComponentMgr.unregister(this);
    },
    updateOnResize: function(){

        var direction = this._lastDirection;
        var windowWidth = document.documentElement.clientWidth;
        var windowHeight = document.documentElement.clientHeight;

        if (!$(this.id)) return;

        var coord = $(this.id).getCoordinates();
        var popupWidth = coord.width;
        var popupHeight = coord.height;
        var scroll = 0;

        //if (!Browser.name === "ie")     /*UIA-1357*/
        if (RC.isFunc(document.body.getScroll) && RC.isObject(document.body.getScroll()) && document.body.getScroll().y) scroll = document.body.getScroll().y;

        var popupTop = this.top;
        if(this.extraClass == 'x-calendar'){
            popupTop = (windowHeight / 2 - popupHeight / 2) + scroll;
        }

        var dx = 0;
        if (RC.isDefined(direction)) {
            if (direction == 'left') {
                dx = - popupWidth / 2 - 10;
            } else if (direction == 'right') {
                dx = popupWidth / 2 + 10;
            }
        }
        if (popupTop < 0) popupTop = 0;

        var pos = {
            "position": "absolute",
            "top": popupTop
        };

        if(this.left !== undefined) {
            pos.left = this.left;
        } else if(this.right !== undefined) {
            pos.right = this.right;
        } else {
            pos.left = windowWidth / 2 - popupWidth / 2 + dx;
        }

        $(this.id).setStyles(pos);

        //cards layout
        if (this.cards != null) {
            var oCardsLayout = $(this.id + '-cardslayout');
            var cardsCoord = oCardsLayout.getCoordinates();

            oCardsLayout.setStyles({
                "position": "absolute",
                "top": popupTop - 51,
                "left": windowWidth / 2 - cardsCoord.width / 2 + dx
            });
        }

        if (RC.isDefined(direction) && 'top' == direction && this.extraClass != 'x-calendar') {
            new Fx.Scroll($(document.body)).toTop();
        }
    },
    _lastDirection: null,
    /**
     * Alignment the window to selected direction
     * @param direction (optional) The direction of the alignment. Default to <tt>center</tt>.
     */
    doAlign : function(direction)
    {
        this._lastDirection = direction;
        this.updateOnResize();
    },

    /**
     * Set window width to the width of it's content
     */
    fitWidth: function(){
        if (this._dom) {
            var contentWidth = $(this.domElements.canvas.firstChild).getWidth();
            this.setWidth(contentWidth);
        }
    },

    /**
     * Alignment the window in the viewport to center. Shortcut of {@link #doAlign} with direction <tt>center</tt>
     */
    center : function()
    {
        this.doAlign('center');
    },

    /**
     * Navigate to next card when 'cards' is used.
     */
    nextCard: function ()
    {
        if (this.cards != null) {
            var bCanGoForward = this.selectedCard < this.cards.length - 1;
            if (bCanGoForward) {
                this.selectCard(this.selectedCard + 1);
            }
        }
    },

    /**
     * Navigate to previous card when 'cards' is used.
     */
    previousCard: function ()
    {
        if (this.cards != null) {
            var bCanGoBack = this.selectedCard > 0;
            if (bCanGoBack) {
                this.selectCard(this.selectedCard - 1);
            }
        }
    },

    /**
     * Gets current card index
     * @return {Integer} Card index
     */
    getActiveCard : function()
    {
        return this.selectedCard;
    },

    /**
     * Activate the card by index.
     * @param {Number} selectIndex
     */
    selectCard: function (selectIndex)
    {

        if (this.cards != null) {
            if (selectIndex >= 0 && selectIndex < this.cards.length) {

                this.selectedCard = selectIndex;
                this.setTitle(this.cards[selectIndex].caption);
                this.fireListener("onChangedCard", selectIndex);

                for (var iCardIndex = 0; iCardIndex < this.cards.length; iCardIndex++) {
                    var bSelected = selectIndex == iCardIndex;
                    //change card buttons
                    var oCardButton = $(this.id + '-cardslayout-cardbutton' + iCardIndex);
                    var oCard = $(this.id + '-x-window-card' + iCardIndex);
                    oCard.removeClass('x-window-card-selected');
                    if (bSelected) {
                        oCard.addClass('x-window-card-selected');
                    }

                    // - change index picture
                    var oCardNumber = oCardButton.firstChild;

                    // - change text
                    var oCardText = oCardButton.getLast();
                    var oCardPane = $(this.id + '-card' + iCardIndex);
                    oCardText.className = (bSelected ? 'x-window-card-index-sel' : 'x-window-card-index-nsl');

                    //display/hide corresponding pane
                    if (oCardPane) oCardPane.setStyle('display', (bSelected ? 'block' : 'none'));

                }
                this.redrawBreadCrumbs();
            }
        }

    },

    /**
     * Redraw breadcrumbs
     */
    redrawBreadCrumbs : function ()
    {
        if (this.cards != null) {
            var cardsCanvas = null;
            if ($(this.id + '-cardslayout')) {
                cardsCanvas = $(this.id + '-cardslayout');
                cardsCanvas.empty();
            } else {
                cardsCanvas = new Element('div', {
                    'id' : this.id + '-cardslayout',
                    'class' : 'x-window-cards-layout',
                    'styles' : {
                        'z-index': this.zIndex - 1,
                        'display': 'block'
                    }
                }).inject(document.body, 'top');
            }
            this.domElements.cards = cardsCanvas;
            var table = new Element('table', {
                cellspacing : 0,
                cellpadding : 0,
                //width       : '100%',
                html : '<tbody></tbody>',
                styles: {
                    margin: '0 auto'
                }
            });
            this.cards.length == 1 && table.setStyle("display", 'none');
            var tr = new Element('tr')
            tr.inject(table.getElement('tbody'));

            new Element('td', {
                html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/popup/cards_left.png') + '" alt="" style="display: block;"/>',
                'class': 'x-window-card-cell'
            }).inject(tr);

            //create each tab
            var cardDisplayNumber = 0;
            var displayCardLength = 0;
            var displayIndex=0;
            var iCardIndex = 0
            var cardsRightFlag = true;
            for (iCardIndex = 0; iCardIndex < this.cards.length; iCardIndex++) {
                if(RC.isEmpty(this.cards[iCardIndex].visible) || RC.isTrue(this.cards[iCardIndex].visible)){
                    displayCardLength++;
                }
            }
            var cardLastIndex = this.cards.length - 1;
            for (iCardIndex = (this.cards.length - 1); iCardIndex > 0 ; iCardIndex--) {
                var cardVisible = (RC.isEmpty(this.cards[iCardIndex].visible) || RC.isTrue(this.cards[iCardIndex].visible));
                if(RC.isTrue(cardVisible)){
                    cardLastIndex = iCardIndex;
                    break;
                }
            }
            for (iCardIndex = 0; iCardIndex < this.cards.length; iCardIndex++) {
                var bSelected = iCardIndex == this.selectedCard;
                var cardVisible = bSelected || (RC.isEmpty(this.cards[iCardIndex].visible) || RC.isTrue(this.cards[iCardIndex].visible));
                cardVisible && cardDisplayNumber++;
                if(RC.isEmpty(this.cards[iCardIndex].visible) || RC.isTrue(this.cards[iCardIndex].visible)){
                    displayIndex++;
                }
                var tdCard = new Element('td', {
                    'class' : 'x-window-card' +
                        (cardDisplayNumber == 1 ? ' x-window-card-first' : '') +
                        (iCardIndex == cardLastIndex ? ' x-window-card-last' : '') +
                        (bSelected ? ' x-window-card-selected' : ''),
                    'id': this.id + '-x-window-card' + iCardIndex,
                    'html': '<span class="x-window-card-triangle1"></span><span class="x-window-card-triangle2"></span>',
                    'styles': {
                        'z-index': (1 + this.cards.length - iCardIndex),
                        'display' : cardVisible ? 'inline-block' : 'none'
                    }
                }).inject(tr);

                //inside table {
                var insideTable = new Element('table', {
                    cellspacing : 0,
                    cellpadding : 0,
                    html : '<tbody></tbody>'});
                var trInside = new Element('tr', {
                        id : this.id + '-cardslayout-cardbutton' + iCardIndex,
                        height : '20px'
                    }
                );
                trInside.inject(insideTable.getElement('tbody'));

                new Element('td', {
                    html  : '<span>' + (cardDisplayNumber) + '</span>',
                    'class' : 'x-window-card-index'
                }).inject(trInside);

                var caption = this.cards[iCardIndex].breadcrumbs ? this.cards[iCardIndex].breadcrumbs : this.cards[iCardIndex].caption;
                new Element('td', {
                    text  : caption,
                    valign : 'middle',
                    'class' : (bSelected ? 'x-window-card-index-sel' : 'x-window-card-index-nsl' )
                }).inject(trInside);
                //}
                var bLastButton = displayIndex == displayCardLength;
                if (cardsRightFlag && bLastButton) {
                    cardsRightFlag = false;
                    new Element('td', {
                        html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/popup/cards_right.png') + '" alt="" style="display: block;"/>',
                        'class': 'x-window-card-cell'
                    }).inject(tr);
                } else if(cardsRightFlag){
                    new Element('td', {
                        html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/popup/cards_middle.png') + '" alt="" style="display: block;"/>',
                        'class': 'x-window-card-cell'
                    }).inject(tr);
                }
                insideTable.inject(tdCard);
            }

            table.inject(cardsCanvas);
        }
    },


    selectCardAndMultiItem : function(arr)
    {
        arr = arr || [];
        var cardIndex = arr[0] || 0;
        var multiItemIndex = arr[1] || 0;

        if (!$(this.id + '-card' + cardIndex)) return;
        this.selectCard(cardIndex);
        if (cardIndex == this.selectedCard) {
            this.selectMultiItem(multiItemIndex);
        }
    },

    getPreviousMultiItems : function()
    {
        return this._historyStackOfMultiItems;
    },

    previousMultiItem : function()
    {
        var currentMultiItemInfo = this._historyStackOfMultiItems.pop();
        if (currentMultiItemInfo) {
            var previousMultiItemInfo = this._historyStackOfMultiItems.pop();
            if (previousMultiItemInfo) {
                RC.Console.log(previousMultiItemInfo);
                this.selectCardAndMultiItem(previousMultiItemInfo);
            }
        }
    },


    getPreviousMultiItemId : function()
    {
        var h = this._historyStackOfMultiItems;
        if (h.length > 1) return h[h.length - 2];
        return null;
    },

    selectMultiItem: function (selectIndex)
    {
        if (this.cards != null) {
            var card = this.cards[this.selectedCard];
            if (card) {
                for (var i = 0; i < card.multiItems.length; i++) {
                    var bSelected = selectIndex == i;
                    var oCardPane = $(this.id + '-card' + this.selectedCard + '-multiItem' + i);
                    if (oCardPane) {
                        oCardPane.setStyle('display', (bSelected ? 'block' : 'none'));
                        //add to history stack
                        if (bSelected) {
                            this.selectedMultiItem = selectIndex;
                            this._historyStackOfMultiItems.push([this.selectedCard, selectIndex]);
                            //RC.Console.info('wizard._historyStackOfMultiItems: ');
                            //RC.Console.log(this._historyStackOfMultiItems);
                            this.fireListener('selectMultiItem', this.selectedCard, selectIndex, oCardPane);
                        }
                    }
                }
            }
        }
    },

    getCurrentMultiItemId : function()
    {
        if (this.cards != null && this.selectedCard != null) {
            var card = this.cards[this.selectedCard];
            if (card) {
                for (var i = 0; i < card.multiItems.length; i++) {
                    var oCardPane = $(this.id + '-card' + this.selectedCard + '-multiItem' + i);
                    if (oCardPane && oCardPane.getStyle("display") != "none") {
                        return [this.selectedCard, i];
                    }
                }
            }
        }
        return null;
    },

    onSelectMultiItem: function(fn)
    {
        this.addListener('selectMultiItem', fn);
    },

    addMultiItem : function(cardId, multiItemId, multiItem)
    {
        var res = null;
        var self = this;
        if (this.cards != null) {
            var card = this.cards[cardId];
            if (card) {
                var cardNode = $(this.id + '-card' + cardId);
                card.multiItems = card.multiItems || [];

                // delete multiItem if this id is already in DOM
                if (cardNode) {
                    $each(cardNode.children, function(item) {
                        if (self.id + '-card' + cardId + '-multiItem' + multiItemId == item.id) {
                            item.destroy();
                        }
                    });
                }

                if (cardNode) this.renderMultiItem(cardId, multiItemId, [multiItem]).inject(cardNode);
                card.multiItems[multiItemId] = [multiItem];
                res = [cardId, multiItemId];
            }
        }
        return res;
    },

    destroyCards: function(cardIds)
    {
        function destroyItem(item) {
            var cmp = RC.getCmp(item.id);
            if (cmp) cmp.destroy();
        }

        var self = this;
        var cardsToDestroy = [];
        if (!RC.isEmpty(cardIds)) {
            cardsToDestroy = cardIds.map(function(id) {return self.cards[id];});
        } else {
            cardsToDestroy = this.cards;
        }

        //var card = this.cards[cardId];
        cardsToDestroy.each(function(card)
        {

            card.multiItems.each(function(multiItem)
            {

                if ('destroy' in multiItem) {
                    multiItem.destroy();
                } else if ('id' in multiItem) {
                    destroyItem(multiItem);
                } else if (RC.isArray(multiItem)) {
                    multiItem.each(function(item) {
                        if ('id' in item) {
                            destroyItem(item);
                        }
                    });
                }

            });

            card.multiItems = [];

        });
    },

    emptyCard: function(cardId) {
        this.destroyCards([cardId]);
    },

    addMultiItemToCard : function(cardId, multiItem, stepId)
    {
        var self = this;
        var res = null;
        if (!cardId) cardId = 0;
        if (!multiItem) multiItem = new RC.Div({});
        if (this.cards != null) {
            var card = this.cards[cardId];
            if (card) res = this.addMultiItem(cardId, (card.multiItems || []).length, multiItem);
        }
        if (res) {
            res.onShow = function(fn)
            {
                self.onSelectMultiItem(function(cardId, itemId, container)
                {
                    if (JSON.encode([cardId, itemId]) == JSON.encode(res)) fn(container);
                });
                return res;//do chain
            };
            res.doSelected = function()
            {
                self.onShow(function()
                {
                    self.selectCardAndMultiItem(res);
                });
                return res;//do chain
            };
            res.multiItem = multiItem;
            res.id = stepId;
        }
        return res;
    },

    setWidth : function(width)
    {
        $(this.id).setStyle('width', width + 'px');
    },

    /**
     * Add onChangedCard listener
     * @param {Function} callback
     */
    onChangeCard : function(callback)
    {
        this.addListener('onChangedCard', callback)
    },

    onShow : function(callback)
    {
        this.addListener('show', callback)
    }
});

RC.reg('window', RC.Window);

// todo rename to RC.Msg.alert();
RC.WindowAlert = function(html, options, callback)
{

    var self = this;

    options = options || {};

    options = Object.merge({
        title:  RC.Lang.Common.ALERT,
        html : html,
        width: 320,
        closable    : true,
        buttons : [
            {
                text    : RC.Lang.Common.CLOSE,
                idSuffix: 'close',
                width   : 50,
                handler : function()
                {
                    self.close();
                    if (typeof callback == 'function') {
                        callback();
                    }
                }
            }
        ]
    }, options);

    RC.WindowAlert.superclass.constructor.call(this, options);

    this.show();

};

RC.extend(RC.WindowAlert, RC.Window);
RC.reg('window-alert', RC.WindowAlert);

/**
 * @deprecated use RC.Msg.confirmEx
 */
RC.WindowConfirm = function(html, options, callbackTrue, callbackFalse)
{

    var self = this;

    options = options || {};

    options = Object.merge({
        title:  RC.Lang.Common.CONFIRM,
        html : html,
        width: 320,
        closable    : false,
        buttons : [
            {
                text    : RC.Lang.Common.NO,
                idSuffix: 'no',
                width   : 50,
                handler : function()
                {
                    self.close();
                    if (typeof callbackFalse == 'function') {
                        callbackFalse();
                    }
                }
            },
            {
                text    : RC.Lang.Common.YES,
                idSuffix: 'yes',
                width   : 50,
                handler : function()
                {
                    self.close();
                    if (typeof callbackTrue == 'function') {
                        callbackTrue();
                    }
                }
            }
        ]
    }, options);

    RC.WindowConfirm.superclass.constructor.call(this, options);

    this.show();

};

RC.extend(RC.WindowConfirm, RC.Window);
RC.reg('window-confirm', RC.WindowConfirm);

/**
 * Utility class for generating different styles of message boxes.
 *
 * @class
 * @name RC.Msg
 * @singleton
 */
RC.Msg = (function()
{

    var self = function()
    {

    };

    /**
     * Displays a confirmation message box with Yes and No buttons (comparable to JavaScript's confirm).
     * If a callback function is passed it will be called after the user clicks either button, and the
     * id of the button that was clicked will be passed as the only parameter to the callback
     * (could also be the top-right close button).
     *
     * @param {String} title The title bar text
     * @param {String} msg The message box body text
     * @param {Function} callback (optional) The callback function invoked after the message box is closed
     */
    self.confirm = function(title, msg, callback, closable){
        var options = {
            title : title,
            html : msg,
            closable : (RC.isBoolean(closable)) ? closable : false
        }
        self.confirmEx(options, callback);
    };

    /**
     * Displays a confirmation message box with two configurable buttons (comparable to JavaScript's confirm).
     * If a callback function is passed it will be called after the user clicks either button, and the
     * id of the button that was clicked will be passed as the only parameter to the callback
     * (could also be the top-right close button).
     *
     * @param {Object} config Object with params of window to show
     * @param {Function} callback (optional) The callback function invoked after the message box is closed
     * @param {String} [bntNoText] The "no" button text
     * @param {String} [btnYesText] The "yes" button text
     */
    self.confirmEx = function(config, callback, btnYesText, btnNoText)
    {
        var options = {
            title       : RC.Lang.Common.ATTENTION,
            html        : "",
            width       : 320,
            closable    : false,
            onClose     : callback,
            buttons     : [
                {
                    text    : btnNoText || RC.Lang.Common.NO,
                    idSuffix: btnNoText ? btnNoText.toLowerCase() : 'no',
                    width   : 50,
                    handler : function()
                    {
                        win.close('no');
                    }
                },
                {
                    text    : btnYesText || RC.Lang.Common.YES,
                    idSuffix: btnYesText ? btnYesText.toLowerCase() : 'yes',
                    width   : 50,
                    handler : function()
                    {
                        win.close('yes');}
                }
            ]
        };

        RC.apply(options, config);

        var win = new RC.Window(options);
        win.show();

    };

    /**
     * Displays a standard read-only message box with an OK button (comparable to the basic JavaScript alert prompt).
     * If a callback function is passed it will be called after the user clicks the button, and the id of the button
     * that was clicked will be passed as the only parameter to the callback (could also be the top-right close button).
     *
     * @param {String} title The title bar text
     * @param {String} msg The message box body text
     * @param {Function} [callback] The callback function invoked after the message box is closed
     * @param {Boolean} [isClosable] Whether window will have "x" button in header, or not
     * @return {RC.Window}
     */
    self.alert = function(title, msg, callback,isClosable)
    {

        callback = RC.onlyOneCall(callback);

        var options = {
            title       : title,
            id          : 'alertWindow',
            html        : msg,
            width       : 400,
            closable    : (RC.isBoolean(isClosable))?isClosable:false,
            onClose     : callback,
            buttons     : [
                {
                    text: RC.Lang.Common.OK,
                    id: 'alert-ok',
                    width: 50,
                    handler: function() {
                        win.close();
                        callback();
                    }
                }
            ]
        };

        var win = new RC.Window(options);
        win.show();

        return win;

    };

    /**
     * Displays a new message box, or reinitializes an existing message box, based on the config options passed in.
     * All display functions (e.g. prompt, alert, etc.) on MessageBox call this function internally, although those
     * calls are basic shortcuts and do not support all of the config options allowed here.
     * @param {Object} config The following config options are supported:
     * <ul>
     *     <li><b>title</b> : The title text</li>
     *     <li><b>msg</b> : The message</li>
     *     <li><b>buttons</b> : The array of buttons</li>
     *     <li><b>callback</b> : A callback function which is called when the dialog is dismissed either by clicking on
     *     the configured buttons, or on the dialog close button, or by pressing the return button to enter input.
     *     Progress and wait dialogs will ignore this option since they do not respond to user actions and can only
     *     be closed programmatically, so any required function should be called by the same code after it closes the dialog.</li>
     * </ul>
     */
    self.show = function(config)
    {
        var doHandlerClose = function(btn)
        {
            win.close();
            if (RC.isFunc(config.callback)) {
                config.callback(btn);
            }
        };

        if (RC.isArray(config.buttons)) {
            for (var i in config.buttons) {
                config.buttons[i] = RC.apply(config.buttons[i], {
                    width : config.buttons[i].width || 60,
                    handler : doHandlerClose.pass(config.buttons[i].text)
                });
            }
        } else {
            config.buttons = [
                {
                    text :RC.Lang.Common.OK,
                    idSuffix: 'ok',
                    width : 60,
                    handler : doHandlerClose.pass('OK')
                }
            ]
        }

        var options = {
            id          : config.id,
            title       : config.title,
            html        : config.msg,
            width       : 400,
            closable    : config.closable || false,
            buttons     : config.buttons
        };

        var win = new RC.Window(options);
        win.show();
    };

    return self;

})();

RC.Wizard = function(params)
{
    for (var p in params) {
        this[p] = params[p];
    }
    this.xtype = 'x-wizard';
    this.id = RC.isEmpty(params.id) ? RC.genId() : params.id;
    this._container = null;
    // register component
    RC.ComponentMgr.register(this);
};

RC.Wizard.prototype = {
    /**
     * @deprecated
     */
    showUpgradeServiceWindow : function(trialSize)
    {
        var win = this.getUpgradeServiceWindow();
        win && win.show();
        return win;
    },

    getUpgradeServiceWindow : function(conf)
    {
        var win;
        var self = this;
        var trialSize = RC.Config.trialDaysLeft;
        var isSuspended = RC.Config.isSuspended;
        conf = conf || {};
        conf.onDone = conf.onDone || function() {};
        conf.onCancel = conf.onCancel || function() {};
        if (!RC.Config.isTrial && !isSuspended){ // workaround for RC-45396
            RC.changeLocation("/overview.html");
            return;
        }

        var config = RC.apply({
            id      : this.id + 'upgradeServiceWindow',
            title   : isSuspended ? RC.Lang.Common.ACCOUNT_SUSPENDED : RC.Lang.Common.UPGRADE_SERVICE_TITLE,
            closable: true,
            bodyStyles : {
                marginBottom : 13
            },
            html    : function() {
                var html = '',
                    pre,
                    trialServiceTextMapping  = {
                        1: RC.UI.Message(RC.Lang.Common.UPGRADE_SERVICE_TEXT_NOT_EXPIRED, trialSize),
                        0: RC.Lang.Common.UPGRADE_SERVICE_TEXT_EXPIRED_TODAY,
                        '-1': RC.Lang.Common.UPGRADE_SERVICE_TEXT_EXPIRED
                    };
                if (isSuspended) {
                    html = RC.Config.isMailboxIsAdmin ? RC.Lang.Common.UPGRADE_SERVICE_TEXT_PRE_ADMIN : RC.Lang.Common.UPGRADE_SERVICE_TEXT_PRE_NON_ADMIN;
                } else {
                    if (RC.Config.isMailboxIsAdmin) {
                        pre = trialServiceTextMapping[!trialSize ? trialSize : (trialSize/Math.abs(trialSize))];
                        html = pre + RC.UI.Message(RC.Lang.Common.UPGRADE_SERVICE_TEXT_ADMIN, RC.Config.displayName);
                    } else {
                        html = RC.UI.Message(RC.Lang.Common.UPGRADE_SERVICE_TEXT_NON_ADMIN, RC.Config.displayName);
                    }
                }
                return html;
            }(),
            buttons : function() {
                    var buttons = [];
                    buttons.push(
                        {
                            text : RC.Lang.Common.CANCEL,
                            idSuffix: 'cancel',
                            extraClass : 'x-btn-cancel',
                            width   : 100,
                            handler : function()
                            {
                                win.close();
                                conf.onCancel();
                            }
                        });

                    if (RC.Config.isMailboxIsAdmin) {
                        buttons.push(
                            {
                                text : isSuspended ? RC.Lang.Common.UPGRADE_CARD : RC.Lang.Common.UPGRADE_NOW,
                                extraClass : 'x-btn-upgrade',
                                width   : 100,
                                handler : function()
                                {
                                    RC.ComponentMgr.load("billing/upgrade.js", function()
                                    {
                                        var cmp = new RC.UI.Billing.Upgrade();
                                        cmp.startWizard();
                                        cmp.addListener("onDone", function()
                                        {
                                            return conf.onDone();
                                        });
                                    });
                                    win.close();
                                }
                            });
                    }
                    return buttons;
                }()
        }, conf);
        //conf = RC.replacePlaceHolders(conf, placeHolders);
        win = new RC.Window(config);
        return win;
    }
};

RC.Wizard.isAllowed = function()
{
    var isAdmin = RC.Config.isMailboxIsAdmin;
    if (!isAdmin) {
        new RC.Window({
            id      : this.id + 'addDirectNumberWindow',
            title   : RC.Lang.Common.ADD_DIRECT_NUMBER,
            html: RC.UI.Message(RC.Lang.Common.WIZARD_ADD_DIRECT_NUMBER, RC.getSkinnedRCLibXImageBase()),
            buttons : [
                {
                    text : RC.Lang.Common.CLOSE,
                    idSuffix: 'close',
                    handler : function()
                    {
                        RC.getCmp(this.id + 'addDirectNumberWindow').hide();
                    }
                }
            ]
        }).show();
    }
    return isAdmin;
};

(function () {

    function getTransactionFailedMsg(billingStatus, param) {
        var text = null;
        var supportNumber = RC.Config.supportNumber;
        var supportEmail = RC.Config.supportEmail;
        var billingStatusArr = RC.Lang.Common.BILLING_STATUS;
        billingStatus = billingStatus || '';
        billingStatus = billingStatus.toUpperCase();

        if (!billingStatusArr[billingStatus]) {
            billingStatus = 'DEFAULT';
        }

        var contactText = RC.isEmpty(supportNumber)
            ? RC.UI.Message(RC.Lang.Common.TRANSACTION_FAILED_CONTACT_TEXT_EMAIL, supportEmail)
            : RC.UI.Message(RC.Lang.Common.TRANSACTION_FAILED_CONTACT_TEXT_NUMBER, RC.UI.Message('<span class="x-text-no-wrap">{0}</span>', RC.Config.supportNumber));

        if (!RC.isEmpty(param)) {
            text = RC.UI.Message(billingStatusArr[billingStatus], param);
        } else {
            text = RC.UI.Message(billingStatusArr[billingStatus], contactText);
        }

        return text;
    }

    function transactionFailed(billingStatus, param, callback, transactionMessageFunction) {
        var winId = 'transactionFailedWin';
        var self = this;
        var text = transactionMessageFunction(billingStatus, param);

        var win = new RC.Window({
            id    : winId,
            title : RC.Lang.Common.TRANSACTION_FAILED,
            width : 500,
            closable : true,
            items : [
                new RC.Div({
                    html : text
                })
            ],
            listeners: {
                close: function(){
                    var cb = self.callback;
                    if (typeof callback == 'function') cb = callback;
                    if (typeof cb == 'function') cb();
                }
            },
            buttons : [
                {
                    text        : RC.Lang.Common.CLOSE,
                    idSuffix: 'close',
                    width   : 60,
                    handler     : function()
                    {
                        win.close();
                    }
                }
            ]
        });
        win.show();
    }

    RC.Wizard.transactionFailed = function (billingStatus, param, callback) {
        transactionFailed(billingStatus, param, callback, getTransactionFailedMsg);
    };

    RC.Wizard.transactionFailedWithoutCreditCard = function (billingStatus, param, callback) {
        transactionFailed(billingStatus, param, callback, getTransactionFailedMsg);
    };

})();

/**
 * Creates DIV container for scrolled area
 *
 * @class
 * @name RC.ScrolledArea
 * @param {Array} params The config object
 * @param {Object} content The content which will be included into this area
 * @return {Object} Generated HTMLObject
 * @function
  */
RC.ScrolledArea = function(params, content)
{

    var area = new Element('div', {
        'class' : 'x-scrollarea'
    });
    var holder = new Element('div').inject(area);
    var content_ = new Element('div').inject(holder);

    if (params.vertical != undefined) {
        var useVertical = true;
        if (params.vertical.height) {
            holder.setStyle('height', params.vertical.height);
            var vShift = params.vertical.shift;
        }
    }

    content.inject(content_);

    if (useVertical)
        var vScroll = RC.Scroll(holder, content_, {kind:'v',shift:(vShift ? vShift : 0)});

    area.scrolls = function()
    {
        return {
            vertical:vScroll
        }
    };

    area.scrollUp = function(){
        vScroll.scrollUp();
    }

    area.scrollDown = function(){
        vScroll.scrollDown();
    }

    return area;
};

/**
 * Implements scrolling of the component
 *
 * @class
 * @name RC.Scroll
 * @param {Object} contentHolder
 * @param {Object} content
 * @param {Object} params The config object
 * @function
  */
RC.Scroll = function(contentHolder, content, params)
{

    contentHolder.setStyle('overflow', 'hidden');
    contentHolder.setStyle('position', 'relative'); //only and special for IE
    content.setStyle('position', 'relative');

    content.synchronize = function(shift)
    {
        if (typeOf(shift) != 'number')
            return;
        content.setStyle('top', -shift * content.factor);
    };

    this.holder = new Element('div', {
        'class': params.kind + 'scroll'
    });

    var holder_ = this.holder;

    holder_.shadowOpacity = {
        steps: 10,
        delta: 50,
        initial:0.4
    };

    holder_.shadowPosition = {
        steps: 50,
        delta: 15
    };

    holder_.controlledStyle = (params.kind == 'v') ? 'top' : 'left';

    holder_.onChangeContentHeight = function()
    {
        holder_.show({fixedPosition:true})
    };

    holder_.show = function()
    {
        var fixedPosition = false;
        if (arguments[0]) {
            if (arguments[0].fixedPosition)
                fixedPosition = arguments[0].fixedPosition;
        }
        if (!fixedPosition) {
            var holderHalfWidth = 8;
            /*if (params.kind == 'v') {
                holder_.setStyle('left', contentHolder.getSize().x + params.shift - holderHalfWidth);
            }

            var floatedShift = contentHolder.getCoordinates().left + contentHolder.getSize().x - holder_.getCoordinates().left - holderHalfWidth;
            if (floatedShift != 0) {
                holder_.setStyle('left', contentHolder.getSize().x + contentHolder.getPosition().x + params.shift - holderHalfWidth);
            }*/
            holder_.setStyle('right', -params.shift - holderHalfWidth);
        }

        /*
         if (params.kind == 'h')
         holder_.setStyle('left',contentHolder.getSize().x + (params.delta ? params.delta : 0));
         */

        holder_.setStyle('display', 'block');
        holder_.pagesCount = content.getSize().y / contentHolder.getSize().y;
        var showScroll = false;
        var showLimiter = false;
        if (holder_.pagesCount > 3) {
            holder_.setStyle('height', contentHolder.getSize().y);
            showScroll = true;
        }
        else if (holder_.pagesCount > 1) {
            //80 px - base holder height
            holder_.setStyle('height', (holder_.pagesCount * 80 < contentHolder.getSize().y ? holder_.pagesCount * 80 : contentHolder.getSize().y));
            showScroll = true;
            showLimiter = true;
        }
        else {
            holder_.setStyle('display', 'none');
        }
        if (showScroll) {
            slider_.setStyle('display', 'block');
            shadow_.setStyle('display', 'block');
        }
        else {
            slider_.setStyle('display', 'none');
            shadow_.setStyle('display', 'none');
        }

        if (showLimiter)
            limiter_.setStyle('display', 'block');
        else
            limiter_.setStyle('display', 'none');

        holder_.pagesSize = (holder_.getSize().y - shadow_.getSize().y) / holder_.pagesCount;

        content.factor = (content.getSize().y - contentHolder.getSize().y) / (holder_.getSize().y - shadow_.getSize().y);
    };

    this.shadow = new Element('div', {
        'class':'shadow',
        'styles':{
            'opacity':'0'
        }
    }).inject(holder_);

    var shadow_ = this.shadow;

    shadow_.opacitySmoother = new RC.utils.Smoother(0, holder_.shadowOpacity.initial, holder_.shadowOpacity.steps, holder_.shadowOpacity.steps);

    shadow_.show = function()
    {
        clearTimeout(this.opacityTimeout);
        this.setStyle('opacity', holder_.shadowOpacity.initial);
    };

    shadow_.hide = function()
    {
        // wait for shadow stopping
        if (shadow_.positionTimeout) {
            setTimeout(function()
            {
                shadow_.hide()
            }, 150);
            return;
        }

        var opacity = this.getStyle('opacity');
        var newOpacity;
        if (opacity > 0) {
            newOpacity = this.opacitySmoother.prev();
            this.setStyle('opacity', newOpacity);
            if (newOpacity > 0) {
                clearTimeout(this.opacityTimeout);
                this.opacityTimeout = setTimeout(function ()
                {
                    shadow_.hide();
                }, holder_.shadowOpacity.delta);
            }
        }
        /* smoot show - may be used
         else if (direction == '+' && opacity < 1) {
         newOpacity = this.opacitySmoother.next();
         this.setStyle('opacity', newOpacity);
         if (newOpacity < 1) {
         clearTimeout(this.opacityTimeout);
         var self = this;
         this.opacityTimeout = setTimeout(function () {
         self.hide(direction)
         }, this.getParent().shadowOpacity.delta);
         }
         }
         */
    };

    holder_.pageUpDown = function()
    {
        if (slider_.clickableUp) {
            holder_.scrollUp();
        }
        if (slider_.clickableDown) {
            holder_.scrollDown();
        }
    };

    holder_.scrollUp = function(){
       shadow_.catchUp(Math.round(parseInt(shadow_.getStyle(holder_.controlledStyle)) - holder_.pagesSize))
    };

    holder_.scrollDown = function(){
       shadow_.catchUp(Math.round(parseInt(shadow_.getStyle(holder_.controlledStyle)) + holder_.pagesSize))
    }


    shadow_.pisitionSmooter = new RC.utils.Smoother(0, 1, holder_.shadowPosition.steps, 0);

    shadow_.catchUp = function(newPosition, revers, autoHideShadow)
    {
        this.show();

        this.revers = (revers != undefined && revers);

        if (typeOf(newPosition) != 'number')
            newPosition = slider_.getStyle(holder_.controlledStyle);

        var pisitionSmooterInterval = {
            start: this.positionTimeout ? this.pisitionSmooter.start : parseInt(shadow_.getStyle(holder_.controlledStyle)),
            stop: parseInt(newPosition)
        };

        this.pisitionSmooter.setInterval(pisitionSmooterInterval);

        if (!this.positionTimeout)
            this.pisitionSmooter.current = 0;

        var catchUp_ = this;
        var controlledSize = holder_.getSize();
        var shadowSize = shadow_.getSize();

        var sizeParam = (holder_.controlledStyle == 'top' ? 'y' : 'x');
        var shadowMaxShift = controlledSize[sizeParam] - shadowSize[sizeParam];

        catchUp_.go = function()
        {
            var next;
            if (shadow_.waitToMouseup) {
                next = Math.round(shadow_.pisitionSmooter.getCurrent());
            }
            else {
                next = Math.round(shadow_.pisitionSmooter.next());
            }

            if (shadow_.revers && !this.delta) {
                this.currentShadow = parseFloat(shadow_.getStyle(holder_.controlledStyle));
                this.currentSlider = parseFloat(newPosition);
                this.delta = this.currentSlider - this.currentShadow
            }

            shadow_.waitToMouseup = false;
            // move shadow ...
            if (!this.delta) {
                if (next >= 0 && next <= shadowMaxShift) {
                    shadow_.setStyle(holder_.controlledStyle, next + 'px');
                    content.synchronize(next);
                }
                else if (next < 0) {
                    shadow_.waitToMouseup = true;
                    shadow_.setStyle(holder_.controlledStyle, '0px');
                    content.synchronize(0);
                }
                else if (next > shadowMaxShift) {
                    shadow_.waitToMouseup = true;
                    shadow_.setStyle(holder_.controlledStyle, shadowMaxShift + 'px');
                    content.synchronize(shadowMaxShift);
                }
            }
            // ... or slider
            else
                slider_.setStyle(holder_.controlledStyle, (this.currentSlider + this.currentShadow - next) + 'px');

            // next step ...
            if ((shadow_.pisitionSmooter.delta > 0 ? next < shadow_.pisitionSmooter.stop : next > shadow_.pisitionSmooter.stop) || shadow_.waitToMouseup)
                shadow_.positionTimeout = setTimeout(function()
                {
                    catchUp_.go();
                }, holder_.shadowPosition.delta);
            // ... or stop catchUp
            else {
                this.revers = false;
                this.delta = undefined;
                shadow_.positionTimeout = undefined;
                if (autoHideShadow)
                    shadow_.hide();
            }
        };

        if (!shadow_.positionTimeout) this.go();

    };

    shadow_.stop = function()
    {
        shadow_.revers = true;
        shadow_.WaitToMouseUp = false;
        shadow_.hide();
        holder_.drag.stop();
    };

    this.slider = new Element('div', {
        'class':'slider',
        'styles': {
            'top':'0px',
            'left':'0px'
        },
        events: {
            'mousedown': function(e)
            {
                var region = holder_.drag.getRegion(holder_);
                if (params.kind == 'v') {
                    var restriction = parseInt((this.getSize().y / 2).toFixed(0));
                    region.y.min = region.y.min - restriction;
                    region.y.max = region.y.max + restriction;
                }
                holder_.drag.region = region;
                holder_.drag.toDrag(this);
                holder_.scrolToPage = true;
                holder_.drag.onDrag = function()
                {
                    holder_.scrolToPage = false;
                    shadow_.catchUp();
                };
                holder_.drag.start(e);
                shadow_.opacitySmoother.setCurrent(holder_.shadowOpacity.steps);
                document.onmouseup = function()
                {
                    shadow_.stop();
                }
            },
            'mousemove': function(e)
            {
                slider_.checkUpDown(e);
            },
            'mouseout': function()
            {
                if (slider_.direction = this.getParent().hasClass('vscroll'))
                    slider_.setStyle('background', 'transparent url(' + RC.getSkinnedRCLibXImageUrl('img/panel/scroll/vslider.png') + ') no-repeat');
                else
                    slider_.setStyle('background', 'transparent url(' + RC.getSkinnedRCLibXImageUrl('img/panel/scroll/hslider.png') + ') no-repeat');

                if (holder_.scrolToPage)
                    shadow_.catchUp(null, true, true);
            },
            'click': function()
            {
                if (holder_.scrolToPage)
                    holder_.pageUpDown();
            }
        }
    }).inject(holder_);

    var slider_ = this.slider;

    slider_.checkUpDown = function(e)
    {

        slider_.clickableUp = false;
        slider_.clickableDown = false;

        var cursor = holder_.drag.cursor.getCurrentPosition(e);
        var slider = holder_.drag.getRegion(this);

        if (slider_.direction == undefined)
            slider_.direction = this.getParent().hasClass('vscroll');

        var cursorPos, sliderPos;
        var bgPrefix;
        if (slider_.direction) {
            cursorPos = cursor.y;
            sliderPos = slider.y;
            bgPrefix = 'v';
        }
        else {
            cursorPos = cursor.x;
            sliderPos = slider.x;
            bgPrefix = 'h';
        }

        if (cursorPos >= sliderPos.min && cursorPos <= sliderPos.min + 21)
            slider_.clickableUp = true;
        if (cursorPos >= sliderPos.max - 21 && cursorPos <= sliderPos.max)
            slider_.clickableDown = true;

        if (!slider_.direction) {
            tmp = slider_.clickableUp;
            slider_.clickableUp = slider_.clickableDown;
            slider_.clickableDown = tmp;
        }

        if (slider_.clickableUp)
            slider_.setStyle('background', 'transparent url(' + RC.getSkinnedRCLibXImageUrl('img/panel/scroll/' + bgPrefix + 'sliderU.png') + ') no-repeat');
        else if (slider_.clickableDown)
            slider_.setStyle('background', 'transparent url(' + RC.getSkinnedRCLibXImageUrl('img/panel/scroll/' + bgPrefix + 'sliderD.png') + ') no-repeat');
        else
            slider_.setStyle('background', 'transparent url(' + RC.getSkinnedRCLibXImageUrl('img/panel/scroll/' + bgPrefix + 'slider.png') + ') no-repeat');

        if (!(slider_.clickableUp || slider_.clickableDown))
            shadow_.waitToMouseup = false;
    };

    this.limiter = new Element('div', {
        'class':'limiter'

    }).inject(holder_);
    var limiter_ = this.limiter;

    holder_.drag = new RC.utils.Drag;

    //RC.preventSelection(this.holder);

    window.addEvent('resize', function()
    {
        holder_.show();
    });

    waitForRender(contentHolder, function() {
        var p = contentHolder.getParent();
        if (p) {
            holder_.inject(contentHolder.getParent(), 'top');
            holder_.show();
        }
    }, null, null);

    return holder_;
};

/**
 * Implements scrolled area
 *
 * @class
 * @name RC.ScrollBox
 * @extends RC.Element
 * @constructor
 * @xtype scrolled-area
 */
RC.ScrollBox = function(config) {
    RC.apply(this, config);
    this.width = RC.isEmpty(config.width) ? "auto" : config.width;
    this.height = RC.isEmpty(config.height) ? 200 : config.height;
    this.minHeight = RC.isEmpty(config.minHeight) ? 65 : config.minHeight;
    this.allowResize = RC.isTrue(config.allowResize);
    this.html = RC.isEmpty(config.html) ? null : config.html;
    this.showShadow = RC.isEmpty(config.showShadow) ? false : config.showShadow;
    this.initialStep = (config.initialStep && config.initialStep > 0) ? config.initialStep : 0; //@TODO Implement
    this.sticky = RC.isTrue(config.sticky);
    this.contentPadding = RC.isTrue(config.contentPadding);
    this.contentPaddingWidth = RC.isTrue(config.contentPaddingWidth);
    this.borderTop = config.borderTop ? config.borderTop : null;

    this.itemCanvas = {};
    this.itemContent = {};
    this.itemContainer = {};

    RC.ScrollBox.superclass.constructor.call(this, config);

};

RC.extend(RC.ScrollBox, RC.Element, {
    onScroll: function(cb) {
        this.itemContainer.addEvent('scroll', cb.bind(this));
        return this;
    },
    getScrollHeight: function() {
        return this.itemContainer.getScrollSize().y;
    },
    getScrollTop: function() {
        return this.itemContainer.getScroll().y;
    },
    setScrollTop: function(scrollTop) {
        this.itemContainer.scrollTo(0, scrollTop);
        return this;
    },
    setWidth: function(width) {

        this.width = width;
        this.itemCanvas.setStyle('width', width);

    },
    setHeight: function(height) {

        this.height = height;
        this.itemContainer.setStyle((this.allowResize ? 'max-' : '') + 'height', height);

    },
    setVisible: function(isVisible) {
        this.itemCanvas.setStyle('display', isVisible ? '' : 'none');
    },
    setShadow: function(flag) {
        this.itemCanvas.toggleClass('x-scrolled-area-shadow', flag);
    },
    /**
     * Render the Element
     * @return {Object} Generated HTMLObject
     */
    render: function() {

        var canvas = new Element('div', {
            'id': this.id,
            'styles': {
                width: this.width
            },
            'class': 'x-scrolled-area',
            'html': '<div id="' + this.id + '-container" class="x-scrolled-area-container">' +
                    '    <div id="' + this.id + '-content" class="x-scrolled-area-content">' + (this.html ? this.html : '') + '</div>' +
                    '</div>'
        });

        this.itemCanvas = canvas;
        this.itemContent = canvas.getElement('#' + this.id + '-content');
        this.itemContainer = canvas.getElement('#' + this.id + '-container');

        this.itemContainer.setStyle('min-height', this.minHeight);

        if (this.contentPadding) this.itemCanvas.addClass('x-scrolled-area-contentPadding');
        if (this.contentPaddingWidth) this.itemCanvas.addClass('x-scrolled-area-contentPaddingWidth');
        if (this.sticky) this.itemCanvas.addClass('x-scrolled-area-sticky');
        if (this.borderTop) this.itemContainer.setStyle('border-top', this.borderTop);

        this.setHeight(this.height);
        this.setShadow(this.showShadow);
        this.setVisible(this.visible);

        this.setScrollTop(this.initialStep);

        return this.itemCanvas;

    }

});

RC.reg('scrollbox', RC.ScrollBox);

(function() {

    var messagesStack = [];

    function getLastFromStack() {
        return (messagesStack.length > 0) ? messagesStack[messagesStack.length - 1] : null;
    }

    function addToStack(box) {
        var last = getLastFromStack();
        if (last) last.setInactive();
        messagesStack.push(box);
        box.setActive();
    }

    function popFromStack() {
        messagesStack.pop();
        var last = getLastFromStack();
        if (last) last.setActive();
    }

    /**
     * Message box tool
     *
     * Event order:
     * 1. domready
     * 2. show
     * 3. hide
     * 4. close
     *
     * Options:
     * + title
     * + width
     * + height
     * + minHeight
     * + items
     * + noButtons
     * + closeable
     *
     * @param options
     */
    RC.MessageBox = function(options) {

        // create superclass
        RC.MessageBox.superclass.constructor.call(this, options);

        var self = this;

        self.config = options || {};

        this.padding = options.padding || 50;
        var bg = new Element('div', {
            'id' : this.id+'bg',
            'class' : 'x-messagebox-bg'
        });

        var canvas = new Element('div', {
            'id': this.id,
            'class': 'x-messagebox' + (this.extraClass ? ' ' + this.extraClass : ''),
            'html': function() {

                var html = [];

                html.push('<div class="x-messagebox-container">');
                html.push('    <div class="x-messagebox-close">&times;</div>');
                html.push('    <div class="x-messagebox-title"></div>');
                html.push('    <div class="x-messagebox-content"></div>');
                html.push('    <div class="x-messagebox-buttons"></div>');
                html.push('</div>');

                return html.join('');

            }()
        });

        this.domElements = {
            bg: bg,
            canvas: canvas,
            content: canvas.getElement('.x-messagebox-content'),
            container: canvas.getElement('.x-messagebox-container'),
            title: canvas.getElement('.x-messagebox-title'),
            buttons: canvas.getElement('.x-messagebox-buttons'),
            close: canvas.getElement('.x-messagebox-close')
        };

        this.setTitle(options.title, true); // This will cause second resize

        document.getElement('body').adopt(bg);
        document.getElement('body').adopt(canvas);

        // Buttons

        if (!options.noButtons) {

            if (RC.isEmpty(options.buttons)) {

                options.buttons = [
                    {
                        text: RC.Lang.Common.CLOSE,
                        idSuffix: 'close',
                        handler: function() {
                            self.close();
                        }
                    }
                ]

            }

            var buttons = [];

            options.buttons.each(function(buttonConfig) {

                buttons.push(RC.apply({
                    width: buttonConfig.width || 80
                }, buttonConfig));

            });

            var buttonsDiv = new RC.Div({
                buttons: buttons
            });

            buttonsDiv.display(self.domElements.buttons);

        }

        // Scrollbox and resizing

        this.scrollBox = new RC.ScrollBox({
            id: this.id + '-scrollbox',
            allowResize: true,
            showShadow: false,
            items: options.items || null,
            html: options.html || null,
            width: options.width || 'auto',
            height: options.height || 300,
            minHeight: options.minHeight || null,
            listeners: {
                display: function() {

                    self.resize();
                    window.addEvent('resize', function(e) {
                        self.resize();
                    });

                }
            }
        });

        this.domElements.close.addEvent('click', function(e){
            e.stop();
            self.close();
        });

        if (!(options.closeable == null || options.closeable)) {
            this.domElements.close.setStyle('display', 'none');
        }

        // Scrollbox is displayed last to init resize
        this.scrollBox.display(self.domElements.content);

        this.fireListener('domready');
        this.show();

    };

    RC.extend(RC.MessageBox, RC.Element, {
        resize: function() {

            var sizeOptions = {styles: ['padding','border','margin']};

            var windowSize = window.getSize();
            var titleSize = this.domElements.title.getComputedSize(sizeOptions);
            var buttonsSize = this.domElements.buttons.getComputedSize(sizeOptions);

            var maxHeight = windowSize.y - this.padding * 2 - (this.title ? titleSize.totalHeight : 0) - buttonsSize.totalHeight;
            this.scrollBox.setHeight(maxHeight);

            var containerSize = this.domElements.container.getSize();

            var left = (windowSize.x - containerSize.x) / 2;
            var top = (windowSize.y - containerSize.y) / 2;

            this.domElements.container.setStyles({
                left: left,
                top: this.config.top || top
            });

        },
        setHeight: function(height) {
            this.scrollBox.setHeight(height);
        },
        setWidth: function(width) {
            this.scrollBox.setWidth(width);
        },
        setActive: function() {
            this.domElements.canvas.addClass('x-messagebox-active');
        },
        setInactive: function() {
            this.domElements.canvas.removeClass('x-messagebox-active');
        },
        getHeight: function() {
            return this.scrollBox.height;
        },
        getWidth: function() {
            return this.scrollBox.width;
        },
        setTitle: function(title, noResize) {

            if (RC.isMooElement(title)) {
                this.title = title;
                this.domElements.title.empty().adopt(title);
            } else {
                this.title = title ? title.toString() : '';
                this.domElements.title.set('html', this.title ? this.title : '');
            }

            this.domElements.title.setStyle('display', this.title ? '' : 'none');

            if (!noResize) this.resize();

        },
        getTitle: function(title) {
            return this.title;
        },
        show: function() {
            this.domElements.canvas.setStyle('display', '');
            this.domElements.canvas.setStyle('display', '');
            addToStack(this);
            this.fireListener('show');
        },
        hide: function() {
            this.domElements.canvas.setStyle('display', 'none');
            this.domElements.bg.setStyle('display', 'none');
            popFromStack();
            this.fireListener('hide');
        },
        close: function(option) {
            this.hide();
            this.domElements.canvas.dispose();
            this.domElements.bg.dispose();
            this.destroy();
            this.fireListener('close', option);
        },
        render : function() {

            RC.Console.log('RC.MessageBox.render()');
            return this.domElements.canvas;

        }
    });


}());

RC.ProgressBar = function(config)
{

    this.minValue = 0;
    this.maxValue = 1;
    this.loading = false;

    RC.apply(this, config);
    RC.ProgressBar.superclass.constructor.call(this, config);

    this.value = this.minValue;

    this.itemCanvas = null;
    this.itemProgress = null;
    this.itemLabel = null;

    this.addEvents('update', 'finish', 'reset');

};

RC.extend(RC.ProgressBar, RC.Element, {
    setLoading: function(loading){
        
        this.itemCanvas[loading ? 'addClass' : 'removeClass']('x-progressbar-loading');

    },
    reset: function(){

        this.value = this.minValue;
        this.setValue(this.value);
        this.fireListener('reset');

    },
    render : function()
    {

        var self = this;
        var canvas = new Element('div', {
            'class': 'x-progressbar'
        });

        var background = new Element('div', {
            'class': 'x-progressbar-bg'
        }).inject(canvas);

        var progress = new Element('div', {
            'class': 'x-progressbar-progress'
        }).inject(background);

        var loading = new Element('div', {
            'class': 'x-progressbar-progress-loading',
            'html': RC.Lang.Common.LOADING
        }).inject(background);

        var label = new Element('div', {
            'class': 'x-progressbar-label'
        }).inject(background);

        this.itemCanvas = canvas;
        this.itemProgress = progress;
        this.itemLabel = label;

        this.reset();
        this.setLoading(this.loading);

        return canvas;
    },

    getValue : function(){
        return this.value;
    },

    setValue : function(value)
    {

        var self = this;

        value = parseInt(value);

        if (value < this.value) {
            throw 'New value cannot be less than previous';
        }

        if (value > this.maxValue) {
            value = this.maxValue;
        }

        this.value = value;

        var percent = Math.ceil(value * 100 / this.maxValue) + '%';

        this.itemProgress.setStyle('width', percent);
        this.itemLabel.set('html', percent);

        this.fireListener('update', value);

        if (value == this.maxValue) {

            self.fireListener('finish');

        }

    },

    incrementValue: function(){

        this.setValue(this.value + 1);

    },
    
    setVisible: function(isVisible){

        this.itemCanvas.setStyle('display', isVisible ? 'block' : 'none');
        
    }
});

RC.reg('div', RC.Div);

/**
 * @class
 * @name RC.Menu
 * @extends RC.Element
 * @constructor
 */
RC.Menu = function(config) {

    var self = this;

    this._items = config.items;
    this._menuMode = config.menuMode;
    delete config.items;
    delete config.menuMode;

    RC.Menu.superclass.constructor.call(this, config);
};

RC.extend(RC.Menu, RC.Element, {
    /**
     * Render the Element
     * @return {Object} Generated HTMLObject
     */
    render : function() {
        var isUserSeparatedUI = this._menuMode !== undefined;

        function handleClick(item, td, event){
            if ('onClick' in item) {
                item.onClick(event);
            } else {
                if (item.href && !item.remote === true) {
                    td.getParent().getElements('td').removeClass('x-menu-selected');
                    td.addClass('x-menu-selected');
                    if (!RC.isFunc(window.history.pushState)) {
                        RC.Loader.show({});
                    }
                    document.getElement('.PageHeader').set('html', item.title);
                    RC.panel.Manager.clearPageContent();
                }
            }
        }

        var table = new Element('table', {
            'class': 'x-menu',
            'id': 'x-menu-' + (this._menuMode || 'common')
        });

        var tbody = new Element('tbody').inject(table);
        var tr = new Element('tr').inject(tbody);
        var maxIndex = this._items.length - 1;

        this._items.each(function(itemGroup, index) {
            var td;

            if (isUserSeparatedUI) {
                td = new Element('td');
            } else {
                td = new Element('td', {
                    'class': (index == 0 ? 'x-menu-first ' : '') +
                        (index == maxIndex ? 'x-menu-last ' : '')
                });
            }

            td.inject(tr);

            var div = new Element('div', {'class': 'x-menu-item-container'}).inject(td);

            var hasSubItems = RC.isArray(itemGroup.items);

            var a = new Element('a', {
                'class': 'x-menu-item' + (hasSubItems ? ' x-menu-item-collapsable' : '') + ' x-follow-link',
                'href': itemGroup.href,
                'html': itemGroup.title + '<span>&#9660;</span>',
                // added attribute for QA
                'data-menutitle': itemGroup['data-menutitle'],

                events: {
                    click: function(e){
                        if(e.shift)
                            return;
                        handleClick(itemGroup, td, e);
                    }
                }
            }).inject(div);


            var isSelected = document.location.toString().indexOf(itemGroup.href) != -1 && itemGroup.href != '#';

            if (hasSubItems) {

                var container = new Element('div', {'class': 'x-menu-item-sub x-follow-link'}).inject(div);
                var ul = new Element('ul').inject(container);

                itemGroup.items.each(function(subItem) {

                    if (subItem.href) {

                        if (document.location.toString().indexOf(subItem.href) != -1) {
                            isSelected = true;
                        }

                        var linkParams = {
                            href: subItem.href,
                            html: subItem.title + '<span></span>',
                            // added attribute for QA
                            'data-menutitle': subItem['data-menutitle'],

                            events: {
                                click: function (e) {
                                    handleClick(subItem, td, e);
                                }
                            }
                        };

                        if(subItem.remote === true) {
                            linkParams['class'] = 'x-remote-link';
                        }

                        if(subItem.blank === true) {
                            linkParams['target'] = "_blank";
                        }

                        new Element('li', {'class': 'x-menu-sub-item'})
                            .inject(ul)
                            .adopt(new Element('a', linkParams));

                    } else {

                        new Element('li', {
                            'class': 'x-menu-sub-title',
                            html: subItem.title + '<span>&#9660;</span>'
                        }).inject(ul);

                    }

                });

                new Element('li', {
                    'class': 'x-menu-sub-stub'
                }).inject(ul);

            }

            if (isSelected) td.addClass('x-menu-selected');

        });

        return table;
    }

});


var RC = RC || {};
RC.Router = (function() {

    function processName(name) {

        var nameParts = name.split('-');
        nameParts.each(function(namePart, i) {
            nameParts[i] = RC.utils.Text.ucFirst(namePart);
        });
        return nameParts.join('');

    }

    var Class = RC.extend(RC.utils.Observable, {
        constructor: function() {

            Class.superclass.constructor.call(this, {});

        },
        parsePath: function(path) {

            path = path.substr(0, path.indexOf('.html'));
            if (path.substr(0, 1) == '/') path = path.substr(1);
            return path.split('/');

        },
        parseComponent: function(pathParts) {

            var index = 'Index';
            var componentGroup = pathParts[0] || index;
            var componentName = pathParts[1] || index;

            var componentPath = (componentName == index) ? componentGroup : componentGroup + '/' + componentName;

            if (componentPath == index)
                componentPath = index.toLowerCase();

            componentPath += '.js';

            // ucfirst
            componentGroup = processName(componentGroup);
            componentName = processName(componentName);

            var component = 'RC.UI.' + ((componentName != index) ? componentGroup + '.' + componentName : componentGroup);

            return {
                path: componentPath,
                group: componentGroup,
                name: componentName,
                component: component
            };

        },

        getComponentByPath: function(path){
            var pathParts = this.parsePath(path),
                component = this.parseComponent(pathParts);

            return component;
        },

        createSinglePage: function(cb) {
            var self = this;
            if (!RC.isFunc(window.history.pushState)) {
                // browser doesn't support HTML5
                return;
            }
            $$('.x-follow-link').addEvent('click', function(e) {
                if(e.target.hasClass('x-remote-link')) {
                    return;
                }
                if (e.target.href) {
                    var destinationHostname = self.parsePath(e.target.href)[2];
                    if (window.location.hostname == destinationHostname || (window.location.hostname + ":" + window.location.port == destinationHostname)) {
                        e.preventDefault();
                        window.history.pushState({}, "", e.target.href);
                        cb();
                        self.run();
                    }
                }
            });
        },

        run: function() {

            var self = this;

            RC.onReady(function() {

                RC.Loader.show({});

                var component = this.getComponentByPath(window.location.pathname);

                RC.ComponentMgr.load(component.path, function() {
                    RC.Loader.hide();

                    if (component.group in RC.UI) {
                        try {
                            self.processValidation(component, window.location.hash);
                        } catch(e) {
                            RC.Console.error("Component " + component.component + " validation failed: ", e);
                        }
                    } else {
                        RC.Console.error('Automatically loaded component %s is not loaded correctly from path %s', component, component.path);
                        RC.alert('Router error');
                    }

                });

            }.bind(this));

        },

        processValidation: function(component, subroute) {
            var group = RC.UI[component.group],
                cmp = group && (group[component.name] || group),
                validation;

            subroute = subroute && subroute.replace('#', '');
            if (subroute && cmp[subroute + 'Validation']) {
                validation = cmp[subroute + 'Validation'];
            } else {
                validation = cmp.Validation;
            }

            var $do = new RC.data.AsyncContext();

            if (validation) {
                for (var ruleName in validation) {
                    if (validation.hasOwnProperty(ruleName)) {
                        (function (ruleName) {
                            var failureRedirect = validation[ruleName];
                            $do(function (cb) {
                                Wrapper.Access[ruleName](function (result) {
                                    if (result.result) {
                                        RC.Console.log(ruleName + ' is ok');
                                        cb();
                                    }
                                    else {
                                        RC.Console.error(ruleName + ' failed');
                                        RC.changeLocation(failureRedirect);
                                    }
                                });
                            });
                        })(ruleName);
                    }
                }
            }
            else{
                RC.Console.warn("Component " + component.component + " doesn't have validation rules");
            }

            $do(cmp.run);
        },

        setHeader: function(header){

            RC.onReady(function() {
                document.getElement('.PageHeader').set('html', header);
            });

        },
        setTitle: function(title, noSetHeader) {

            var self = this;

            RC.onReady(function() {

                document.title = title +  ' - ' + (!RC.isEmpty(RC.Config.headerAccountBlock) ?RC.Config.headerAccountBlock : RC.Config.brandDisplayName);
                if (!noSetHeader) self.setHeader(title);

            });

        }
    });

    return new Class();

})();

(function() {

    /**
     * var template = new RC.Template(html);
     * var form = new RC.form.FormPanel({
     *     id: 'test',
     *     template: template
     * });
     *
     * template.bind('string', 'xxx');
     * template.bind('element', new Element('div', {html:'xxx'}));
     * template.bind('fieldName1', form.addItem({xtype:...}));
     * template.bind('fieldName2', form.addItem({xtype:...}));
     *
     * After that form can be displayed in a regular way:
     * RC.panel.Manager.display(form);
     * or embedded in other object:
     * new RC.Div({items: [form]});
     *
     * @param template
     */
    RC.Template = function(template) {

        var bindStrings = {};
        var bindElements = {};

        var self = this;

        /**
         * Binds a parameter to a template
         * @param {String} key
         * @param {*} value
         */
        self.bind = function(key, value) {

            if (RC.isMooElement(value)) {
                bindElements[key] = value;
            } else {
                bindStrings[key] = ((value != null) ? value.toString() : '');
            }

            return self;

        };

        self.get = function(key){
            return bindElements[key] || bindStrings[key];
        };

        /**
         * @return {Elements}
         */
        self.compile = function() {

            var templateParsed = template.toString();

            Object.each(bindStrings, function(value, key) {
                templateParsed = templateParsed.split('%' + key + '%').join(value);
            });

            var element = new Element('div', {
                html: templateParsed
            });

            Object.each(bindElements, function(value, key) {
                element.getElement('div[id=template-' + key + ']').adopt(value);
            });

            return element.getChildren();

        }

    };

})();


/*jslint */
/*global RC */

/**
 * @class
 * @name RC.data.Store
 * @extends RC.utils.Observable
 * System store
 *
 * @constructor
 * @param {Object} config The config object
 * @xtype store
 */
RC.data.Store = function(config)
{
    config = config || {};
    /**
     * @cfg {String} cmd
     * Command to send to the server
     */
    this.cmd = config.cmd || null;
    /**
     * @cfg {Array} data
     * Array of JSON objects with direct data
     */
    this.data = config.data || null;

    /**
     * @cfg {Boolean} useMap
     * Defaults to <tt>false</tt>. If you use map instead of array set to TRUE
     */
    this.useMap = RC.isTrue(config.useMap);
    /**
     * @cfg {Boolean} autoLoad
     * Defaults to <tt>true</tt>. If you want to load data manually set to FALSE
     */
    this.autoLoad = RC.isEmpty(config.autoLoad) ? true : RC.isTrue(config.autoLoad);
    /**
     * @cfg {Boolean} postponedStart
     * Defaults to <tt>false</tt>. If you want to load data by timeout
     */
    this.postponedStart = RC.isEmpty(config.postponedStart) ? 1 : config.postponedStart;
    /**
     * @cfg {Array} records
     * Array of RAW records passed from server or traversed from data
     */
    this.records = [];
    /**
     * @cfg {Array} records
     * Array of filtered records
     */
    this.recordsFiltered = [];
    /**
     * @cfg {Array} params
     * Additional parameters to request
     */
    this.params = config.params || null;
    /**
     * @cfg {Array} params
     * Fields of data
     */
    this.fields = config.fields || null;
    /**
     * @cfg {String} transport
     * Engine of transport. 'ajax' by default.
     */
    this.transport = config.transport || 'ajax';
    /**
     * @cfg {String} ns
     * Namespace of method. Will be used only in case of 'socket' transport.
     */
    this.ns = config.ns || "";
    /**
     * @cfg {String} root
     * Root element
     */
    this._root = RC.isEmpty(config.root) ? 'records' : config.root;
    /**
     * Original response from the server
     * @private
     */
    this._response = null;

    this._useWrapper = RC.isTrue(config.useWrapper);


    this._filterCallback = config.filter || null;
    this._sortCallback = config.sort || null;
    this._sortReverse = config.sortReverse || false;

    this.disableInitialFiltering = config.disableInitialFiltering || false;

    this.disableFilterSortEvents = false;

    // Parent constructor
    RC.data.Store.superclass.constructor.call(this, config);

    this.addEvents(
        /**
         * @event load
         * Fires after a new set of Records has been loaded.
         * @param {RC.data.Store} this
         */
            'sort',
        /**
         * @event load
         * Fires after a new set of Records has been loaded.
         * @param {RC.data.Store} this
         */
            'filter',
        /**
         * @event load
         * Fires after a new set of Records has been loaded.
         * @param {RC.data.Store} this
         */
            'load',
        /**
         * @event beforerequest
         * Fires before a request is made for a new data object.
         * @param {RC.data.Store} this
         */
            'beforeRequest',
        /**
         * @event beforeload
         * Fires before a parsing of a result is made for a new data object. If the beforeload handler returns false the load action will be canceled.
         * @param {RC.data.Store} this
         */
            'beforeload', //TODO Should be renamed to beforeParse
        /**
         * @event loadRecord
         * Fires for each loaded record.
         * @param {RC.data.Store} this
         * @param {Object} record
         * @param {Number} index
         */
            'loadRecord',
        /**
         * @event lastRecordRendered
         * Fires for last loaded record.
         * @param {Number} records.length
         */
            'lastRecordRendered',
        /**
         * @event exception
         * Fires if an exception occurs in the Proxy during a remote request.
         * @param {RC.data.Store} this
         */
            'exception',
        /**
         * @event clear
         * Fires when the data cache has been cleared.
         * @param {RC.data.Store} this
         */
            'clear',
        /**
         * @event add
         * Fires when Records have been added to the Store
         * @param {RC.data.Store} this
         * @param {Object} record
         * @param {int} index
         */
            'add',
        /**
         * @event add
         * Fires when Records have been removed from the Store
         * @param {RC.data.Store} this
         * @param {Object} record
         * @param {int} index
         */
            'remove'
            );
};

RC.extend(RC.data.Store, RC.utils.Observable, {

    /**
     * @public
     * @function
     * @name RC.data.Store#callMethod
     * @param {Function} success
     * @return {void}
     */
    callMethod: function (success) {
        'use strict';
        var self = this,
            service = new RC.Ajax();
        service.send({
            cmd: (!RC.isEmpty(self.ns) ? self.ns + "." : "") + self.cmd,
            params: self.params,
            useWrapper: !RC.isEmpty(self.ns) ? true : self._useWrapper,
            onSuccess: success,
            onError: function (o) {
                if (self.fireListener('exception', o) !== false) {
                    RC.Console.error('Server error: %s: %s', o.status.errorCode, o.status.message);
                }
            }
        });
    },

    /**
     * Loads the Record cache from the configured proxy using the configured reader.
     * To perform any post-processing where information from the load call is required use a {@link #load} event handler.
     */
    load : function() {

        this.fireListener('beforeRequest');

        if (RC.isArray(this.data)) {
            this.parse({
                success : true,
                records : this.data
            });
        } else {
            var self = this;
            setTimeout(function()
            {
                switch (self.transport) {
                    default:
                        self.callMethod(function (o) {
                            self.parse(o);
                        });
                        break;
                    case 'socket':
                        var socketRequest = {
                            type : self.cmd,
                            ns : self.ns,
                            request : self.params,
                            onSuccess : function(o)
                            {
                                self.parse(o);
                            },
                            onError : function(o)
                            {
                                if (self.fireListener('exception', o) != false)
                                    RC.Console.error('Server error: %s: %s', o.status.errorCode, o.status.message);
                            }
                        };
                        RC.Transport.send(socketRequest);
                        break;
                }
            }, self.postponedStart);
        }
    },

    /**
     * Parse response
     * @param {Object} o
     */
    parse : function(o) {
        if (o == null) {
            return;
        }

        // set response
        this._response = o;

        // we want to remove exists rows if possible
        this.removeAll(true);

        // remember records
        this.records = o[this._root];

        // fire event if need
        var rec = this.fireListener('beforeload', this.records);
        if (rec) this.records = rec;

        var nArr, k;

        if (this.fields && !this.useMap) {
            nArr = [];
            for (k in this.fields) {
                nArr.push({
                    id : this.fields[k],
                    value : this.records[this.fields[k]]
                });
            }
            this.records = nArr;
        }

        if (this.useMap && !RC.isArray(this.records) && this.records !== undefined) {
            nArr = [];
            for (k in this.records) {
                nArr.push({
                    id : k,
                    value : this.records[k]
                });
            }
            this.records = nArr;
        }

        // Do not fire filtering events during initial filtering
        this.disableFilterSortEvents = true;
        if (!this.disableInitialFiltering){
            this.filter();
        }
        this.disableFilterSortEvents = false;

        if (this.getCount() > 0) {
            if (this.hasListener('loadRecord')) {
                // fill object which defined in loadRecord listener
                var self = this;
                self.each(function(record, idx) {
                    self.fireListener('loadRecord', record, idx);
                });
                if (self.hasListener('lastRecordRendered')) {
                    self.fireListener('lastRecordRendered', self.getCount());
                }
            }
        }

        if (!this.disableInitialFiltering){
            this.filter();
        }

        this.fireListener('load', this.records);
    },

    /**
     * Reload store with given params
     * TODO Allow to provide new custom records (change params to common config object)
     * @param {Array} params
     */
    reload : function(params) {

        // remove exists rows
        if (RC.isObject(params)) {
            this.params = params;
        }

        this.removeAll();
        this.load();
    },

    getResponse : function() {
        return this._response ? this._response : {};
    },

    /**
     * @deprecated
     * @param index
     * @param record
     */
    changeRecord : function(index, record) {

        this.replaceAt(index, record, true);
        this.fireListener('changeRecord', record, index); // Remember, that new record may not appear in filtered results

    },

    // Filtering and sorting

    clearFilter: function() {

        this.filter(false);

    },

    getOriginalIndex: function(item) {
        return this.records.indexOf(item);
    },

    filter: function(callback) {

        var self = this;

        if (callback != undefined) {

            if (RC.isFunc(callback)) {
                this._filterCallback = callback;
            } else {
                this._filterCallback = null;
            }

        }

        if (RC.isFunc(this._filterCallback)) {

            this.recordsFiltered = [];

            this.records.each(function(item)
            {

                if (self._filterCallback(item)) {

                    self.recordsFiltered.push(item);

                }

            });

        } else {

            this.recordsFiltered = this.records;
        }

        if (!this.disableFilterSortEvents) this.fireListener('filter');

        // Apply sort after filtering
        this.sort();

    },

    sort: function(callback, reverse) {

        var self = this;

        // Set new options if provided
        if (!RC.isEmpty(callback)) this._sortCallback = callback;
        if (!RC.isEmpty(reverse)) this._sortReverse = reverse;

        if (!RC.isEmpty(this._sortCallback)) {

            var compFunction = RC.isFunc(this._sortCallback) ? this._sortCallback : function(item1, item2)
            {

                var field = self._sortCallback.toString(); // Treat callback as a field name

                if (item1[field] > item2[field]) return 1;
                else if (item1[field] < item2[field]) return -1;
                return 0;

            };

            try {
                this.recordsFiltered.sort(compFunction);
            } catch (e) {
                RC.Console.error('RC.data.Store.sort(): An error occured while sorting: %s', e.message);
            }

            if (this._sortReverse) this.recordsFiltered.reverse();

        }

        if (!this.disableFilterSortEvents) this.fireListener('sort');

    },

    // EXT WAY

    /**
     * Gets the number of cached records
     */
    getCount: function() {
        return this.recordsFiltered.length;
    },

    /**
     * Returns a range of Records between specified indices
     * @param startIndex
     * @param endIndex
     */
    getRange: function(startIndex, endIndex) {

        if (this.recordsFiltered === undefined) {
            RC.Console.warn('RC.data.Store.getRange(%s, %s): Records are not defined', startIndex, endIndex);
            return [];
        }

        if (!RC.isDefined(startIndex) && !RC.isDefined(endIndex)) return this.recordsFiltered;
        if (!endIndex) endIndex = this.recordsFiltered.length - 1;

        return this.recordsFiltered.slice(startIndex, endIndex + 1);

    },

    /**
     * Get the Record at the specified index
     * @param index
     */
    getAt: function(index) {

        if (!this.recordsFiltered[index]) {
            RC.Console.warn('RC.data.Store.getAt(%s): Record not found', index);
            return undefined;
        }

        return this.recordsFiltered[index];

    },

    /**
     * Get the index within the cache of the passed Record
     * Is safe for items passed e.g. from callbacks, DNW with outer records (because of clone() in constructor() method)
     * TODO: fromIndex
     * @param record
     */
    indexOf: function(record) {

        var index = this.recordsFiltered.indexOf(record); // Using mootools function if not provided by browser

        if (index == -1) {
            RC.Console.warn('RC.data.Store.indexOf(record): Record not found');
        }

        return index;

    },

    /**
     * Get the index within the cache of the passed Record
     * Wroks with everything, but much slower
     * TODO: fromIndex
     * @param record
     */
    indexOfEquiv: function(record) {

        var index = -1;

        for (var i = 0, max = this.recordsFiltered.length; i < max; i++) {

            if (RC.equiv(this.recordsFiltered[i], record)) {
                index = i;
                break;
            }

        }

        if (index == -1) {
            RC.Console.warn('RC.data.Store.indexOfEquiv(record): Record not found');
        }

        return index;

    },

    /**
     * @param callback
     * @param scope
     */
    each: function(callback, scope) {

        var currentScope = scope || this;

        for (var i = 0, max = this.recordsFiltered.length; i < max; i++) {

            callback.call(currentScope, this.recordsFiltered[i], i);

        }

    },

    /**
     * Inserts Records into the Store at the given index and fires the add event
     * @param index
     * @param record
     */
    insert: function(index, record) {

        if (RC.isObject(record)) {
            var rawIndex = this.getOriginalIndex(this.getAt(index)); // Determine original index
            if (rawIndex == -1){
                rawIndex = 0;
            }
            this.records.splice(rawIndex, 0, record);
            this.filter();
            this.fireListener('add', record, index); // Remember, that new record may not appear in filtered results
        } else {
            RC.Console.warn('RC.data.Store.insert(): Only objects are OK to be in store, %s passed', typeof record);
        }

    },

    /**
     * Replaces Records into the Store at the given index and fires the add event
     * @param index
     * @param record
     */
    replaceAt: function(index, record, silent) {

        if (RC.isObject(record)) {
            var rawIndex = this.getOriginalIndex(this.getAt(index)); // Determine original index
            this.records[rawIndex] = record;
            this.filter();
            if (!silent) this.fireListener('add', record, index); // Remember, that new record may not appear in filtered results
        } else {
            RC.Console.warn('RC.data.Store.replaceAt(): Only objects are OK to be in store, %s passed', typeof record);
        }

    },

    /**
     * Add Records to the Store and fires the add event
     * @param record
     */
    add: function(record) {

        if (RC.isObject(record)) {
            this.records.push(record);
            this.filter();
            this.fireListener('add', record, undefined); // Remember, that new record may not appear in filtered results
        }

    },
    
    batchAdd: function(records) {
    
        if (RC.isArray(records)) {
            var self = this;
        
            records.each(function(record) {
                if (RC.isObject(record)) {
                    self.records.push(record);
                }
            });
            
            this.filter();
            this.fireListener('batchAdd', records); // Remember, that new record may not appear in filtered results
        }
        
    },

    /**
     * Remove all Records from the Store and fires the clear event
     * @param silent
     */
    removeAll: function(silent) {

        this.records = [];
        if (!RC.isTrue(silent)) {
            this.filter();
            this.fireListener('clear');
        }

    },

    /**
     * Remove a Record from the Store at the specified index. Fires the remove event.
     * @param index
     */
    removeAt: function(index) {

        this.remove(this.getAt(index));

    },

    /**
     * Remove Records from the Store and fires the remove event
     * @param record
     */
    remove: function(record) {

        var index = this.records.indexOf(record);

        if (index == -1) return;

        delete this.records[index];
        this.records = this.records.clean();

        this.filter();
        this.fireListener('remove', record);

    },
    
    batchRemove: function(records) {
    
        if (RC.isArray(records)) {
            var self = this;
            records.each(function(record) {
                var index = self.records.indexOf(record);

                if (index != -1) {
                    delete self.records[index];
                }
            });
            this.records = this.records.clean();

            this.filter();
            this.fireListener('batchRemove', records);
        }
        
    },


    // LEGACY


    /**
     * Remove all Records from the Store and fires the {@link #clear} event.
     * Alias of removeAll() method
     * @deprecated
     */
    clear : function()
    {
        this.removeAll();
    },
    /**
     * Add Record to the Store and fires the {@link #add} event.
     * Alias for add() method
     * @deprecated
     * @param {Object} item
     */
    addRecord : function(item)
    {
        this.add(item);
    },
    /**
     * Get array of records
     * Alias of getRange() method
     * @deprecated
     */
    getRecords : function()
    {
        return this.getRange();
    },
    /**
     * Get size of the store
     * Alias of getSize() method
     * @deprecated
     */
    size : function()
    {
        return this.getCount();
    }

});

// Register shortcut of the component
RC.reg('store', RC.data.Store);

/**
 * @class
 * @name RC.data.JsonStore
 * @extends RC.data.Store
 * Small helper class to make creating {@link RC.data.Store}s from JSON data easier.
 * @constructor
 * @param {Object} config The config object
 * @xtype jsonstore
 */
RC.data.JsonStore = function(config)
{
    // create superclass
    RC.data.JsonStore.superclass.constructor.call(this, config);
};

RC.extend(RC.data.JsonStore, RC.data.Store, {
    /**
     * Load data from entered JSON array. Not implemented.
     * @param {Array} records
     */
    loadData : function(records)
    {

    },
    /**
     * Read data from store
     * @param {Object} r
     * @param {String} name
     */
    read : function(r, name)
    {
        var value = r[name];
        return RC.isEmpty(value) ? (Browser.name === "ie" ? '&nbsp;' : '&#160;') : value;
    },
    /**
     * Write data to store. Not used for now.
     */
    write : function()
    {

    }
});

RC.reg('jsonstore', RC.data.JsonStore);

/*jslint */
/*global RC, setTimeout */

(function () {
    'use strict';

    var cache = {},
        events = {};

    /**
     * @class
     * @name RC.data.JsonCacheStore
     * @extends RC.data.JsonStore
     */
    RC.data.JsonCacheStore = RC.extend(RC.data.JsonStore, {

        /**
         * @public
         * @function
         * @name RC.data.JsonCacheStore#callMethod
         * @param {Function} success
         * @return {void}
         */
        callMethod: function (success) {
            var command = this.cmd,
                params = [],
                hash = '',
                property;
            if (!RC.isEmpty(this.ns)) {
                command = this.ns + command;
            }
            if (!cache[command]) {
                cache[command] = {};
                events[command] = {};
            }
            if (this.params) {
                for (property in this.params) {
                    if (this.params.hasOwnProperty(property)) {
                        params.push(property + '=' + JSON.stringify(this.params[property]));
                    }
                }
            }
            params.sort();
            hash = params.join('|');
            if (!events[command][hash]) {
                events[command][hash] = new RC.utils.Observable({});
                events[command][hash].addEvents('deliver');
            }
            if (cache[command][hash] === null) {
                events[command][hash].addListener('deliver', function (o) {
                    success(o);
                });
            } else if (cache[command][hash]) {
                setTimeout(function () {
                    success(cache[command][hash]);
                }, 0);
            } else {
                cache[command][hash] = null;
                RC.data.JsonCacheStore.superclass.callMethod.call(this, function (o) {
                    cache[command][hash] = o;
                    events[command][hash].fireListener('deliver', o);
                    success(o);
                });
            }
        }

    });

    /**
     * @public
     * @function
     * @name RC.data.JsonCacheStore.clean
     * @param {String} command
     * @param {Object} [params]
     * @return {void}
     */
    RC.data.JsonCacheStore.clean = function clean(command, params) {
        var hash,
            temp = [],
            property;
        command = String(command);
        if (params) {
            for (property in params) {
                if (params.hasOwnProperty(property)) {
                    temp.push(property + '=' + JSON.stringify(params[property]));
                }
            }
        }
        temp.sort();
        hash = temp.join('|');
        if (cache[command] && cache[command][hash]) {
            delete cache[command][hash];
        }
        if (events[command] && events[command][hash]) {
            delete events[command][hash];
        }
    };

}());





RC.data.AsyncContext = function AsyncContext(contextCallback, parentContext) {
    var contextConstructor = arguments.callee;
    var commandsStack = [];
    var commandPointer = -1;
    var asyncCommandsRunning = 0;
    var isIdle = true;
    var isSwitchedToChildContext = false;
    var isTerminated = false;
    var childContext;
    var self = run;

    contextCallback = contextCallback || function () {};

    var commandType = {
        LINE: "LINE",
        IF: "IF",
        CALLBACK: "CALLBACK"
    };

    self.$if = function () {
        if (isSwitchedToChildContext) {
            return childContext.$if.apply(this, arguments);
        } else {
            return asyncIf.apply(this, arguments);
        }
    };

    self.forEachSync = function () {
        if (isSwitchedToChildContext) {
            return childContext.forEachSync.apply(this, arguments);
        } else {
            return getForEachFunction(true).apply(this, arguments);
        }
    };

    self.forEachAsync = function () {
        if (isSwitchedToChildContext) {
            return childContext.forEachAsync.apply(this, arguments);
        } else {
            return getForEachFunction(false).apply(this, arguments);
        }
    };

    self.callback = function () {
        if (isSwitchedToChildContext) {
            return childContext.callback.apply(this, arguments);
        } else {
            return runCallback.apply(this);
        }
    };

    self.sync = function () {
        if (isSwitchedToChildContext) {
            return childContext.sync.apply(this, arguments);
        } else {
            var commands = Array.prototype.slice.call(arguments);
            addCommands(commands, true);
        }
    };

    self.terminate = function () {
        if (isSwitchedToChildContext) {
            childContext.terminate();
        } else {
            if (!isTerminated) {
                terminate();
                if (isParentContextExists() &&
                    typeof parentContext.terminate == 'function') {

                    parentContext.terminate();
                }
            }
        }
    };

    self.switchParentContext = function (context) {
        if (isParentContextExists() &&
            typeof parentContext.switchParentContext == 'function') {

            parentContext.switchParentContext(self);
        }
        isSwitchedToChildContext = true;
        childContext = context;
    };

    self.withParams = function () {
        var args = Array.prototype.slice.call(arguments);
        return function () {
            var func = args[0];
            func.apply(this, args.splice(1));
        }
    };

    addInlineCapability(self);
    addInlineCapability(self.sync);
    addInlineCapability(self.forEachSync);
    addInlineCapability(self.forEachAsync);

    return self;

    function addInlineCapability(func) {
        func.inline = function () {
            var args = Array.prototype.slice.call(arguments);
            return function () {
                func.apply(func, args);
            }
        }
    }

    function isParentContextExists() {
        return typeof parentContext != 'undefined' && parentContext !== null;
    }

    function run() {
        if (isSwitchedToChildContext) {
            childContext.apply(this, arguments);
        } else {
            var commands = Array.prototype.slice.call(arguments);
            if (commands.length == 1) {
                addCommands(commands, true);
            } else {
                addCommands(commands, false);
            }
        }
    }

    function runCallback() {
        commandsStack.push({
            type: commandType.CALLBACK,
            sync: true,
            completed: false,
            context: self
        });
        continueIfIdle();
    }

    function addCommands(commands, isSync) {
        for (var i = 0; i < commands.length; i++) {
            var command = commands[i];
            if (typeof command != 'function') {
                throw "[command] should be a function";
            }
            commandsStack.push({
                type: commandType.LINE,
                sync: isSync,
                command: command,
                completed: false,
                context: self
            });
        }
        continueIfIdle();
    }

    function continueIfIdle() {
        if (isIdle) {
            isIdle = false;
            commandPointer++;
            executeCurrentCommand();
        }
    }

    function asyncIf(condition) {
        return function (commandIfTrue) {
            if (typeof commandIfTrue != 'function') {
                throw "[commandIfTrue] should be a function";
            }
            var commandRecord = {
                type: commandType.IF,
                sync: true,
                condition: condition,
                commandIfTrue: commandIfTrue,
                commandIfFalse: function () {},
                completed: false,
                context: self
            };

            commandsStack.push(commandRecord);

            immediatelyCall(continueIfIdle);

            return {
                $else: function (commandIfFalse) {
                    if (typeof commandIfFalse != 'function') {
                        throw "[commandIfFalse] should be a function";
                    }
                    commandRecord.commandIfFalse = commandIfFalse;
                }
            };
        }
    }

    function terminate() {
        isTerminated = true;
    }

    function getForEachFunction(isSync) {
        return function (items) {
            return function (itemHandler) {
                var commands = [];
                if (items.constructor === Array) {
                    commands = getCommandsFromArray(items);
                } else {
                    commands = getCommandsFromObject(items);
                }
                addCommands(commands, isSync);

                function getCommandsFromArray(items) {
                    var commands = [];
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        commands.push(handler(item));
                    }
                    return commands;
                }

                function getCommandsFromObject(items) {
                    var commands = [];
                    for (var itemProp in items) {
                        if (items.hasOwnProperty(itemProp)) {
                            var item = items[itemProp];
                            commands.push(handler(item));
                        }
                    }
                    return commands;
                }

                function handler(item) {
                    return function (callback) {
                        itemHandler(item, callback);
                    }
                }
            };
        }
    }

    function executeCurrentCommand() {
        if (!isTerminated) {
            var currentCommandRecord = commandsStack[commandPointer];
            var currentType;
            if (typeof currentCommandRecord != 'undefined') {
                currentType = currentCommandRecord.type;
            }

            switch (currentType) {
                case commandType.LINE:
                case commandType.IF:
                    if (currentCommandRecord.sync) {
                        executeCommandSynchronously(currentCommandRecord);
                    } else {
                        executeCommandAsynchronously(currentCommandRecord);
                    }
                    break;
                case commandType.CALLBACK:
                    executeContextCallback(currentCommandRecord);
                    break;
                default:
                    commandPointer = commandsStack.length - 1;
                    isIdle = true;
            }
        }
    }

    function executeContextCallback(currentCommandRecord) {
        if (asyncCommandsRunning === 0) {
            if (!currentCommandRecord.completed) {
                contextCallback();

                currentCommandRecord.completed = true;
                commandPointer++;
                executeCurrentCommand();
            }
        }
    }

    function executeCommandSynchronously(currentCommandRecord) {
        if (asyncCommandsRunning === 0) {

            var type = currentCommandRecord.type;

            switchToChildContext(currentCommandRecord, syncCallback);

            if (type === commandType.LINE) {
                var command = convertToAsyncCommand(currentCommandRecord.command);
                command(syncCallback);

            } else if (type === commandType.IF) {
                var conditionResult;
                if (typeof currentCommandRecord.condition == 'function') {
                    conditionResult = currentCommandRecord.condition();
                } else {
                    conditionResult = !!currentCommandRecord.condition;
                }
                if (conditionResult) {
                    convertToAsyncCommand(currentCommandRecord.commandIfTrue)(syncCallback);
                } else {
                    convertToAsyncCommand(currentCommandRecord.commandIfFalse)(syncCallback);
                }
            }

            switchBackFromChildContext();
        }

        function syncCallback() {
            if (!currentCommandRecord.completed) {
                currentCommandRecord.completed = true;
                commandPointer++;
                executeCurrentCommand();
            }
        }
    }

    function continueSynchronously() {
        if (asyncCommandsRunning === 0) {
            var currentCommandRecord = commandsStack[commandPointer];
            if (typeof currentCommandRecord != 'undefined') {
                if (currentCommandRecord.sync) {
                    executeCurrentCommand();
                }
            }
        }
    }

    function executeCommandAsynchronously(currentCommandRecord) {
        asyncCommandsRunning++;

        var command = convertToAsyncCommand(currentCommandRecord.command);

        switchToChildContext(currentCommandRecord, asyncCallback);

        command(asyncCallback);

        switchBackFromChildContext();

        commandPointer++;

        executeCurrentCommand();

        function asyncCallback() {
            if (!currentCommandRecord.completed) {

                currentCommandRecord.completed = true;
                asyncCommandsRunning--;

                continueSynchronously();
            }
        }
    }

    function switchToChildContext(currentCommandRecord, contextCallback) {
        self.switchParentContext(currentCommandRecord.context);

        childContext = new contextConstructor(contextCallback, self);
        isSwitchedToChildContext = true;
    }

    function switchBackFromChildContext() {
        isSwitchedToChildContext = false;
        childContext = undefined;
    }

    function convertToAsyncCommand(command) {
        if (isAsyncFunction(command)) {
            return command;
        } else {
            return function (callback) {
                command();
                self.callback();
            }
        }

        function isAsyncFunction (func) {
            return func.length>0;
        }
    }

    function immediatelyCall(callback) {
        setTimeout(
            function () {
                callback.apply(self);
            }, 0
        );
    }
};

var smoothData = [
    0          ,6.23052E-05,0.000249205,0.000560654,0.000996573,0.001556855,0.002241359,0.003049915,0.003982321,0.005038345,
    0.006217724,0.007520164,0.00894534 ,0.010492897,0.01216245 ,0.013953582,0.015865847,0.017898769,0.02005184 ,0.022324524,
    0.024716255,0.027226437,0.029854444,0.032599621,0.035461284,0.038438719,0.041531186,0.044737912,0.0480581  ,0.051490921,
    0.055035519,0.058691012,0.062456489,0.06633101 ,0.070313611,0.074403299,0.078599055,0.082899832,0.087304559,0.091812139,
    0.096421448,0.101131337,0.105940633,0.110848136,0.115852624,0.12095285 ,0.126147542,0.131435406,0.136815124,0.142285356,
    0.147844737,0.153491883,0.159225386,0.165043817,0.170945726,0.176929643,0.182994075,0.189137512,0.195358422,0.201655256,
    0.208026443,0.214470396,0.220985509,0.227570159,0.234222703,0.240941485,0.24772483 ,0.254571046,0.261478429,0.268445257,
    0.275469793,0.282550286,0.289684973,0.296872074,0.304109799,0.311396344,0.318729893,0.326108619,0.333530681,0.340994232,
    0.34849741 ,0.356038345,0.363615159,0.371225963,0.37886886 ,0.386541946,0.394243307,0.401971025,0.409723175,0.417497823,
    0.425293032,0.43310686 ,0.440937359,0.448782578,0.456640561,0.46450935 ,0.472386984,0.4802715  ,0.488160933,0.496053317,
    0.503946683,0.511839067,0.5197285  ,0.527613016,0.53549065 ,0.543359439,0.551217422,0.559062641,0.56689314 ,0.574706968,
    0.582502177,0.590276825,0.598028975,0.605756693,0.613458054,0.62113114 ,0.628774037,0.636384841,0.643961655,0.65150259,
    0.659005768,0.666469319,0.673891381,0.681270107,0.688603656,0.695890201,0.703127926,0.710315027,0.717449714,0.724530207,
    0.731554743,0.738521571,0.745428954,0.75227517 ,0.759058515,0.765777297,0.772429841,0.779014491,0.785529604,0.791973557,
    0.798344744,0.804641578,0.810862488,0.817005925,0.823070357,0.829054274,0.834956183,0.840774614,0.846508117,0.852155263,
    0.857714644,0.863184876,0.868564594,0.873852458,0.87904715 ,0.884147376,0.889151864,0.894059367,0.898868663,0.903578552,
    0.908187861,0.912695441,0.917100168,0.921400945,0.925596701,0.929686389,0.93366899 ,0.937543511,0.941308988,0.944964481,
    0.948509079,0.9519419  ,0.955262088,0.958468814,0.961561281,0.964538716,0.967400379,0.970145556,0.972773563,0.975283745,
    0.977675476,0.97994816 ,0.982101231,0.984134153,0.986046418,0.98783755 ,0.989507103,0.99105466, 0.992479836,0.993782276,
    0.994961655,0.996017679,0.996950085,0.997758641,0.998443145,0.999003427,0.999439346,0.999750795,0.999937695,1          ]
        ;

/**
 * @class
 * @name RC.utils.Drag
 * @function 
 */
RC.utils.Drag = function()
{
    var self = this;
    this.cursor = {

        lastPosition : {
            x: null,
            y: null,
            isSet : false
        },

        resetLastPosition: function()
        {
            self.cursor.lastPosition.x = null;
            self.cursor.lastPosition.y = null;
            self.cursor.lastPosition.isSet = false;
        },

        getLastPosition: function()
        {
            return {
                x: self.cursor.lastPosition.x,
                y: self.cursor.lastPosition.y,
                isSet: self.cursor.lastPosition.isSet
            }
        },

        setLastPosition: function(e)
        {
            var pos = self.cursor.getCurrentPosition(e);
            self.cursor.lastPosition.x = pos.x;
            self.cursor.lastPosition.y = pos.y;
            self.cursor.lastPosition.isSet = true;

        },

        getCurrentPosition: function(e)
        {
            e = self.fixE(e);
            if (e.pageX || e.pageY) {
                x_ = e.pageX;
                y_ = e.pageY;
            }
            else if (e.page && (e.page.x || e.page.y)) {
                x_ = e.page.x;
                y_ = e.page.y;
            }
            else {
                var de = document.documentElement;
                var b = document.body;
                x_ = e.clientX + (de.scrollLeft || b.scrollLeft) - (de.clientLeft || 0);
                y_ = e.clientY + (de.scrollTop || b.scrollTop) - (de.clientTop || 0);
            }
            return { x: x_, y: y_ };
        }
    };

    this.element = null;

    this.region = null;

    this.targets = null;

    this.checkCursor = false;

    this.started = false;

    this.addTarget = function(region)
    {
        if (self.targets == null)
            self.targets = [];
        this.targets[this.targets.length] = region;

    };

    this.fixE = function(e)
    {
        e = e || window.event;
        if (typeof e.layerX == 'undefined') e.layerX = e.offsetX;
        if (typeof e.layerY == 'undefined') e.layerY = e.offsetY;
        return e;
    };

    this.toDrag = function(el)
    {
        this.element = el;
        if (self.region == null)
            self.region = self.getRegion(document)
    };

    this.check = function(d)
    {
        var area = self.region;
        var element = self.getRegion(self.element);
        self.closestTarget(element);
        //var cursorOnElement = true;
        var lastCursorPosition = self.cursor.getLastPosition();
        var checkX = element.x.min + d.x >= area.x.min && element.x.max + d.x <= area.x.max;
        var checkY = element.y.min + d.y >= area.y.min && element.y.max + d.y <= area.y.max;
        var checkCursorX = self.checkCursor ? lastCursorPosition.x >= element.x.min &&
                lastCursorPosition.x <= element.x.max : true;
        var checkCursorY = self.checkCursor ? lastCursorPosition.y >= element.y.min &&
                lastCursorPosition.y <= element.y.max : true;
        return {
            x: checkX && checkCursorX && checkCursorY,
            y: checkY && checkCursorX && checkCursorY
        }
    };

    this.closestTarget = function(el)
    {
        if (self.targets == null)
            return;
        var elmPos = {x:(el.x.min + el.x.max) / 2 , y:(el.y.min + el.y.max) / 2};
        var min = 2147483647;
        var selectedTrg = null;
        var trgs = self.targets;
        for (var i = 0; i < trgs.length; i++) {
            var trgPos = {x:(trgs[i].x.min + trgs[i].x.max) / 2 , y:(trgs[i].y.min + trgs[i].y.max) / 2};
            var distance = Math.sqrt((Math.pow((trgPos.x - elmPos.x), 2) + Math.pow((trgPos.y - elmPos.y), 2)));
            if (distance < min) {
                min = distance;
                selectedTrg = trgs[i];
            }
        }
    };

    this.start = function(e)
    {
        if (self.element == null)
            return;

        self.cursor.setLastPosition(e);
        self.started = true;

        document.onmousemove = function(e)
        {
            var lastPos = self.cursor.getLastPosition();
            if (!lastPos.isSet)
                return;
            var currentPos = self.cursor.getCurrentPosition(e);
            var dX = currentPos.x - lastPos.x;
            dX = isNaN(dX) ? 0 : dX;
            var dY = currentPos.y - lastPos.y;
            dY = isNaN(dY) ? 0 : dY;
            var delta = {'x': dX, 'y' :dY};
            self.drag(delta);
            self.cursor.setLastPosition(e);
        };
        RC.preventSelection();
    };

    this.drag = function(d)
    {
        var check = self.check(d);
        if (check.x)
            self.element.style.left = parseInt(self.element.style.left) + d.x + 'px';
        if (check.y)
            self.element.style.top = parseInt(self.element.style.top) + d.y + 'px';
        if (typeof(self.onDrag) == 'function') {
            self.onDrag(check, d);
        }
    };

    this.stop = function()
    {
        //if (!this.started)
        //    return;
        if (self.element == null)
            return;
        self.cursor.resetLastPosition();
        self.element = null;
        self.region = null;
        self.targets = null;
        self.started = false;
        document.onmousemove = '';
        document.onmouseup = '';
        RC.preventSelection(false);
    };

    this.getRegion = function(el)
    {
        var position = el.getPosition();
        var size = el.getSize();
        return {x: {min: position.x, max:position.x + size.x}, y: {min:  position.y, max:  position.y + size.y}};
    }
};

/**
 * @class
 * @name RC.utils.Smoother
 * @function
 */
RC.utils.Smoother = function(start, stop, steps, current)
{

    this.start = start || 0;
    this.stop = stop || 1;

    this.setInterval = function(interval)
    {
        this.start = interval.start;
        this.stop = interval.stop;
        this.delta = this.stop - this.start;
    };

    this.steps = steps || smoothData.length;
    this.current = 0 || current;

    this.step = smoothData.length / this.steps;
    this.delta = this.stop - this.start;


    this.setCurrent = function(current)
    {
        this.current = current;
    };

    this.next = function()
    {
        this.current += 1;
        return scale(smoothData[index()]);
    };

    this.getCurrent = function()
    {
        return scale(smoothData[index()]);
    };

    this.prev = function()
    {
        this.current -= 1;
        return scale(smoothData[index()]);
    };

    var self = this;

    function index()
    {
        var idx = (self.current * self.step).toFixed(0);
        if (idx > smoothData.length - 1) idx = smoothData.length - 1;
        if (idx < 0) idx = 0;
        return idx;
    }

    function scale(val)
    {
        return val * self.delta + self.start
    }
};

/**
 * TODO: REFACTOR AND MOVE TO RC.util namespaces
 * @ignore
 */
var DragDrop = {
	firstContainer : null,
	lastContainer : null,
	
	makeListContainer : function(list) {
		// each container becomes a linked list node
		if (this.firstContainer == null) {
			this.firstContainer = this.lastContainer = list;
			list.previousContainer = null;
			list.nextContainer = null;
		} else {
			list.previousContainer = this.lastContainer;
			list.nextContainer = null;
			this.lastContainer.nextContainer = list;
			this.lastContainer = list;
		}
		
		// these functions are called when an item is draged over
		// a container or out of a container bounds.  onDragOut
		// is also called when the drag ends with an item having
		// been added to the container
		list.onDragOver = new Function();
		list.onDragOut = new Function();
		list.onDragStart = new Function();
		list.onDragEnd = new Function();
		
    	var items = list.getElementsByTagName( "li" );
    	
		for (var i = 0; i < items.length; i++) {
			DragDrop.makeItemDragable(items[i]);
		}
	},

	makeItemDragable : function(item) {
		XDrag.makeDraggable(item);
		item.setDragThreshold(5);
		
		// tracks if the item is currently outside all containers
		item.isOutside = false;
		
		item.onDragStart = DragDrop.onDragStart;
		item.onDrag = DragDrop.onDrag;
		item.onDragEnd = DragDrop.onDragEnd;
	},

	onDragStart : function(nwPosition, sePosition, nwOffset, seOffset) {
		// update all container bounds, since they may have changed
		// on a previous drag
		//
		// could be more smart about when to do this
		var container = DragDrop.firstContainer;
		while (container != null) {
			container.northwest = Coordinates.northwestOffset( container, true );
			container.southeast = Coordinates.southeastOffset( container, true );
			container = container.nextContainer;
		}
		
		// item starts out over current parent
		this.parentNode.onDragStart(this);
		this.parentNode.onDragOver();
		this.startParent = this.parentNode;
	},

	onDrag : function(nwPosition, sePosition, nwOffset, seOffset) {
		// check if we were nowhere
		if (this.isOutside) {
			// check each container to see if in its bounds
			var container = DragDrop.firstContainer;
			while (container != null) {
				if (nwOffset.inside( container.northwest, container.southeast ) ||
					seOffset.inside( container.northwest, container.southeast )) {
					// we're inside this one
					container.onDragOver();
					this.isOutside = false;
					
					// since isOutside was true, the current parent is a
					// temporary clone of some previous container node and
					// it needs to be removed from the document
					var tempParent = this.parentNode;
					tempParent.removeChild( this );
					container.appendChild( this );
					tempParent.parentNode.removeChild( tempParent );
					break;
				}
				container = container.nextContainer;
			}
			// we're still not inside the bounds of any container
			if (this.isOutside)
				return;
		
		// check if we're outside our parent's bounds
		} else if (!(nwOffset.inside( this.parentNode.northwest, this.parentNode.southeast ) ||
			seOffset.inside( this.parentNode.northwest, this.parentNode.southeast ))) {
			
			this.parentNode.onDragOut();
			this.isOutside = true;
			
			// check if we're inside a new container's bounds
			var container = DragDrop.firstContainer;
			while (container != null) {
				if (nwOffset.inside( container.northwest, container.southeast ) ||
					seOffset.inside( container.northwest, container.southeast )) {
					// we're inside this one
					container.onDragOver();
					this.isOutside = false;
					this.parentNode.removeChild( this );
					container.appendChild( this );
					break;
				}
				container = container.nextContainer;
			}
			// if we're not in any container now, make a temporary clone of
			// the previous container node and add it to the document
			if (this.isOutside) {
				var tempParent = this.parentNode.cloneNode( false );
				this.parentNode.removeChild( this );
				tempParent.appendChild( this );
				document.getElementsByTagName( "body" ).item(0).appendChild( tempParent );
				return;
			}
		}
		
		// if we get here, we're inside some container bounds, so we do
		// everything the original dragsort script did to swap us into the
		// correct position
		
		var parent = this.parentNode;
				
		var item = this;
		var next = DragUtils.nextItem(item);
		while (next != null && this.offsetTop >= next.offsetTop - 2) {
			var item = next;
			var next = DragUtils.nextItem(item);
		}
		if (this != item) {
			DragUtils.swap(this, next);
			return;
		}

		var item = this;
		var previous = DragUtils.previousItem(item);
		while (previous != null && this.offsetTop <= previous.offsetTop + 2) {
			var item = previous;
			var previous = DragUtils.previousItem(item);
		}
		if (this != item) {
			DragUtils.swap(this, item);
			return;
		}
	},

	onDragEnd : function(nwPosition, sePosition, nwOffset, seOffset) {
		// if the drag ends and we're still outside all containers
		// it's time to return ourselves to the source parent
		if (this.isOutside) {
			this.startParent.onDragOver();
			this.isOutside = false;
			
			// since isOutside was true, the current parent is a
			// temporary clone of some previous container node and
			// it needs to be removed from the document
			var tempParent = this.parentNode;
			tempParent.removeChild( this );
			this.startParent.appendChild( this );
			tempParent.parentNode.removeChild( tempParent );			
		}
		this.parentNode.onDragEnd(this);
		this.parentNode.onDragOut();
		this.style["top"] = "0px";
		this.style["left"] = "0px";
	}
};

/**
 * @ignore
 */
var DragUtils = {
	swap : function(item1, item2) {
		var parent = item1.parentNode;
		parent.removeChild(item1);
		parent.insertBefore(item1, item2);

		item1.style["top"] = "0px";
		item1.style["left"] = "0px";
	},

	nextItem : function(item) {
		var sibling = item.nextSibling;
		while (sibling != null) {
			if (sibling.nodeName == item.nodeName) return sibling;
			sibling = sibling.nextSibling;
		}
		return null;
	},

	previousItem : function(item) {
		var sibling = item.previousSibling;
		while (sibling != null) {
			if (sibling.nodeName == item.nodeName) return sibling;
			sibling = sibling.previousSibling;
		}
		return null;
	}		
};

/**
 * @ignore
 * TODO Remove?
 */
var XDrag = {
	BIG_Z_INDEX : 10000,
	group : null,
	isDragging : false,

	makeDraggable : function(group) {
		group.handle = group;
		group.handle.group = group;

		group.minX = null;
		group.minY = null;
		group.maxX = null;
		group.maxY = null;
		group.threshold = 0;
		group.thresholdY = 0;
		group.thresholdX = 0;

		group.onDragStart = new Function();
		group.onDragEnd = new Function();
		group.onDrag = new Function();

		// TODO: use element.prototype.myFunc
		group.setDragHandle = XDrag.setDragHandle;
		group.setDragThreshold = XDrag.setDragThreshold;
		group.setDragThresholdX = XDrag.setDragThresholdX;
		group.setDragThresholdY = XDrag.setDragThresholdY;
		group.constrain = XDrag.constrain;
		group.constrainVertical = XDrag.constrainVertical;
		group.constrainHorizontal = XDrag.constrainHorizontal;

		group.onmousedown = XDrag.onMouseDown;
	},

	constrainVertical : function() {
		var nwOffset = Coordinates.northwestOffset(this, true);
		this.minX = nwOffset.x;
		this.maxX = nwOffset.x;
	},

	constrainHorizontal : function() {
		var nwOffset = Coordinates.northwestOffset(this, true);
		this.minY = nwOffset.y;
		this.maxY = nwOffset.y;
	},

	constrain : function(nwPosition, sePosition) {
		this.minX = nwPosition.x;
		this.minY = nwPosition.y;
		this.maxX = sePosition.x;
		this.maxY = sePosition.y;
	},

	setDragHandle : function(handle) {
		if (handle && handle != null)
			this.handle = handle;
		else
			this.handle = this;

		this.handle.group = this;
		this.onmousedown = null;
		this.handle.onmousedown = XDrag.onMouseDown;
	},

	setDragThreshold : function(threshold) {
		if (isNaN(parseInt(threshold))) return;

		this.threshold = threshold;
	},

	setDragThresholdX : function(threshold) {
		if (isNaN(parseInt(threshold))) return;

		this.thresholdX = threshold;
	},

	setDragThresholdY : function(threshold) {
		if (isNaN(parseInt(threshold))) return;

		this.thresholdY = threshold;
	},

	onMouseDown : function(event) {
		event = XDrag.fixEvent(event);
		XDrag.group = this.group;

		var group = this.group;
		var mouse = event.windowCoordinate;
		var nwOffset = Coordinates.northwestOffset(group, true);
		var nwPosition = Coordinates.northwestPosition(group);
		var sePosition = Coordinates.southeastPosition(group);
		var seOffset = Coordinates.southeastOffset(group, true);

		group.originalOpacity = group.style.opacity;
		group.originalZIndex = group.style.zIndex;
		group.initialWindowCoordinate = mouse;
		// TODO: need a better name, but don't yet understand how it
		// participates in the magic while dragging
		group.dragCoordinate = mouse;

		XDrag.showStatus(mouse, nwPosition, sePosition, nwOffset, seOffset);

		group.onDragStart(nwPosition, sePosition, nwOffset, seOffset);

		// TODO: need better constraint API
		if (group.minX != null)
			group.minMouseX = mouse.x - nwPosition.x +
					group.minX - nwOffset.x;
		if (group.maxX != null)
			group.maxMouseX = group.minMouseX + group.maxX - group.minX;

		if (group.minY != null)
			group.minMouseY = mouse.y - nwPosition.y +
					group.minY - nwOffset.y;
		if (group.maxY != null)
			group.maxMouseY = group.minMouseY + group.maxY - group.minY;

		group.mouseMin = new Coordinate(group.minMouseX, group.minMouseY);
		group.mouseMax = new Coordinate(group.maxMouseX, group.maxMouseY);

		document.onmousemove = XDrag.onMouseMove;
		document.onmouseup = XDrag.onMouseUp;

		return false;
	},

	showStatus : function(mouse, nwPosition, sePosition, nwOffset, seOffset) {
		window.status =
				"mouse: " + mouse.toString() + "    " +
				"NW pos: " + nwPosition.toString() + "    " +
				"SE pos: " + sePosition.toString() + "    " +
				"NW offset: " + nwOffset.toString() + "    " +
				"SE offset: " + seOffset.toString();
	},

	onMouseMove : function(event) {
		event = XDrag.fixEvent(event);
		var group = XDrag.group;
		var mouse = event.windowCoordinate;
		var nwOffset = Coordinates.northwestOffset(group, true);
		var nwPosition = Coordinates.northwestPosition(group);
		var sePosition = Coordinates.southeastPosition(group);
		var seOffset = Coordinates.southeastOffset(group, true);

		//XDrag.showStatus(mouse, nwPosition, sePosition, nwOffset, seOffset);

		if (!XDrag.isDragging) {
			if (group.threshold > 0) {
				var distance = group.initialWindowCoordinate.distance(
						mouse);
				if (distance < group.threshold) return true;
			} else if (group.thresholdY > 0) {
				var deltaY = Math.abs(group.initialWindowCoordinate.y - mouse.y);
				if (deltaY < group.thresholdY) return true;
			} else if (group.thresholdX > 0) {
				var deltaX = Math.abs(group.initialWindowCoordinate.x - mouse.x);
				if (deltaX < group.thresholdX) return true;
			}

			XDrag.isDragging = true;
			group.style["zIndex"] = XDrag.BIG_Z_INDEX;
			group.style["opacity"] = 0.75;
		}

		// TODO: need better constraint API
		var adjusted = mouse.constrain(group.mouseMin, group.mouseMax);
		nwPosition = nwPosition.plus(adjusted.minus(group.dragCoordinate));
		nwPosition.reposition(group);
		group.dragCoordinate = adjusted;

		// once dragging has started, the position of the group
		// relative to the mouse should stay fixed.  They can get out
		// of sync if the DOM is manipulated while dragging, so we
		// correct the error here
		//
		// TODO: what we really want to do is find the offset from
		// our corner to the mouse coordinate and adjust to keep it
		// the same

		// changed to be recursive/use absolute offset for corrections
		var offsetBefore = Coordinates.northwestOffset(group, true);
		group.onDrag(nwPosition, sePosition, nwOffset, seOffset);
		var offsetAfter = Coordinates.northwestOffset(group, true);

		if (!offsetBefore.equals(offsetAfter)) {
			var errorDelta = offsetBefore.minus(offsetAfter);
			nwPosition = Coordinates.northwestPosition(group).plus(errorDelta);
			nwPosition.reposition(group);
		}

		return false;
	},

	onMouseUp : function(event) {
		event = XDrag.fixEvent(event);
		var group = XDrag.group;

		var mouse = event.windowCoordinate;
		var nwOffset = Coordinates.northwestOffset(group, true);
		var nwPosition = Coordinates.northwestPosition(group);
		var sePosition = Coordinates.southeastPosition(group);
		var seOffset = Coordinates.southeastOffset(group, true);

		document.onmousemove = null;
		document.onmouseup   = null;
		group.onDragEnd(nwPosition, sePosition, nwOffset, seOffset);

		if (XDrag.isDragging) {
			// restoring zIndex before opacity avoids visual flicker in Firefox
			group.style["zIndex"] = group.originalZIndex;
			group.style["opacity"] = group.originalOpacity;
		}

		XDrag.group = null;
		XDrag.isDragging = false;

		return false;
	},

	fixEvent : function(event) {
		if (typeof event == 'undefined') event = window.event;
		Coordinates.fixEvent(event);

		return event;
	}
};

/**
 * @ignore
 */
var Coordinates = {
	ORIGIN : new Coordinate(0, 0),

	northwestPosition : function(element) {
		var x = parseInt(element.style.left);
		var y = parseInt(element.style.top);

		return new Coordinate(isNaN(x) ? 0 : x, isNaN(y) ? 0 : y);
	},

	southeastPosition : function(element) {
		return Coordinates.northwestPosition(element).plus(
				new Coordinate(element.offsetWidth, element.offsetHeight));
	},

	northwestOffset : function(element, isRecursive) {
		var offset = new Coordinate(element.offsetLeft, element.offsetTop);

		if (!isRecursive) return offset;

		var parent = element.offsetParent;
		while (parent) {
			offset = offset.plus(
					new Coordinate(parent.offsetLeft, parent.offsetTop));
			parent = parent.offsetParent;
		}
		return offset;
	},

	southeastOffset : function(element, isRecursive) {
		return Coordinates.northwestOffset(element, isRecursive).plus(
				new Coordinate(element.offsetWidth, element.offsetHeight));
	},

	fixEvent : function(event) {
		event.windowCoordinate = new Coordinate(event.clientX, event.clientY);
	}
};

function Coordinate(x, y) {
	this.x = x;
	this.y = y;
}

Coordinate.prototype.toString = function() {
	return "(" + this.x + "," + this.y + ")";
}

Coordinate.prototype.plus = function(that) {
	return new Coordinate(this.x + that.x, this.y + that.y);
}

Coordinate.prototype.minus = function(that) {
	return new Coordinate(this.x - that.x, this.y - that.y);
}

Coordinate.prototype.distance = function(that) {
	var deltaX = this.x - that.x;
	var deltaY = this.y - that.y;

	return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
}

Coordinate.prototype.max = function(that) {
	var x = Math.max(this.x, that.x);
	var y = Math.max(this.y, that.y);
	return new Coordinate(x, y);
}

Coordinate.prototype.constrain = function(min, max) {
	if (min.x > max.x || min.y > max.y) return this;

	var x = this.x;
	var y = this.y;

	if (min.x != null) x = Math.max(x, min.x);
	if (max.x != null) x = Math.min(x, max.x);
	if (min.y != null) y = Math.max(y, min.y);
	if (max.y != null) y = Math.min(y, max.y);

	return new Coordinate(x, y);
}

Coordinate.prototype.reposition = function(element) {
	element.style["top"] = this.y + "px";
	element.style["left"] = this.x + "px";
}

Coordinate.prototype.equals = function(that) {
	if (this == that) return true;
	if (!that || that == null) return false;

	return this.x == that.x && this.y == that.y;
}

// returns true of this point is inside specified box
Coordinate.prototype.inside = function(northwest, southeast) {
	if ((this.x >= northwest.x) && (this.x <= southeast.x) &&
		(this.y >= northwest.y) && (this.y <= southeast.y)) {

		return true;
	}
	return false;
}


/**
 * History management component that allows you to register arbitrary tokens that signify application history state on navigation actions.
 * You can then handle the history {@link #change} event in order to reset your application UI to the appropriate state when the user navigates
 * forward or backward through the browser history stack.
 *
 * @class
 * @name RC.utils.History
 * @singleton
 */
RC.utils.History = (function ()
{
    var iframe, hiddenField;
    var ready = false;
    var currentToken;

    function getHash()
    {
        var hashSymbol = "#";
        var href = top.location.href, i = href.indexOf("#");
        if (i == -1) {
            hashSymbol = "%2523";
            i = href.indexOf(hashSymbol);
        }
        return i >= 0 ? href.substr(i + hashSymbol.length) : null;
    }

    function doSave()
    {
        hiddenField.value = currentToken;
    }

    function handleStateChange(token)
    {
        currentToken = token;
        RC.utils.History.change(token);
    }

    function updateIFrame(token)
    {
        var html = ['<html><body><div id="state">',token,'</div></body></html>'].join('');
        try {
            var doc = iframe.contentWindow.document;
            doc.open();
            doc.write(html);
            doc.close();
            return true;
        } catch (e) {
            alert(e);
            return false;
        }
    }

    function checkIFrame()
    {
        if (!iframe.contentWindow || !iframe.contentWindow.document) {
            setTimeout(checkIFrame, 10);
            return;
        }

        var doc = iframe.contentWindow.document;
        var elem = doc.getElementById("state");
        var token = elem ? elem.innerText : null;

        var hash = getHash();

        setInterval(function ()
        {

            doc = iframe.contentWindow.document;
            elem = doc.getElementById("state");

            var newtoken = elem ? elem.innerText : null;

            var newHash = getHash();

            if (newtoken !== token) {
                token = newtoken;
                handleStateChange(token);
                top.location.hash = token;
                hash = token;
                doSave();
            } else if (newHash !== hash) {
                hash = newHash;
                updateIFrame(newHash);
            }

        }, 50);

        ready = true;
    }

    function startUp()
    {
        currentToken = hiddenField.value ? hiddenField.value : getHash();

        if (Browser.name === "ie") {
            checkIFrame();
        } else {
            var hash = getHash();
            setInterval(function ()
            {
                var newHash = getHash();
                if (newHash !== hash) {
                    hash = newHash;
                    handleStateChange(hash);
                    doSave();
                }
            }, 50);
            ready = true;
        }
    }

    return {

        /**
         * The id of the hidden field required for storing the current history token.
         * @type {String}
         */
        fieldId: 'x-history-field',

        /**
         * The id of the iframe required by IE to manage the history stack.
         * @type {String}
         */
        iframeId: 'x-history-frame',

        /**
         * Detects mode which was used.
         * @type {Boolean}
         */
        f5Mode  : false,

        /**
         * @event change
         * Fires when navigation back or forwards within the local page's history occurs.
         * @param {RC.utils.History} this
         * @param {String} token The token
         */
        change : function() {},

        /**
         * Initialize the global History instance.
         * @param {Boolean} onReady
         */
        init: function (onReady)
        {
            hiddenField = $(RC.utils.History.fieldId);
            if (Browser.name === "ie") {
                iframe = $(RC.utils.History.iframeId);
            }
            RC.utils.History.change(getHash());
        },

        /**
         * Add a new token to the history stack. This can be any arbitrary value, although it would commonly be
         * the concatenation of a component id and another id marking the specifc history state of that component. 
         * @param {String} token
         * @param {Boolean} refresh
         */
        add: function (token, refresh)
        {
            if (this.f5Mode)
                return;
            top.location.hash = token;
        },

        /**
         * Programmatically steps back one step in browser history (equivalent to the user pressing the Back button).
         */
        back: function()
        {
            history.go(-1);
        },

        /**
         * Programmatically steps forward one step in browser history (equivalent to the user pressing the Forward button).
         */
        forward: function()
        {
            history.go(1);
        },

        /**
         * Retrieves the currently-active history token.
         * @return {String} The token
         */
        getToken: function()
        {
            return ready ? currentToken : getHash();
        },

        /**
         * Retrieves history token by index.
         * @param {Number} idx
         * @return {String} The token
         */
        getTokenIndexOf: function(idx)
        {
            var token = ready ? currentToken : getHash();
            if (token == null)
                return null;
            if (token.indexOf('/') == -1 && idx == 0)
                return token;
            else if (token.indexOf('/') == -1)
                return null;
            token = token.split('/');
            return token[idx] !== undefined ? token[idx] : null;
        }
    };
})();

RC.apply(RC.utils.History, RC);

RC.utils.DateFormatter = function() {
    var self = this;

    var DEFAULT_CONFIG = {
        "langCode": "en_US",
        "timeZoneOffset": "00:00",
        "serverTimeZoneOffset": "00:00",
        "shortDateFormat": "MM/DD/YYYY",
        "longDateFormat": "dddd, MMMM DD, YYYY",
        "fileNameTimestampFormat": "MMDDYYYY-HHmmss",
        "shortTimeFormat": "h:mm A",
        "hoursType": "USA",
        "dateSeparator": "/",
        "timeSeparator": ":"
    };
    var DEFAULT_LANG = {
        DURATION_IN_PROGRESS: "In progress",
        DATE_TODAY: "Today",
        DATE_YESTERDAY: "Yesterday"
    };

    var conf = {};

    var lang = {};

    var weekDaysData = [];

    self.moment = {};

    /**
     * Specify date, time formats and other configuration data.
     *
     * @param configuration {object} Normally this is 'config.regionalFormat' data.
     * @param langSettings {object} Normally this is part or related lang resource.
     * @param momentLocale {String} Locale name for MomentJS. Leave empty to use "en_US"
     */
    self.init = function(configuration, langSettings, momentLocale) {
        initConf(configuration);
        initLang(langSettings);
        initMomentJs(momentLocale);
        weekDaysData = [];
    };

    function parseZoneOffset(tzString){
        var result = 0;
        var match = /([+-]?)([0-9]{1,2}):([0-9]{1,2})/g.exec(tzString);
        if (match && match[2] != "" && match[3] != "") {
            result = match[2] * 60 + match[3] * 1;

            if (match[1] == "-"){
                result = -1 * result;
            }
        }
        return result;
    }

    function initConf(configuration) {
        configuration = configuration || {};
        conf.langCode = configuration.langCode || DEFAULT_CONFIG.langCode;
        conf.timeZoneOffset = configuration.timeZoneOffset || DEFAULT_CONFIG.timeZoneOffset;
        conf.serverTimeZoneOffset = configuration.serverTimeZoneOffset || DEFAULT_CONFIG.serverTimeZoneOffset;
        calculateDateCorrection();
        conf.shortDateFormat = configuration.shortDateFormat || DEFAULT_CONFIG.shortDateFormat;
        conf.longDateFormat = configuration.longDateFormat || DEFAULT_CONFIG.longDateFormat;
        conf.fileNameTimestampFormat = configuration.fileNameTimestampFormat || DEFAULT_CONFIG.fileNameTimestampFormat;
        correctDateFormats();
        conf.shortTimeFormat = configuration.shortTimeFormat || DEFAULT_CONFIG.shortTimeFormat;
        conf.hoursType = parseHoursType(configuration.hoursType) || DEFAULT_CONFIG.hoursType;
        correctShortTimeFormat();
        conf.dateSeparator = configuration.dateSeparator || DEFAULT_CONFIG.dateSeparator;
        conf.timeSeparator = configuration.timeSeparator || DEFAULT_CONFIG.timeSeparator;

        function calculateDateCorrection() {
            var mailboxOffset = parseZoneOffset(conf.timeZoneOffset);
            var serverOffset = parseZoneOffset(conf.serverTimeZoneOffset);

            conf.serverTimeZoneOffsetSec = serverOffset;
            conf.defaultDateCorrection = (mailboxOffset - serverOffset) * 60 * 1000;
        }

        function parseHoursType(hoursType) {
            var result = hoursType || DEFAULT_CONFIG.hoursType;
            result = result.toLocaleUpperCase();
            if (result != "H24") {
                result = DEFAULT_CONFIG.hoursType;
            }
            return result;
        }

        function correctShortTimeFormat() {
            if (conf.shortTimeFormat && conf.hoursType) {
                if (conf.hoursType == "H24") {
                    conf.shortTimeFormat = conf.shortTimeFormat.replace(/\s*[a]/gi, "");
                    conf.shortTimeFormat = conf.shortTimeFormat.replace(/[h]/g, "H");
                } else {
                    conf.shortTimeFormat = conf.shortTimeFormat.replace(/[HH]{1,2}/g, "h");
                    if (conf.shortTimeFormat.indexOf("a") == -1 && conf.shortTimeFormat.indexOf("A") == -1) {
                        conf.shortTimeFormat = conf.shortTimeFormat + " A";
                    }
                }
            }
        }

        function correctDateFormats() {
            conf.shortDateFormat = convertDateFormat(conf.shortDateFormat);
            conf.longDateFormat = convertDateFormat(conf.longDateFormat);
            conf.fileNameTimestampFormat = convertDateFormat(conf.fileNameTimestampFormat);

            function convertDateFormat(javaDateFormat) {
                var result = javaDateFormat;
                if (result) {
                    result = result.replace(/[y]/g, "Y");
                    result = result.replace(/(^|[^d])[d]{2,2}(?![d])/g, "$1DD");
                    result = result.replace(/(^|[^d])[d](?![d])/g, "$1D");
                }
                return result;
            }
        }
    }

    function initLang(langSettings) {
        langSettings = langSettings || {};
        lang.DURATION_IN_PROGRESS = langSettings.DURATION_IN_PROGRESS || DEFAULT_LANG.DURATION_IN_PROGRESS;
        lang.DATE_TODAY = langSettings.DATE_TODAY || DEFAULT_LANG.DATE_TODAY;
        lang.DATE_YESTERDAY = langSettings.DATE_YESTERDAY || DEFAULT_LANG.DATE_YESTERDAY;
    }

    function initMomentJs(momentLocale) {
        var momentLang = "en";
        if (momentLocale && momentLocale != null) {
            momentLang = momentLocale;
        }
        conf.momentLang = momentLang;
        //Be sure that RCLib includes patched version of MomentJS. Otherwise, please handle issues with RequireJS.
        self.moment = moment;
        self.moment.lang(momentLang);
    }

    /**
     * Extract dateValue.time value for RC date. Otherwise returns dateValue.
     * @param dateValue
     * @returns {*}
     */
    function prepareDateObject(dateValue) {
        var result = dateValue;
        if (dateValue.time != undefined && dateValue.time != null) {
            result = dateValue.time;
            //Look at server TZ offset
            if (dateValue.timezoneOffset != undefined && dateValue.timezoneOffset != null && typeof dateValue.timezoneOffset == "number") {
                result = result - dateValue.timezoneOffset * 60 * 1000;
            }
        }
        return result;
    }

    //Init configuration using default parameters
    self.init();

    /**
     * Get current locale code.
     *
     * @returns {string} Something like 'en_US'.
     */
    self.getLangCode = function() {
        return conf.langCode;
    };
    /**
     * Get current short date format.
     *
     * @returns {string} Something like 'MM/dd/yyyy'.
     */
    self.getShortDateFormat = function() {
        return conf.shortDateFormat;
    };

    /**
     * Get current long date format.
     *
     * @returns {string} Something like 'dddd, MMMM dd, yyyy'.
     */
    self.getLongDateFormat = function() {
        return conf.longDateFormat;
    };

    /**
     * Get current short time format.
     *
     * @returns {string} Something like 'h:mm A'.
     */
    self.getShortTimeFormat = function() {
        return conf.shortTimeFormat;
    };

    /**
     * Get date correction based on mailbox time zone. Current mailbox time zone will be used if timeZoneOffset parameter is not specified.
     *
     * @returns {int} difference between browser's and mailbox time zones.
     */
    self.getDateCorrection = function() {
        return -1 * conf.serverTimeZoneOffsetSec * 60 * 1000;
    };

    /**
     * Get additional lang resource.
     *
     * @returns {object} Constants for RC specific labels.
     */
    self.getLang = function() {
        return lang;
    };

    /**
     * Format duration. If withHours is true, function returns following results:
     * <ul>
     * <li>durationInSecons=-1, result="In progress"</li>
     * <li>durationInSecons=0, result="0:00:00"</li>
     * <li>durationInSecons=3, result="0:00:03"</li>
     * <li>durationInSecons=63, result="0:01:03"</li>
     * <li>durationInSecons=3663, result="1:01:03"</li>
     * </ul>.
     * Otherwise:
     * <ul>
     * <li>durationInSecons=-1, result="In progress"</li>
     * <li>durationInSecons=0, result="0:00"</li>
     * <li>durationInSecons=3, result="0:03"</li>
     * <li>durationInSecons=63, result="1:03"</li>
     * </ul>
     *
     * @param seconds {number} duration in seconds.
     * @param withHours {boolean} Whether to display the "hours" part.
     * @returns {string} Human readable label.
     */
    self.formatDuration = function(seconds, withHours) {
        var result = lang.DURATION_IN_PROGRESS;
        if (seconds != null && seconds >= 0) {
            var hours = 0;
            if (withHours === true) {
                hours = ~~(seconds / (60 * 60));

            }
            seconds = seconds - hours * (60 * 60);

            var min = ~~(seconds / 60);
            seconds = seconds - min * 60;

            function normalize(time) {
                return time < 10 ? "0" + time : time;
            }

            if (withHours === true) {
                result = hours + conf.timeSeparator + normalize(min) + conf.timeSeparator + normalize(seconds);
            } else {
                result = min + conf.timeSeparator + normalize(seconds);
            }
        }
        return result;
    };

    /**
     * Format time value. Result dependents from formation configuration, for example may be:
     * <ul>
     * <li>05:04 PM</li>
     * <li>23:05</li>
     * </ul>.
     *
     * @param time {Date|string|int|object} time. Method can resolve int (unix type), string (full date), Js and momemtn JS date or RC date object (now only "time" field is used)
     * @param isUTC {boolean} true if date should be converted into UTC. False if date will displayed in current time zone
     * @returns {string} Human readable label.
     */
    self.formatTime = function(time, isUTC) {
        var result = "";
        if (time != undefined && time != null) {
            var tempDate;
            if (isUTC == true){
                tempDate = self.moment.utc(prepareDateObject(time));
            } else {
                tempDate = self.moment(prepareDateObject(time));
            }
            if (tempDate.isValid()) {
                result = tempDate.format(conf.shortTimeFormat);
            }
        }
        return result;
    };

    /**
     * Format date value use short format and day of week. Result dependents from formation configuration, for example may be:
     * <ul>
     * <li>Mon 05/19/2014</li>
     * <li>"Today" or "Yesterday" if "humanize" === true</li>
     * </ul>.
     *
     * @param date {Date|string|int|object} time. Method can resolve int (unix type), string (full date), Js and momemtn JS date or RC date object (now only "time" field is used)
     * @param humanize {boolean} true if today and Yesterday dates should be replaced by words. Otherwise regular date format will be used.
     * @returns {string} Human readable label.
     */
    self.formatMidDate = function(date, humanize) {
        var result = "";
        if (date && date != null) {
            var tempDate = self.moment(prepareDateObject(date));
            if (tempDate.isValid()) {
                if (humanize == true) {
                    var now = self.moment();
                    if (tempDate._isUTC) { // It really means date in mailbox's time format interpreted as UTC
                        now = self.moment.utc();
                        now.add(conf.defaultDateCorrection, "ms");
                    }
                    if (now.isSame(tempDate, "day")) {
                        result = lang.DATE_TODAY;
                    } else if (now.subtract(1, "day").isSame(tempDate, "day")) {
                        result = lang.DATE_YESTERDAY;
                    } else {
                        result = tempDate.format("ddd " + conf.shortDateFormat);
                    }
                } else {
                    result = tempDate.format("ddd " + conf.shortDateFormat);
                }
            }
        }
        return result;
    };

    /**
     * Format date value use short format. Result dependents from formation configuration, for example may be:
     * <ul>
     * <li>05/19/2014</li>
     * <li>19.05.2014</li>
     * </ul>.
     *
     * @param date {Date|string|int|object} time. Method can resolve int (unix type), string (full date), Js and momemtn JS date or RC date object (now only "time" field is used)
     * @param isUTC {boolean} true if date should be converted into UTC. False if date will displayed in current time zone
     * @returns {string} Human readable label.
     */
    self.formatShortDate = function(date, isUTC) {
        var result = "";
        if (date && date != null) {
            var tempDate;
            if (isUTC == true){
                tempDate = self.moment.utc(prepareDateObject(date));
            } else {
                tempDate = self.moment(prepareDateObject(date));
            }
            if (tempDate.isValid()) {
                result = tempDate.format(conf.shortDateFormat);
            }
        }
        return result;
    };

    /**
     * Format date and time value. Result dependents from formation configuration, for example may be:
     * <ul>
     * <li>05/19/2014 06:15 PM</li>
     * <li>19.05.2014 18:15</li>
     * </ul>.
     *
     * @param date {Date|string|int|object} time. Method can resolve int (unix type), string (full date), Js and momemtn JS date or RC date object (now only "time" field is used)
     * @param dateFormat {string} Optional parameter for date part. But default short date format is used
     * @param isUTC {boolean} true if date should be converted into UTC. False if date will displayed in current time zone
     * @returns {string} Human readable label.
     */
    self.formatDateTime = function(date, dateFormat, isUTC) {
        var result = "";
        if (date != undefined && date != null) {
            var tempDate;
            if (isUTC == true){
                tempDate = self.moment.utc(prepareDateObject(date));
            } else {
                tempDate = self.moment(prepareDateObject(date));
            }
            if (tempDate.isValid()) {
                var format = (dateFormat || (conf.shortDateFormat + " ")) + conf.shortTimeFormat;
                result = tempDate.format(format);
            }
        }
        return result;
    };

    /**
     * Format date value. Result dependents from formation configuration, for example may be:
     * <ul>
     * <li>05/19/2014</li>
     * <li>19.05.2014</li>
     * </ul>.
     *
     * @param date {Date|string|int|object} time. Method can resolve int (unix type), string (full date), Js and momemtn JS date or RC date object (now only "time" field is used)
     * @param dateFormat {string} Optional parameter for date part. But default short date format is used
     * @returns {string} Human readable label.
     */
    self.formatDate = function(date, dateFormat) {
        var result = "";
        if (date && date != null) {
            var tempDate = self.moment(prepareDateObject(date));
            if (tempDate.isValid()) {
                var format = dateFormat || conf.shortDateFormat;
                result = tempDate.format(format);
            }
        }
        return result;
    };

    /**
     * Prepare date for file name.
     *
     * @param date {Date|string|int|object} time. Method can resolve int (unix type), string (full date), Js and momemtn JS date or RC date object (now only "time" field is used)
     * @returns {string} Something like 01282014_180023 for 2014-01-28 18:00:23.
     */
    self.formatFileNameTimestamp = function(date) {
        var result = "";
        if (date && date != null) {
            var tempDate = self.moment(prepareDateObject(date));
            if (tempDate.isValid()) {
                result = tempDate.format(conf.fileNameTimestampFormat);
            }
        }
        return result;
    };

    /**
     *
     * Prepare months names for date picker. Result depends of current used language (momentjs locale).
     *
     * @returns {Array} Array of arrays. Each row contains index and human readable month name.
     */
    self.createMonthsStore = function() {
        var date = self.moment();
        var result = [];
        for (var i = 0; i < 12; i++) {
            result.push([i, date.month(i).format("MMMM")]);
        }
        return result;
    };

    /**
     * Prepare date for string.
     *
     * @param dateString {string} String representation of date.
     * @param format {string} Optional value with MomentJS date format. If it is not specifies, short date format will be used.
     * @returns {Date} JS date object if date was parsed. Otherwise returns null.
     */
    self.parseDate = function(dateString, format) {
        format = format || conf.shortDateFormat;

        var result = null;
        if (dateString) {
            var date = self.moment(dateString, format, true);
            if (date.isValid()) {
                result = date.toDate();
            }
        }
        return result;
    };

    /**
     * Convert date to UTC (set Time Zone 00:00).
     * @param {Date} date
     * @returns {Moment} MomentJS date with 00:00 time zone. Otherwise returns null.
     */
    self.toUtc = function(date){
        var result = null;
        if (date != undefined && date != null) {
            var src = self.moment.utc(prepareDateObject(date));
            if (src.isValid()){
                result = src;
            }
        }
        return result;
    };

    /**
     * Is the 12-hour time format?
     *
     * @returns {boolean} true if 12-hour time format. false for 24-hour.
     */
    self.isUsaTimeFormat = function() {
        return conf.hoursType != "H24";
    };

    var WeekDay = function(isoWeekDay, description) {
        var self = this;
        //Do not translate these values. This is keys for server data, not user labels.
        var isoWeekMapping = [
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday',
            'Sunday'
        ];
        self.name = isoWeekMapping[isoWeekDay - 1];
        self.description = description;
        /**
         * ISO week day number. Start from 1. First day is Monday for every locale.
         * value from 1 (Monday) to 7 (Sunday)
         * @type {number}
         */
        self.isoWeekDay = isoWeekDay;
        /**
         * Is this work day?
         * true for work day and false for weekends.
         * @type {boolean}
         */
        self.isWorkDay = ((isoWeekDay != 6) && (isoWeekDay != 7));
    };
    /**
     * Week day data. Contains english name, localized name (according current language) and .
     * @constructor
     */
    self.WeekDay = WeekDay;

    /**
     * Get week days info according current language and regional formatting.
     *
     * @returns {Array} Array of WeekDay objects. First day is taken from current user's regional settings.
     */
    self.prepareWeekDaysData = function() {
        if (weekDaysData.length <= 0) {
            var date = self.moment();
            for (var i = 0; i < 7; i++) {
                date.lang(conf.langCode);
                date = date.weekday(i);
                date.lang(conf.momentLang);
                weekDaysData.push(new WeekDay(date.isoWeekday(), date.format("dddd")));
            }
        }
        return RC.clone(weekDaysData);
    }
};

/**
 * @class
 * @name RC.utils.Date
 * @singleton
 */
RC.utils.Date = new RC.utils.DateFormatter();


/**
 * Created by dmitry.ashurov on 25.04.2014.
 */
RC.ns("RC.utils.TimeIntervals");

/**
 * Value of time interval in minutes.
 * Must be a whole divider of an hour (60 minutes), e.g. 5, 10, 15, etc.
 * @type {number}
 */
RC.utils.TimeIntervals.TIME_STEP = 15;
RC.utils.TimeIntervals.AM = "am";
RC.utils.TimeIntervals.PM = "pm";

RC.utils.TimeIntervals.getIntervalsList = function(isUSATimeFormat) {
    "use strict";
    var step = RC.utils.TimeIntervals.TIME_STEP,
        hour = 60,
        day = hour * 24;

    var start  = isUSATimeFormat ? hour : 0;
    var period = isUSATimeFormat ? day/2 + hour : day;

    var list = [];

    for (var i = start; i < period; i += step) {
        var minutes = i % hour;
        list[list.length] = [i, parseInt(i / 60) + ":" + (minutes < 10 ? minutes + '0' : minutes)];
    }

    //12 hours period special handler
    if(isUSATimeFormat) {
        var tail = list.splice(-4);
        list = tail.concat(list);
    }

    return list;
};

RC.utils.TimeIntervals.minutes2seconds = function(time, ampm, isUSATimeFormat) {
    if (isUSATimeFormat) {
        if (RC.isEmpty(time) || time < 60 || time >= 780 || (ampm != RC.utils.TimeIntervals.AM && ampm != RC.utils.TimeIntervals.PM)) {
            return null;
        }

        if (time >= 720) {
            time -= 720;
        }

        var seconds = time * 60;
        if (ampm == 'pm') {
            seconds += 43200;
        }
    } else {
        seconds = time * 60;
    }
    return seconds;
};

RC.utils.TimeIntervals.getMinutesBySeconds = function(seconds, isUSATimeFormat) {
    var minutes = seconds / 60;
    if (isUSATimeFormat) {
        if (minutes >= 720) {
            if (minutes >= 780) {
                minutes -= 720;
            }
        } else {
            if (minutes < 60) {
                minutes += 720;
            }
        }
    }
    return minutes;
};

/**
 * Detect day part (AM or PM) using time in seconds.
 *
 * @param seconds {number|string} time in seconds
 * @returns {string} RC.utils.TimeIntervals.AM or RC.utils.TimeIntervals.PM value
 */
RC.utils.TimeIntervals.getAMPMBySeconds = function(seconds) {
    var hours = (seconds / 60 / 60) % 24;
    var ampm = null;
    if (hours >= 12) {
        ampm = RC.utils.TimeIntervals.PM;
    } else {
        ampm = RC.utils.TimeIntervals.AM;
    }
    return ampm;
};

RC.utils.CurrencyFormatter = function () {
    var self = this;

    /**
     * This is part of 'config.regionalFormat' currency.
     */
    var DEFAULT_CONFIG_MONEY = {
        symbol: '$',
        format: {
            pos: '%s%v',
            neg: '(%s%v)',
            zero: '%s%v'
        },
        decimal: '.',
        thousand: ',',
        precision: '2'
    };

    var DEFAULT_CONFIG_CENTS = {
        symbol: '',
        format: '%v%s',
        decimal: '.',
        thousand: ',',
        precision: '1'
    };

    self.init = function(regionalFormat) {
        initConf(regionalFormat);
    };

    function initConf(regionalFormat) {
        regionalFormat = regionalFormat || {};

        DEFAULT_CONFIG_MONEY.symbol = regionalFormat.currencySymbol || DEFAULT_CONFIG_MONEY.symbol;
        DEFAULT_CONFIG_CENTS.symbol = regionalFormat.currencyDecimalSymbol || DEFAULT_CONFIG_CENTS.symbol;

        DEFAULT_CONFIG_MONEY.decimal = regionalFormat.decimalSeparator || DEFAULT_CONFIG_MONEY.decimal;
        DEFAULT_CONFIG_MONEY.thousand = regionalFormat.thousandSeparator || DEFAULT_CONFIG_MONEY.thousand;
        DEFAULT_CONFIG_CENTS.decimal = regionalFormat.decimalSeparator || DEFAULT_CONFIG_CENTS.decimal;
        DEFAULT_CONFIG_CENTS.thousand = regionalFormat.thousandSeparator || DEFAULT_CONFIG_CENTS.thousand;

        DEFAULT_CONFIG_MONEY.precision = regionalFormat.currencyDecimals || DEFAULT_CONFIG_MONEY.precision;
        DEFAULT_CONFIG_MONEY.format.pos = regionalFormat.positiveCurrencyFormat || DEFAULT_CONFIG_MONEY.format.pos;
        DEFAULT_CONFIG_MONEY.format.neg = regionalFormat.negatieCurrencyFormat || DEFAULT_CONFIG_MONEY.format.neg;
        DEFAULT_CONFIG_MONEY.format.zero = regionalFormat.zeroCurrencyFormat || DEFAULT_CONFIG_MONEY.format.zero;

        accounting.settings.currency = DEFAULT_CONFIG_MONEY;
    }

    self.init();

    self.getConfMoney = function () {
        return DEFAULT_CONFIG_MONEY;
    };

    self.getConfCents = function () {
        return DEFAULT_CONFIG_CENTS;
    };

    /**
     * Format currency value using current configuration. For example for US lang and "$" result may be:
     * <ul>
     *     <li>$1,234.50 for positive values<li>
     *     <li>($1,234.50) for negative values<li>
     * </ul>
     *
     * @param value {int|string} amount of money.
     * @param precision precision {int} the number of decimal places.
     * @returns {*} Formatted result and currency symbol.
     */
    self.formatCurrency = function (value, precision) {
        precision = precision || DEFAULT_CONFIG_MONEY.precision;
        return accounting.formatMoney(value, DEFAULT_CONFIG_MONEY.symbol, precision);
    };

    /**
     * Format currency value using current configuration. Also it displays small values like 2 cents.
     * For example for US lang and "$" result may be:
     * <ul>
     *     <li>$1,234.50 for positive values<li>
     *     <li>($1,234.50) for negative values<li>
     *     <li>2.5 for small positive values<li>
     *     <li>(2.5) for small negative values<li>
     * </ul>
     *
     * @param value {int|string} amount of money.
     * @returns {*} Formatted result and currency sumbol.
     */
    self.formatCurrencyAsCent = function (value) {
        if(value >= 1 || value <= -1){
            return self.formatCurrency(value);
        } else {
            var cents = value * 100;

            return accounting.formatMoney(cents, DEFAULT_CONFIG_CENTS);
        }
    };
};

RC.utils.Currency = new RC.utils.CurrencyFormatter();


RC.utils.NumberFormatter = function() {
    var self = this;

    var DEFAULT_CONFIG = {
        "precision": 0,
        "thousand": ",",
        "decimal": "."
    };
    var DEFAULT_LANG = {
        "SIZE_KB": "{0} KB",
        "SIZE_PAGE": "1 page",
        "SIZE_PAGES": "{0} pages"
    };

    var conf = {};

    var lang = {};

    /**
     * Specify decimal, thousand separators and other configuration data.
     *
     * @param configuration {object} Normally this is 'config.regionalFormat' data.
     * @param langSettings {object} Normally this is part or related lang resource.
     */
    self.init = function(configuration, langSettings) {
        initConf(configuration);
        initLang(langSettings);
    };
    function initConf(configuration) {
        configuration = configuration || {};
        conf.thousand = configuration.thousandSeparator || DEFAULT_CONFIG.thousand;
        conf.decimal = configuration.decimalSeparator || DEFAULT_CONFIG.decimal;
        conf.precision = DEFAULT_CONFIG.precision;

        accounting.settings.number = conf;
    }

    function initLang(langSettings) {
        langSettings = langSettings || {};
        lang.SIZE_KB = langSettings.SIZE_KB || DEFAULT_LANG.SIZE_KB;
        lang.SIZE_PAGE = langSettings.SIZE_PAGE || DEFAULT_LANG.SIZE_PAGE;
        lang.SIZE_PAGES = langSettings.SIZE_PAGES || DEFAULT_LANG.SIZE_PAGES;
    }

    //Init configuration using default parameters
    self.init();

    /**
     * Get current thousand separator.
     *
     * @returns {string} Something like ','.
     */
    self.getThousandSeparator = function() {
        return conf.thousand;
    };
    /**
     * Get current decimal separator.
     *
     * @returns {string} Something like '.'.
     */
    self.getDecimalSeparator = function() {
        return conf.decimal;
    };

    /**
     * Get additional lang resource.
     *
     * @returns {object} Constants for RC specific labels.
     */
    self.getLang = function() {
        return lang;
    };

    /**
     * Format numberResult dependents from formation configuration, for example may be:
     * <ul>
     * <li>1,234.56 (for precision == 2)</li>
     * <li>1,234 (for precision == 0)</li>
     * </ul>.
     *
     * @param value {int|double} Numeric value.
     * @param precision {int} the number of decimal places.
     * @returns {string} Human readable string.
     */
    self.formatNumber = function(value, precision) {
        precision = precision || conf.precision;
        var result = "";
        if (value != undefined && value != null) {
            result = accounting.formatNumber(value, precision);
        }
        return result;
    };

    /**
     * Format file size in KB, for example may be:
     * <ul>
     * <li>1,234 KB</li>
     * <li>12 KB</li>
     * </ul>.
     *
     * @param value {int|double} File size in bytes.
     * @returns {string} Human readable string.
     */
    self.formatFileSize = function(value) {
        var result = "";
        if (value != undefined && value != null && value >= 0) {

            var size = ~~(value / 1024);
            if (size * 1024 != value) {
                size++;
            }
            size = accounting.formatNumber(size, 0);
            result = RC.UI.Message(lang.SIZE_KB, size);
        }
        return result;
    };

    /**
     * Format size in pages, for example may be:
     * <ul>
     * <li>0 pages</li>
     * <li>1 page</li>
     * <li>2 pages</li>
     * <li>1,234 pages</li>
     * </ul>.
     *
     * @param value {int|double} number of pages.
     * @returns {string} Human readable string.
     */
    self.formatPages = function(value) {
        var result = "";
        if (value != undefined && value != null && value >= 0) {
            value = accounting.formatNumber(value, 0);
            if (value == 1) {
                result = RC.UI.Message(lang.SIZE_PAGE, value);
            } else {
                result = RC.UI.Message(lang.SIZE_PAGES, value);
            }
        }
        return result;
    }
};

/**
 * @class
 * @name RC.utils.Numbers
 * @singleton
 */
RC.utils.Numbers = new RC.utils.NumberFormatter();

/**
 * Created by IntelliJ IDEA.
 * User: mikhail.pershin
 * Date: 5/6/11
 * Time: 5:21 PM
 * To change this template use File | Settings | File Templates.
 * @class
 * @name RC.utils.String
 * @singleton
 */

RC.utils = RC.utils || {};
RC.utils.Text = RC.utils.Text || {};

/**
 *
 * @param text
 * @param params object
 */
RC.utils.Text.trunc = function(text, params) {
    if (typeof text == 'string') {
        params = params || {};
        /**
         * length: Defaults to 200
         *  The number of characters to display before truncating.
         * minTrail: Defaults to 20
         *  The minimum number of "extra" characters required to truncate. This option allows you to prevent truncation of a section of text that is only a few characters longer than the specified length.
         * ellipsisText: Defaults to "..."
         *  The text to append to the truncated portion.
         */
        params.len = params.len || 200;
        params.minTrail = params.minTrail || 20;
        params.ellipsisText = params.ellipsisText || "...";

        if (text.length <= params.len + params.minTrail)
            return text;

        var i = params.len;
        while (text[i] != ' ' && i < params.len + params.minTrail)
            i++;
        return text.substring(0, i) + params.ellipsisText;
    }
    return text;
};

/**
 * Remove all non-latin symbols and change spaces to '-'
 * @param text text to clean up
 * @param removeDigits if true (default) remove digits
 */
RC.utils.Text.safe = function(text, removeDigits) {
    if (typeof text == 'string') {
        removeDigits = !RC.isEmpty(removeDigits) ? RC.isTrue(removeDigits) : true;
        text = text.replace(/\s/g, '-');
        if (!removeDigits)
            return text.replace(/[^$A-Za-z0-9_\-]/g, '');
        else
            return text.replace(/[^$A-Za-z_\-]/g, '');
    }
    return text;
};

/**
 * Cross-Browser Split 1.0.1
 * (c) Steven Levithan <stevenlevithan.com>; MIT License
 * An ECMA-compliant, uniform cross-browser split method
 * @see http://blog.stevenlevithan.com/archives/cross-browser-split
 * */

RC.utils.Text.split = function(str, separator, limit) {
    // if `separator` is not a regex, use the native `split`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
        return RC.utils.Text.split._nativeSplit.call(str, separator, limit);
    }

    var output = [],
        lastLastIndex = 0,
        flags = (separator.ignoreCase ? "i" : "") +
                (separator.multiline ? "m" : "") +
                (separator.sticky ? "y" : ""),
        separator = RegExp(separator.source, flags + "g"), // make `global` and avoid `lastIndex` issues by working with a copy
        separator2, match, lastIndex, lastLength;

    str = str + ""; // type conversion
    if (!RC.utils.Text.split._compliantExecNpcg) {
        separator2 = RegExp("^" + separator.source + "$(?!\\s)", flags); // doesn't need /g or /y, but they don't hurt
    }

    /* behavior for `limit`: if it's...
     - `undefined`: no limit.
     - `NaN` or zero: return an empty array.
     - a positive number: use `Math.floor(limit)`.
     - a negative number: no limit.
     - other: type-convert, then use the above rules. */
    if (limit === undefined || +limit < 0) {
        limit = Infinity;
    } else {
        limit = Math.floor(+limit);
        if (!limit) {
            return [];
        }
    }

    while (match = separator.exec(str)) {
        lastIndex = match.index + match[0].length; // `separator.lastIndex` is not reliable cross-browser

        if (lastIndex > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));

            // fix browsers whose `exec` methods don't consistently return `undefined` for nonparticipating capturing groups
            if (!RC.utils.Text.split._compliantExecNpcg && match.length > 1) {
                match[0].replace(separator2, function() {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) {
                            match[i] = undefined;
                        }
                    }
                });
            }

            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
            }

            lastLength = match[0].length;
            lastLastIndex = lastIndex;

            if (output.length >= limit) {
                break;
            }
        }

        if (separator.lastIndex === match.index) {
            separator.lastIndex++; // avoid an infinite loop
        }
    }

    if (lastLastIndex === str.length) {
        if (lastLength || !separator.test("")) {
            output.push("");
        }
    } else {
        output.push(str.slice(lastLastIndex));
    }

    return output.length > limit ? output.slice(0, limit) : output;
};

RC.utils.Text.split._compliantExecNpcg = /()??/.exec("")[1] === undefined; // NPCG: nonparticipating capturing group
RC.utils.Text.split._nativeSplit = String.prototype.split;

RC.utils.Text.htmlEntitiesRecursive = function(object) {

    var self = RC.utils.Text.htmlEntitiesRecursive;

    if (typeof(object) == 'string') {

        return htmlentities(object);

    } else if (RC.isArray(object)) {

        Array.each(object, function(subObject, index) {
            object[index] = self(subObject);
        });

    } else if (typeof object == 'object' && Object.getLength(object) > 0) {

        Object.each(object, function(subObject, index) {
            object[index] = self(subObject);
        });

    }

    return object;

};

RC.utils.Text.decline = function(number, plural, singular) {
    number = parseInt(number, 10);
    return (number % 10 == 1 && number % 100 != 11) ? singular : plural;
};

RC.utils.Text.ucFirst = function(text) {
    return text.substr(0, 1).toLocaleUpperCase() + text.substr(1);
};

RC.utils.Text.lcFirst = function(text) {
    return text.substr(0, 1).toLocaleLowerCase() + text.substr(1);
};

RC.utils.Text.idFromText = function(text) {

    if (!RC.isFunc(text.toString)) return text;

    var parts = text.toString().split(/[^a-z0-9]+/i);

    parts.each(function(part, i) {
        parts[i] = RC.utils.Text.ucFirst(part);
    });

    return RC.utils.Text.lcFirst(parts.join(''));

};
RC.utils.Text.showTitle = function(targetElement, waitForComponent) {

    function setTitle() {
        if (RC.isMooElement(targetElement)) {
            targetElement.measure(function() {
                var title = '';
                if (targetElement.offsetWidth < targetElement.scrollWidth) {
                    title = targetElement.get('text');
                }
                targetElement.set('title', title);
            });
        }
    }

    if (!waitForComponent) {
        setTitle();
        return;
    }

    if (waitForComponent instanceof RC.utils.Observable) {
        waitForComponent.addListener('domready', domreadyFn);
    } else if (RC.isMooElement(waitForComponent)) {
        waitForComponent.addEvent('domready', domreadyFn);
    } else {
        RC.Console.warn('RC.utils.Text.setTitle: waitForComponent is invalid');
    }
    function domreadyFn() {
        setTimeout(function() {
            setTitle();
        }, 100);
    }
};

RC.utils.Text.pregQuote = function(str) {
    return (str + '').replace(/([\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:])/g, "\\$1");
};

/**
 * @param data
 * @param search
 * @param replace must contain $1 for regexped string
 * @returns {String}
 */
RC.utils.Text.highlight = function(data, search, replace) {
    return data.replace(new RegExp("(" + RC.utils.Text.pregQuote(search) + ")", 'gi'), replace);
};

RC.utils.Text.highlightHTML = function(search, replacedString) {
    if (RC.isEmpty(search)) return replacedString;

    var regexReplace = new RegExp('(' + search.escapeRegExp() + ')', 'ig');
    var regexHTML = /(<[^>]+?>)/i;
    var array = RC.utils.Text.split(replacedString, regexHTML);

    array.each(function(part, i) {
        if (!part.match(regexHTML)) {
            array[i] = part.replace(regexReplace, '<strong>$1</strong>');
        }
    });
    return array.join('');
};

RC.utils.Text.passwordCharFilter = function(evt) {

    var event = evt.event;
    var charCode = (event.which) ? event.which : event.keyCode;

    var nonValid = (((charCode > 64 && charCode < 91) || (charCode >= 186 && charCode < 193) || (charCode >= 219 && charCode <= 222) || charCode == 32 || (charCode >= 106 && charCode <= 111)) && !(event.ctrlKey || event.metaKey) || (event.shiftKey && (charCode >= 48 && charCode <= 57)));

    return !nonValid;

};

RC.utils.Text.mailTo = function(email) {
    return RC.UI.Message('<a href="mailto:{0}">{0}</a>', email);
};

RC.utils.Text.link = function(link, linkText, target, tabIndex) {
    target = target || '_self';
    linkText = linkText || link;
    var tabIndexAttr = RC.isEmpty(tabIndex) ? '' : RC.UI.Message('tabindex="{0}"', tabIndex);
    return RC.UI.Message('<a href="{0}" target="{2}" {3}>{1}</a>', link, linkText,  target, tabIndexAttr);
};

RC.UI = RC.UI || {};

RC.UI.Message = function(string) {
    if (!string) return "";
    var args = $A(arguments.length === undefined ? [arguments] : arguments);
    args.shift();
    if (!RC.isEmpty(args) && RC.isObject(args[0])) {
        args = args[0];
    }
    return string.replace(/(\{(\w+?)\})/gi, function(g0, g1, g2) {
        return RC.isDefined(args[g2]) ? args[g2] : g1;
    });
};

/**
 * @class
 * @name RC.Error
 * Error Collection
 */
var RC = RC || {};

/**
 * Error Collection
 * @param {String} component Component name|id|similar - an identifier, that is used from outside (optional)
 */
RC.Error = function(component) {

    component = component || "unnamed";
    var errors = [];

    /**
     * Returns true if there is no errors
     * @return {Boolean}
     */
    this.isValid = function() {
        return (this.getAsArray().length == 0);
    };

    /**
     * Add error collection or a string error
     * @param {RC.Error|String} error
     * @return {RC.Error}
     */
    this.add = function(error) {
        errors.push(error);
        return this;
    };

    /**
     * Clean all errors
     * @return {RC.Error}
     */
    this.clean = function() {
        errors = [];
        return this;
    };

    /**
     * Returns plain array of errors texts.
     * Recursively iterates over nested collections.
     * @return {Array}
     */
    this.getAsArray = function() {

        var arr = [];

        errors.each(function(error) {

            if (error instanceof RC.Error) {
                arr = arr.concat(error.getAsArray());
            } else {
                arr.push(error); // component + ': ' + error
            }

        });

        return arr;

    };

    /**
     * Return an output of getAsArray() method concatenated with delimeter '\n' by default (optional)
     * @return {String}
     */
    this.getAsText = function(delimeter) {
        return this.getAsArray().join(delimeter || (Browser.name === "ie" ? '<br>' : '\n'));
    };

    /**
     * Return component name|id|similar
     * @return {String}
     */
    this.getComponent = function() {
        return component;
    };

};

/**
 * Helper method. Checks if exception is an instance of RC.Error and fires callback if true, throws exception if otherwise
 *
 * Usage:
 *
 * RC.Error.tryCatch(function(){
 *      some actions
 * }, function(e){
 *     RC.alert(e.getAsText());
 * });
 *
 * @param {Function} onSuccess
 * @param {Function} onError
 */
RC.Error.tryCatch = function(onSuccess, onError) {

    try {

        onSuccess();

    } catch (exception) {

        if (exception instanceof RC.Error) {

            onError(exception);

        } else {

            throw exception;

        }

    }

};

RC.utils.DNDStatusPicker = function(params) {

    this.id = RC.isEmpty(params.id) ? RC.genId() : params.id;
    this.containerId = params.containerId;
    this.statusImg = null;
    this.statusText = null;
    this.dropDownLayout = null;
    this.dropDownContentBox = null;
    this.clickable = params.clickable !== false;

    this.isUserSeparatedUI = params.isUserSeparatedUI;

    //params.width = params.width || 100;

    this.optionsImages = [
        [
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_hi_left.png')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_hi_mid.png')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_hi_right.png')]

        ],
        [
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_top_left.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_top_mid.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_top_right.gif')]
        ],
        [
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_bot_left.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_bot_mid.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_bot_right.gif')]
        ]
    ];

    var dndImages = {
        red: 'icon_DND_no_calls.PNG',
        orange: 'icon_DND_no_dept_calls.PNG',
        green: 'icon_DND_all_calls.PNG'
    };

    if (this.isUserSeparatedUI) {
        dndImages = {
            red: 'icon_dnd_red.png',
            orange: 'icon_dnd_orange.png',
            green: 'icon_dnd_green.png'
        };
    }

    var dndOffText = RC.Lang.Common.DND_OFF;
    var dndOnText = RC.Lang.Common.DND_ON;
    this.dndStatuses = [
        {
            id : 'TakeAllCalls',
            text : RC.Lang.Common.TAKE_ALL_CALLS,
            statusText :dndOffText,
            extraStyle:'padding-top:34px;',
            img : RC.getSkinnedRCLibXImageUrl('img/common/' + dndImages.green),
            cssClass : 'x-dnd-item-takeAllCalls',
            inList : true
        },
        {
            id : 'DoNotAcceptDepartmentCalls',
            text : RC.Lang.Common.NO_DEPT_CALLS,
            statusText : dndOnText,
            img : RC.getSkinnedRCLibXImageUrl('img/common/' + dndImages.orange),
            cssClass : 'x-dnd-item-doNotAcceptDepartmentCalls',
            inList : RC.Config.isAgent
        },
        {
            id : 'TakeDepartmentCallsOnly',
            text : RC.Lang.Common.DEPT_CALLS_ONLY,
            statusText :dndOnText,
            img : RC.getSkinnedRCLibXImageUrl('img/common/' + dndImages.orange),
            cssClass : 'x-dnd-item-takeDepartmentCallsOnly',
            inList : false
        },
        {
            id : 'DoNotAcceptAnyCalls',
            text : RC.Lang.Common.DENY_ALL_CALLS,
            statusText :dndOnText,
            img : RC.getSkinnedRCLibXImageUrl('img/common/' + dndImages.red),
            cssClass : 'x-dnd-item-doNotAcceptAnyCalls',
            inList : true
        }
    ];

    RC.utils.DNDStatusPicker.superclass.constructor.call(this, params);

    this.values = {
        dndStatus : null
    };
};

RC.extend(RC.utils.DNDStatusPicker, RC.utils.Observable, {
    setClickable: function(isClickable) {
        this.clickable = isClickable;
    },
    render : function() {

        this.load(function() {
            var table = new Element('table', {
                id : 'DNDStatusPicker-' + RC.genId(),
                cellspacing : '0',
                cellpadding : '0',
                width : this.isUserSeparatedUI ? '' : '60'
            });

            var tbody = new Element('tbody', {});
            var tr = new Element('tr', {});

            tbody.adopt(tr);
            table.adopt(tbody);

            tr.adopt(new Element('td').adopt(
                    this.statusImg = new Element('img', {
                        src : this.values.dndStatus.img,
                        alt : ''
                    })));

            if (!this.isUserSeparatedUI) {
                tr.adopt(new Element('td').adopt(
                        this.statusText = new Element('span', {
                            'class' : this.values.dndStatus.cssClass,
                            html : this.values.dndStatus.statusText
                        })));
            }

            var canvas = new Element('div', {
                id    : this.id + '-wrapper',
                //'class' : 'x-form-contactpicker',
                width : this.width
            }).adopt(
                    table
                    ).adopt(
                    this.dropDownLayout = new Element('div', {
                        style : 'position: relative; z-index: 120; display : none' // z-index should correspond to RC.Menu's one
                    }));

            var container = $(this.containerId);

            table.addEvent('click', function(e)
            {
                if (this.clickable) {
                    this.fillDropDownContentBox();
                    this.visibleDropDownLayout(!this.isVisibleDropDownLayout());
                }
                return false;
            }.bind(this));

            this.renderDropDownArea().inject(new Element('div', {
                style : 'position: absolute; left: -17px; top : 5px;'
            }).inject(this.dropDownLayout));

            container.adopt(canvas);

            this.dropDownLayout.addEvent('mouseleave', function(){
                this.visibleDropDownLayout(false);
            }.bind(this));
            document.addEvent('click', function(e) {
                this.visibleDropDownLayout(false);
            }.bind(this));
        }.bind(this));
 
    },

    load : function(callback) {
        var self = this;
        (new RC.Ajax).send({
            cmd : 'rules.getDNDStatus',
            useWrapper : true,
            onSuccess : function(o)
            {
                self.values.dndStatus = null;
                for(var i=0;i<self.dndStatuses.length;i++) {
                    if(self.dndStatuses[i].id == o.dndStatus) {
                        self.values.dndStatus = self.dndStatuses[i];
                        break;
                    }
                }

                if(RC.isFunc(callback)) {
                    callback();
                }
            }
        });
    },

    save : function() {
        var self = this;
        (new RC.Ajax).send({
            cmd : 'rules.setDNDStatus',
            useWrapper : true,
            params : {
                dndStatus : this.values.dndStatus.id
            },
            onSuccess : function(o)
            {
                self.renderCurrentStatus();
            }
        });
    },

    renderCurrentStatus : function() {
        if (this.values.dndStatus != null) {
            this.statusImg.set('src', this.values.dndStatus.img);

            if (!this.isUserSeparatedUI) {
                this.statusText.set('html', this.values.dndStatus.statusText);
                this.statusText.set('class', this.values.dndStatus.cssClass);
            }
        }
    },

    renderDropDownArea : function() {
        var decorationTable = new Element('table', {
            id    : this.id + '-DropDownArea',
            'class': 'dndDropDownArea',
            'cellspacing': '0',
            'cellpadding': '0',
            'html': '<tbody></tbody>'
        });
        new Element('tr').inject(decorationTable.getElement('tbody'))
                .adopt(
                new Element('td'))
                .adopt(
                new Element('td'))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor-bot-right'
                }));
        new Element('tr').inject(decorationTable.getElement('tbody'))
                .adopt(
                new Element('td'))
                .adopt(
                this.dropDownContentBox = new Element('td', {'class': 'dndDropDownAreaContent'}))
                .adopt(
                new Element('td', {
                    'id': this.id + '-scroll-box'
                }));
        new Element('tr').inject(decorationTable.getElement('tbody'))
                .adopt(
                new Element('td'))
                .adopt(
                new Element('td'))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor-bot-right'
                }));
        return  decorationTable;
    },

    renderDropDownItemsArea : function() {
        var table = new Element('table', {
            id    : this.id + '-DropDownItemsArea',
            cellspacing : 0,
            cellpadding : 0,
            style : 'width : auto;',
            html: '<tbody></tbody>'
        });
        $each(this.dndStatuses, function(rec, i) {
            if(!rec || !RC.isTrue(rec.inList)) return;

            this.renderDropDownItem(rec, i).inject(table.getElement('tbody'));

        }.bind(this));
        return table;
    },

    renderDropDownItem : function(dndStatusItem, index) {
        var selected = this.values.dndStatus.id == dndStatusItem.id;
        var tr = new Element('tr', {
            id    : this.id + '-DropDownItem-' + index,
            styles : {
                height : '26px',
                cursor : 'pointer'
            },
            'class': dndStatusItem.cssClass,
            events : {
                mouseover : function() {
                    tr.style.backgroundColor = '#ededed';
                },
                mouseout : function() {
                    tr.style.backgroundColor = '';
                },
                click : function() {
                    this.values.dndStatus = dndStatusItem;
                    this.save();
                    this.visibleDropDownLayout(false);
                }.bind(this)
            }
        })
                .adopt(new Element('td', {
                    html : selected ? '<img src="' + RC.getSkinnedRCLibXImageUrl('img/common/dnd-menu-arrow.png') + '" alt=""/>' : '&nbsp',
                    'style' : 'padding-top: 6px;'}))
                .adopt(new Element('td', {html : '<img src="' + dndStatusItem.img + '" alt=""/>', 'style' : 'padding: 6px 0 0 2px;'}))
                .adopt(new Element('td', {html : '<b>' + dndStatusItem.text + '</b>', 'style' : 'padding: 5px 6px 0 5px;'}));
        return tr;
    },

    clear : function() {
        this.values.dndStatus = {};
        this.setValue('');
        this.visibleDropDownLayout(false);
    },

    fillDropDownContentBox : function() {
        this.dropDownContentBox.innerHTML = '';
        var dropDownDiv = this.renderDropDownItemsArea();
        if (dropDownDiv.innerHTML)
           dropDownDiv.inject(this.dropDownContentBox);
        else
            return false;
        return true;
    },

    visibleDropDownLayout : function(flg) {
        this.dropDownLayout.style.display = !!flg ? 'block' : 'none';
    },

    isVisibleDropDownLayout : function() {
        return this.dropDownLayout.style.display != 'none';
    }
});


RC.reg('x-form-dndstatuspicker', RC.utils.DNDStatusPicker);

/**
 * @class
 * @name RC.Notification
 * @param config
 * @constructor
 */
RC.utils.Notification = function() {

    var COOKIE_ID = "DESKTOP_NOTIFICATIONS_ON";
    var isOn = Cookie.read(COOKIE_ID) === "true";

    this.instances = {};

    this.isSupported = function() {
        return window.Notification !== undefined;
    };

    this.renderButton = function(params) {

        this.id = RC.isEmpty(params.id) ? RC.genId() : params.id;
        this.containerId = params.containerId;

        var container = $(this.containerId);

        var statusOn = new Element('div', {
            html: '<table cellspacing="0" cellpadding="0" width="160" class="' + this.containerId + '-on"><tr><td><img src="' + RC.getSkinnedRCLibXImageUrl('img/common/desk-notifications-on.png') + '"></td><td>&nbsp;' + RC.Lang.Common.DESKTOP_NOTIFICATIONS_ON + '</td></tr></table>'
        });

        statusOn.addEvent('click', function(e) {
            container.innerHTML = "";
            container.adopt(statusOff);
            isOn = false;
            Cookie.write(COOKIE_ID, false, {path: '/'});
        });


        var statusOff = new Element('div', {
            html: '<table cellspacing="0" cellpadding="0" width="160" class="' + this.containerId + '-off"><tr><td><img src="' + RC.getSkinnedRCLibXImageUrl('img/common/desk-notifications-off.png') + '"></td><td>&nbsp;' + RC.Lang.Common.DESKTOP_NOTIFICATIONS_OFF + '</td></tr></table>'
        });

        statusOff.addEvent('click', function(e) {
            requestPermission(function() {
                if(isPermissionGranted()) {
                    container.innerHTML = "";
                    container.adopt(statusOn);
                    isOn = true;
                    Cookie.write(COOKIE_ID, true, {path: '/'});
                }
            });
        });

        if(isPermissionGranted() && isCookieOn()) {
            container.adopt(statusOn);
        } else {
            container.adopt(statusOff);
        }

    };

    this.show = function(options) {
        var self = this;

        //TODO make enable-disable mechanism
        //if(!isEnabled()) return;

        if(!isPermissionGranted()) {
            requestPermission(function() {
                show();
            });
        } else {
            show();
        }

        function show() {
            var title = options.title || "";
            var body = options.body || "";
            var icon = options.icon || "";

            var n = new Notification(title, {
                body: body,
                icon: icon
            });

            n.uid = options.uid;

            n.onclick = function(e) {
                delete self.instances[n.uid];

                window.focus();
                if(typeof options.onclick === 'function') {
                    options.onclick(e);
                }
            };

            self.instances[options.uid] = n;
        }

    };

    this.hide = function(uid) {
        var n = this.instances[uid];
        n && n.close();
    };

    function isEnabled() {
        return isCookieOn() && isPermissionGranted();
    }

    function isCookieOn() {
        return isOn;
    }

    function isPermissionGranted() {
        return window.Notification.permission === "granted" && window.Notification.permission !== 'denied';
    }

    function requestPermission(callback) {
        window.Notification.requestPermission(function (permission) {
            if(!('permission' in window.Notification)) {
                window.Notification.permission = permission;
            }
            self.granted = permission === 'granted';
            callback();
        });
    }


};

RC.reg('x-form-notificationstatuspicker', RC.utils.Notification);

RC.ns("RC.UI");

(function () {
    var link;
    var Class = RC.extend(RC.utils.Observable, {
        constructor:function (config) {
            config = config || {};
            var hideEventEnabled = hideEventEnabled || (typeof hideEventEnabled == "undefined");

            var self = this;

            var timeOutHandler;
            var defaultTimeOut = 500;
            var dropDownContent;
            var dropDownContentWrapper;
            var tipSwitch;
            var disablingLayer;
            this.id = RC.genPrefixedId({id: config.id, idFromText: 'HelperMenu-'});

            this.clearTimeout = function () {
                clearTimeout(timeOutHandler);
            }

            this.enableHide = function(enabled){
                enabled = enabled || (typeof enabled == "undefined");
                hideEventEnabled = enabled;
            }

            function hideEvent(){
                if (hideEventEnabled) {
                    self.hide();
                }
            }

            this.enableInteraction = function(enabled){
                enabled = enabled || (typeof enabled == "undefined");

                if (enabled) {
                    disablingLayer && disablingLayer.setStyle('display', 'none');
                }
                else{
                    if (!disablingLayer){
                        disablingLayer = new Element('div', {
                            'class' : 'x-helper-disablingLayer',
                            'events':{
                                'click':function (e) {
                                    e.stop();
                                }
                            }
                        });
                        disablingLayer.inject(dropDownContentWrapper);
                    }
                    disablingLayer.setStyle('display', 'block');
                }
            }

            this.showOnTimeout = function (timeout, displayOn) {
                timeOutHandler = setTimeout(function(){
                    self.show(displayOn, 'in')
                }, timeout || defaultTimeOut);
            }

            this.show = function (displayOn, fadeAction) {
                self.updateSwitchText(displayOn);
                var fadeAction = fadeAction? fadeAction : 'show';
                dropDownContentWrapper.setStyle('display', 'block');
                dropDownContentWrapper.fade(fadeAction);
            };

            this.hide = function () {
                //remove restrictions
                self.enableHide();
                self.enableInteraction();

                self.clearTimeout();

                dropDownContentWrapper.fade('hide');
                dropDownContentWrapper.setStyle('display', 'none');
            }

            this.hideOnTimeout = function (timeout) {
                timeOutHandler = setTimeout(function () {
                    hideEvent();
                }, timeout || defaultTimeOut);
            }

            self.updateSwitchText = function (displayOn) {
                displayOn = typeof displayOn == "undefined" ?
                    !RC.panel.EntryPanel.Tooltips.isEnabled() : displayOn;
                var text = displayOn ? RC.Lang.Common.FEATURE_TIPS_ON : RC.Lang.Common.FEATURE_TIPS_OFF;
                tipSwitch.set('text', text);
            };

            this.render = function (config) {
                link = config.link || $(config.linkId);
                if(config.plainLink){
                	link.addEvent('click', function (e) {
                		window.open(RC.Config.helpLink);
                    });
                }else{
                	link.addEvent('click', function (e) {
                        self.clearTimeout();
                        self.show();
                    });

                    link.addEvent('mouseleave', function (e) {
                        self.hideOnTimeout();
                    });

                    dropDownContentWrapper = new Element('div', {
                        'class':'x-helper-link-dropdown-wrapper'
                    });

                    dropDownContentWrapper.inject(link);

                    dropDownContentWrapper.addEvents({
                        'mouseenter':function (e) {
                            self.clearTimeout();
                        },
                        'mouseleave':function (e) {
                            self.hideOnTimeout();
                        }
                    });

                    dropDownContent = new Element('div', {
                        'class':'x-helper-link-dropdown',
                        'html':''
                    });

                    dropDownContent.inject(dropDownContentWrapper);
                    function addItem(itemType,name, callback) {
                        var item = new Element('div', {
                            'id' :self.id + '-' + itemType,
                            'class':'x-helper-link-dropdown-item',
                            'html':name,
                            'events':{
                                'click':function (e) {
                                    e.stop();
                                    RC.isFunc(callback) && callback();
                                }
                            }
                        });

                        item.inject(dropDownContent);
                        return item;
                    }

                    addItem('helpCenter',RC.Lang.Common.HELP_CENTER, function () {
                        window.open(RC.utils.Common.getTelusLocaleLink(RC.Config.helpLink));
                    });

                    tipSwitch = addItem('featureTipsSwitch',"", function () {
                        RC.panel.EntryPanel.Tooltips.toogleEnabled();
                        hideEvent();
                    });

                };
            }
            Class.superclass.constructor.call(this, config);
        }
    });

    RC.UI.HelperMenuPicker = new Class({id: 'HelperMenu'});
}());

RC.utils.Component = RC.extend(RC.utils.Observable, {
            constructor : function() {
                RC.utils.Component.superclass.constructor.apply(this, [arguments]);
            },
            _getKey: function(key) {
                return '_' + key.toString();
            },
            _parseData: function(data) {

                var self = this;

                if (RC.isEmpty(data)) throw new Error("RC.utils.Component._parseOptions(): Data is empty");

                Object.each(data, function(val, key) {

                    var privateKey = self._getKey(key);
                    if (privateKey in self) {
                        self[privateKey] = val;
                    } else {
                        RC.Console.warn('RC.utils.Component._parseOptions(): Property "%s"(%o) not found in component', key, val);
                    }

                });

            }
        });

(function() {

    var countryIDs = {
        US: 1,
        UK: 224,
        Canada: 39
    };

    var defaultCountryLocalizations = function() {
        return {
            FULL_STATE: RC.Lang.Common.STATE,
            STATE : RC.Lang.Common.USASTATE,
            FULL_ZIP_CODE: RC.Lang.Common.FULL_ZIP_CODE,
            ZIP_CODE : RC.Lang.Common.ZIP_CODE,
            COUNTRY_NAME: RC.Lang.Common.COUNTRY_UNITED_STATES,
            HOME_STATE: RC.Lang.Common.HOME_STATE,
            HOME_ZIP_CODE: RC.Lang.Common.HOME_ZIP_CODE,
            BUSINESS_STATE: RC.Lang.Common.BUSINESS_STATE,
            BUSINESS_ZIP_CODE: RC.Lang.Common.BUSINESS_ZIP_CODE,
            OTHER_STATE: RC.Lang.Common.OTHER_STATE,
            OTHER_ZIP_CODE: RC.Lang.Common.OTHER_ZIP_CODE
        };
    };

    var countryDescs = {
        '1' : {
            name : 'COUNTRY_UNITED_STATES',
            countryDisplayOrders : [countryIDs.US , countryIDs.Canada],
            zipCodeValidator: function() {}
        },
        '224' : {
            name : 'COUNTRY_UK',
            countryDisplayOrders : [countryIDs.UK , countryIDs.US , countryIDs.Canada],
            getLocalizations: function() {
                return {
                    FULL_STATE: RC.Lang.Common.COUNTY,
                    STATE : RC.Lang.Common.COUNTY,
                    FULL_ZIP_CODE: RC.Lang.Common.POSTCODE,
                    ZIP_CODE : RC.Lang.Common.POSTCODE,
                    COUNTRY_NAME: RC.Lang.Common.COUNTRY_UK_FULL,
                    HOME_STATE: RC.Lang.Common.HOME_COUNTY,
                    HOME_ZIP_CODE: RC.Lang.Common.HOME_POSTCODE,
                    BUSINESS_STATE: RC.Lang.Common.BUSINESS_COUNTY,
                    BUSINESS_ZIP_CODE: RC.Lang.Common.BUSINESS_POSTCODE,
                    OTHER_STATE: RC.Lang.Common.OTHER_COUNTY,
                    OTHER_ZIP_CODE: RC.Lang.Common.OTHER_POSTCODE
                };
            },
            zipCodeValidator: function(value) {
                return !RC.isEmpty(value) &&
                    (value.length >= 6 && value.length <= 8) &&
                    (value.match(/\S+\s\S+/) == value);
            }
        },
        '39' : {
            name : 'COUNTRY_CANADA',
            countryDisplayOrders : [countryIDs.Canada , countryIDs.US],
            zipCodeValidator: function() {},
            getLocalizations: function() {
                return {
                    FULL_STATE: RC.Lang.Common.PROVINCE,
                    STATE : RC.Lang.Common.PROVINCE,
                    FULL_ZIP_CODE: RC.Lang.Common.POSTAL_CODE,
                    ZIP_CODE : RC.Lang.Common.POSTAL_CODE,
                    COUNTRY_NAME: RC.Lang.Common.COUNTRY_CANADA,
                    HOME_STATE: RC.Lang.Common.HOME_PROVINCE,
                    HOME_ZIP_CODE: RC.Lang.Common.HOME_POSTAL_CODE,
                    BUSINESS_STATE: RC.Lang.Common.BUSINESS_PROVINCE,
                    BUSINESS_ZIP_CODE: RC.Lang.Common.BUSINESS_POSTAL_CODE,
                    OTHER_STATE: RC.Lang.Common.OTHER_PROVINCE,
                    OTHER_ZIP_CODE: RC.Lang.Common.OTHER_POSTAL_CODE
                };
            }
        }
    };

    var letterGroups = {
        'a': ['a', '', '', ''],
        'A': ['A', '', '', ''],
        'c': ['c', ''],
        'C': ['C', ''],
        'e': ['e', '', '', '', ''],
        'E': ['E', '', '', '', ''],
        'i': ['i', '', ''],
        'I': ['I', '', ''],
        'o': ['o', '', ''],
        'O': ['O', '', ''],
        'u': ['u', '', '', ''],
        'U': ['U', '', '', ''],
        'y': ['y', ''],
        'Y': ['Y', '']
    };

    function getLetterGroup(groupName) {
        return letterGroups[groupName] || [groupName];
    }

    var localeCookieName = 'RCLANG';

    RC.utils.Lang = {
        countryIDs: countryIDs,
        countryDescs : countryDescs,
        isUK: function(id) {
            return (id == countryIDs.UK);
        },
        isUS: function(id) {
            return (id == countryIDs.US);
        },
        isCanada: function(id) {
            return (id == countryIDs.Canada);
        },

        getLocalizations: function(id) {
            var country = countryDescs[id];
            var getLocalizationsFn = (country && country.getLocalizations) ?
                country.getLocalizations :
                defaultCountryLocalizations;
            return getLocalizationsFn();
        },

        getDefaultCountry: function() {
            return RC.Config.brandCountryId;
        },

        getLocalizedCountryName: function(countryId) {
            countryId = countryId || RC.Config.brandCountryId;
            var countryName = RC.Lang.Common.COUNTRY_CODES[countryId];
            var neededThe = RC.utils.Lang.isUK(countryId) || RC.utils.Lang.isUS(countryId);
            return neededThe? RC.UI.Message(RC.Lang.Common.COUNTRY_NAME_FORMAT_WITH_THE , countryName) : countryName;
        },
        countriesSortCallback: function(a, b) {
            return RC.utils.Lang.createCountriesSortFn()(a, b);
        },

        createCountriesSortFn: function(targetCountryId) {
            return function(a, b) {
                var countryDisplayOrders = countryDescs[targetCountryId || RC.Config.brandCountryId].countryDisplayOrders;
                var countryId;

                for (var i = 0; i < countryDisplayOrders.length; i++) {
                    countryId = countryDisplayOrders[i];
                    if (a.id == countryId) return -1;
                    if (b.id == countryId) return 1;
                }

                // US
                if (a.id == countryIDs.US) return -1;
                if (b.id == countryIDs.US) return 1;

                // By name
                return a.name.localeCompare(b.name);
            }
        },
        extend: function(namespace, strings) {
            namespace = RC.apply(namespace, strings);
        },

        getLocaleFromCookie: function() {
            return Cookie.read(localeCookieName) || RC.Config.userLanguage;
        },
        setLocaleInCookie: function(val) {
            var isEndUser = (!RC.Config.partnerSSOUserType || RC.Config.partnerSSOUserType === 'cu') && !RC.Config.isAdminSession;
            if(isEndUser) {
                Cookie.write(localeCookieName, val);
            }
        },
        isLetterInGroup: function(groupName, letter) {
            return getLetterGroup(groupName).contains(letter);
        },
        getLetterGroupName: function(letter) {
            var result = letter;
            for (var groupName in letterGroups) {
                if (letterGroups.hasOwnProperty(groupName) && letterGroups[groupName].contains(letter)) {
                    result = groupName;
                    break;
                }
            }
            return result;
        }
    };
})();

(function() {

    var userTypes = {
        USER: "User",
        DIGITAL_USER: "DigitalUser",
        VIRTUAL_USER: "VirtualUser",
        FAX_USER: "FaxUser"
    };

    var mailboxTypes = {
        USER: "User",
        DIGITAL_USER: "DigitalUser",
        VIRTUAL_USER: "VirtualUser",
        FAX_USER: "FaxUser",
        DEPARTMENT: "Department",
        ANNOUNCEMENT: "Announcement",
        VOICEMAIL: "Voicemail",
        PAGING: "PagingOnly",
        // todo may be incorrect
        SHAREDLINE:"SharedLinesGroup",
        IVR_MENU:"IVRMenu",
        APPLICATION: "Application",
        MONITORING: "Monitoring"
    };

    var mailboxStates = {
        Enabled : 0,
        Disabled : 1,
        Freezed : 2,
        NotActivated : 3
    };
    var actions = {
        addExt: 'addExt',
        removeExt: 'removeExt',
        updateExtInfo: 'updateExtInfo',
        addNumber: 'addNumber',
        removeNumber: 'removeNumber',
        updateNumber: 'updateNumber',
        addPhone:'addPhone',
        updatePhone:'updatePhone'
    };

    RC.utils.Extension = {
        userTypes : userTypes,
        mailboxTypes : mailboxTypes,
        mailboxStates : mailboxStates,
        actions: actions,

        isMailboxEnabled: function(mailboxInfo){ // TODO Move to mailbox model when it will be created
            return !(!mailboxInfo.enabled || mailboxInfo.mailboxState == mailboxStates.Disabled);
        },

        isUserType : function(type){
            return Object.some(userTypes, function(userType) {
                return userType === type;
            });
        },

        isDepartmentType : function(type){
            return type === mailboxTypes.DEPARTMENT;
        },

        isSharedLinesGroupType : function(type){
            return type === mailboxTypes.SHAREDLINE;
        },

        isPagingOnlyType: function(type) {
            return type === mailboxTypes.PAGING;
        },

        isApplicationType: function(type) {
            return type === mailboxTypes.APPLICATION;
        },

        isMonitoringType: function(type) {
            return type === mailboxTypes.MONITORING;
        },

        isPagingAvailableMailbox: function(type){
            return (type == mailboxTypes.USER || type == mailboxTypes.SHAREDLINE|| type == mailboxTypes.DIGITAL_USER);
        },

        isIVRMenuType: function(type){
            return type === mailboxTypes.IVR_MENU;
        },

        isVoicemailType: function(type){
            return type === mailboxTypes.VOICEMAIL;
        },

        isAnnouncementType: function(type){
            return type === mailboxTypes.ANNOUNCEMENT;
        },

        isDigitalUserType: function(type) {
            return type === mailboxTypes.DIGITAL_USER;
        },
        
        isVirtualUserType: function(type) {
            return type === mailboxTypes.VIRTUAL_USER;
        },

        isDialByNameAvailableMailbox: function(ext) {
            return !(this.isIVRMenuType(ext.type) || this.isPagingOnlyType(ext.type) || ext.enabled === false);
        },

        getPagingAvailableMailboxes : function(callback){
            var self = this;
            Wrapper.Extensions.listExtensionsBrief(
                new Wrapper.Requests.ListExtensionsRequest(RC.Config.loggedMailboxId),
                function (response){
                    var mailboxes = Array.filter(response.extensions, function (r) {
                        return r.enabled && self.isPagingAvailableMailbox(r.type);
                    });
                    callback(mailboxes);
                }
            )
        }
    }

})();

(function() {
    var digitKeys = {
        KEY1: "Key1",
        KEY2: "Key2",
        KEY3: "Key3",
        KEY4: "Key4",
        KEY5: "Key5",
        KEY6: "Key6",
        KEY7: "Key7",
        KEY8: "Key8",
        KEY9: "Key9",
        KEY0: "Key0"
    };

    var allKeys = Object.merge(Object.clone(digitKeys), {
        STAR: "Star",
        POUND: "Pound",
        NO_INPUT_FINAL: "NoInputFinal"
    });

    var languages = {
        ENGLISH_US: 1033,
        ENGLISH_UK: 2057,
        FRENCH_CA: 3084
    };

    var actionTypes = {
        ConnectToMailBox: 'ConnectToMailBox',
        ConnectToMailBoxVM: 'ConnectToMailBoxVM',
        ExternalTransfer: 'ExternalTransfer',
        ConnectToDialByNameDirectory: 'ConnectToDialByNameDirectory',
        RepeatPrompt: 'RepeatPrompt',
        ReturnToPreviousMenu: 'ReturnToPreviousMenu',
        ReturnToRootMenu: 'ReturnToRootMenu',
        Disconnect: 'Disconnect',
        Undefined: 'Undefined'
    };

    RC.utils.IVRMenu = {
        digitKeys: digitKeys,
        allKeys: allKeys,
        actionTypes: actionTypes,
        languages: languages,

        isDigitKey: function(keyValue) {
            return Object.some(digitKeys, function(key) {
                return key == keyValue;
            });
        },

        isStarKey: function(keyValue) {
            return keyValue == allKeys.STAR;
        },

        isPoundKey: function(keyValue) {
            return keyValue == allKeys.POUND;
        },

        isNoInputFinal: function(keyValue) {
            return keyValue == allKeys.NO_INPUT_FINAL;
        },

        isExternalTransfer: function(actionType) {
            return actionType === actionTypes.ExternalTransfer;
        },

        isConnectToMailBox: function(actionType) {
            return actionType === actionTypes.ConnectToMailBox;
        },

        isConnectToMailBoxVM: function(actionType) {
            return actionType === actionTypes.ConnectToMailBoxVM;
        },

        isConnectToDBN: function(actionType) {
            return actionType === actionTypes.ConnectToDialByNameDirectory;
        },

        isDisconnect: function(actionType) {
            return actionType === actionTypes.Disconnect;
        },

        isUndefined: function(actionType) {
            return actionType === actionTypes.Undefined;
        }
    }

})();

(function () {
    var paymentType = {
        TOLLFREE: 'TollFree',
        LOCAL: 'Local',
        byName: function (name) {
            for (var prop in this.PaymentType) {
                if (typeof prop == 'string' && this[prop] == name) return this.PaymentType[prop];
            }
            return null;
        }
    };

    var deviceType = {
        SOFT_PHONE: -1,
        OTHER_PHONE: 0,
        IPHONE: -5,
        //BLA : -11,
        PAGING_ONLY: -10
    };

    var YealinkW52PID = 57;

    var phoneType = {
        VOICE_FAX: 'VoiceFax',
        DEDICATED_FAX: 'DedicatedFax',
        FAX_ONLY: 'FaxOnly',
        VOICE_ONLY: 'VoiceOnly',
        ADDITIONAL_COMPANY: 'AdditionalCompany'
    };

    var phoneNumberAdditionType = {
        FREE       : 'Free',
        PAID       : 'Paid',
        NOTALLOWED : 'NotAllowed',
        TRIAL      : 'Trial',
        byName : function(name) {
            for (var prop in this.PhoneNumberAdditionType) {
                if (typeof prop == 'string' && this[prop] == name) return this.PhoneNumberAdditionType[prop];
            }
            return this.PhoneNumberAdditionType.getDefault();
        },
        getDefault : function() {
            return this.PhoneNumberAdditionType.NOTALLOWED
        }
    }

    RC.utils.DigitalLine = {
        PaymentType: paymentType,
        PhoneType : phoneType,
        DeviceType : deviceType,
        Yealink_W52P_ID: YealinkW52PID,
        PhoneNumberAdditionType : phoneNumberAdditionType,

        isNumberCanBeAssigned: function (numberInfo) {
            return (!numberInfo.mainNumber)
                && (!(numberInfo.paymentType == paymentType.TOLLFREE))
                && (!RC.isTrue(numberInfo.pending))
                && (!RC.isTrue(numberInfo.hasSipLine))
                && (numberInfo.phoneType == phoneType.VOICE_FAX || numberInfo.phoneType == phoneType.VOICE_ONLY);
        },

        isNumberCanBeAssignedToSharedLineGroup : function(numberInfo){
            return (!numberInfo.mainNumber)
                && (!(numberInfo.international))
                && (!(numberInfo.paymentType == paymentType.TOLLFREE))
                && (!RC.isTrue(numberInfo.pending))
                && (!RC.isTrue(numberInfo.hasSipLine))
                && (numberInfo.phoneType == phoneType.VOICE_FAX || numberInfo.phoneType == phoneType.VOICE_ONLY)
                && (RC.utils.Extension.isUserType(numberInfo.extensionType) || RC.utils.Extension.isSharedLinesGroupType(numberInfo.extensionType) || numberInfo.mappedMailbox == 0)
                && (!RC.isTrue(numberInfo.userUnassigned));
        },

        phoneNumber2Label : function(phoneNumber, extensionDisplayFormat) {
            extensionDisplayFormat = extensionDisplayFormat || RC.Lang.Common.EXTENSION_DISPLAY_NAME;
            var userString = phoneNumber.mappedMailbox == 0 ? RC.Lang.Common.AUTO_RECEPTIONIST :
                RC.UI.Message(extensionDisplayFormat, phoneNumber.extensionPin, phoneNumber.extensionName);
            //todo replace margin with parametrized value
            // WARN margin super hack =) Table is so boooooring
            return phoneNumber.phoneNumber + "<span style='margin-left: 20px'></span>" + userString;
        },

        // UIA-20288
        // todo need move maxDLNumbers from RC.Config to wrapper.billing.getAvailableAdditionalServices and call it every time if needed
        // todo need research why maxDLNumbers is equals 0 if it's office (for example 3322)
        isLimitDLReached : function(existingPhoneLinesCount, newPhoneLinesCount){
            var limitReached = true;

            var maxAllowedCntDLNumbers = RC.Config.maxDLNumbers;
            var isDLLimitReached = RC.Config.bDLLimitReached;

            //if user wanna buy any quantity of unassigned phones - go ahead! -> "unlimited mode" = true
            if(!newPhoneLinesCount) return !limitReached;

            if(isDLLimitReached) return limitReached;

            // HardCode!!!!!
            // todo ask AT why for offices (3322 for example) it ALWAYS equals 0
            if(maxAllowedCntDLNumbers == 0)  return  !limitReached;

            if((newPhoneLinesCount + existingPhoneLinesCount) >= maxAllowedCntDLNumbers) return  limitReached;

            return !limitReached;

        },

        allowedDLCount : function(existingPhoneLinesCount, newPhoneLinesCount){
            /*
            null means there is no restriction
             */
            var r = null;

            var maxAllowedCntDLNumbers = RC.Config.maxDLNumbers;
            if (maxAllowedCntDLNumbers > 0){
                r = maxAllowedCntDLNumbers - existingPhoneLinesCount - newPhoneLinesCount;
            }
            return r;
        },

        getNoShippingMessage : function(excludeSoftPhone) {
            var brandCountryName = RC.utils.Lang.getLocalizedCountryName(RC.Config.brandCountryId);
            var textOne = RC.Lang.Common.NO_SHIPPING_MESSAGE_TEXT_ONE;
            var textTwo = excludeSoftPhone ? RC.Lang.Common.NO_SHIPPING_MESSAGE_TEXT_TWO_WO_SOFTPHONE :
                            RC.Lang.Common.NO_SHIPPING_MESSAGE_TEXT_TWO;

            var html = [];
            html.push('<table cellspacing="0" cellpadding="0" width="100%" style="border: 1px solid #AECBDA;"><tbody><tr>');
            html.push('     <td bgcolor="#D1E3EE" align="center" width="100%" style="padding: 5px; font-size: 14px; color: #063F60; border-bottom: 1px solid #AECBDA;">');
            html.push(          RC.UI.Message(textOne, brandCountryName));
            html.push('     </td>');
            html.push('</tr><tr>');
            html.push('     <td bgcolor="#D1E3EE" width="100%" class="cell" style="padding: 8px;">');
            html.push(          RC.UI.Message(textTwo, brandCountryName));
            html.push('</tr></tbody></table>');
            return html.join('');
        },

        isDigitalUsersExist : function(callback){
            var $do = new RC.data.AsyncContext();
            var isDigitalUsersExist, digitalUserName;

            RC.Loader.show({});

            function isExist(cb){
                Wrapper.System.isDigitalUsersExist(function (response) {
                    isDigitalUsersExist = response.result;
                    cb();
                });
            }

            function getName(cb){
                if (!isDigitalUsersExist) {
                    /*
                    if digitalUsers don't exist - we get their name to shown in alerts and so on
                     */
                    Wrapper.System.getCounters(function(o) {
                        digitalUserName = o.availableMailboxTypes.DigitalUser;
                        cb();
                    });

                } else {
                    cb();
                }
            }

            function returnResult(){
                RC.Loader.hide();
                callback(isDigitalUsersExist, digitalUserName);
            }

            $do(isExist);
            $do(getName);
            $do(returnResult);
        }
};
})();


(function() {

    var DEFAULT_FLASH_VERSION = '11';
    var PLUGIN_PAGE = 'http://www.adobe.com/go/getflashplayer';
    var oSWFParams = {
        'allowScriptAccess'  : 'always',
        'quality'              : 'high',
        'scale'                : 'noscale',
        'salign'               : 'lt',
        'bgcolor'              : '#ffffff',
        'menu'                 : 'false',
        'wmode'                : 'transparent',
        'pluginspage'         : PLUGIN_PAGE
    };

    RC.utils.Flash = {
        PLUGIN_PAGE : PLUGIN_PAGE,
        getPromptText: function(options) {
            options = options || {};
            return RC.UI.Message(RC.Lang.Common.FLASH_VALIDATE_VERSION_TEXT, options.prompt || RC.Lang.Common.FLASH_VALIDATE_VERSION_PROMPT, RC.utils.Flash.PLUGIN_PAGE);
        },
        validateFlashVersion : function(callback, version, customOptions) {
            customOptions = customOptions || {};
            var mobile = (/iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i.test(navigator.userAgent.toLowerCase()));
            if (!RC.utils.Flash.hasFlashPlayerVersion(version) && !mobile) {
                RC.isFunc(callback) && callback();
                RC.Msg.show({
                    title: customOptions.title || RC.Lang.Common.FLASH_VALIDATE_VERSION_TITLE,
                    msg: RC.utils.Flash.getPromptText(customOptions),
                    buttons:[],
                    closable: true
                });
                return false;
            }
            return true;
        },

        hasFlashPlayerVersion : function(version) {
             return swfobject.hasFlashPlayerVersion( version || DEFAULT_FLASH_VERSION);
        },

        renderSwf : function(container, swfObjId, movieLink, width, height,flashvar,align){
            if (Browser.name !== "ie") { //due webkit engine bug: DOM ERROR 7
                var tagEmbed = new Element('embed', {
                    'type'            : 'application/x-shockwave-flash',
                    'pluginspage'    : PLUGIN_PAGE,
                    'width'           : width,
                    'height'          : height,
                    'align'           : align || "middle" ,
                    'id'              : swfObjId,
                    'flashvars'      : flashvar,
                    'src'             : movieLink
                });
                tagEmbed.setProperties(oSWFParams);
                tagEmbed.inject(container);
            } else {
                var params = flashvar ? RC.apply({} ,{'flashvars' : flashvar} ,oSWFParams) : oSWFParams;
                new Swiff(movieLink, {
                    'id'                 : swfObjId,
                    'width'             : width,
                    'height'            : height,
                    'align'             : align || "middle",
                    'params'            : params,
                    'container'         : container,
                    'properties'        : {
                        'codebase'      : 'https://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=11,0,0,0'
                    }
                });
            }
        }

    }
})();

(function() {
    RC.utils.Video = {
        validateFlashVersion: function(){
            if (!RC.utils.Flash.validateFlashVersion(function() {}, RC.media.VideoPlayer.flashVersion)){
                return false;
            }
            return true;
        },
        openVideoWindow: function(config){
            if(this.validateFlashVersion()){
                var win = new RC.media.VideoPlayerWindow(config);
                win.show();
            }
        }
    }
})();

/*jslint */
/*global RC, Cookie, Wrapper */

/**
 * @class
 * @name RC.utils.BulkBuyOperation
 * @extends RC.utils.Observable
 */
RC.utils.BulkBuyOperation = (function () {
    'use strict';

    var inProgressCookieName = 'RC.BulkBuyOperationInProgress',
        statusChangedData = {
            users: false,
            phones: false
        },
        Class = RC.extend(RC.utils.Observable, {

            constructor: function (config) {
                Class.superclass.constructor.call(this, config || {});
                this.dataType = config.dataType;
            },

            isInProgress: function () {
                return RC.isTrue(Cookie.read(inProgressCookieName));
            },
            setInProgress: function (flag) {
                RC.Console.log('setBulkBuyOperationInProgressStatus: ' + flag);
                Cookie.write(inProgressCookieName, flag);
            },
            isEnterpriseUI: function () {
                return RC.Config.enterpriseUIEnabled;
            },
            isEnterpriseUIBulkUploadEnabled: function () {
                return RC.Config.isEnterpriseUIBulkUploadEnabled;
            },
            isTokenChanged: function (initToken) {
                var currentToken = RC.utils.History.getTokenIndexOf(0);
                if (currentToken && initToken !== currentToken) {
                    RC.Console.warn('BulkBuyOperation context changed: ', initToken, ' -> ', currentToken);
                    return true;
                }
                return false;
            },
            checkInProgress: function (params) {
                params = params || {};
                var self = this,
                    dataType = self.dataType,
                    initToken = RC.utils.History.getTokenIndexOf(0);
                if (!statusChangedData.hasOwnProperty(dataType)) {
                    RC.Console.warn(' unknown BulkBuyOperation:dataType');
                    return;
                }
                Wrapper.Extensions.isBulkBuyOperationInProgress({
                    onSuccess: function (o) {
                        var item;
                        if (self.isTokenChanged(initToken)) {
                            return;
                        }
                        if (!o.result && self.isInProgress()) {
                            for (item in statusChangedData) {
                                if (statusChangedData.hasOwnProperty(item)) {
                                    statusChangedData[item] = true;
                                } // mark as to be handled
                            }
                        }
                        if (statusChangedData[dataType]) { // may be true after this time's check or since last time
                            RC.Console.log('BulkBuyOperation: status changed ' + dataType);
                            self.fireListener('statusChange', o.result);
                            statusChangedData[dataType] = false; // mark as handled
                        }
                        self.setInProgress(o.result);
                        self.fireListener('complete', o.result);
                    },
                    onError: function () {
                        //no-op
                    }
                });
            }
        });

    return Class;

}());

RC.utils.BulkApplyOperation = (function() {
    var inProgressCookieName = 'RC.BulkApplyOperationInProgress';
    var statusChangedData = {
        users: false,
        phones: false
    };

    var Class = RC.extend(RC.utils.Observable, {

        constructor: function(config) {
            Class.superclass.constructor.call(this, config || {});
            this.dataType = config.dataType;
        },

        isInProgress: function() {
            return RC.isTrue(Cookie.read(inProgressCookieName));
        },
        setInProgress: function(flag) {
            RC.Console.log('setBulkApplyOperationInProgressStatus: ' + flag);
            Cookie.write(inProgressCookieName, flag);
        },
        isEnterpriseUI: function() {
            return RC.Config.enterpriseUIEnabled;
        },
        isTokenChanged: function(initToken) {
            var currentToken = RC.utils.History.getTokenIndexOf(0);
            if (currentToken && initToken != currentToken) {
                RC.Console.warn('BulkApplyOperation context changed: ', initToken, ' -> ', currentToken);
                return true;
            }
            return false;
        },
        checkInProgress: function(params) {
            var self = this;
            params = params || {};
            var dataType = self.dataType;
            var initToken = RC.utils.History.getTokenIndexOf(0);
            if (!statusChangedData.hasOwnProperty(dataType)) {
                RC.Console.warn(' unknown BulkApplyOperation:dataType');
                return;
            }
            Wrapper.Extensions.isBulkApplyTemplateInProgress({
                onSuccess: function(o) {
                    if (self.isTokenChanged(initToken)) {
                        return;
                    }
                    if (!o.result && self.isInProgress()) {
                        for (var item in statusChangedData) {
                            statusChangedData.hasOwnProperty(item) && (statusChangedData[item] = true); // mark as to be handled
                        }
                    }
                    if (statusChangedData[dataType]) { // may be true after this time's check or since last time
                        RC.Console.log('BulkApplyOperation: status changed ' + dataType);
                        self.fireListener('statusChange');
                        statusChangedData[dataType] = false; // mark as handled
                    }
                    self.setInProgress(o.result);
                    self.fireListener('complete', o.result);
                },
                onError: function() {
                    //no-op
                }
            });
        }
    });

    return Class;

})();

RC.utils.BulkApplyTemplate = {};

RC.utils.BulkApplyTemplate.validate = function(onSuccess)
{
    if (!RC.Config.enterpriseUIEnabled) {
        onSuccess();
        return;
    }
    Wrapper.Extensions.isBulkApplyTemplateInProgress({
        onSuccess: function(o) {
            if (!!o.result) {
                RC.Msg.alert(RC.Lang.Common.ALERT, RC.Lang.Common.IN_PROGRESS_BULK_APPLY_TEMPLATE_ERROR_MESSAGE, function() {}, true);
            } else {
                onSuccess();
            }
        },
        onError: function(o) {
            RC.Msg.alert(RC.Lang.Common.ALERT, o.status.localizedMessage || o.status.message, function() {}, true);
        }
    });
};

RC.utils.BulkImportContacts = {};

RC.utils.BulkImportContacts.invl = 0;

RC.utils.BulkImportContacts.clearInterval = function() {
    clearInterval(RC.utils.BulkImportContacts.invl);
    RC.utils.BulkImportContacts.invl = 0;
};

RC.utils.BulkImportContacts.verifyImport = function (gridMask, onSuccess) {
    doCheck(function (isInProgress) {
        if (isInProgress) {
            RC.getCmp(gridMask).setVisible(isInProgress);
            RC.utils.BulkImportContacts.invl = setInterval(function () {
                doCheck(function (r) {
                    if (!r) {
                        RC.utils.BulkImportContacts.clearInterval();
                        RC.getCmp(gridMask).setVisible(false);
                        onSuccess();
                    }
                });
            }, 30000);
        }
    });
};

RC.utils.BulkImportContacts.validate = function (onSuccess) {
    Wrapper.Extensions.isContactsImportInProgress({
        onSuccess: function (o) {
            if (!!o.result) {
                RC.Msg.alert(RC.Lang.Common.ALERT, RC.Lang.Common.IN_PROGRESS_BULK_IMPORT_CONTACTS_ERROR_MESSAGE, function() {}, true);
            } else {
                onSuccess();
            }
        },
        onError: function (o) {
            RC.Msg.alert(RC.Lang.Common.ALERT, o.status.localizedMessage || o.status.message, function() {}, true);
        }
    });
};


var doCheck = function (cb) {
    Wrapper.Extensions.isContactsImportInProgress({
        onSuccess: function (r) {
            cb(r.result);
        }
    });
};

(function() {

    RC.utils.Billing = {
        getAvailableUserTypes: function() {
            var userTypes = [];
            for (var mailboxType in RC.Config.availableMailboxTypes) {
                if (RC.Config.availableMailboxTypes.hasOwnProperty(mailboxType)
                    && RC.utils.Extension.isUserType(mailboxType)) {
                    userTypes.push(mailboxType);
                }
            }
            return userTypes;
        },

        hasMultipleUserTypes: function() {
            return RC.utils.Billing.getAvailableUserTypes().length > 1;
        },

        isATTNewEdition: function() {
            return RC.Config.isServiceRangeAvailable && RC.Config.tierId != 4424;
        },

        isBillableFeatureSuppressed: function() {
            return RC.Config.partnerBillingUI;
        }
    }

})();

(function() {
    var brands = {
        7310: 'TELUS',
        3420: 'ATT',
        3710: 'UK'
    };
    var telusLocalMap = {
        'en_US': '',
        'fr_CA': 'fr/',
        'en_GB': '',
        'en_CA': ''
    };
    var brandConfigs = {
        HelpLink: {
            TELUS: function(articleId) {
                return RC.Config.helpLink.match(".*\/") + telusLocalMap[RC.utils.Lang.getLocaleFromCookie()] + articleId;
            },
            DEFAULT: function(articleId) {
                return RC.Config.helpLink + (RC.Config.helpLink.contains('?') ? '&' : '?') + "ARTICLEID=" + articleId;
            },
            ATT: function(articleId) {
                return RC.Config.helpLink + (RC.Config.helpLink.contains('?') ? '&' : '?') + "ARTICLEID=" + articleId;
            },
            UK: function(articleId) {
                return RC.Config.helpLink + (RC.Config.helpLink.contains('?') ? '&' : '?') + "ARTICLEID=" + articleId;
            }
        },
        SupportNumber: {
            TELUS: function() {
                return RC.UI.Message(RC.Lang.Common.SUPPORT_NUMBERS, noWrap(RC.Config.supportNumber), noWrap(RC.Config.serviceNumber), noWrap(RC.Config.secondSupportNumber));
            },
            DEFAULT: function() {
                return noWrap(RC.Config.supportNumber);
            },
            ATT: function() {
                return noWrap(RC.Config.supportNumber);
            },
            UK: function() {
                return noWrap(RC.Config.supportNumber);
            }
        }
    };

    function getBrandValueByType(type, params) {
        var brandId = brands[RC.Config.brandId] || 'DEFAULT';
        var getValueFn = brandConfigs[type][brandId];
        return getValueFn(params);
    }

    function noWrap(value) {
        return RC.UI.Message('<span class="x-text-no-wrap">{0}</span>', value);
    }

    RC.utils.Common = {
        /**
         * Automatic encode special characters like #,&
         *
         * @param option
         * @param option.to
         * @param option.cc
         * @param option.bcc
         * @param option.subject
         * @param option.body
         */
        mailTo: function (option) {
            document.location.href = RC.UI.Message(
                "mailto:{0}?cc={1}&bcc={2}&subject={3}&body={4}",
                format(option.to),
                format(option.cc),
                format(option.bcc),
                format(option.subject),
                format(option.body)
            );
            function format(string) {
                return RC.isDefined(string) ? encodeURIComponent(string) : "%20";
            }
        },
        showCallSupportMsg: function(callback) {
            RC.Msg.alert(RC.Lang.Common.ALERT, RC.utils.Common.getContactSupportMsg(), callback, true);
        },
        getContactSupportMsg: function() {
            return RC.UI.Message(RC.Lang.Common.CALL_SUPPORT_MESSAGE, RC.utils.Text.mailTo(RC.Config.supportEmail));
        },
        getHelpLink: function(articleId) {
            return getBrandValueByType('HelpLink', articleId);
        },
        getSupportNumber: function() {
            return getBrandValueByType('SupportNumber');
        },
        getDownloadGreetingURL: function(greetingId, mailboxId) {
            var reqParams = [
                'cmd=downloadGreeting',
                'gId=' + greetingId,
                'mailboxId=' + mailboxId,
                'antiCache=' + Math.random()
            ];
            return '/mobile/media?' + reqParams.join('&');
        },
        formatAsI18NKey: function (string) {
            return string.toUpperCase().replace(/[-\\ /]+/g,'_').replace(/[^A-Z0-9_]/g,'');
        },
        getErrorMessage: function(serverResponse, defaultMsg, customErrorConfig) {
            customErrorConfig = customErrorConfig || {};
            var dynamicFieldsContext = customErrorConfig.dynamicFields || RC.Lang.Common.SERVER_API_ERROR_DYNAMIC_FIELDS,
                errorMessagesContext = customErrorConfig.errorMessages || RC.Lang.Common.SERVER_API_ERRORS;

            var errorCode = serverResponse.status.errorCode;
            var errorFields = serverResponse.status.fields || {};
            var problemDescription = errorFields.ParameterProblemDescription || '';
            var dynamicFieldKey;

            if (!RC.isEmpty(problemDescription)) {
                dynamicFieldKey = RC.utils.Common.formatAsI18NKey(problemDescription);
                errorFields.ParameterProblemDescription = dynamicFieldsContext[dynamicFieldKey] || problemDescription;
            }

            var localizedErrorMsg = errorMessagesContext[errorCode];
            var isMessageDefined = !RC.isEmpty(localizedErrorMsg);
            var msg = defaultMsg || RC.Lang.Common.INTERNAL_ERROR;

            if (isMessageDefined && ('INTERNAL_ERROR' !== errorCode || !RC.isEmpty(errorFields))) {
                msg = RC.UI.Message(localizedErrorMsg, errorFields);
            }
            return msg;
        },
        getCustomErrorMessage: function(serverResponse, defaultMsg) {
            return RC.utils.Common.getErrorMessage(serverResponse, defaultMsg, {
                errorMessages: RC.Lang.Common.CUSTOM_SERVER_API_ERRORS
            });
        },

        isShowAccountMessages : function (){
            return RC.Config.hasMessagesAccess || (!RC.Config.baaEnabled && RC.Config.hasNonHipaaMessagesAccess);
        },

        getTelusLocaleLink: function(link) {
            var lastWordIndex = link.lastIndexOf('/'),
                baseLink = link.substring(0,lastWordIndex + 1),
                lastWord = link.substr(lastWordIndex + 1);
            var currentLocale = RC.utils.Lang.getLocaleFromCookie();

            return link && (baseLink + telusLocalMap[currentLocale] + lastWord);
        }
    };
})();

RC.utils = RC.utils || {};
RC.utils.TAP = RC.utils.TAP || {};

RC.utils.TAP.getTAPLevel = function () {
    return RC.Config.applicationLevel || 0;
};

(function() {
    var mainPageWidth = 1024;
    var leftPanelWidth = 250;
    var commonMarginSpace = 18;
    var smallCommonMarginSpace = 12;
    var panelBorderWidth = 1;
    var bRightPanelWidth = mainPageWidth - leftPanelWidth - commonMarginSpace;
    var mRightPanelWidth = Math.floor((bRightPanelWidth - commonMarginSpace) / 2);
    var sRightPanelWidth = 320;
    var halfPanelWidth = Math.floor((mainPageWidth - commonMarginSpace - 4) / 2);
    var defaultTabTitleWidth = Math.floor(mRightPanelWidth / 2) - smallCommonMarginSpace - panelBorderWidth;

    RC.utils.Layout = {
        //main content width
        mainPageWidth: mainPageWidth,
        commonMarginSpace: commonMarginSpace,
        smallCommonMarginSpace: smallCommonMarginSpace,
        panelBorderWidth: panelBorderWidth,

        // big right panel, like phone system help panel
        bRightPanelWidth: bRightPanelWidth,
        // medium right panel, 2nd and 3rd panel are with equal width
        mRightPanelWidth: mRightPanelWidth,
        //small right Panel, like overview page
        sRightPanelWidth: sRightPanelWidth,

        halfPanelWidth: halfPanelWidth,

        callHandlingTabTitleWidth: 124,
        defaultTabTitleWidth: defaultTabTitleWidth,
        arrangeWindowsAtHorizontalCenter: function(wins) {
            if (!RC.isArray(wins) || wins.length == 0) {
                return;
            }

            var gap = 20;
            var boundWidth = 0;
            var winLeftsRelativeToBound = [];

            wins.forEach(function(win, idx) {
                var precedingWin,
                    precedingWinWidth;

                boundWidth += getWinWidth(win);
                if (idx == 0) {
                    winLeftsRelativeToBound[0] = 0;
                } else {
                    precedingWin = wins[idx - 1];
                    precedingWinWidth = getWinWidth(precedingWin);
                    winLeftsRelativeToBound[idx] = winLeftsRelativeToBound[idx - 1] + precedingWinWidth + gap;
                }
            });
            
            boundWidth += gap * (wins.length - 1);

            var viewportWidth = document.documentElement.clientWidth;
            var boundLeft = (viewportWidth - boundWidth) / 2;

            wins.forEach(function(win, idx) {
                var winEl = $(win.id);
                winEl.setStyle('left', boundLeft + winLeftsRelativeToBound[idx]);
            });

            function getWinWidth(win) {
                return $(win.id).getSize().x;
            }

        }        
    };
})();

RC.form = {
    /**
     * Creates form element by xtype
     * @param {Object} item The item object
     */
    createElement : function (item)
    {
        var xtype = "";
        if (!RC.isEmpty(item.xtype)) {
            xtype = item.xtype;
            item.xtype = (item.xtype.substr(0, 7) != 'x-form-') ? 'x-form-' + item.xtype : item.xtype;
        }
        if(xtype == "div")
             item.xtype = "div";
        if(xtype == "scrollbox") // fix to allow scrollboxes in forms
             item.xtype = "scrollbox";
        var cmp = RC.createComponent(item);
        if (cmp == null && !(item instanceof RC.form.Field)) {
            // todo IT'S UGLY each element must have XTYPE!!!
            // remove xtype at all
            item.xtype = xtype;
            cmp = new RC.form.Field(item);
        }
        return {obj : cmp, built : true};
    }
};

/**
 * Standard form container.
 *
 * @class
 * @name RC.form.FormPanel
 * @extends RC.Element
 * @constructor
 * @param {Object} params The config object
 */
RC.form.FormPanel = function(params)
{
    this.template = params.template;
    this.autoZIndex = params.autoZIndex === undefined ? true : params.autoZIndex;
    // todo REMOVE IT
    this.width = params.width === undefined ? null : params.width;
    /**
     * @cfg {Number} labelWidth The width of the label. Will be used in {@link #labelAlign}='left'
     */
    this.labelWidth = params.labelWidth !== undefined ? params.labelWidth : "";
    /**
     * @cfg {Number} fieldWidth The width of the field.
     */
    this.fieldWidth = params.fieldWidth !== undefined ? params.fieldWidth : "";
    /**
     * @cfg {String} align The alignment of the label (do not use it for text alignment!!!).
     * @deprecated
     */
    this.align = RC.isEmpty(params.align) ? 'left' : params.align;
    /**
     * @cfg {String} labelAlign The alignment of the label (do not use it for text alignment!!!). Use this field instead of {@link #align}.
     */
    this.labelAlign = params.labelAlign || this.align;
    /**
     * @cfg {String} formStyle The style of the form
     */
    this.formStyle = RC.isEmpty(params.formStyle) ? null : params.formStyle;
    
    this.formContainerClass = RC.isEmpty(params.formContainerClass) ? '' : params.formContainerClass;
    // should use FORM tag or DIV
    // todo refactor it
    this.useFormTag = params.useFormTag !== undefined ? params.useFormTag : false;
    this._rootTag = this.useFormTag ? 'form' : 'div';

    if (this.useFormTag) {
        this.formAction = params.formAction || false;
        this.formMethod = params.formMethod || 'GET';
        this.formTarget = params.formTarget || '_top';
    }

    // hidden collection of items
    this._items = [];
    // hidden collection of stores
    this._stores = [];
    // todo need to remove _dataStore
    this._dataStore = null;
    // cached container
    this._container = null;
    // counter for spacer elements
    this.spIdx = 0;
    // create superclass
    RC.form.FormPanel.superclass.constructor.call(this, params);
    // validation errors
    this._validationErrors = new RC.Error(this.id);
    this._validationInitiated = false;
    // collection of the supported events
    this.addEvents(
    /**
     * @event validate
     * Fires when a component is asked for it's errors
     * Fires AFTER validation of form's elements validation
     * @param {RC.Element} this
     */
        'validate'
            );
};

RC.extend(RC.form.FormPanel, RC.Element, {
    /**
     * Render this Component
     * @return {Object} Generated HTMLObject
     */
    render: function()
    {
        this._container = new Element('div', {
            'id': this.id,
            'class': this.formContainerClass + ' x-form-align-' + this.labelAlign,
            'html': (this.title != null ? '<div style="font-weight: bold; margin: 0 4px;">' + this.title + '</div>' : '')
        });

        if (this.width != null)
            if (this.width == +this.width) {
                this._container.setStyle('width', this.width + "px");    
            } else {
                this._container.setStyle('width', this.width);    
            }
            

        if (this.formStyle != null)
            this._container.set('style', this._container.get('style') + ';' + this.formStyle);

        var self = this;


        var rootEl = new Element(this._rootTag, {
            'id': this.id + '-formochka'
        });

        if (this.useFormTag) {

            if (!this.formAction) {

                rootEl.addEvent("submit", function(e) {
                    e.preventDefault();
                });

            } else {

                rootEl.set('action', this.formAction);
                rootEl.set('method', this.formMethod);
                rootEl.set('target', this.formTarget);

            }
        }

        rootEl.inject(self._container);
        this._rootEl = rootEl;

        var parent = self._container.getElement(self._rootTag);

        if (this.template) {

            parent.adopt(this.template.compile());

        } else {

            // parse and render all child
            this.items.each(function(item) {

                if (RC.isEmpty(item) || RC.isFalse(item)) return;

                var parsedItem = self.parseItem(item);
                var canvas = parsedItem.compile();
                canvas.inject(parent);

            });

        }

        this._items.each(function(item) {

            if (RC.isEmpty(item)) return;

            //TODO This should be unified with RC.Element behavior
            parent.addEvent('domready', function() {
                item.fireListener('domready', item.getRenderedCanvas(), parent);
            });

        });

        new Element('div', {
            'class': 'x-clearFix'
        }).inject(this._container);

        this.setVisible(this.visible);

        //this.fireListener('render');

        return this._container;
    },
    /**
     * If the form is configured as a regular form, this method will submit it via regular HTTP
     */
    submit: function(){
        if (!this.formAction || !this.useFormTag) {
            RC.Console.error('RC.form.FormPanel.submit(): Form is not configured to send data via HTTP.');
        }
        RC.Loader.show({});
        this._rootEl.submit();
    },
    /**
     * This method is deprecated.
     * @param {Object} data
     */
    setStore: function(data)
    {
        RC.Console.info("RC.form.FormPanel.setStore() is deprecated.");
        this._dataStore = data;
    },

    /**
     * This method is deprecated.
     * @return {Object}
     */
    getStore: function()
    {
        RC.Console.info("RC.form.FormPanel.getStore() is deprecated.");
        return this._dataStore;
    },

    /**
     * Gets value of the form element
     * @param {String} field The name of the field.
     * @param {Boolean} asObject (optional). Set to <tt>true</tt> if you want to return this value as object.
     * @deprecated
     */
    getValue: function(field, asObject)
    {
        RC.Console.info("RC.form.FormPanel.getValue() is deprecated. Use RC.form.FormPanel.findField(fieldName).getValue() instead of.");
        var item = this.findField(field);
        if (item) {
            return item.getValue(asObject);
        }
    },

    /**
     * Gets label of the field
     * @param {String} field The name of the field.
     */
    getLabel: function(field)
    {
        return this.getValue(field, true).getParent().getNext().get('html');
    },

    /**
     * Sets value to the field. TODO: This method need to refactored
     * @param {String} field The name of the field.
     * @param {*} value The value which will be set into the field.
     * @param {*} hiddenValue The hidden value which will be set into the field.
     * @deprecated
     */
    setValue: function(field, value, hiddenValue)
    {
        RC.Console.info("RC.form.FormPanel.setValue() is deprecated. Use RC.form.FormPanel.findField(fieldName).setValue() instead of.");
        var item = this.findField(field);
        if (item) item.setValue(value, hiddenValue);
    },

    /**
     * Initiates form validation
     * Returns true if client-side validation on the form is successful.
     * @return {Boolean}
     */
    validate: function(){

        var self = this;
        var isValid = true;

        this.cleanErrors();

        if (RC.isArray(this._items) && this._items.length > 0) {

            this._items.each(function(item){

                if (item && 'validate' in item && typeof item.validate == 'function') {

                    // Initiate validation
                    if (!item.validate()) isValid = false;

                    // Add existing nested errors
                    self._validationErrors.add(item.getErrors());

                }

            });

        }

        this.fireListener('validate');
        
        this._validationInitiated = true;

        return isValid;

    },
    /**
     * Alias for validate() method
     * @return {Boolean}
     */
    isValid: function(){
        return this.validate();
    },
    /**
     * Returns an array of error objects
     * If element has not been validated before  performs validation
     * @return {RC.Error}
     */
    getErrors: function(){

        if (!this._validationInitiated) this.validate();
        return this._validationErrors;

    },
    /**
     * Add a custom error
     * (!) These errors will be overwritten on next validate() method call
     * You can check validity by calling form.hasErrors() which won't call validate()
     * @param message
     */
    addError: function(message){
        this._validationErrors.add(message);
    },
    hasErrors: function(){
        if (!this._validationInitiated) this.validate();
        return (!this._validationErrors.isValid());
    },
    /**
     * Returns a plain array of error messages
     * If form has not been validated before  performs validation
     * @return {Array}
     */
    getErrorsPlain: function(){

        return this.getErrors().getAsArray();

    },
    /**
     * Returns errors as an HTML <ul><li> elements as string
     * If form has not been validated before  performs validation
     * @return {String}
     */
    getErrorsText: function(){

        return this.getErrors().getAsText();

    },
    cleanErrors: function(){
        
        this._validationErrors.clean();
        this._validationInitiated = false;

        if (RC.isArray(this._items) && this._items.length > 0) {

            this._items.each(function(item){

                if (item && 'cleanErrors' in item && typeof item.cleanErrors == 'function') item.cleanErrors();

            });

        }

    },

    /**
     * Resets values in the form
     */
    reset: function()
    {
        $(this.id).getElements('input').each(function(item)
        {
            if (item.type == 'text' || item.type == 'password')
                item.value = "";
        });
        $(this.id).getElements('textarea').each(function(item)
        {
            item.value = "";
        });
    },

    /**
     * Find a RC.form.Field in this form.
     * @param {String} id The value to search for (specify either a id, dataIndex, name or hiddenName).
     * @return {RC.form.Field} field
     */
    findField: function(id)
    {
        for (var i = 0; i < this._items.length; i++) {
            var item = this._items[i];
            if (item != undefined) {
                if (item.id == this.id + '-' + id || item.name == id) {
                    return item;
                }
            }
        }
        RC.Console.warn('Field %s not found in form %s[id=%s]', id, this.name, this.id);
        return null;
    },

    /**
     * Deprecated. Use {@link #findField} instead of.
     * @param {String} name The name of the form
     */
    getItem: function(name)
    {
        RC.Console.info("RC.form.FormPanel.getItem() is deprecated. Use RC.form.FormPanel.findField(fieldName) instead of.");
        return this.findField(name);
    },

    /**
     * Returns the fields in this form as an object with key/value pairs as they would be submitted using a standard form submit.
     * If multiple fields exist with the same name they are returned as an array.
     * @param {Boolean} asString (optional) Pass true to return the values as a string. (defaults to false, returning an Object)
     * @return {String/Object}
     */
    getValues: function(asString)
    {
        var values = [];
        var q;
        for (var i = 0; i < this._items.length; i++) {
            var item = this._items[i];
            if (item != undefined && RC.isDefined(item.name) && RC.isFunc(item.getValue)) {
                values.push([item.name, item.getValue()]);
            }
        }
        if (RC.isTrue(asString)) {
            var strArr = [];
            for (q in values) {
                if (RC.isNumeric(q)) {
                    strArr.push(values[q][0] + "=" + values[q][1]);
                }
            }
            return strArr.join('&');
        } else {
            var objArr = {};
            for (q in values) {
                if (RC.isNumeric(q)) {
                    objArr[values[q][0]] = values[q][1];
                }
            }
            return objArr;
        }
    },

    /**
     * Set values for fields in this form in bulk.
     * @param {Array/Object} values <p>Either an array in the form:</p>
     <pre><code>
     [
     {id:'clientName', value:'Fred. Olsen Lines'},
     {id:'portOfLoading', value:'FXT'},
     {id:'portOfDischarge', value:'OSL'}
     ]
     </code></pre>
     <p>or an object hash of the form:</p>
     <pre><code>
     {
     clientName: 'Fred. Olsen Lines',
     portOfLoading: 'FXT',
     portOfDischarge: 'OSL'
     }
     </code></pre>
     */
    setValues: function(values)
    {
        var q, field;
        if (RC.isArray(values)) {
            for (q = 0; q < values.length; q++) {
                field = this.findField(values[q].id);
                if (field != null) {
                    field.setValue(values[q].value);
                }
            }
        } else {
            for (q in values) {
                field = this.findField(q);
                if (field != null) {
                    field.setValue(values[q]);
                }
            }
        }
    },
    parseItem: function(item){

        if (RC.isEmpty(item)) {
            return;
        }
        if (item == '-') {
            item = {
                xtype   : 'spacer',
                id      : 'sp' + this.spIdx
            };
            this.spIdx++;
        }

        if (RC.isEmpty(item.id)) {
            item.id = RC.genPrefixedId({prefix: this.id, idFromText: item.name});
        } else {
            //Removal of the following comment is unsafe, it will definitely break some of the QAA scripts and maybe some components, that relied on namespaced form ids
            //if (item.xtype !== 'form' && !(item instanceof RC.form.FormPanel)) // Might be useful in future - disable propagation of formId into next form
            item.id = this.id + '-' + item.id;
        }

        var cebt = RC.form.createElement(item);
        var built = cebt.built;
        var o = cebt.obj;

        if (o == null) {
            o = item;
        }

        if (o && o.id && (!RC.getCmp(o.id) || RC.getCmp(o.id) != o)) RC.ComponentMgr.register(o); // make component findable with namespaced id along with original in case id has changed after creation

        if (built) {
            o.formId = this.id;

            if (!RC.isEmpty(this.labelAlign) && RC.isEmpty(o.labelAlign))
                o.labelAlign = this.labelAlign;

            if (!RC.isEmpty(this.labelWidth) && RC.isEmpty(o.labelWidth))
                o.labelWidth = this.labelWidth;

            if (!RC.isEmpty(this.fieldWidth) && RC.isEmpty(o.width))
                o.width = this.fieldWidth;

            if (!RC.isEmpty(this.fieldWidth) && RC.isEmpty(o.fieldWidth))
                o.fieldWidth = this.fieldWidth;

            this._items[this._items.length] = o;

            // render element
        } else {
            // xtype group also is item
            this._items.push(item);
        }

        return o;

    },
    /**
     * Adds item into the form
     * @param {Object} item The item object
     * @param {Object/String} prevId Id of the previous element
     * @param {String} direction This field is deprecated. TODO: Remove it
     */
    addItem: function(item, prevId, direction)
    {

        var o = this.parseItem(item);
        if (o === undefined) {
            return;
        }
        var sCanvas = o.compile();

        if (prevId !== undefined && $(prevId) != null) {
            sCanvas.inject(prevId, RC.isEmpty(direction) ? 'after' : direction);
        } else {
            return sCanvas;
        }
    },

    /**
     * Removes item from the form
     * @param {String} id The ID of the element
     */
    removeItem: function(id)
    {
        var elid = $(this.id + '-' + id);
        var item = null;
        for (var q = 0; q < this._items.length; q++) {
            if (this._items[q] === undefined) {
                continue;
            }
            if (this._items[q].id == this.id + '-' + id) {
                item = this._items[q];
                delete this._items[q];
                break;
            }
        }
        if (item == null)
            return;
        if (item.xtype == 'radiogroup') {
            elid.getParent().destroy();
        } else {
            if (elid != null)
                elid.destroy();
        }
    },


    /**
     * @ignore
     * @deprecated
     */
    setFocus: function(field)
    {
        RC.Console.info("RC.form.FormPanel.setFocus() is deprecated. Use RC.form.FormPanel.findField(fieldName).focus() instead of.");
        this.findField(field).focus();
    },

    /**
     * @ignore
     */
    setVisible: function(field, state)
    {
        if (RC.isBoolean(field)) {
            this._container.setStyle('display', RC.isTrue(field) ? '' : 'none');
            return;
        }
        RC.Console.info("RC.form.FormPanel.setVisible() is deprecated. Use RC.form.FormPanel.findField(fieldName).setVisible() instead of.");
        var item = this.findField(field);
        if (item && typeof item.setVisible == 'function') item.setVisible(state);
    },

    /**
     * Gets generated HTMLObject
     * @return {Object}
     */
    getContainer: function()
    {
        return this._container;
    },

    /**
     * Gets FORM node
     * @return {Object} Form HTMLObject
     */
    getRootNode : function()
    {
        return this._container.getElement(this._rootTag)
    },
    waitForRender: function(callback){

        RC.waitForElement('#' + this.id, callback); //TODO Futherly avoid $(#id) in favor of detection form.getContainer() inside document

    }
});

/**
 * @todo Refactor it
 * @param params
 * @ignore
 */
RC.Holder = function(params)
{
    // expand flag
    this.expanded = RC.isTrue(params.expanded);
    // display bottom rule
    this.displayRule = RC.isTrue(params.displayRule);
    // title of element
    this.title = RC.isEmpty(params.title) ? null : params.title;
    this.extraStyle = RC.isEmpty(params.extraStyle) ? null : params.extraStyle;
    // create superclass
    RC.Holder.superclass.constructor.call(this, params);
};

RC.extend(RC.Holder, RC.Element, {
    render: function()
    {
        var self = this;

        var canvas = new Element('div', {
            'id': this.id,
            //'html': (this.title != null ? '<div style="font-weight: bold;"><table width="100%" border="0"><tr><td><nobr>'+this.title+'</nobr></td><td width="100%" style="padding-right: 40px; padding-top: 8px;"><img width="100%" height="2" alt="" src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '"></td></tr></table>' : ''),
            'styles': {
                'width': this.width
            }
        });

        new Element('div', {
            html   : (this.title != null ? this.title : ''),
            'class': 'x-form-label-standAlone x-form-holder-label',
            events: {
                'click': function()
                {
                    self.toggleExpand();
                }
            }
        }).inject(canvas);


        if (this.extraStyle != null)
            canvas.set('style', canvas.get('style') + ';' + this.extraStyle);

        // containter for holder
        var zone = new Element('div', {
            'id': this.id + "-zone"
        });
        if (!this.expanded)
            zone.setStyle('display', 'none');
        zone.inject(canvas);

        // parse and render all child
        this.items.each(function(item)
        {
            if (item.compile === undefined) {
                item.formId = this.formId;
                item = RC.createComponent(item);
            }
            item.compile().inject(zone);
        });


        new Element('div', {
            'id': this.id + '-show',
            'html': '<a href="javascript: void(0);">' + RC.Lang.Common.MORE + '</a> <img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/arrow_down.gif') + '" alt="" />',
            'styles': {
                'float': 'right',
                'font-size': '11px',
                'display': (this.expanded ? 'none' : 'block')
            },
            'events': {
                'click': function()
                {
                    self.toggleExpand();
                }
            }
        }).inject(canvas, 'top');

        new Element('div', {
            'class': 'x-clearFix'
        }).inject(canvas);

        new Element('div', {
            'html': '<a href="javascript: void(0);">' + RC.Lang.Common.HIDE + '</a> <img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/arrow_up.gif') + '" alt="" />',
            'styles': {
                'text-align': 'right',
                'font-size': '11px',
                'margin-top' : '12px'
            },
            'events': {
                'click': function(e)
                {
                    self.toggleExpand();
                }
            }
        }).inject(zone);

        new Element('div', {
            'html': (this.displayRule ? '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>' : ''),
            'class'   : (this.displayRule  ? 'spacer':'')
        }).inject(zone);

        return canvas;
    },
    toggleExpand: function()
    {
        if (this.expanded) {
            $(this.id + "-zone").setStyle("display", "none");
            $(this.id + "-show").setStyle("display", "block");
        } else {
            $(this.id + "-zone").setStyle("display", "block");
            $(this.id + "-show").setStyle("display", "none");
        }
        this.expanded = !this.expanded;
    }
});

RC.reg('x-form-holder', RC.Holder);
RC.reg('holder', RC.Holder);
RC.reg('form', RC.form.FormPanel);


/**
 * Base class for form fields that provides default event handling, sizing, value handling and other functionality.
 *
 * @class
 * @name RC.form.Field
 * @extends RC.utils.Observable
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-field
 */
RC.form.Field = function(config)
{
    // apply all fields
    RC.apply(this, config);
    // remove xtype at all (bot not from the config)
    if (RC.isEmpty(this._xtype)) {
        this._xtype = this.xtype;
        this.xtype = null;
    }
    /**
     * @cfg {Boolean} allowBlank Specify <tt>false</tt> to validate that the value's length is > 0 (defaults to <tt>true</tt>)
     */
    this.allowBlank = RC.isEmpty(this.allowBlank) ? true : RC.isTrue(this.allowBlank);
    this.validationErrorMessage = config.validationErrorMessage;

    this.wrapLabel = RC.isTrue(config.wrapLabel);
    /**
     * @cfg {String} emptyText Temporary emptyText for the field's value
     */
    this.emptyText = RC.isEmpty(this.emptyText) ? '' : this.emptyText;
    this.emptyTextClass = 'x-form-emptyText';
    this.emptyTextVisibleClass = 'x-form-emptyText-visible';
    this.inputElementTag = 'input';
    // finalize id
    this.id = RC.genPrefixedId({id: config.id, idFromText: this.name});

    /**
     * @cfg {String} textAlign Alignment of value
     */
    this.textAlign = config.textAlign || 'left';
    this.buttonsCentered = RC.isTrue(config.buttonsCentered);

    this.tabindex = config.tabindex || 1;

    // call parent superclass
    RC.form.Field.superclass.constructor.call(this, config);

    // validation errors
    this._validationErrors = new RC.Error(this.id);
    this._validationInitiated = false;
    this._validationErrorClass = 'x-form-textfield-error';
    this.addEvents(
    /**
     * @event render
     * Fires after the component markup is rendered.
     * @param {RC.Element} this
     */
        'render',
    /**
     * @event show
     * Fires after the component is shown when calling the show method.
     * @param {RC.Element} this
     */
        'show',
    /**
     * @event hide
     * Fires after the component is hidden when calling the hide method.
     * @param {RC.Element} this
     */
        'hide',
    /**
     * @event removed
     * Fires when a component is removed from a DOM
     * @param {RC.Element} this
     */
        'removed',
    /**
     * @event beforeremove
     * Fires before a component will be removed from a DOM. Return FALSE to cancel action.
     * @param {RC.Element} this
     */
        'beforeremove',
    /**
     * @event display
     * Fires when a component is displayed
     * @param {RC.Element} this
     */
        'display',
    /**
     * @event validate
     * Fires when a component is asked for it's errors
     * @param {RC.Element} this
     */
        'validate'
        );
    this._renderedCanvas = null;
};

RC.extend(RC.form.Field, RC.utils.Observable, {
    // todo move to UTILS
    cutText: function(text, length)
    {
        if (RC.isEmpty(text))
            return {
                title: null,
                text: ""
            };
        // try to cut unnecessary symbols
        if (length != null && text.length > length)
            return {
                title: RC.strFromURLEnc(text),
                text: RC.strFromURLEnc(text.substr(0, length) + "...")
            };
        else
            return {
                title: null,
                text: RC.strFromURLEnc(text)
            };
    },
    /**
     * @deprecated
     * @ignore
     */
    set: function(value, hiddenValue)
    {
        RC.Console.info("RC.form.Field.set() is deprecated. Use RC.form.Field.setValue() instead of.");
        this.setValue(value, hiddenValue);
    },

    /**
     * @ignore
     * @deprecated
     */
    get: function(value)
    {

    },

    getInputElementSearchString: function(){

        return 'input[name=' + this.name + ']';

    },

    getInputElement: function(){

        var form = RC.getCmp(this.formId);
        if (!form) return null;

        var container = form.getContainer();
        if (!container) return null;

        var el = container.getElements('#' + this.id + '-field, #' + this.id);
        if (!el) return null;

        var elements = el.getElement(this.getInputElementSearchString());

        return elements[0] ? elements[0]: null;

    },

    /**
     * Sets a data value into the field and validates it.
     * @param {*} value The value to set
     * @param {*} hiddenValue (optional) The hidden value to set
     * @param {boolean} [allowHtml=false]
     */
    setValue: function(value, hiddenValue, allowHtml) {
        var input = this.getInputElement(),
            temp = String(value || '');

        value = typeof value === 'undefined' || value == null ? "" : value;

        if (!input) {
            return;
        }
        if (allowHtml) {
            input.set('value', temp);
        } else {
            input.set('value', temp.replace(/<(?:\/)?\w+[^>]*>/g, ''));
        }
        this.handleEmptyText();

        this.fireListener('change');

    },

    handleEmptyText: function(value){
        if (!this.emptyText) return;
        value = value || this.getValue(false, true);
        this.itemHtml.toggleClass(this.emptyTextVisibleClass, RC.isEmpty(value));
    },

    setEmptyText: function(emptyText){
        var self = this;
        var itemHtml = self.itemHtml;
        var emptyTextEl = itemHtml.getElement('>div.x-form-emptyText');
        emptyTextEl && emptyTextEl.destroy();

        self.emptyText = emptyText;
        if (!RC.isEmpty(self.emptyText)) {
            self._createEmptyText();
            self.handleEmptyText();
        }
    },

    /**
     * Returns the normalized data value (undefined or emptyText will be returned as '').
     * @param {bool} [asObject] (optional} Set to <tt>true</tt> if you want to return this value as object.
     * @param {bool} [noClean] (optional} Set to <tt>true</tt> if you want to get the value as is without trimming and cleaning for multiplie spaces
     * @return {*}
     */
    getValue: function(asObject, noClean)
    {
        var item = this.getInputElement(),
            value;

        if (!item) {
            RC.Console.warn("RC.form.Field.getValue(): Item with name " + this.name + " not found");
            return null;
        }

        //return RC.isTrue(asObject) ? item : item.value.trim();
        if (!!asObject) return item;

        if (item.value) {
            value = item.value;
            if (typeof value === 'string' &&
                String(item.type).toLowerCase() !== 'password') {
                value = value.split('<').join('&lt;');
                value = value.split('>').join('&gt;');
            }
            if (noClean !== true) {
                value = value.trim();
            }
            return value;
        }
        return '';
    },

    /**
     * Add an error to a field with a given message
     * @param {String} message
     */
    addError: function(message) {

        this._validationErrors.add(message);

    },
    /**
     * Validates the field value
     * @return {Boolean} True if the value is valid, else false
     */
    validate: function()
    {
       this.cleanErrors();

        // Legacy code
        if (!this.allowBlank && RC.isEmpty(this.getValue())) {
            this.addError(this.validationErrorMessage || RC.UI.Message(RC.Lang.Common.FIELD_MANDATORY, this.name));
        }

        this.fireListener('validate');

        this._validationInitiated = true;

        return !this.hasErrors();
    },
    /**
     * Alias for validate() method
     * @return {Boolean}
     */
    isValid: function()
    {
        return this.validate();
    },
    /**
     * Returns an array of errors of CURRENT validation state of the field (it means after last call of validate() method)
     * If element has not been validated before performs validation
     * @return {RC.Error}
     */
    getErrors: function()
    {

        if (!this._validationInitiated) this.validate();
        return this._validationErrors;

    },
    hasErrors: function()
    {

        if (!this._validationInitiated) this.validate();
        return (!this._validationErrors.isValid());

    },
    cleanErrors: function()
    {
        this._validationErrors.clean();
        this._validationInitiated = false;

    },

    /**
     * Try to focus this component.
     */
    focus: function()
    {

        var item = this.getInputElement();
        item && item.focus();

    },

    /**
     * Try to focus this component.
     */
    blur: function()
    {

        var item = this.getInputElement();
        item && item.blur();

    },

    /**
     * Convenience function to hide or show this component by boolean.
     * @param {Boolean} visible
     */
    setVisible: function(visible)
    {
        // todo change to virtual container (not getElementById)
        var el = RC.getCmp(this.formId).getContainer().getElement('div[id=' + this.id + ']');
        if (el != null) {
            el.setStyle('display', visible ? '' : 'none');
        }
    },
    /**
     * Compiles element
     * @return {Object} Generated HTMLObject
     */
    compile : function()
    {
        this._renderedCanvas = this.render();
        return this._renderedCanvas;
    },
    getRenderedCanvas: function(){
        if (!this._renderedCanvas) RC.Console.warn('RC.form.Field.getRenderedCanvas(): Trying to access unrendered canvas %s[%s]', this.name, this.id);
        return this._renderedCanvas;
    },

    _getEmptyTextContainer: function() {
        return this.itemHtml;
    },
    _createEmptyText: function() {
        var self = this;
        var itemHtml = self.itemHtml;
        var input = itemHtml.getElement(self.inputElementTag);
        var emptyText = new Element('div', {
            'class': self.emptyTextClass,
            'html': self.emptyText
        });

        self.itemEmptyText = emptyText;

        self._getEmptyTextContainer().adopt(emptyText);

        self.handleEmptyText(self.value);

        input.addEvent('focus',
            function(e) {
                itemHtml.removeClass(self.emptyTextVisibleClass);
            }).addEvent('blur',
            function(e) {
                self.handleEmptyText();
            }).addEvent('change', function(e) {
                self.handleEmptyText();
            });
    },

    /**
     * Renders the component
     * @return {Object} Generated HTMLObject
     * @private
     */
    render: function()
    {
        var self = this;
        var item = this;
        var itemHtml = null;
        var btnElId = this.id + '-field';
        // need to get element by dom id

        if (['x-form-textfield', 'textfield', 'x-form-password', 'password', 'x-form-phone', 'phone'].indexOf(item._xtype) == -1) {

            RC.Console.error('RC.form.Field.render(): Text field is rendered instead of proper form element (xtype:%s)', item._xtype);
            return this.renderFieldLabel();

        }

        if (!item.fieldWidth && item.width) item.fieldWidth = item.width;
        var itemWidth = RC.isEmpty(item.fieldWidth) ? '188' : item.fieldWidth;

        itemHtml = new Element('div', {
            'id': btnElId,
            'class': "x-form-textfield" + (item.noMargin ? ' x-form-textfield-noMargin' : ''),
            'style' : RC.isEmpty(item.extraFieldStyles) ? '' : item.extraFieldStyles,
            'html': '<input id="' + btnElId + '-' + item.name + '" tabindex="' + this.tabindex + '" onfocus="RC.Selection.clearSelection();" type="' + (item._xtype == 'password' || item._xtype == 'x-form-password' ? 'password' : 'text') + '" class="x-form-input" name="' +
                    item.name + '" value="' + htmlquotes((RC.isEmpty(item.value) ? '' : item.value)) + '" maxlength="' + (RC.isNumeric(item.maxLength) ? item.maxLength : 64) + '" ' +
                    ((item.readonly===true) ? ' readonly ' : '') + ' />'
        });
        itemHtml.setStyle('width', itemWidth);

        var input = itemHtml.getElement(this.inputElementTag);
        this.itemHtml = itemHtml;

        if (Browser.name === "ie") {
            input.setStyle('margin-left', 0);
        }

        input.setStyle('text-align', this.textAlign);

        if (!RC.isEmpty(item.emptyText)) {
             self._createEmptyText();
        }

        input.addEvent('keydown', function(e){
            return item.fireListener('keydown', e);
        });

        input.addEvent('keyup', function(e){
            item.fireListener('keypress', input.get('value'));
        });

        input.addEvent('blur', function(e){
            item.fireListener('blur', input.get('value'));
        });

        input.addEvent('focus', function(e){
            item.fireListener('focus', input.get('value'));
        });

        // todo replace to CHANGE event
        if (item.onInputChange) {
            if (window.addEventListener) {
                input.addEventListener('input', function (e)
                {
                    item.onInputChange.call(input, e, item.getValue(), item);
                }, false);
            } else {
                input.attachEvent('onpropertychange', function(e)
                {
                    item.onInputChange.call(input, e, item.getValue(), item);
                });
            }
        }

        item.setEnable = function(bEnable)
        {

            itemHtml.toggleClass('x-form-textfield-disabled', !bEnable);
            input.set('disabled', RC.isTrue(bEnable) ? '' : 'disabled');

        };

        item.setValidationError = function() {
            itemHtml.addClass(item._validationErrorClass);
        };
        item.clearValidationError = function() {
            itemHtml.removeClass(item._validationErrorClass);
        };

        var sCanvas = this.renderFieldLabel();

        itemHtml && itemHtml.inject(sCanvas);

        this.fireListener('render', itemHtml, sCanvas);

        return sCanvas;

    },

    disable : function ()
    {
        this.setEnable(false);
    },

    enable : function ()
    {
        this.setEnable(true);
    },

    setLabel : function(v)
    {
        var label = $(this.formId).getElementById(this.id).getElements('label.x-form-label');
        label.set('html', v + RC.Lang.Common.COLON_SIGN);
        RC.utils.Text.showTitle(label);
    },

    hasFieldLabel: function(){
        if (this.emptyFieldLabel) return true;
        return this.fieldLabel != '' && this.fieldLabel !== undefined && this.fieldLabel != null;
    },

    renderFieldLabel : function()
    {
        var item = this;

        var labelWidth = RC.isTrue(RC.isDefined(item.autoLabelWidth)) ? "auto" : (RC.isDefined(item.labelWidth) ? (item.labelWidth + 'px') : '');

        var extraClass = (typeof item.extraClass == 'string') ? " " + item.extraClass : "";

        var sCanvas = new Element('div', {
            'id'    : item.id,
            'class' : 'x-form-item x-form-item-align-' + this.labelAlign
        });

        if (item.hasFieldLabel()) {

            var fieldLabelId = item.id + '-fieldLabel';

            item.fieldLabel = item.fieldLabel + (RC.isDefined(item.fieldLabelSeparator) ? item.fieldLabelSeparator : RC.Lang.Common.COLON_SIGN);

            if (this.emptyFieldLabel) this.fieldLabel = '&nbsp;'; // May be used to move field as usual but w/o a label

            var label = new Element('label', {
                'id': fieldLabelId,
                'style': (!RC.isEmpty(item.labelStyle) ? item.labelStyle : ''),
                'class': 'x-form-label' + (item.wrapLabel ? ' x-form-label-wrap' : ''),
                'html': item.fieldLabel
            });

            if (labelWidth) label.setStyle('width', labelWidth);

            sCanvas.adopt(label);
            RC.utils.Text.showTitle(label, this);
        }

        if (!RC.isEmpty(extraClass)) sCanvas.addClass(extraClass);
        if (RC.isTrue(item.noMargin)) sCanvas.addClass('x-form-item-noMargin');
        if (RC.isTrue(item.eachRow)) sCanvas.addClass('x-form-item-eachRow');

        if (!RC.isEmpty(this.hintText) && item.fieldLabel) {
            new RC.form.ToolTip({
                render  : sCanvas.getElement('label'),
                text    : this.hintText,
                id : this.id + "-tooltip-hint"
            });
        }

        if (!RC.isEmpty(this.extraStyle)) {
            sCanvas.set('style', (RC.isEmpty(sCanvas.get('style')) ? this.extraStyle : (sCanvas.get('style') + ';' + this.extraStyle)));
        }

        if (!RC.isTrue(this.visible) && this.visible !== undefined) {
            sCanvas.setStyle('display', 'none');
        }

        return sCanvas;
    }
});

RC.reg('x-form-field', RC.form.Field);
RC.reg('x-form-textfield', RC.form.Field);
RC.reg('x-form-password', RC.form.Field);
RC.reg('x-form-phone', RC.form.Field);


/**
 * @class
 * @name RC.form.Textarea
 * @extends RC.utils.Observable
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-textarea
 */
RC.form.Textarea = function(config) {
    RC.form.Textarea.superclass.constructor.call(this, config);
    this.inputElementTag = 'textarea';
};

RC.extend(RC.form.Textarea, RC.form.Field, {
    getInputElementSearchString: function(){

        return 'textarea[name=' + this.name + ']';

    },
    render: function() {
        var item = this;
        var btnElId = this.id + '-field';
        // need to get element by dom id

        if (!item.fieldWidth && item.width) item.fieldWidth = item.width;
        var itemWidth = RC.isEmpty(item.fieldWidth) ? '188' : item.fieldWidth;

        var itemHtml = new Element('table', {
            id: btnElId,
            cellspacing: 0,
            cellpadding: 0,
            'class': "x-form-textarea" + (item.noMargin ? ' x-form-textarea-noMargin' : ''),
            styles: {
                width: itemWidth
            },
            html: '<tbody></tbody>'
        });
        this.itemHtml = itemHtml;

        if (item.extraClass !== undefined) {
            itemHtml.addClass(item.extraClass);
        }
        if (!RC.isEmpty(item.extraStyles)) {
            itemHtml.setStyles(item.extraStyles);
        }

        var txtArTr1 = new Element('tr', {'class': 'x-form-textarea-top'});
        new Element('td').inject(txtArTr1);
        new Element('td').inject(txtArTr1);
        new Element('td').inject(txtArTr1);

        txtArTr1.inject(itemHtml.getElement('tbody'));

        var txtArTr2 = new Element('tr', {'class': 'x-form-textarea-content'});
        new Element('td', {'class': 'x-form-textarea-content-left'}).inject(txtArTr2);
        new Element('td', {
            'class': 'x-form-textarea-content-content',
            html: '<textarea id="' + btnElId + '-' + item.name + '" onfocus="RC.Selection.clearSelection();" class="x-form-input" name="' + item.name + '" tabindex="' + this.tabindex + '" style="' +
                (RC.isEmpty(item.height) ? '' : ('height:' + item.height + 'px;')) + '"' +
                (RC.isNumeric(item.maxLength) ? ' maxlength="' + item.maxLength + '"' : '') + '>' + htmlquotes((RC.isEmpty(item.value) ? '' : item.value)) + '</textarea>'
        }).inject(txtArTr2);
        var _itemHtmlInput = txtArTr2.getElement(item.inputElementTag);
        if (RC.isNumeric(item.maxLength)) {
            _itemHtmlInput.addEvent('keydown',
                function(e)
                {
                    //RC.Console.log(e.key);
                    if (
                        this.value.length > item.maxLength &&
                            !e.control &&
                            e.key != 'delete' && e.key != 'backspace' &&
                            e.key != 'left' && e.key != 'right' && e.key != 'up' && e.key != 'down'
                        ) {
                        e.stop();
                        return false;
                    }
                }).addEvent('change',
                function()
                {
                    this.value = this.value.substr(0, item.maxLength);
                }).addEvent('blur', function()
            {
                this.fireEvent('change');
            });
        }
        new Element('td', {'class': 'x-form-textarea-content-right'}).inject(txtArTr2);

        txtArTr2.inject(itemHtml.getElement('tbody'));

        var txtArTr3 = new Element('tr', {'class': 'x-form-textarea-bottom'});
        new Element('td').inject(txtArTr3);
        new Element('td').inject(txtArTr3);
        new Element('td').inject(txtArTr3);

        txtArTr3.inject(itemHtml.getElement('tbody'));

        item.setEnable = function(bEnable) {

            itemHtml.toggleClass('x-form-textarea-disabled', bEnable);
            if (bEnable) {
                _itemHtmlInput.removeAttribute('disabled');
            } else {
                _itemHtmlInput.setAttribute('disabled', "disabled");
            }

        };
        if (!RC.isEmpty(item.emptyText)) {
            this._createEmptyText();
        }
        var sCanvas = this.renderFieldLabel();

        itemHtml && itemHtml.inject(sCanvas);

        return sCanvas;

    },

    _getEmptyTextContainer: function() {
        var itemHtml = this.itemHtml;
        return itemHtml.getElement('.x-form-textarea-content-content');
    }
});

RC.reg('x-form-textarea', RC.form.Textarea);

/**
 * @class
 * @name RC.form.Spacer
 * @extends RC.form.Field
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-spacer
 */
RC.form.Spacer = function(config) {
    RC.form.Spacer.superclass.constructor.call(this, config);
};

RC.extend(RC.form.Spacer, RC.form.Field, {
    setValue: function(value, hiddenValue) {
    },
    getValue: function(asObject) {
    },
    render: function() {

        var item = this;

        var sCanvas = new Element('div', {
            'id': item.id,
            'html': '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>',
            'class': 'x-clearFix spacer ' + (RC.isEmpty(item.extraClass) ? '' : item.extraClass)
        });

        if (!RC.isEmpty(this.extraStyle)) {
            sCanvas.set('style', sCanvas.get('style') + ';' + this.extraStyle);
        }

        if (!RC.isTrue(this.visible) && this.visible !== undefined) {
            // todo use Eelment.show()/.hide()
            sCanvas.setStyle('display', 'none');
        }

        return sCanvas;

    }
});

RC.reg('x-form-spacer', RC.form.Spacer);


/**
 * @class
 * @name RC.form.HintText
 * @extends RC.form.Field
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-hint
 */
RC.form.HintText = function(config)
{
    RC.form.HintText.superclass.constructor.call(this, config);
};

RC.extend(RC.form.HintText, RC.form.Field, {
    /**
     * Sets a data value into the field and validates it.
     * @param {*} value The value to set
     * @param {*} hiddenValue (optional) The hidden value to set
     */
    setValue: function(value, hiddenValue)
    {
        return null;
    },

    /**
     * Returns the normalized data value (undefined or emptyText will be returned as '').
     * @param {Boolean} asObject (optional} Set to <tt>true</tt> if you want to return this value as object.
     * @return {*}
     */
    getValue: function(asObject)
    {
        return null;
    },
    /**
     * Renders the component
     * @return {Object} Generated HTMLObject
     * @private
     */
    render: function()
    {
        var self = this;
        var item = this;
        var itemHtml = null;
        var btnElId = this.id + '-field';
        // need to get element by dom id

        item.setEnable = function(bEnable)
        {

            itemHtml.toggleClass('x-form-textfield-disabled', bEnable);
            itemHtml.getElement('input').set('disabled', RC.isTrue(bEnable) ? '' : 'disabled');

        };

        itemHtml = new Element('div', {
            'id': btnElId,
            'class': "x-form-hint",
            'html': item.text
        });

        var sCanvas = item.renderFieldLabel();

        itemHtml && itemHtml.inject(sCanvas);

        return sCanvas;
    }
});

RC.reg('x-form-hint', RC.form.HintText);


/**
 * @class
 * @name RC.form.HintIcon
 * @extends RC.utils.Observable
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-hint-icon
 */
RC.form.HintIcon = function(config)
{
    RC.form.HintIcon.superclass.constructor.call(this, config);
};

RC.extend(RC.form.HintIcon, RC.form.Field, {
    render: function()
    {
        var item = this;

        var sCanvas = this.renderFieldLabel();

        if (item._xtype == 'hint-icon') {
            new RC.form.ToolTip({
                render  : sCanvas,
                text    : item.text
            });
        }

        return sCanvas;
    }
});

RC.reg('x-form-hint-icon', RC.form.HintIcon);


/**
 * @class
 * @name RC.form.Hidden
 * @extends RC.form.Field
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-field
 */
RC.form.Hidden = function(config) {
    RC.form.Hidden.superclass.constructor.call(this, config);
};

RC.extend(RC.form.Hidden, RC.form.Field, {
    render: function() {

        var item = this;

        var sCanvas = item.renderFieldLabel();

        sCanvas.adopt(new Element('input', {
            type: 'hidden',
            name: item.name,
            value: item.value
        })).setStyle('display', 'none');

        return sCanvas;
    }
});

RC.reg('x-form-hidden', RC.form.Hidden);


/**
 * @class
 * @name RC.form.Displayfield
 * @extends RC.utils.Observable
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-displayfield
 */
RC.form.Displayfield = function(config) {
    RC.form.Displayfield.superclass.constructor.call(this, config);
};

RC.extend(RC.form.Displayfield, RC.form.Field, {
    getInputElementSearchString: function(){

        return '#' + this.id + '-value';

    },
    /**
     * Sets a data value into the field and validates it.
     * @param {*} value The value to set
     * @param {*} hiddenValue (optional) The hidden value to set
     */
    setValue: function(value, hiddenValue) {

        var el = this.getInputElement();

        if (!el) return;

        if (RC.isMooElement(value)) {
            el.adopt(value);
        } else {
            el.set('html', value);
            RC.utils.Text.showTitle(el);
        }

        this.fireListener('change');

    },

    /**
     * Returns the normalized data value (undefined or emptyText will be returned as '').
     * @param {Boolean} asObject (optional} Set to <tt>true</tt> if you want to return this value as object.
     * @return {*}
     */
    getValue: function(asObject) {

        var el = this.getInputElement();

        if (!el) return null;

        return el.get('html');

    },
    /**
     * Renders the component
     * @return {Object} Generated HTMLObject
     * @private
     */
    render: function() {
        var item = this;
        var itemHtml = null;
        var btnElId = this.id + '-field';
        // need to get element by dom id

        if (item.fieldWidth && !item.width) item.width = item.fieldWidth;
        var itemWidth = RC.isEmpty(item.width) ? '188' : item.width;

        var divValue = new Element('div', {
            id: this.id + '-value',
            'class': 'x-form-displayfield-value',
            styles: {
                width: itemWidth
            }
        });

        if (!RC.isEmpty(item.value)) {
            if (RC.isMooElement(item.value)) divValue.adopt(item.value);
            else divValue.set('html', item.value);
        }

        itemHtml = new Element('table', {
            'id': btnElId,
            cellspacing: 0,
            cellpadding: 0,
            'class': "x-form-displayfield",
            styles: {
                width: itemWidth
            },
            html: '<tbody></tbody>'
        });

        itemHtml.getElement('tbody').adopt(new Element('tr').adopt(new Element('td').adopt(divValue)));
        RC.utils.Text.showTitle(divValue, this);

        item.setEnable = function(bEnable) {

            itemHtml.toggleClass('x-form-textfield-disabled', bEnable);
            itemHtml.getElement('input').set('disabled', RC.isTrue(bEnable) ? '' : 'disabled');

        };

        var sCanvas = this.renderFieldLabel();

        itemHtml && itemHtml.inject(sCanvas);

        this.fireListener('render');

        return sCanvas;

    }
});

RC.reg('x-form-displayfield', RC.form.Displayfield);

/**
 * @class
 * @name RC.form.Button
 * @extends RC.form.Field
 * Simple Button class. TODO: Need to be removed.
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-button
 */
RC.form.Button = function(params)
{
    /**
     * @type {Boolean}
     */
    this.disabled = !!params.disabled;
    this.img = null;
    this.container = null;
    RC.form.Button.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Button, RC.form.Field, {
    render: function()
    {
        var item = this;
        var itemHtml = null;
        var btnElId = this.id + '-button';
        // need to get element by dom id
        var domID = item.id;

        // extra class if need
        var extraClass = typeof item.extraClass == 'string' ? " " + item.extraClass : "";

        var self = this;

        var buttonText = item.value === undefined ? item.text : item.value;

        var buttonConfig = Object.clone(this);
        buttonConfig.text = buttonText;
        buttonConfig.spanValue = true;
        buttonConfig.width = this.fieldWidth || this.width;
        buttonConfig.tabindex = this.tabindex;
        buttonConfig.visible = true;
        this._button = RC.Button.createButton(buttonConfig, btnElId, function(){
            RC.Selection.clearSelection();
            if (item.handler != null) item.handler.call(self, RC.getCmp(self.formId) ? RC.getCmp(self.formId)._dataStore : null);

        });
        itemHtml = this._button.compile();
        itemHtml.addClass('x-form-button');
        if (!RC.isEmpty(this.extraButtonStyles)) {
            itemHtml.set('style', itemHtml.get('style') + ';' + this.extraButtonStyles);
        }

        var sCanvas = item.renderFieldLabel();
        var label = sCanvas.getElement('label');
        if(label) label.set('for', btnElId);

        if (itemHtml != null) {
            itemHtml.inject(sCanvas);
        }

        if (!RC.isEmpty(this.extraStyle)) {
            sCanvas.set('style', sCanvas.get('style') + ';' + this.extraStyle);
        }

        if (!RC.isTrue(this.visible) && this.visible !== undefined) {
            // todo use Eelment.show()/.hide()
            sCanvas.setStyle('display', 'none');
        }
        this.container = sCanvas;
        return sCanvas;
    },
    enable: function(){
        this._button.enable();
    },
    disable: function(){
        this._button.disable();
    },
    set: function(value, hiddenValue){
        this._button.set.apply(this._button, [value, hiddenValue]);
    }
});

RC.reg('x-form-button', RC.form.Button);

/**
 * @class
 * @name RC.form.GroupButton
 * @extends RC.form.Field
 * A grouping container for {@link RC.form.Button} controls.
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-groupbutton
 */
RC.form.GroupButton = function(params) {
    this.formId = params.formId;
    RC.form.GroupButton.superclass.constructor.call(this, params);
};

RC.extend(RC.form.GroupButton, RC.GroupButton, {
    callHandler: function() {
        return this.handler.apply(this, [this.getValue(), RC.getCmp(this.formId)._dataStore]);
    },
    render: function() {
        this.name = this.id.replace(this.formId + '-', '');
        return RC.form.GroupButton.superclass.render.call(this);
    },
    /**
     * Backward compatibility with RC.form.Field
     * TODO Will be removed
     * @deprecated
     * @return {*}
     */
    set: function() {
        return this.setValue.apply(this, arguments);
    },
    get: function() {
        return this.getValue.apply(this, arguments);
    }
});

RC.reg('x-form-groupbutton', RC.form.GroupButton);

/**
 * @class
 * @name RC.form.ButtonGroup
 * @extends RC.utils.Observable
 * @constructor
 * @param {Object} config The config object
 * @xtype x-form-buttongroup
 */
RC.form.ButtonGroup = function(config)
{
    RC.form.ButtonGroup.superclass.constructor.call(this, config);
};

RC.extend(RC.form.ButtonGroup, RC.form.Field, {
    /**
     * Renders the component
     * @return {Object} Generated HTMLObject
     * @private
     */
    render: function()
    {
        var item = this;
        var itemHtml = null;
        var btnElId = this.id + '-field';

        item.setEnable = function(bEnable)
        {

            itemHtml.toggleClass('x-form-textfield-disabled', bEnable);
            itemHtml.getElement('input').set('disabled', RC.isTrue(bEnable) ? '' : 'disabled');

        };

        itemHtml = new Element('table', {
            'id': btnElId,
            'class'  : 'x-buttons-area' + (this.buttonsCentered ? ' x-buttons-area-centered' : ''),
            'html': '<tr><td class="x-buttons-area-container"></td></tr>'
        });
        if (item.extraClass !== undefined) {
            itemHtml.addClass(item.extraClass);
        }
        var coHTML = itemHtml.getElement('td');
        item.items.each(function(rec) {
            RC.Button.createButton(rec, RC.genPrefixedId({id: rec.id, idFromText: rec.text, prefix: item.id, item: item}), function() {
                if (rec.handler != null)
                    rec.handler(RC.getCmp(item.formId)._dataStore);
            }).compile().inject(coHTML);
        });
        item.setVisible = function(flag)
        {
            if (flag && sCanvas.getStyle('display') == 'none') {
                sCanvas.setStyle('display', '');
            } else {
                if (flag) {
                    itemHtml.removeClass('x-hidden');
                } else {
                    itemHtml.addClass('x-hidden'); // class is added when element should be invisible
                }
            }
        };

        var sCanvas = this.renderFieldLabel();

        itemHtml && itemHtml.inject(sCanvas);

        return sCanvas;
    }
});

RC.reg('x-form-buttongroup', RC.form.ButtonGroup);


/**
 * @class
 * @name RC.form.Checkbox
 * @extends RC.form.Field
 * Single checkbox field. Can be used as a direct replacement for traditional checkbox fields.
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-checkbox
 */
RC.form.Checkbox = function(params) {
    this.visible = params.visible;
    this.fullWidth = RC.isDefined(params.fullWidth) ? RC.isTrue(params.fullWidth) : false;
    RC.form.Checkbox.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Checkbox, RC.form.Field, {
    _itemHtml: null,
    getInputElementSearchString: function(){

        return 'input[name=' + this.name + ']';

    },
    getValue: function(asObject) {

        var item = this.getInputElement();

        if (!item || !item.get('checked')) return false;

        return RC.isEmpty(item.value) ? true : (!!asObject ? item : true);

    },
    render: function() {
        var itemHtml = new Element('table', {
            'id': this.id + '-field',
            'cellspacing': 0,
            'cellpadding': 0,
            'class': 'x-form-checkbox' +
                (this.boxLabel ? ' x-form-checkbox-hasLabel' : '') +
                (this.checked ? ' x-form-checkbox-checked' : '') +
                (this.border ? ' x-form-checkbox-border' : '') +
                (this.fullWidth ? ' x-form-checkbox-fullWidth' : '') +
                (this.disabled ? ' x-form-checkbox-disabled' : '') +
                (this.extraClass ? ' ' + this.extraClass : ''),
            'html': '<tbody></tbody>'
        });

        this._itemHtml = itemHtml;
        itemHtml.addClass('x-cursor-pointer');

        if (this.extraClass) itemHtml.addClass(this.extraClass);

        var self = this;

        var clickEvent = function(e) {
            if (self.disabled) {
                return;
            }
            RC.Selection.clearSelection();
            var input = this.getElement('input');
            if (input == null) {
                input = this.getPrevious().getElement('input');
            }
            if (false === self.fireListener('beforeChange', input.checked, e)) {
                return;
            }
            input.checked = !input.checked;
            self._itemHtml.toggleClass('x-form-checkbox-checked', input.checked);
            self.fireListener('change', input.checked, e);
        };

        var hint;
        var hintContainer;
        if (!RC.isEmpty(this.hintText)) {
            hintContainer = new Element('span', {
                id: this.id + '-hinttd',
                html: ''
            });
            hint = new RC.form.ToolTip({
                render  : hintContainer,
                text    : this.hintText
            });
        }

        new Element('tr').adopt(
            new Element('td', {
                tabindex: this.tabindex,
                html: '<input type="checkbox" id="' + self.id + '-field-' + self.name + '" name="' + this.name + '" value="' + (RC.isEmpty(this.value) ? '' : this.value) + '" ' +
                    (RC.isTrue(this.checked) ? 'checked="true"' : '') + ' style="display: none;"/><img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/dot.gif') + '" id="' + this.id + '-icon" alt="" />',
                events: {
                    'click': clickEvent,
                    'keyup': function(e){
                        if (e.key == 'space') {
                            e.stop();
                            this.fireEvent('click', e);
                        }
                    }
                },
                'class': 'x-form-checkbox-box'
            }),
            ( !RC.isEmpty(self.boxLabel) ? new Element('td', {
                id: self.id + '-label',
                html: self.boxLabel,
                'class': 'x-form-checkbox-label',
                events: {
                    'click': clickEvent
                }
            }).adopt(hintContainer) : null)
        ).inject(itemHtml.getElement('tbody'));

        if (this.items !== undefined) {
            var tdLabel = itemHtml.getElement('td[id=' + this.id + '-label]');
            var placeholders = tdLabel.getElements('div.checkbox_placeholder');
            for (var q = 0; q < this.items.length; q++) {
                var o = RC.getCmp(this.formId).addItem(this.items[q]);
                placeholders[q].set('html', '');
                o.inject(placeholders[q]);
            }
            tdLabel.removeEvent('click', clickEvent);
            itemHtml.addClass('x-cursor-default');
        }

        if (this.hasFieldLabel()) {

            var sCanvas = this.renderFieldLabel();
            itemHtml.inject(sCanvas);
            return sCanvas;
        }

        if (this.extraStyle !== undefined)
            itemHtml.set('style', itemHtml.get('style') + ';' + this.extraStyle);

        if (this.visible !== undefined && !RC.isTrue(this.visible))
            itemHtml.setStyle('display', 'none');

        this._container = itemHtml;

        return itemHtml;
    },
    set: function(value) {
        var el = null;
        if (this.formId) {
            el = RC.getCmp(this.formId).getContainer().getElement(this.getInputElementSearchString());
        } else {
            el = this._container.getElement("input");
        }
        if (el != null) {
            el.checked = value != null && value.toString() == el.get('value').toString();
            this._itemHtml.toggleClass('x-form-checkbox-checked', el.checked);
        }
    },
    get: function() {
        var el = null;
        if (this.formId) {
            el = RC.getCmp(this.formId).getContainer().getElement(this.getInputElementSearchString());
        } else {
            el = this._container.getElement("input");
        }
        if (el != null) {
            return el.checked;
        }
    },
    setVisible: function(state) {
        var el = RC.getCmp(this.formId).getContainer().getElement('div[id=' + this.id + ']');
        if (el == null)
            el = RC.getCmp(this.formId).getContainer().getElement('table[id=' + this.id + '-field]');
        if (el != null)
            el.setStyle('display', state ? '' : 'none');
    },
    isVisible : function(){
        //todo implement with correct container and move to RC.form.Field class
        return this._itemHtml && RC.isVisible(this._itemHtml);
    },
    disabled: false,
    disable: function() {
        this.disabled = true;
        var input = this._container.getElement('input');
        if (input == null) {
            input = this.getPrevious().getElement('input');
        }
        input.setProperty("disabled", "disabled");
        this._container.addClass('x-form-checkbox-disabled');
    },
    enable: function() {
        this.disabled = false;
        var input = this._container.getElement('input');
        if (input == null) {
            input = this.getPrevious().getElement('input');
        }
        input.removeProperty("disabled");
        this.set(input.checked ? input.value : null);
        this._container.removeClass('x-form-checkbox-disabled');
    }
});

RC.reg('x-form-checkbox', RC.form.Checkbox);

/**
 * A grouping container for {@link RC.form.Checkbox} controls.
 *
 * @class
 * @name RC.form.CheckboxGroup
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-checkboxgroup
 */
RC.form.CheckboxGroup = function(params) {
    RC.form.CheckboxGroup.superclass.constructor.call(this, params);
    this.fullWidth = RC.isDefined(params.fullWidth) ? RC.isTrue(params.fullWidth) : false;
};

RC.extend(RC.form.CheckboxGroup, RC.form.Field, {
    filter: function(filter){

        var self = this;

        var parent = self.container.getParent();
        var children = self.container.getChildren('tr');

        self.container.dispose();

        this.items.each(function(item, index){

            var cell = children[index];
            if (!cell) return;
            cell.toggleClass('x-hidden', !filter(item));

        });

        parent.adopt(self.container);

    },
    render: function() {
        var self = this;

        var isTop = (this.align == 'top');

        var itemHtml = this.renderFieldLabel();

        var content = new Element('table', {
            'id': this.id + '-field',
            'class': 'x-form-checkbox-table' +
                     (this.fullWidth ? ' x-form-checkbox-table-fullWidth' : ''),
            cellspacing: 0,
            cellpadding: 0,
            html: '<tbody></tbody>'
        });
        content.inject(itemHtml);

        this.container = content.getElement('tbody');

        this.items.each(function(f,idx) {
            f.name = self.name;
            f.border = self.border;
            f.fullWidth = self.fullWidth;
            var o = new RC.form.Checkbox(f);
            o.addListener("change", function(v) {
                self.fireListener('change', v);
            });
            o.formId = self.formId;
            new Element('tr',{'class' :(idx==(self.items.length-1) ? 'last-row' : null)}).adopt(
                new Element('td').adopt(o.render())
            ).inject(self.container);

        });

        return itemHtml;
    },

    // get array of checked items
    getChecked: function() {
        var boxes = [];
        $(this.id).getElements('input[type=checkbox]').each(function(item) {
            if (item.checked)
                boxes.include(item.value);
        });
        return boxes;
    },

    isChecked : function(){
        return !!this.getChecked().length;
    }
});

RC.reg('x-form-checkboxgroup', RC.form.CheckboxGroup);

/**
 * A combobox control with support for autocomplete, remote-loading, paging and many other features.
 *
 * @class
 * @name RC.form.Combobox
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-combo
 */
RC.form.Combobox = function(params) {

    // loaded data
    this._data = [];

    this.viewConfig = params.viewConfig || {};

    this.domElements = {};

    this.selectedIndex = -1;
    this.emptyText = '&#160;';

    RC.form.Combobox.superclass.constructor.call(this, params);

    this.init();

};

/**
 * A grouping container for {@link RC.form.Combobox} controls.
 *
 * @class
 * @name RC.form.ComboboxGroup
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-combogroup
 */
RC.form.ComboboxGroup = function(params) {
    RC.form.ComboboxGroup.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Combobox, RC.form.Field, {

    getStorageAsArray: function(){

        var recs = this._data;

        if (recs.length == 0) recs = this.store.getRange();

        return recs;

    },

    /**
     * Called externally
     * @param idx
     * @returns {*}
     */
    setValue: function(idx) {
        function compareObjects(x, y) {
            for (p in y) {
                if (typeof(x[p]) == 'undefined') {
                    return false;
                }
            }
            for (p in y) {
                if (y[p]) {
                    switch (typeof(y[p])) {
                        case 'object':
                            if (!compareObjects(x[p], y[p])) {
                                return false
                            }
                            break;
                        case 'function':
                            if (typeof(x[p]) == 'undefined' || (y[p].toString() != x[p].toString())) {
                                return false;
                            }
                            break;
                        default:
                            if (y[p] != x[p]) {
                                return false;
                            }
                    }
                }
                else {
                    if (x[p]) {
                        return false;
                    }
                }
            }
            for (p in x) {
                if (typeof(y[p]) == 'undefined') {
                    return false;
                }
            }
            return true;
        }

        if (idx == null)
            return;

        var recs = this.getStorageAsArray();

        var length = (recs && 'length' in recs) ? recs.length : 0;

        for (var i = 0; i < length; i++) {
            var r = recs[i];
            if ((r[this.hiddenValue] == idx) || (typeof idx == 'object' && compareObjects(idx, r[this.hiddenValue]))) {
                this.setSelectedIndex(i);
                this.fireSelectedEvent();
                break;
            }
        }

        return idx;
    },

    _getIndexByHiddenValue: function(idx) {
        if (idx == null)
            return;
        var recs = this._data;
        if (recs.length == 0)
            recs = this.store.records;

        for (var i = 0; i < recs.length; i++) {
            var r = recs[i];
            if (r[this.hiddenValue] == idx) {
                return i;
            }
        }
    },

    /**
     * Called externally
     * @param idx
     * @returns {*}
     */
    setByIndex: function(idx) {
        if (idx == null || idx < 0)
            return;
        var recs = this._data;
        if (recs.length == 0) {
            recs = this.store.records;
        }
        if (idx >= recs.length) {
            return;
        }
        var r = recs[idx];
        this.setValue(r[this.hiddenValue]);
        return idx;
    },

    fireSelectedEvent: function(){
        this.fireListener('selected', this.getStorageAsArray()[this.selectedIndex], this);
    },

    setSelectedIndex: function(i, allowEmpty){

        this.selectedIndex = i;
        this.domElements.select.value = this.selectedIndex;
        // IVR-599
        window.setTimeout(function(){ // For chrome/ie it has to be done with a small delay
            this.domElements.select.value = this.selectedIndex;
        }.bind(this), 1);
        this.propagateValue(allowEmpty);

    },

    getValue: function() {
        if (this.selectedIndex == -1) return null;
        var recs = this.getStorageAsArray();
        if (!(this.selectedIndex in recs)) return null; // it might happen, that selected index is not yet loaded in AJAX stores
        return recs[this.selectedIndex][this.hiddenValue];
    },

    getVisibleValue: function() {
        if (this.selectedIndex == -1) return null;
        var recs = this.getStorageAsArray();
        return recs[this.selectedIndex][this.visibleValue];
    },

    getLabel: function() {
        return this.domElements.value.get('html');
    },

    _setLabel: function(label) {
         this.domElements.value.set('html', label);
    },

    setEmptyText: function(emptyText) {
        this.emptyText = emptyText;
        this._setLabel(emptyText);
    },

    resetWithData: function(data, value) {

        this.reset();
        this._data = data;
        this.buildFixed();
        this.setValue(value);

    },

    reset: function() {
        this.domElements.select.empty();
        this._setLabel(this.emptyText);
        this.selectedIndex = -1;
        this.optionsCount = 0;
        this.fireListener("reset");
    },

    build: function(records) {
        this.disable(true);
        this.reset();
        this.optionsCount = records.length;
        var self = this;
        records.each(function(item) {
            self.addOption(item);
        });
        this.propagateValue();
        this.disable(this.disabled);
    },

    buildFixed: function() {
        if (this._data.length < 1)
            return;
        this.disable(true);

        var self = this;

        this.hiddenValue = 'value';
        this.visibleValue = 'text';
        this._data.each(function(record) {
            self.addOption(record);
        });
        this.propagateValue();
        this.disable(this.disabled);
    },

    propagateValue: function(allowEmpty) {
        var value = this.getVisibleValue();
        this._setLabel(value || this.emptyText);
        if (allowEmpty !== true && !value) {
            this.domElements.select.selectedIndex = -1;
            window.setTimeout(function(){ // For chrome/ie it has to be done with a small delay
                this.domElements.select.selectedIndex = -1;
            }.bind(this), 1);
        }
    },

    addDataAttr: false,

    addOption: function(r) {

        if (r.renderGroup) {

            var optgroup = new Element('optgroup', {
                label: this.getValueFromStore(r)
            });

            this.domElements.select.adopt(optgroup);

        } else {

            var props = {
                value: this._getIndexByHiddenValue(r[this.hiddenValue]),
                html: this.getValueFromStore(r),
                selected: r[this.hiddenValue] == this.getValue(),
                disabled: r.renderDisabled

            };

            if(this.addDataAttr) {
                props['data-value'] = r[this.hiddenValue];
            }

            var option = new Element('option', props);

            this.domElements.select.adopt(option);

            //if (this.viewConfig.rowCellStyle) option.setStyles(this.viewConfig.rowCellStyle(r));

            this.fireListener('add', r);
        }

    },

    getValueFromStore: function(r) {
        var html = (r[this.visibleValue].length > 0 ? r[this.visibleValue] : '&#160;');
        if (typeof this.renderer == 'function') {
            html = this.renderer(r[this.visibleValue], r);
        }
        return html;
    },

    disable: function(disable) {
        this.domElements.itemHtml.toggleClass('x-form-combo-disabled', !!disable);

        if (disable) {
            this.domElements.select.set('disabled', 'disabled');
        } else {
            this.domElements.select.removeAttribute('disabled');
        }

    },
    init: function() {

        var self = this;

        function pushValue(e) {
            e.stop();
            self.setSelectedIndex(parseInt(this.value), true);
            self.fireSelectedEvent();
        }

        function onKeypup(e) {
            if(e.key != 'tab' && e.code != 16){
                pushValue.call(this, e);
            }
        }

        this.domElements.select = new Element('select', {
            'class': 'x-form-combo-select',
            tabindex: this.tabindex,
            id: this.id + '-combo-value',
            name: this.name,
            value: this.selectedIndex,
            events: {
                change: pushValue
            }
        });

        if(Browser.name !== "ie"){
            this.domElements.select.addEvent('keyup', onKeypup);
        }

//        /**
//         * MouseDown event is fired after
//         */
//        this.domElements.select.addEvent('mousedown', function(e){
//            if (self.domElements.itemHtml.hasClass('x-form-combo-focus')) pushValue.bind(this)(e);
//        });

        this.domElements.select.addEvent('focus', function(){
            self.domElements.itemHtml.addClass('x-form-combo-focus');
        });

        this.domElements.select.addEvent('blur', function(){
            self.domElements.itemHtml.removeClass('x-form-combo-focus');
        });

        this.domElements.knob = new Element('div', {
            'class': 'x-form-combo-knob'
        });

        this.domElements.value = new Element('div', {
            'class': 'x-form-combo-value',
            'html': this.emptyText
        });

        this.domElements.itemHtml = new Element('div', {
            'id': this.id + '-combo',
            'class': 'x-form-combo' + (this.noMargin ? ' x-form-combo-noMargin' : ''),
            'styles': {
                'width': this.width
            }
        });

    },
    render: function() {
        var self = this;

        this.width = this.width || 188;

        this.domElements.itemHtml.setStyle('width', this.width);

        var data = [];

        if (this.store !== undefined) {
            if (this.store.length > 0) {
                // if we define value, which was contained in store, we need to select it and deselect other all
                var definedValueIndex = -1;
                if (!RC.isEmpty(this.value)) {
                    definedValueIndex = 0;
                    while (definedValueIndex < this.store.length && this.store[definedValueIndex][0] != this.value)
                        definedValueIndex++;
                    if (definedValueIndex >= this.store.length) {
                        definedValueIndex = -1;
                    } else {
                        this.store[definedValueIndex][2] = "selected";
                    }
                }
                for (var i = 0; i < this.store.length; i++) {
                    // reset selected value, if this.value contain element from store
                    if (definedValueIndex >= 0 && definedValueIndex != i)
                        this.store[i][2] = "";
                    data[i] = { value: this.store[i][0], text: this.store[i][1], renderDisabled: !!this.store[i][3]};
                    //option parameters processing
                    if (!this.store[i][3] && this.store[i][2] == 'selected') {
                        this.selectedIndex = i;
                        this.defaultStoreOption = {
                            value: this.store[this.selectedIndex][0], name: this.store[this.selectedIndex][1]
                        };
                    }
                }
            }
            // if we found a data object
            if (this.store instanceof RC.data.Store) {
                this.store.addListener('load', function(r) {
                    if (RC.isDefined(self.value)) {
                        var selectedIndex = self._getIndexByHiddenValue(self.value);
                        if (selectedIndex != undefined) {
                            self.setSelectedIndex(selectedIndex);
                        }
                    }
                    this.propagateValue();
                }, this);
                this.store.addListener('loadRecord', this.addOption, this);
                this.store.addListener('clear', function() {
                    self.reset();
                }, this);
                if (this.store.autoLoad) RC.Ajax.Queue.add(this.store, this);
//                if(this.store.autoLoad) this.store.load();
            }
        }
        this._data = data;

        if (this.defaultStoreOption) {
            this.domElements.select.value = this._getIndexByHiddenValue(this.defaultStoreOption.value);
        }

        var itemHtml = this.domElements.itemHtml;

        if (this.extraBodyStyle != null)
            itemHtml.set('style', itemHtml.get('style') + ';' + this.extraBodyStyle);

        if (!this.disabled) {
            itemHtml.addClass('x-cursor-pointer');
        }

        if (this.disabled) itemHtml.addClass('x-form-combo-disabled');

        var wrap = new Element('div', {
            'id': this.id + '-wrap',
            'class': 'x-form-combo-wrap'
        });

        wrap.inject(itemHtml);

        this.domElements.select.inject(wrap);
        this.domElements.knob.inject(wrap);
        this.domElements.value.inject(wrap);

        this.buildFixed();

        // extra class if need
        var extraClass = typeof this.extraClass == 'string' ? " " + this.extraClass : "";

        var sCanvas = this.renderFieldLabel();
        sCanvas.addClass('x-form-item-combobox');

        if (!RC.isEmpty(extraClass))
            sCanvas.addClass(extraClass);

        if (!RC.isEmpty(this.extraStyle)) {
            sCanvas.set('style', sCanvas.get('style') + ';' + this.extraStyle);
        }

        itemHtml.inject(sCanvas);

        if (!RC.isTrue(this.visible) && this.visible !== undefined) {
            // todo use Eelment.show()/.hide()
            sCanvas.setStyle('display', 'none');
        }

        // fire RENDER event
        if (self.hasListener('render')) {
            sCanvas.addEvent('domready', function(e) {
                self.fireListener('render');
            });
        }

        return sCanvas;
    }
});

RC.extend(RC.form.ComboboxGroup, RC.form.Field, {
    render: function() {
        var itemHtml = new Element('div', {
            'id': this.id + '-items',
            'class': 'x-form-combo-items'
        });
        var self = this;
        this.items.each(function(rec) {
            var store = rec.store;
            for (var q = 0; q < store.length; q++) {
                if (rec.value == store[q][0]) {
                    store[q].push('selected');
                    break;
                }
            }

            rec.zIndex = RC.idSeed;
            rec.store = store;
            RC.getCmp(self.formId).addItem(rec instanceof RC.form.Combobox ? rec : new RC.form.Combobox(rec)).inject(itemHtml);
        });
        var sCanvas = this.renderFieldLabel();
        sCanvas.addClass('x-form-combogroup');
        itemHtml.inject(sCanvas);
        return sCanvas;
    }
});

RC.reg('x-form-combo', RC.form.Combobox);
RC.reg('x-form-combobox', RC.form.Combobox);
RC.reg('x-form-combogroup', RC.form.ComboboxGroup);

/**
 * Provides a date input field with a date picker dropdown and automatic date validation. Usage example:
 * <pre><code>
 * {
 *   yearsRange : [1900, 2100], // years range for select field
 *   format     : 'mm/dd/yy', // OUTPUT format
 *   value      : 'mm/dd/yy', // default date formatted accordingly to RFC 1123 (25 Dec 2000 or Dec 25, 2000 or 12/25/2000) or date object
 * }
 * </code></pre>
 *
 * @class
 * @name RC.form.DatePicker
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-datepicker
 */
RC.form.DatePicker = function(params) {

    // Cast field as text
    params.xtype = 'textfield';
    params.width = params.width || 100;
    params.fieldWidth = params.width;

    this.showLabel = (params.showLabel != undefined) ? params.showLabel : true;

    this.date = new Date();

    this.disabledDaysCallback = RC.isFunc(params.disabledDaysCallback) ? params.disabledDaysCallback : null;

    this.format = params.format;

    if (!params.yearsRange) {
        var year = new Date().getFullYear();
        params.yearsRange = [year, year + 10];
    }

    this.yearsRange = params.yearsRange;
    this.initValue = !!params.value;
    this.isEmpty = true;
    this.isOriginalEmpty = true;

    if (params.value) {
        if (typeof params.value == 'object') {
            this.date = params.value;
        } else {
            this.date = new Date(params.value);
        }

        this.isEmpty = false;
    }

    this.isOriginalEmpty = this.isEmpty;

    this.originalDate = new Date(this.date.getTime());

    this.element = {
        window: null
    };
    this.rendered = {
        window: null,
        clear: null,
        field: null,
        label: null,
        canvas: null
    };

    RC.form.DatePicker.superclass.constructor.call(this, params);
};

RC.extend(RC.form.DatePicker, RC.form.Field, {
    _isDisabledDay: function(day) {
        var self = this;
        return RC.isFunc(self.disabledDaysCallback) && !!self.disabledDaysCallback(day);
    },
    /**
     * Creates window, assembles form controls and inserts them into window's content
     * @private
     */
    _createWindow: function() {
        var Lang = RC.Lang.Common;
        if (this.disabled) return false;

        var self = this;
        var formId = self.id + '-form';
        var calendarWrapId = 'calendar-wrap';

        function reRenderCalendar() {
            RC.getCmp(formId).findField(calendarWrapId)._renderedCanvas.empty().adopt(self._renderCalendar());
        }

        var yearsRange = [];
        for (var i = this.yearsRange[0]; i <= this.yearsRange[1]; i++) {
            yearsRange.push([i.toString(), i.toString()]);
        }


        // Render YEAR select
        var yearSelect = new RC.form.Paginator({
            formId  : self.formId,
            id      : 'paginator-year',
            store   : yearsRange,
            width   : '77px',
            listeners  : {
                selected:   function(r) {
                    //console.dir(r);
                    self.date.setFullYear(r.value);
                    self.date.setDate(1);
                    reRenderCalendar();
                }
            }
        });
        var store = RC.utils.Date.createMonthsStore();
        store[0].push('selected');
        // Render MONTH select
        var monthSelect = new RC.form.Paginator({
            formId  : self.formId,
            id      : 'paginator-month',
            store   : store,
            width   : '117px',
            listeners  : {
                selected:   function(r) {
                    //console.dir(r);
                    self.date.setMonth(r.value);
                    self.date.setDate(1);
                    reRenderCalendar();
                }
            }
        });

        this.element.window = new RC.Window({
            'id'        : this.id + '-window',
            'title'     : Lang.CALENDAR_PICKER_TITLE,
            'width'     : 340,
            'extraClass'  : 'x-calendar',
            'closable'  : true,
            items: [
                {
                    xtype: 'form',
                    id: formId,
                    items:[
                        {
                            xtype:'fieldgroup',
                            items:[
                                monthSelect,
                                yearSelect
                            ]
                        },
                        {
                            xtype:'div',
                            id: calendarWrapId
                        }
                    ]
                }
            ],
            buttons:  [
                {
                    xtype:'button',
                    value: Lang.CANCEL,
                    idSuffix: 'cancel',
                    handler : function() {
                        self.element.window.close();
                    }
                },
                {
                    xtype:'button',
                    value: Lang.TODAY,
                    disabled: self._isDisabledDay(new Date()),
                    handler : function() {
                        self.setDate(new Date());
                        self.element.window.close();
                    }
                }
            ],
            listeners: {
                show: function() {
                    reRenderCalendar();
                    // Set initial states
                    yearSelect.setValue(self.date.getFullYear());
                    monthSelect.setValue(self.date.getMonth());
                }
            }
        });

        this.element.window.show(false);
        this.element.window.center();
    },
    /**
     * Sets the field's value according to internal date object
     * @param {Date} date If specified, replaces with itself the internal date object
     */
    setDate: function(date) {
        if (date !== undefined) {
            this.date = date;
        }

        this.isEmpty = false;

        var value = this.getDate();

        this.setValue(value);
        this.originalDate = new Date(this.date.getTime());

        this.rendered.label.innerHTML = this.date.toDateString();
        this.rendered.clear.setStyle('display', 'block');

        this.fireListener('pick', this.date);
    },
    /**
     * Clears date in the field
     */
    clearValue: function() {
        this.isEmpty = true;

        this.setValue('');
        this.rendered.label.innerHTML = '';
        this.rendered.clear.setStyle('display', 'none');
    },
    /**
     * Returns formatted internal date object according to format specified in init
     * @return {String}
     */
    getDate: function() {
        if (this.isEmpty) {
            return null;
        }

       // var value = this.format.split('dd').join('j').split('mm').join('n').split('yy').join('Y'); // transform to PHP date query
        return RC.utils.Date.formatDate(this.date, this.format);
    },
    /**
     * @return {Date}
     */
    getDateObject: function() {
        if (this.isEmpty) return null;
        return this.date;
    },
    /**
     * @return {int}
     */
    getTime: function() {
        if (this.isEmpty) return null;
        return this.date.getTime();
    },
    /**
     * @return {int}
     */
    getValue: function() {
        return this.getTime();
    },
    /**
     * Disables element by flag
     * @param {Boolean} flag
     */
    disable: function(flag) {
        this.disabled = !!flag;
        var input = this.rendered.field.getElement('input');
        if (this.disabled) {
            this.rendered.canvas.addClass('x-form-datepicker-disabled');
            input.setAttribute('disabled', 'disabled');
        } else {
            this.rendered.canvas.removeClass('x-form-datepicker-disabled');
            input.removeAttribute('disabled');
        }
    },
    /**
     * Returns number of weeks since the beginning of a year specified
     * @param {Date} date
     * @private
     */
    _getWeekNumber: function(date) {
        var sunday = new Date(date.getTime());
        sunday.setDate(sunday.getDate() - sunday.getDay());

        var msecPerWeek = 1000 * 60 * 60 * 24 * 7;

        var first = new Date(date.getTime());
        first.setFullYear(date.getFullYear(), 0, 1);
        first.setDate(first.getDate() - first.getDay());

        return Math.floor(((sunday.getTime() - first.getTime()) / msecPerWeek)) + 1;
    },
    /**
     * Renders calendar itself and returns the DOM Element
     * @return {Element}
     * @private
     */
    _renderCalendar: function() {
        var self = this;

        var html = [];
        //html.push('<table class="x-form-datepicker-calendar">');
        //html.push('<div>Current date: ' + this.date.toLocaleDateString() + '</div>'); // For debug purposes

        // Cycle through weekdays
        html.push('<thead><tr><th>&nbsp;</th>');
        var Lang = RC.Lang.Common;
        var currentUserLanguage = RC.utils.Lang.getLocaleFromCookie();
        var date = RC.utils.Date.moment();
        for (var i = 0; i < 7; i++) {
            date.lang(RC.Config.regionalFormat.langCode);
            date = date.weekday(i);
            date.lang(currentUserLanguage);
            html.push('<th>' + date.format("dd") + '</th>');
        }
        html.push('</tr></thead>');

        html.push('<tbody><tr>');

        var current = RC.utils.Date.moment(this.date.getTime()).startOf('month');
        // First indent
        html.push('<th>' + current.week() + '</th>');
        //Detect the first weekday for regionalFormat locale but display strings according user language.
        current.lang(RC.Config.regionalFormat.langCode);
        var indent = current.weekday();
        current.lang(currentUserLanguage);
        for (i = 0; i < indent; i++) {
            html.push('<td>&nbsp;</td>');
        }


        do {
            var cYear = current.year();
            var cMonth = current.month();
            var cDate = current.date();

            var isSaturday = current.day() == 6;
            var cls = (current.day() == 0 || isSaturday) ? 'x-form-datepicker-calendar-holiday' : '';

            if (
                cYear == self.originalDate.getFullYear() &&
                    cMonth == self.originalDate.getMonth() &&
                    cDate == self.originalDate.getDate()
                ) {
                cls += ' x-form-datepicker-calendar-current';
            }
            if (self._isDisabledDay(current)) {
                cls += ' x-form-datepicker-calendar-disabledDays';
            }
            html.push('<td class="' + cls + '"><a href="#">' + cDate + '</a></td>');

            //Switch to locale from RegionalFormatting, then process weekday and then return to user language locale.
            current.lang(RC.Config.regionalFormat.langCode);
            if (current.weekday() == 6) {
                html.push('</tr><tr>');
            }
            current.add(1, "day");
            if (current.weekday() == 0) {
                html.push('<th>' + current.week() + '</th>');
            }
            current.lang(currentUserLanguage);

        } while (cMonth == current.month());

        html.push('</tr></tbody>');
        //html.push('</table>');

        var table = new Element('table', {
            html: html.join('')
        }).addClass('x-form-datepicker-calendar');

        table.getElements('tbody td a').addEvent('click', function(e, win) {

            var day = parseInt(this.innerHTML);
            var selectedDate = new Date(self.date.getTime());
            if (day) {
                selectedDate.setDate(day);
                if (self._isDisabledDay(selectedDate)) {
                    return false;
                }
                self.setDate(selectedDate);
                self.element.window.close();
            }

            return false;
        });

        return table;
    },
    /**
     * Renders calendar field
     * @return {Element}
     */
    render: function() {

        var self = this;

        self.value = self.getDate();
        self.rendered.field = RC.form.DatePicker.superclass.render.call(this);

        var label = new Element('div', {
            'id'    : this.id + '-label',
            'class' : 'x-form-datepicker-label'
        });

        if (!this.showLabel) label.setStyle('display', 'none');

        var icon = new Element('div', {
            'id': this.id + '-calendar',
            'class':    'x-form-datepicker-icon'
        });

        var clear = new Element('div', {
            'id': this.id + '-calendar',
            'class': 'x-form-datepicker-wrap'
        }).addEvent('click', function() {
                if (!self.disabled) self.clearValue();
            });

        self.rendered.label = label;
        self.rendered.clear = clear;

        var origRenderedElement = this.rendered.field.getElement('.x-form-textfield');
        origRenderedElement.dispose();

        var field = new Element('div', {
            'id': this.id + '-wrap',
            'class': 'x-form-datepicker-wrap'
        }).inject(this.rendered.field);

        field.adopt(origRenderedElement, icon, label, clear);

        var canvas = this.rendered.field;
        canvas.addClass('x-form-datepicker');

        self.rendered.canvas = canvas;

        // Prevent direct user input
        self.rendered.field.getElement('input').addEvent('focus', function() {
            this.blur();
        });

        $$(self.rendered.field, label, icon).addEvent('click', function(event, win) {
            event.stop();
            self._createWindow();
        });

        setTimeout(function() { // TODO Replace with true FormPanel onRender event or similar
            self.isEmpty = self.isOriginalEmpty; //TODO Remove possible merge conflict

            self.setDate();
            self.isEmpty = self.isOriginalEmpty;
            if (!self.initValue) self.clearValue();

        }, 50);

        this.disable(this.disabled);

        return canvas;

    }
});

RC.reg('x-form-datepicker', RC.form.DatePicker);

/*
*
* Example
*
*       try {
            RC.ComponentMgr.load('contacts.group.form', function() {

                var fieldsToFetch = ["homePhone", "homePhone2", "businessPhone", "businessPhone2", "mobilePhone",
                                "companyPhone", "assistantPhone", "carPhone", "otherPhone", "callbackPhone"];

                var storeObj = (new RC.Contacts.Group.Store(fieldsToFetch)).getStore();
                storeObj.addListener('beforeload', function(records) {
                    records.each(function(r, i, records) {
                        var c = 0;
                        fieldsToFetch.each(function(f) {
                            if (r[f]) c++;
                        });
                        if (c == 0) delete records[i];
                    });
                    records.clean();

                });
                storeObj.load();

                var contactPicker = null;

                var winWizard = new RC.Window({
                    title : 'Rule wizard',
                    id : 'ruleWizard',
                    closable : true,
                    width: 850,
                    items : [
                        {
                            xtype : 'form',
                            items : [
                                new RC.Div({html : "90"}),
                                contactPicker = new RC.form.ContactPicker({
                                    name : 'contactPicker',
                                    store : storeObj
                                }),
                                new RC.Div({html : "91"})
                            ]
                        }

                    ],
                    buttons : [
                        {
                            text : 'getValues()',
                            handler : function(){
                                RC.Console.dir(contactPicker.getValues());
                            }

                        }
                    ]
                });

                winWizard.show();

            });
        }
        catch(e) {
            RC.Console.warn(e)
        }
        return;
*
* */

RC.form.ContactPicker = function(params) {

    // Cast field as text
    params.xtype = 'textfield';
    params.width = params.width || 100;
    params.fieldWidth = params.fieldWidth || params.width;

    this.scrollingConfig = params.scrollingConfig || {
        vertical: {
            height: 175,
            width : 260,
            shift: 14
        }
    };

    this.clearable = params.clearable || false;
    this.dontFormatEscapeDelimeters = params.dontFormatEscapeDelimeters || false;
    this.storable  = RC.isTrue(params.storable) || false;
    this.delimeter = params.delimeter || ";";
    this.dropDownFormatter = params.dropDownFormatter || function() {};
    this.dropDownItemSelectedCallback = params.dropDownItemSelectedCallback || function() {};
    this.valueVormatter = params.valueFormatter || function() {};

    this.optionsImages = [
        [
            [RC.getSkinnedRCLibXImageUrl('img/panel/help-corner-top-left.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_hi_mid.png')],
            // nofound
            [RC.getSkinnedRCLibXImageUrl('img/panel/help-corner-top-right.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/help-corner-top-right.gif')]

        ],
        [
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_top_left.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_top_mid.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_top_right.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_top_right.gif')]

        ],
        [
            [RC.getSkinnedRCLibXImageUrl('img/panel/help-corner-bottom-left.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/combo/lst_bot_mid.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/help-corner-bottom-right.gif')],
            [RC.getSkinnedRCLibXImageUrl('img/panel/help-corner-bottom-right.gif')]
        ]
    ];

    RC.form.ContactPicker.superclass.constructor.call(this, params);

    this.addEvents("onEnterPressed");
    
    var Lang = RC.Lang.Common;

    this.metadata = {
        homePhone : Lang.HOME_PHONE,
        email : Lang.EMAIL,
        email2 : Lang.EMAIL,
        email3 : Lang.EMAIL,
        homePhone2 : Lang.HOME_PHONE_2,
        businessPhone : Lang.BUSINESS_PHONE,
        businessPhone2 : Lang.BUSINESS_PHONE_2,
        mobilePhone : Lang.MOBILE_PHONE,
        companyPhone : Lang.COMPANY_PHONE,
        assistantPhone : Lang.ASSISTANT_PHONE,
        carPhone : Lang.CAR_PHONE,
        otherPhone : Lang.OTHER_PHONE,
        callbackPhone : Lang.CALLBACK_PHONE,
        businessFax : Lang.BUSINESS_FAX,
        otherFax    : Lang.OTHER_FAX
    };
    this.fieldsToFetch = params.fieldsToFetch || [ "homePhone",
        "email",
        "email2",
        "email3",
        "homePhone2",
        "businessPhone",
        "businessPhone2",
        "mobilePhone",
        "companyPhone",
        "assistantPhone",
        "carPhone",
        "otherPhone",
        "callbackPhone",
        "businessFax",
        "otherFax"];

    this.store = params.store;
    this.groupStore = params.groupStore;

    this.values = {
        name       : null,
        abEntryId  : null,
        firstName  : null,
        lastName   : null,
        phoneType  : null,
        phoneTitle : null,
        number     : null
    };

    this.input = null;
    this.scrolledArea = null;
    this.dropDownLayout = null;
    this.dropDownContentBox = null;
    this.scrollBox = null;
    this.dropDownDiv = null;
    this.slider = null;
    this.recordsNumber = 0;
    this.renderedItems = new Array();
    this.currentIndex = -1;
};

RC.extend(RC.form.ContactPicker, RC.form.Field, {
    render : function() {
        var canvas = new Element('div', {
            id    : this.id + '-wrapper',
            'class' : 'x-form-contactpicker',
            width : this.width
        })
                .adopt(RC.form.ContactPicker.superclass.render.call(this))
                .adopt(
                this.dropDownLayout = new Element('div', {
                    style : 'position: relative; display : none'
                }));

        var self = this;

        this.input = canvas.getElement('input[name=' + this.name + ']');
        this.input.autocomplete='off'; // special for Opera
        this.input.addEvent('keyup', function(e) {
            if (e.key == 'esc') {
                if(self.isVisibleDropDownLayout()) self.visibleDropDownLayout(false);
            } else if (['up', 'down','enter', this.delimeter].contains(e.key)) {
                if (!this.isVisibleDropDownLayout()) {
                    if (e.key == 'enter') this.fireListener("onEnterPressed");
                    if (this.delimeter == e.key) {
                        var currentValues = this.input.value.split(this.delimeter);
                        if(currentValues.length > 1) {
                            this.addValue({ number: currentValues[currentValues.length-2].trim() });
                        }
                    }
                    if (e.key == 'down') {
                        this.fillDropDownContentBox(this.store.getRecords(), this.groupStore ? this.groupStore.getRecords() : null, new RegExp("^(.*)", 'i'));
                        this.visibleDropDownLayout(true);
                    }
                } else if (this.renderedItems.length > 0) {
                    switch (e.key) {
                        case 'up':
                            if (this.currentIndex > 0) {
                                this.highlightItem(this.renderedItems[this.currentIndex - 1], true);
                                this.highlightItem(this.renderedItems[this.currentIndex], false);
                                if (this.renderedItems[this.currentIndex-1].getCoordinates().top <= this.dropDownContentBox.getCoordinates().top) {
                                    this.scrollDropDownArea(-1);
                                }
                                this.currentIndex = this.currentIndex - 1;
                            }
                            break;
                        case 'down':
                            if (this.currentIndex < this.renderedItems.length - 1) {
                                this.highlightItem(this.renderedItems[this.currentIndex + 1], true);
                                if (this.currentIndex > -1) {
                                    this.highlightItem(this.renderedItems[this.currentIndex], false);
                                }
                                if (this.renderedItems[this.currentIndex + 1].getCoordinates().bottom >= this.dropDownContentBox.getCoordinates().bottom){
                                    this.scrollDropDownArea(1);
                                }
                                if (this.currentIndex == -1) {
                                    this.slider.set(0);
                                }
                                this.currentIndex = this.currentIndex + 1;
                            }
                            break;
                        case 'enter':
                            if (this.currentIndex != -1) {
                                this.renderedItems[this.currentIndex].fireEvent('click');
                            }
                            break;
                    }
                }
            } else {
                var values = this.input.value.split(this.delimeter);
                var query = (values.length > 0 ? values[values.length-1].trim() : "");
                if (query != '*')
                    query = query.escapeRegExp();
                else
                    query = '.*';
                if (query)
                    query = this.fillDropDownContentBox(this.store.getRecords(), this.groupStore ? this.groupStore.getRecords() : null, new RegExp("^(" + query + ")", 'i'));
                this.visibleDropDownLayout(!!query);
            }
        }.bind(this));

        if (this.clearable) {
            var clear = new Element('div', {
                'id'    : this.id + '-clear',
                'class' : 'x-form-contactpicker-clear'
            }).addEvent('click', function() {
                self.clear();
            });
            canvas.adopt(clear);
            this.input.style.width = '240px';
        }

        this.renderDropDownArea().inject(new Element('div', {
            'class' : 'x-contactpicker-dropdown'
        }).inject(this.dropDownLayout));

        return canvas;
    },

    // shift - number of entries to be scrolled
    // -1 means one entry up
    //  1 means one entry down
    scrollDropDownArea : function(shift) {
        var steps = this.recordsNumber*34 - this.scrollingConfig.vertical.height; // 34 = height:24px + paddingTop:10px
        var scrollShift = (steps/34) < 2 ? steps : 34;
        this.slider.set(this.slider.step + shift * scrollShift);
    },

    // item - given item
    // flag - boolean value: true - highlight item
    //                       false - delete highlighting
    highlightItem : function(item, flag){
        if (flag) {
            item.addClass("highlight");
        } else {
            item.removeClass("highlight");
        }
    },

    renderDropDownArea : function() {
        var decorationTable = new Element('table', {
            id    : this.id + '-DropDownArea',
            'cellspacing': '0',
            'cellpadding': '0',
            'html': '<tbody></tbody>',
            'class' : 'x-contactpicker-dropdownarea'
        });
        new Element('tr').inject(decorationTable.getElement('tbody'))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor11',
                    'html': ''
                }))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor12',
                    'html'   : ''
                }))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor13'
                }))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor14',
                    'html': ''
                }));
        new Element('tr').inject(decorationTable.getElement('tbody'))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor21',
                    'html'   : ''
                }))
                .adopt(
                this.dropDownContentBox = new Element('td', {
                    'id': this.id + '-decor22',
                    'styles': {
                        'width': '100%'
                    }
                }))
                .adopt(
                this.scrollBox = new Element('td', {
                    'id': this.id + '-scroll-box',
                    'class': 'x-contactpicker-scrollbox',
                    'styles': {
                        'width': '20px'
                    }
                }))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor24',
                    'html'   : ''
                }));
        new Element('tr').inject(decorationTable.getElement('tbody'))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor31',
                    'html': ''
                }))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor32',
                    'html'   : ''
                }))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor33',
                    'html'   : ''
                }))
                .adopt(
                new Element('td', {
                    'id': this.id + '-decor34',
                    'html': ''
                }));
        return  decorationTable;
    },

    formatrDropDownItem : function(hash, re) {
        var format = function(str) {
            return  str.replace(re, "<b>$1</b>");
        };
        var preformat = this.dropDownFormatter(hash);
        if(RC.isEmpty(preformat)) {
            var name = (hash.firstName || hash.lastName) ? (format(hash.firstName || '') + (hash.lastName?' ':'') + format(hash.lastName || '')) : format(hash.name || '');
            return name + ', ' + hash.phoneTitle + ' ' + format(hash.number);
        }
        else
            return format(preformat);
    },

    renderDropDownItemsArea : function(recs, groupRecs, re) {
        var div = new Element('div', {
            id    : this.id + '-DropDownItemsArea',
            'styles' : {
                'position' : 'relative',
                'overflow-y' : 'hidden',
                'height' : this.scrollingConfig.vertical.height
            }
        });
        var innerDiv = new Element('div').inject(div);
        this.recordsNumber = 0;
        $each(recs, function(rec, i) {
            if(!rec) return;
            $each(this.fieldsToFetch, function(key) {
                var phone = rec[key];
                var fullName = getContactDisplayName(rec, "firstName");
                if (!RC.isEmpty(phone) && (rec.firstName.match(re) || rec.lastName.match(re) || phone.replace(/[^0-9]/g, '').match(re) || fullName.match(re))) {
                    var hash = {
                        name       : fullName,
                        abEntryId  : rec.contactId,
                        firstName  : rec.firstName,
                        lastName   : rec.lastName,
                        phoneType  : key,
                        phoneTitle : this.metadata[key],
                        number     : phone
                    };
                    hash.html = this.formatrDropDownItem(hash, re);
                    this.renderDropDownItem(hash, this.recordsNumber).inject(innerDiv);
                    this.recordsNumber++;
                }
            }.bind(this));
        }.bind(this))
        if (groupRecs){
            $each(groupRecs, function(rec, i) {
                    if(!rec) return;
                        var groupName = rec["groupName"];
                        if (!RC.isEmpty(groupName) && rec.groupName.match(re)) {
                            var hash = {
                                name       : groupName,
                                abEntryId  : rec.groupId,
                                isGroup: true
                            };
                            hash.html = this.formatrDropDownItem(hash, re);
                            this.renderDropDownItem(hash, this.recordsNumber).inject(div);
                            this.recordsNumber++;
                        }
                }.bind(this))
        }
        return div;
    },

    renderDropDownItem : function(hash, index) {
        var self = this;
        var div = new Element('div', {
            id    : this.id + '-DropDownItem-' + index,
            'class': 'x-contactpicker-dropdownitem',
            html :  hash.html,
            events : {
                mouseover : function() {
                    self.currentIndex = index;
                    self.renderedItems.each(function(item){
                        self.highlightItem(item, false);
                    });
                    self.highlightItem(div, true);
                },
                mouseout : function() {
                    self.currentIndex = -1;
                    self.highlightItem(div, false);
                },
                click : function() {
                    this.values = hash;
                    this.addValue(hash);
                    self.dropDownItemSelectedCallback(hash);
                    this.visibleDropDownLayout(false);
                }.bind(this)
            }

        });
        this.renderedItems.push(div);
        return div;
    },

    getValues : function() {
        var parts = this.input.value.split(',');
        var number = parts[0],
                name = (parts[1] || "").replace(/^( )+/, "");
        if (!this.values.number || number != this.values.number) {
            this.values = {
                number : number
            };
            if (name) this.values.name = name;
        } else {
            if (name)  this.values.name = name;
        }

        //var res = (this.values.number||"").replace(/[^0-9]/g, "").length? this.values : {};
        return this.values;
    },

    addValue : function(hash) {
        var format = function(_hash) {
            return _hash.number + (_hash.name ? ', ' + _hash.name : "");
        };
        // clean
        var preformat = this.valueVormatter(hash);
        if(RC.isEmpty(preformat)) preformat = format(hash);
        // remove all delimeters to save logic
        preformat = this.dontFormatEscapeDelimeters ? preformat : preformat.replace(new RegExp(this.delimeter, 'g'), '');
        preformat = preformat.trim();

        // store
        if(!this.storable) {
            this.setValue(preformat);
        } else {
            // store all
            function cleanArray(actual) {
                var newArray = new Array();
                for (var i = 0; i < actual.length; i++) {
                    if (actual[i]) {
                        newArray.push(actual[i]);
                    }
                }
                return newArray;
            }

            var previousValue = this.input.value;
            var previousValues = previousValue.split(this.delimeter);
            previousValues.each(function(stringItem){
                stringItem = stringItem.trim();
                if (preformat == stringItem) preformat = "";
            });
            if (!RC.isEmpty(preformat)) {
                if(previousValues.length > 0) previousValues[previousValues.length - 1] = preformat;
                previousValues = cleanArray(previousValues);
                this.setValue(previousValues.join(this.delimeter) + this.delimeter);
            }
        }
    },

    clear : function() {
        this.values = {};
        this.setValue('');
        this.visibleDropDownLayout(false);
    },

    fillDropDownContentBox : function(recs, groupRecs, re) {
        re = re || new RegExp("*");
        this.dropDownContentBox.innerHTML = '';
        this.renderedItems = [];
        this.dropDownDiv = this.renderDropDownItemsArea(recs, groupRecs, re);
        var self = this;

        /*
         RC.strFromURLEnc will exclude false-positive "true" on data with only tags, for example "<div></div>"
         */

        if (RC.strFromURLEnc(this.dropDownDiv.innerHTML)) {
            var steps;
            if (!$(this.id + '-scrollbar')) {
                var divScrollBar = new Element('div', {
                    id : this.id + '-scrollbar',
                    'class' : 'x-scrollbar',
                    styles : {
                        display : 'block'
                    }
                });
                var divArUp = new Element('div', {
                    id : this.id + '-arr-up',
                    'class' : 'x-scrollbar-up-arrow'
                });
                var divArDown = new Element('div', {
                    id : this.id + '-arr-down',
                    'class' : 'x-scrollbar-down-arrow'
                });
                var divSlider = new Element('div', {
                    id : this.id + '-slider',
                    'class' : 'x-scrollbar-slider',
                    styles : {
                        'height' : this.scrollingConfig.vertical.height - 50,
                        'padding-top': 20
                    }
                });
                var divKnob = new Element('div', {
                    id : this.id + '-knob',
                    styles : {
                        'position': 'relative',
                        'width': '14px',
                        'height': '29px',
                        'cursor': 'pointer',
                        'background': 'url(' + RC.getSkinnedRCLibXImageUrl('img/panel/combo/slider.gif') + ')'
                    },
                    html: '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/combo/slider.gif') + '">'
                });

                divKnob.inject(divSlider);
                divArUp.inject(divScrollBar);
                divSlider.inject(divScrollBar);
                divArDown.inject(divScrollBar);

                this.scrollBox.adopt(divScrollBar);

                this.slider = new Slider(divSlider, divKnob, {
                    steps: steps,
                    mode: 'vertical',
                    initialStep : 0,
                    onChange: function(step) {
                        self.dropDownDiv.scrollTo(0, step);
                    }
                });

                divArDown.set({
                    events: {
                        click : function() {
                            this.scrollDropDownArea(1);
                        }.bind(this)
                    }
                });
                divArUp.set({
                    events: {
                        click : function() {
                            this.scrollDropDownArea(-1);
                        }.bind(this)
                    }
                });
            }

            $$(self.dropDownDiv, self.slider).addEvent('mousewheel', function(e) {
                e = new Event(e).stop();
                var scrollShift = (steps / 34) < 2 ? steps : 34;
                var step = self.slider.step - e.wheel * scrollShift;
                self.slider.set(step);
            });
            $(document.body).addEvent('mouseleave', function() {
                self.slider.drag.stop()
            });

            this.dropDownContentBox.adopt(this.dropDownDiv);

            this.visibleDropDownLayout(true);
            var scrollHeight = this.dropDownDiv.getScrollHeight();
            steps = scrollHeight - this.scrollingConfig.vertical.height;

            if (steps >  0) {
                $(this.id + '-scrollbar').setStyle('display', 'none');
                $(this.id + '-scrollbar').setStyle('display', 'block');
                self.slider.setRange([0, steps]);
            } else {
                $(this.id + '-scrollbar').setStyle('display', 'block');
                $(this.id + '-scrollbar').setStyle('display', 'none');
            }
            if (Browser.name === "ie") {
                $$('td[id*=-decor]').each(function(item) {
                    item.setStyle('display', 'none');
                    item.setStyle('display', 'block');
                });
            }
            self.slider.set(0);
        }
        else
            return false;

        return true;
    },

    visibleDropDownLayout : function(flg) {
        this.dropDownLayout.style.display = !!flg ? 'block' : 'none';
    },

    isVisibleDropDownLayout : function() {
        return this.dropDownLayout.style.display != 'none';
    }
});


RC.reg('x-form-contactpicker', RC.form.ContactPicker);

/*
        Example:

        var picker = new RC.form.TimePicker({
            value :  36900, // 10:15 am (by default 9.00 am)
            width : 200
        });

        var win = new RC.Window({
            title : 'Title',
            width : 300,
            items : [
                new RC.form.FormPanel({
                    items : [
                        picker
                    ]
                })
            ],
            buttons :  [
                {
                    text : "Click Me",
                    handler : function() {
                        RC.Console.dir(picker.getTime());
                        alert("Call RC.form.TimePicker::setTime ....")
                        picker.setTime(64000);
                    }
                }
            ]
        })

        win.show();

        return;

 */

RC.form.TimePicker = function(params) {
    params = params || {};

    // Cast field as text
    params.xtype = 'combogroup';
    params.width = params.width || 100;
    params.fieldWidth = params.width;
    this.isUSATimeFormat = RC.utils.Date.isUsaTimeFormat();

    this.showLabel = (params.showLabel != undefined) ? params.showLabel : true;
    //time in sec . by default 9.00 am
    this.value = params.value || 32600;

    var hoursArray = [];
    if (this.isUSATimeFormat) {
        for (var k = 0; k < 12; k++)  hoursArray[hoursArray.length] = [k, !k? '12' : k.toString() ];
    } else {
        for (k = 0; k < 24; k++)  hoursArray[hoursArray.length] = [k, k.toString() ];
    }

    this._hoursCombo = null;
    this._minutesCombo = null;
    this._amPmCombo = null;

    params.items = [
        this._hoursCombo = new RC.form.Combobox({
            name         : 'hours',
            visibleValue : 'view',
            hiddenValue  : 'hidden',
            width        : 75,
            store   : hoursArray
        }),
        this._minutesCombo = new RC.form.Combobox({
            name    : 'minutes',
            visibleValue : 'view',
            hiddenValue  : 'hidden',
            width   : 75,
            store   : [
                [0,  '00'],
                [15, '15'],
                [30,  '30'],
                [45,  '45']
            ]
        }),
        this._amPmCombo = new RC.form.Combobox({
            name    : 'AMPM',
            visibleValue : 'view',
            visible : this.isUSATimeFormat,
            hiddenValue  : 'hidden',
            width   : 60,
            store   : [
                ['am', RC.Lang.Common.AM],
                ['pm',  RC.Lang.Common.PM]
            ]
        })
    ];


    RC.form.TimePicker.superclass.constructor.call(this, params);

};

RC.extend(RC.form.TimePicker, RC.form.ComboboxGroup, {

    // num in seconds
    setTime : function(/*@type integer*/ num) {
        //todo check num
        var hours = Math.floor(num / 3600);
        var minutes = Math.floor((num % 3600) / 60);

        if (this.isUSATimeFormat) {
            this._hoursCombo.setValue(hours >= 12 ? hours - 12 : hours);
            this._minutesCombo.setValue(Math.floor(minutes / 15) * 15);
            this._amPmCombo.setValue(hours >= 12 ? 'pm' : 'am');
        } else {
            this._hoursCombo.setValue(hours);
            this._minutesCombo.setValue(Math.floor(minutes / 15) * 15);
        }

         //RC.Console.log(num + ' - ' + hours + ' : ' + minutes + ' ' + (hours > 12 ? hours - 12 : hours) + ' : ' + (Math.floor(minutes / 15) * 15) + ' ' + (hours > 12 ? 'pm' : 'am'));
    },

    getTime : function() {
        var hours = this._hoursCombo.getValue();
        var minutes = this._minutesCombo.getValue();
        var amPm = this._amPmCombo.getValue();
        var hours24 = amPm == 'pm' ? hours + 12 : hours;

        return {
            hours   : hours,
            hours24 : this.isUSATimeFormat ? hours24 : hours,
            minutes : minutes,
            amPm    : amPm,
            // in seconds
            inSeconds : hours24 * 3600 + minutes * 60
        }
    },

    render : function() {
        var sCanvas = RC.form.TimePicker.superclass.render.call(this);
        sCanvas.addEvent('domready', function(e) {
            this.setTime(this.value);
        }.bind(this));
        return sCanvas;
    }
});

RC.reg('x-form-timepicker', RC.form.TimePicker);




/**
 * Standard container used for grouping items within a form.
 *
 * @class
 * @name RC.form.Fieldset
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-fieldset
 */
RC.form.Fieldset = function(params) {
    //this.xtype = 'fieldset';
    this.legend = (params.legend) ? params.legend : '';
    this.legendCollapsed = (params.legendCollapsed) ? params.legendCollapsed : params.legend;
    this.collapsable = (params.collapsable) ? params.collapsable : false;
    this.collapsed = (params.collapsed) ? params.collapsed : false;
    this.container = (params.container) ? params.container : false;
    this.backgroundFix = (params.backgroundFix) ? params.backgroundFix : false;
    this.itemsNamed = (params.itemsNamed) ? params.itemsNamed : null;
    this.showHideMore = params.moreText || params.hideText;
    this.moreText = (params.moreText) ? params.moreText : 'More';
    this.hideText = (params.hideText) ? params.hideText : 'Hide';
    this.linesOnly = !!params.linesOnly;

    if (!this.collapsable) this.collapsed = false;
    RC.form.Fieldset.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Fieldset, RC.form.Field, {
    render : function() {

        var self = this;
        var form = RC.getCmp(this.formId);

        var canvas = new Element('div', {
            'id'    : this.id,
            'class' : (this.container ? 'x-form-container' : 'x-form-fieldset') + (this.showHideMore ? ' x-form-fieldset-showMoreHide' : '') + (this.linesOnly ? ' x-form-fieldset-linesOnly' : ''),
            'html'  : this.container ? this.html : ''
        });

        var content;

        if (!this.container) {

            if (this.legend) {

                canvas.adopt(
                        function() {

                            var div = new Element('div', {
                                'class' : 'x-form-fieldset-legend'
                            });

                            if (self.collapsable) {

                                div.adopt(new Element('a', {
                                    href: '#',
                                    html: self.legend
                                }));

                            } else {

                                div.set('html', self.legend);

                            }

                            return div;

                        }()
                        );

            }

            canvas.adopt(
                    new Element('div', {
                        'class' : 'x-form-fieldset-content',
                        'html'  : this.html
                    }),
                    new Element('div', { // fix form labels
                        'class': 'clearfix'
                    }));

            content = canvas.getElement('.x-form-fieldset-content');
            var legendLink = canvas.getElement('.x-form-fieldset-legend a');

            if (this.collapsable) {

                canvas.addClass('x-form-fieldset-collapsable');
               
                canvas.adopt(
	                        new Element('a', {'class' : 'x-form-fieldset-control x-form-fieldset-control-show', 'html' : '<span>'+this.moreText+'</span>', 'href' : '#'}),
	                        new Element('a', {'class' : 'x-form-fieldset-control x-form-fieldset-control-hide', 'html' : '<span>'+this.hideText+'</span>', 'href' : '#'})
                        );
             
                

                var showLink = canvas.getElement('.x-form-fieldset-control-show');
                var hideLink = canvas.getElement('.x-form-fieldset-control-hide');

                $$(showLink, hideLink, legendLink).addEvent('click', function(e) {

                    e.stop();
                    this.blur();
                    self.setCollapsed(!self.getCollapsed());
                    return false;

                });

            }

        } else {

            content = canvas;

        }

        // Items generation
        if (this.items !== undefined) {

            // If template provided
            if (this.html) {

                var placeholders = content.getElements('div.item_placeholder');
                for (var q = 0; q < this.items.length; q++) {
                    if (this.items[q] && placeholders[q]) {
                        var o = form.addItem(this.items[q]);
                        placeholders[q].getParent().adopt(o, 'after', placeholders[q]);
                        placeholders[q].destroy();
                    }
                }

            } else {

                if (this.items.length > 0) {
                    this.items.each(function(item) {
                        content.adopt(form.addItem(item));
                    });
                }

            }

        }

        /**
         * Named items generation
         * Basic usage  add "html" property to the field with code like this
         * <div class='item_named_placeholder'> %someItemId% </div>  % are essential, spaces will be trimmed
         * and "itemsNamed" property with "someItemId" property defined with an RC object
         */
        if (this.itemsNamed && this.html) {

            content.getElements('div.item_named_placeholder').each(function(placeholder){

                var itemId = placeholder.innerHTML.trim();
                itemId = itemId.substr(1, itemId.length - 2); // reduce %'s

                if (itemId in self.itemsNamed) {

                    var o = form.addItem(self.itemsNamed[itemId]);
                    var render = RC.isMooElement(self.itemsNamed[itemId]) ? self.itemsNamed[itemId] : o;
                    placeholder.getParent().adopt(render, 'after', placeholder);
                    placeholder.destroy();

                } else {

                    placeholder.setStyles({color: 'red'}).innerHTML = 'Placeholder item [' + itemId + '] not found'; // in itemsNamed property

                }

            });

        }

        // Public methods

        this.setVisible = function(isVisible) {

            canvas.setStyle('display', !!isVisible ? 'block' : 'none');

        };

        this.setCollapsed = function(isCollasped) {

            if (this.collapsable) {

                canvas[isCollasped ? 'addClass' : 'removeClass']('x-form-fieldset-collapsed');
                if (legendLink) legendLink.set('html', isCollasped ? self.legendCollapsed : self.legend);
                self.fireListener('collapsed', isCollasped);

            }

        };

        this.getCollapsed = function() {

            return canvas.hasClass('x-form-fieldset-collapsed');

        };

        // Dealing with properties

        if (RC.isTrue(this.collapsable) && RC.isTrue(this.collapsed)) this.setCollapsed(true);

        if (!RC.isEmpty(this.extraClass))
            canvas.addClass(this.extraClass);

        if (!RC.isEmpty(this.extraStyle)) {
            canvas.set('style', canvas.get('style') + ';' + this.extraStyle);
        }

        if (!RC.isEmpty(this.extraStyles)) {
            canvas.setStyles(this.extraStyles);
        }

        if (!RC.isTrue(this.visible) && this.visible !== undefined) {
            this.setVisible(false);
        }

        if (this.backgroundFix !== false) {
            canvas.getElements('div.x-form-fieldset-legend, a.x-form-fieldset-control span').setStyle('background-color', this.backgroundFix);
        }

        this.fireListener('render', canvas);

        return canvas;

    }

});

RC.reg('x-form-fieldset', RC.form.Fieldset);

/**
 * Standard container used for grouping items within a form.
 *
 * @class
 * @name RC.form.Fieldgroup
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-fieldgroup
 */
RC.form.Fieldgroup = function(params) {
    this.addSpaces = RC.isDefined(params.addSpaces) ? RC.isTrue(params.addSpaces) : true; // add spaces by default
    RC.form.Fieldgroup.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Fieldgroup, RC.form.Field, {
    render: function() {

        var self = this;
        var form = RC.getCmp(this.formId);

        var canvas = new Element('div', {
            'id': this.id,
            'class': 'x-form-fieldgroup' +
                     (this.addSpaces ? ' x-form-fieldgroup-addSpaces' : '')
        });

        var rightCanvas = new Element('div', {
            'id': this.id + '-rightCanvas',
            'class': 'x-form-fieldgroup-rightCanvas'
        }).inject(canvas);

        var useRightCanvas = false;

        if (this.items !== undefined && this.items.length > 0) {

            this.items.each(function(item, index) {
                switch (item) {

                    // begin using the right-justified button container
                    case ' ':
                    case '->':
                        useRightCanvas = true;
                        break;

                    // add a vertical separator bar between items
                    case '-':
                    case '|':
                        //TODO Implement separators
                        break;

                    // add horizontal space between elements
                    case '':
                        canvas.adopt(new Element('div', {
                            'class': 'x-form-fieldgroup-space'
                        }));
                        break;

                    // add item
                    default:
                        new Element('div', {
                            'class': 'x-form-fieldgroup-item' + (index == 0 || item.isFirst ? ' x-form-fieldgroup-item-first' : '')
                        }).adopt(form.addItem(item)).inject(useRightCanvas ? rightCanvas : canvas);
                        break;

                }

            });

        }

        this.setVisible = function(isVisible) {
            canvas.setStyle('display', !!isVisible ? 'block' : 'none');
        };

        if (!RC.isEmpty(this.extraClass))
            canvas.addClass(this.extraClass);

        if (!RC.isEmpty(this.extraStyle)) {
            canvas.set('style', canvas.get('style') + ';' + this.extraStyle);
        }

        if (!RC.isEmpty(this.extraStyles)) {
            canvas.setStyles(this.extraStyles);
        }

        if (!RC.isTrue(this.visible) && this.visible !== undefined) {
            this.setVisible(false);
        }

        this.fireListener('render', canvas);

        return canvas;

    }

});

RC.reg('x-form-fieldgroup', RC.form.Fieldgroup);

/**
 * @class
 * @name RC.form.FileUpload
 * @extends RC.form.Field
 * @constructor
 * @param {Object} container 
 * @param {Object} options The config object
 */
RC.form.FileUpload = function(container, options)
{
    var self = this;

    this.field = container.getElement('input[type=file]');
    this.submit = container.getElement('input[type=submit]');

    if (!this.field) throw 'Field not found';
    if (!this.submit) throw 'Submit not found';

    this.id = (this.field.id) ? this.field.id : this.field.name;

    this.wrapper = new Element('div', {
        'id'    : this.id + '-wrap',
        'class' : 'x-form-fileupload-wrap'
    });

    if (Browser.name === "safari" || Browser.name === "chrome") this.wrapper.addClass('x-form-fileupload-webkit');

    this.wrapper.wraps(this.field);

    this.field.addClass('x-form-fileupload-field');
    this.field.addClass('x-form-fileupload-field-file');
    this.submit.addClass('x-form-fileupload-field');

    this.browse = new RC.form.Button({
        'id'            : this.id + '-browse',
        'width'         : 70,
        'value'         : RC.Lang.Common.BROWSE
    }).render().addClass('x-form-fileupload-button');

    var textWidth = Browser.name === "ie" ? 110 : 120;

    this.text = new RC.form.Field({
        'xtype'         : 'textfield',
        'width'         : textWidth,
        'fieldWidth'    : textWidth,
        'id'            : this.id + '-text'
    }).render().addClass('x-form-fileupload-text');

    this.browse.getElement('table td:nth-child(2)').setStyle('padding', '0 8px');
    this.text.getElement('input').addEvent('focus', function()
    {

        this.blur();

    });

    this.wrapper.adopt(this.browse, this.text);

    this.field.addEvent('change', function()
    {

        self.text.getElement('input').value = this.value;

    });

    // submit

    this.submitWrapper = new Element('div', {
        'id'    : this.id + '-wrap',
        'class' : 'x-form-fileupload-wrap-submit'
    });

    this.submitWrapper.wraps(this.submit);
    this.submitButton = new RC.form.Button({
        'id'            : this.id + '-submit',
        'width'         : 70,
        'value'         : RC.Lang.Common.ATTACH
    }).render().addClass('x-form-fileupload-button').addClass('x-form-fileupload-button-submit');
    this.submitWrapper.adopt(this.submitButton);
    this.submitButton.getElement('table td:nth-child(2)').setStyle('padding', '0 4px');


};


/**
 * Basic Label field.
 *
 * @class
 * @name RC.form.Label
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-label
 */
RC.form.Label = function(params)
{
    this.fieldLabelSeparator = RC.isDefined(params.fieldLabelSeparator) ? params.fieldLabelSeparator : RC.Lang.Common.COLON_SIGN;
    RC.form.Label.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Label, RC.form.Field, {
    render : function()
    {
        var sCanvas = this.renderFieldLabel();

        sCanvas.addClass('x-form-label-standAlone');

        if (this.isError) sCanvas.addClass('x-form-label-error');

        if (this.img) new Element('div', {
            'class': 'x-form-label-standAlone-image',
            'html': '<img src="' + this.img + '" alt="" />'
        }).inject(sCanvas, 'top');

        sCanvas.adopt(new Element('div', {
            'class': 'x-form-label-standAlone-value',
            'id': this.id + '-value',
            'html': this.value
        }));

        if (this.extraStyles) sCanvas.setStyles(this.extraStyles);

        if (this.html) sCanvas.set('html', this.html);

        if (this.items !== undefined) {
            var placeholders = sCanvas.getElements('div.label_placeholder');
            for (var q = 0; q < this.items.length; q++) {
                if (this.items[q]) {
                    var o = RC.getCmp(this.formId).addItem(this.items[q]);
                    placeholders[q].set('html', '');
                    o.inject(placeholders[q]);
                }
            }
        }

        return sCanvas;

    },

    setFieldLabel : function(text)
    {
        $(this.id).getElement('span').set('html', text + this.fieldLabelSeparator);
    },

    setValue    : function(value)
    {
        $(this.id + '-value').set('html', value);
    }
});

RC.reg('x-form-label', RC.form.Label);

/**
 * @class
 * @name RC.form.List
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-list
 */
RC.form.List = function(params)
{
    RC.form.List.superclass.constructor.call(this, params);
};

RC.extend(RC.form.List, RC.form.Field, {
    /**
     * Sets a data value into the field and validates it.
     * @param {*} value The value to set
     * @param {*} hiddenValue (optional) The hidden value to set
     */
    setValue: function(value, hiddenValue)
    {
        // todo change to virtual container (not getElementById)
        var htmlValue = new Element('div', {
            'html': value
        });

        if (!RC.getCmp(this.formId)) return;
        if (!RC.getCmp(this.formId).getContainer()) return;
        var el = RC.getCmp(this.formId).getContainer().getElement('div[id=' + this.id + ']');
        if (el == null) {
            return;
        }

        if (el.getElement('input') != null) {
            el.getElement('input').value = htmlValue.get('text');
            el.getElement('input').fireEvent('change');
        }

        el.getElement('div[id=' + this.id + '-value]').set('html', value);
        if (!RC.isEmpty(hiddenValue))
            el.getElement('input[id=' + this.id + '-value-hidden]').set('value', hiddenValue);

        this.fireListener('change');

    },
    /**
     * Sets value to collection by index
     * @param idx
     * @param value
     * @param hiddenValue
     */
    setAt: function(idx, value, hiddenValue)
    {
        var el = $(this.formId).getElement('table[id=' + this.id + ']');
        if (el == null) {
            return;
        }
        var tr;
        if (parseInt(idx).toString() == "NaN") {
            tr = el.getElement('tr[id=' + idx + '-row]');
        } else {
            tr = el.getElements('tr')[idx];
            idx = tr.id.replace('-row', '');
        }

        if (tr != null) {
            tr.getElement('div[id=' + idx + '-value]').set('html', value);
            tr.getElement('input[id=' + idx + '-value-hidden]').set('value', hiddenValue);
        }
    },
    /**
     * Gets value from collection by index
     * @param idx
     */
    getAt: function(idx)
    {
        var tr;
        if (parseInt(idx).toString() == "NaN") {
            tr = $(this.id).getElement('tr[id=' + idx + '-row]');
        } else {
            tr = $(this.id).getElements('tr')[idx];
            idx = tr.id.replace('-row', '');
        }

        if (tr != null) {
            return tr.getElement('input[id=' + idx + '-value-hidden]').get('value');
        }
        return null;
    },
    /**
     * Sets text to collection by index
     * @param idx
     * @param text
     */
    setTextAt: function(idx, text)
    {
        var el = $(this.formId).getElement('table[id=' + this.id + ']');
        if (el == null) {
            return;
        }
        var tr;
        if (parseInt(idx).toString() == "NaN") {
            tr = el.getElement('tr[id=' + idx + '-row]');
        } else {
            tr = el.getElements('tr')[idx];
            idx = tr.id.replace('-row', '');
        }

        if (tr != null) {
            tr.getElement('div[id=' + idx + '-text]').set('html', text);
        }
    },
    getLabel: function(idx)
    {
        var tr;
        if (parseInt(idx).toString() == "NaN") {
            tr = $(this.id).getElement('tr[id=' + idx + '-row]');
        } else {
            tr = $(this.id).getElements('tr')[idx];
            idx = tr.id.replace('-row', '');
        }

        if (tr != null) {
            return tr.getElement('div[id=' + idx + '-value]').get('text');
        }
        return null;
    },
    setVisible: function(state)
    {
        $(this.id).setStyle('display', state ? '' : 'none');
        $(this.id + '-fieldLabel').setStyle('display', state ? '' : 'none');
    },
    render: function()
    {
        var listItems = new Element('table', {
            id          : this.id,
            cellspacing : 0,
            cellpadding : 0,
            width       : this.width || 300,
            html        : '<tbody></tbody>',
            'class'     : 'x-form-list'
        });
        if (this.extraBodyStyle != null)
            listItems.set('style', listItems.get('style') + ';' + this.extraBodyStyle);

        if (this.extraClass != null)
            listItems.set('class', listItems.get('class') + ' ' + this.extraClass);

        var self = this;

        this.items.each(function(r)
        {
            var rId = RC.isEmpty(r.id) ? RC.genId() : r.id;
            new Element('td', {
                'id': rId,
                'class': self.id + '-item x-form-list-bg',
                'html': '<div style="">' +
                        (!RC.isEmpty(r.value) ? '<input type="hidden" id="' + rId + '-value-hidden" name="' + this.id + '" value="' + (RC.isEmpty(r.hiddenValue) ? '' : r.hiddenValue) + '" />' +
                                '<div id="' + rId + '-value" class="x-form-list-bg-value">' + r.value + '</div><div id="' + rId + '-text" class="x-form-list-bg-text">' : '') +
                        r.text + (!RC.isEmpty(r.value) ? '</div>' : '') + '</div>',
                'events': {
                    'click': function()
                    {
                        RC.GroupButton.deselectHelper(this);
                        if (this.hasClass('x-form-list-bg-top')) this.addClass('x-form-list-selected-top');
                        if (this.hasClass('x-form-list-bg-bottom')) this.addClass('x-form-list-selected-bottom');
                        this.addClass('x-form-list-selected');
                        if (typeof r.handler == 'function')
                            r.handler(RC.getCmp(self.formId)._dataStore);
                    }
                }
            }).inject(new Element('tr', {
                id: rId + '-row'
            }).inject(listItems.getElement('tbody')));
        });

        var tds = listItems.getElements('td');
        tds[0].addClass('x-form-list-bg-top');
        tds[tds.length - 1].addClass('x-form-list-bg-bottom');

        var sCanvas = this.renderFieldLabel();

        listItems.inject(sCanvas);

        if (this.visible !== undefined && !RC.isTrue(this.visible))
            sCanvas.setStyle('display', 'none');

        return sCanvas;
    },
    clearSelection: function ()
    {
        $$('td.x-form-list-selected').each(function(item)
        {
            item.removeClass('x-form-list-selected');
            item.removeClass('x-form-list-selected-top');
            item.removeClass('x-form-list-selected-bottom');
        });
    }
});

RC.reg('x-form-list', RC.form.List);

/**
 * Paginator form control. Usage example:
 * <pre><code>
 * {
 *    store   : [ // as for Combobox
 *      [2010, '2010'],
 *      [2011, '2011', 'selected'],
 *      [2012, '2012']
 *    ],
 *    valuePrev : 'Prev', // value for prev button
 *    valueNext : 'Next', // value for next button
 * }
 * </code></pre>
 *
 * @class
 * @name RC.form.Paginator
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-paginator
 */
RC.form.Paginator = function(params)
{
    this.valuePrev = params.valuePrev ? params.valuePrev : '';
    this.valueNext = params.valueNext ? params.valueNext : '';

    this.element = {
        prev: null,
        next: null
    };

    this.rendered = {
        prev: null,
        next: null,
        canvas: null
    };

    RC.form.Paginator.superclass.constructor.call(this, params);

    this.addListener('selected', function(){

        this._checkAvailability();

    }.bind(this));

};

RC.extend(RC.form.Paginator, RC.form.Combobox, {
    /**
     * Advance the list back and forward
     * @param by
     */
    _advance: function(by)
    {

        by = (by > 0) ? 1 : -1;

        this.setByIndex(this.selectedIndex + by);

        RC.Selection.clearSelection();

        var select;
        if ('getSelection' in window) {

            select = window.getSelection();
            select.removeAllRanges();

        } else {

            document.selection.clear();

        }

    },
    _checkAvailability: function()
    {

        this.element.prev.enable();
        //this.rendered.prev.removeClass('x-form-button-disabled');
        this.element.next.enable();
        //this.rendered.next.removeClass('x-form-button-disabled');

        var index = this.selectedIndex;
        if (index == 0) {

            this.element.prev.disable();
            //this.rendered.prev.addClass('x-form-button-disabled');

        }
        if (index >= this.getStorageAsArray().length - 1) {

            this.element.next.disable();
            //this.rendered.next.addClass('x-form-button-disabled');

        }

    },
    render : function()
    {

        var self = this;

        //DEBUG Earlier we had to decorate callback
        this.addListener('selected', function(r){
            self._checkAvailability(r);
        });

        var valueNextClass = (self.valueNext) ? '' : ' x-form-paginator-button-icon-alone';
        var valuePrevClass = (self.valuePrev) ? '' : ' x-form-paginator-button-icon-alone';

        self.element.prev = new RC.form.Button({
            formId  : self.formId,
            id      : this.id + '-prev',
            extraClass: 'x-form-paginator-button-prev',
            extraButtonStyles : self.extraPrevStyle,
            handler: function(dataStore)
            {
                self._advance(-1);
            },
            value   : '<span class="x-form-paginator-button-prev-icon' + valuePrevClass + '" /></span>' + this.valuePrev // Button can't set the position of the icon
        });

        self.element.next = new RC.form.Button({
            formId  : self.formId,
            id      : this.id + '-next',
            extraClass: 'x-form-paginator-button-next',
            extraButtonStyles : self.extraNextStyle,
            handler: function(dataStore)
            {
                self._advance(1);
            },
            value   : this.valueNext + '<span class="x-form-paginator-button-next-icon' + valueNextClass + '"></span>' // Button can't set the position of the icon
        });

        // Replace combo images
        self.comboImages = [
            [
                [RC.getSkinnedRCLibXImageUrl('img/panel/form/paginator/clp_left.gif')],
                [RC.getSkinnedRCLibXImageUrl('img/panel/form/paginator/clp_mid.gif')],
                [RC.getSkinnedRCLibXImageUrl('img/panel/form/paginator/clp_right.gif')],
                [RC.getSkinnedRCLibXImageUrl('img/panel/form/paginator/clp_right_g.gif')]
            ],
            [
                [RC.getSkinnedRCLibXImageUrl('img/panel/form/paginator/exp_left.gif')],
                [RC.getSkinnedRCLibXImageUrl('img/panel/form/paginator/exp_mid.gif')],
                [RC.getSkinnedRCLibXImageUrl('img/panel/form/paginator/exp_right.gif')]
            ]
        ];

        self.rendered.prev = self.element.prev.render();
        self.rendered.next = self.element.next.render();

        // Create table
        var itemHtml = new Element('table', {
            'class': 'x-form-paginator-table',
            'cellspacing': 0,
            'cellpadding': 0
        });


        var canvas = RC.form.Paginator.superclass.render.call(this);
        canvas.addClass('x-form-paginator');

        var origRenderedElement = canvas.getElement('.x-form-combo');
        origRenderedElement.dispose();

        // Add elements
        itemHtml.adopt(new Element('tbody').adopt(new Element('tr').adopt([
            new Element('td').adopt(self.rendered.prev),
            new Element('td').adopt(origRenderedElement),
            new Element('td').adopt(self.rendered.next)
        ])));

        canvas.adopt(itemHtml);

        self.rendered.canvas = canvas;

        self._checkAvailability();
        if (self.visible !== undefined) self.setVisible(self.visible);

        return canvas;
    },
    setVisible: function(isVisible){
        this.rendered.canvas.setStyle('display', !!isVisible ? '' : 'none');
    }
});

RC.reg('x-form-paginator', RC.form.Paginator);

/**
 * Single radio field. Same as Checkbox, but provided as a convenience for automatically setting the input type.
 * Radio grouping is handled automatically by the browser if you give each radio in a group the same name. *
 *
 * @class
 * @name RC.form.Radio
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-radio
 */
RC.form.Radio = function(params)
{
    this.visible = params.visible;
    RC.form.Radio.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Radio, RC.form.Field, {
    getInputElementSearchString: function(){

        return 'input[name=' + this.name + ']';

    },
    getValue: function(asObject) {

        var item = this.getInputElement();

        if (!item || !item.get('checked')) return false;

        return RC.isEmpty(item.value) ? true : (!!asObject ? item : true);

    },
    render : function()
    {
        var itemHtml = new Element('table', {
            'id'            : this.id,
            'cellspacing'   : 0,
            'cellpadding'   : 0,
            'html'          : '<tbody></tbody>',
            'class'         : 'x-radio-group-table-single'
        });

        itemHtml.addClass('x-cursor-pointer');

        var self = this;

        var inputId = self.formId + '-' + self.name;

        var fnHandler = function()
        {
            // set hidden field
            var input = self.getInputElement();
            input.checked = true;

            // set visual effect
            var img = this.getElement('img[class=x-radio-group-img]');
            if (img == null)
                img = this.getPrevious().getElement('img[class=x-radio-group-img]');
            if (img != null) {
                $(self.formId).getElements('img[class=x-radio-group-img]').each(function(its)
                {
                    if (its.getPrevious().id == inputId && its.src.indexOf('radio-') > -1)
                        its.src = RC.getSkinnedRCLibXImageUrl('img/panel/form/radio.png');
                });
                img.set('src', RC.getSkinnedRCLibXImageUrl('img/panel/form/radio' + (input.checked ? '-checked' : '') + '.png'));
            }

            // fire item events
            if (typeof self.handler == 'function')
                self.handler();

            // fire group events
            self.fireListener('change', input.value, self.formId);
        };

        new Element('tr').adopt(
                new Element('td', {
                    'class': 'x-radio-group-td x-radio-group-td-input',
                    'tabindex': this.tabindex,
                    'events' : {
                        'click' : fnHandler,
                        'keyup': function(e){
                            if (e.key == 'space') {
                                e.stop();
                                this.fireEvent('click', e);
                                return false;
                            }
                        }
                    }
                }).adopt(
                        new Element('input', {
                            'type': 'radio',
                            'id': inputId,
                            'name': self.name,
                            'value': self.value,
                            'checked': self.checked,
                            'styles': {
                                'display': 'none'
                            }
                        }),
                        new Element('img', {
                            'class': "x-radio-group-img",
                            'src': RC.getSkinnedRCLibXImageUrl('img/panel/form/radio' + (self.checked ? '-checked' : '') + '.png'),
                            'alt': ''
                        })
                    ),
                new Element('td', {
                    id      : this.id + '-label',
                    html    : this.boxLabel,
                    'class' : 'x-radio-group-td x-radio-group-td-label' + (RC.isEmpty(this.boxLabel) ? ' x-radio-group-td-label-empty' : ''),
                    events : {
                        'click' : fnHandler
                    }
                })).inject(itemHtml.getElement('tbody'));

        if (this.hasFieldLabel()) {

            var sCanvas = this.renderFieldLabel();
            itemHtml.inject(sCanvas);

            return sCanvas;

        }

        if (this.extraStyle !== undefined)
            itemHtml.set('style', itemHtml.get('style') + ';' + this.extraStyle);

        if (this.visible !== undefined && !RC.isTrue(this.visible))
            itemHtml.setStyle('display', 'none');

        return itemHtml;
    },
    //TODO Implement getValue
    setVisible: function(state)
    {
        var el = RC.getCmp(this.formId).getContainer().getElement('div[id=' + this.id + ']');
        if (el == null)
            el = RC.getCmp(this.formId).getContainer().getElement('table[id=' + this.id + ']');
        if (el != null)
            el.setStyle('display', state ? '' : 'none');
    }
});


/**
 * A grouping container for {@link RC.form.Radio} controls.
 *
 * @class
 * @name RC.form.RadioGroup
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-radiogroup
 */
RC.form.RadioGroup = function(params)
{
    /**
     * @property boolean Status of the component
     */
    this.disabled = false;
    /**
     * @property string Visiblity of the component
     */
    this.visible = (params.scrolling != null ? !!params.visible : true);
    this.scrolling = (params.scrolling ? params.scrolling : null);
    /**
     * @property boolean Determine of 100% cell's usage at the end of the row
     */
    this.cellFiller = (params.cellFiller ? params.cellFiller : true);
    this.fullWidth = RC.isDefined(params.fullWidth) ? RC.isTrue(params.fullWidth) : false;
    /**
     * Call parent constructor and pass parameters of configuration
     */
    RC.form.RadioGroup.superclass.constructor.call(this, params);
};

RC.extend(RC.form.RadioGroup, RC.form.Field, {
    getLabel : function()
    {
        var el = this.getFieldCanvas();
        if (el == null) {
            return;
        }
        var inputs = el.getElements('input[type=hidden]');
        var cValue = RC.getCmp(this.formId).getValue(this.name);
        for (var q = 0; q < inputs.length; q++) {
            if (inputs[q].value == cValue) {
                return inputs[q].getParent().getNext().get('html');
            }
        }
    },
    setVisible: function(state)
    {
        var el = this.getFieldCanvas();
        if (el == null) {
            return;
        }
        if (!RC.isEmpty(this.fieldLabel)) {
            var sel = RC.getCmp(this.formId).getContainer().getElementById(this.id);
            if (sel == null)
                sel = el.getParent();
            el = sel;
        }
        el.setStyle('display', state ? '' : 'none');
        if (this.scrolledArea != null) {
            this.scrolledArea.setStyle('display', state ? '' : 'none');
            this.scrolledArea.scrolls().vertical.show({fixedPosition:true});
        }
    },

    /**
     * Change value for element by old value
     * @param oldValue
     * @param newValue
     */
    changeValue: function(oldValue, newValue)
    {
        var el = this.getFieldCanvas();
        if (el == null) {
            return;
        }
        el.getElements('input[type=hidden]').each(function(input)
        {
            if (input.value == oldValue)
                input.value = newValue;
        });
    },

    /**
     * Sets check state by value
     * @param value
     */
    setValue: function(value)
    {
        var el = this.getFieldCanvas();
        if (el == null) {
            return;
        }
        el.getElements('input[type=hidden]').each(function(input)
        {
            if (input.value == value) { //TODO value.toString() - if nothing will be changed, input.value is always a string because it's taken from DOM element's property
                input.getParent().fireEvent('click');
            }
        });
    },

    //todo Is it correct method?
    /**
     * Get value
     * @return string
     */
    get: function()
    {
        var el = this.getFieldCanvas();
        if (el == null) return null;
        var inputs = el.getElements('input[type=hidden]');
        var form = RC.getCmp(this.formId);
        if (form == null) return null;
        var cValue = form.getValue(this.name);
        for (var q = 0; q < inputs.length; q++) {
            if (inputs[q].value == cValue) {
                return cValue;
            }
        }
        return null;
    },

    /**
     * Get values of all child elements
     * @return array Array of values
     */
    getValues: function()
    {
        var el = this.getFieldCanvas();
        if (el == null) {
            return null;
        }
        var inputs = el.getElements('input[type=hidden]');
        var values = new Array();
        for (var i = 0; i < inputs.length; i++) {
            values[i] = inputs[i].value;
        }
        return values;
    },
    
    getHiddenInputElement: function() {
        return RC.getCmp(this.formId).getContainer().getElement('input[id=' + this.formId + '-' + this.name + ']');
    },
    
    getFieldCanvas: function() {
        return RC.getCmp(this.formId).getContainer().getElement('table[id=' + this.id + '-field]');
    },
    
    scrollToFirstCheckedItem: function() {
        var formInput = this.getHiddenInputElement();
        if (formInput == null) return;

        var el = this.getFieldCanvas();
        if (el == null) return;

        var value = formInput.value;

        var imgElements = el.getElements('img[class=x-radio-group-img]');
        var input = null;

        var offsetTop;
        var scrollArea;
        var tdElement;
        for(var i = 0; i < imgElements.length; i++) {
            tdElement = imgElements[i].getParent();
            input = tdElement.getElement('input[type=hidden]');
            if (input.value == value) {
                offsetTop = tdElement.offsetTop;
                scrollArea = tdElement.getParent('.x-scrolled-area-container');
                scrollArea && (scrollArea.scrollTop = offsetTop);
                break;
            }
        }
    },

    /**
     * Render component
     * @return HTMLObject Object of rendered component
     */
    render: function()
    {
        var itemHtml = new Element('table', {
            'id': this.id + '-field',
            'class': 'x-radio-group-table' +
                     (this.border ? ' x-radio-group-table-border' : '') +
                     (this.fullWidth ? ' x-radio-group-table-fullWidth' : '') +
                     (this.align == 'top' ? ' x-radio-group-table-top' : ''),
            'cellpadding': 0,
            'cellspacing': 0,
            'html': '<tbody></tbody>'
        });

        if (this.eachRow) itemHtml.addClass('x-radio-group-eachRow');

        if (!RC.isEmpty(this.extraClass)) {
            itemHtml.addClass(this.extraClass);
        }

        if (!RC.isEmpty(this.extraStyle)) {
            itemHtml.set('style', itemHtml.get('style') + ';' + this.extraStyle);
        }

        var coItemHtml = itemHtml.getElement('tbody');
        var tr = null;
        var self = this;
        var idx = 0;
        var checkedValue = "";
        var radioIdx = 0;
        var radioIndex = 0;

        this.container = coItemHtml;

        this.items.each(function(rec)
        {
            if (RC.isEmpty(rec)) {
                return;
            }

            if (RC.isEmpty(rec.id)) {
                rec.id = self.formId + '-' + self.name + radioIdx;
            }

            if (self.layout == 'table') {
                self.eachRow = idx > 0;
                if (idx == 0)
                    idx++;
                else
                    idx = 0;
            }

            radioIndex++;

            var text;
            if (RC.isEmpty(rec.boxLabel)) {
                rec.boxLabel = "";
            }
            if (rec.boxLabel.indexOf('<') > -1) {
                text = { title : "", text : rec.boxLabel};
            } else {
                text = self.cutText(rec.boxLabel, rec.overflow);
            }

            if ((!RC.isTrue(self.eachRow) && tr == null) ||
                    (RC.isTrue(self.eachRow) && self.layout != 'table') ||
                    (tr == null && self.layout == 'table') ||
                    RC.isTrue(self.border)){
                var eachRowClass = 'x-radio-group-item';
                if(self.items.length > 0){
                    if(1 == radioIndex){
                        eachRowClass += ' x-radio-group-item-first';
                    }
                    else if(radioIndex == self.items.length){
                        eachRowClass += ' x-radio-group-item-last';
                    }
                }

                tr = new Element('tr', {
                    'class': eachRowClass + (RC.isEmpty(rec.visible)? ' ' : (RC.isTrue(rec.visible)? ' ' : ' x-hidden'))
                });
            }

            var fnHandler = function()
            {
                RC.Selection.clearSelection();
                if (RC.isTrue(self.disabled)) {
                    return;
                }
                // set hidden field
                var input = RC.getCmp(self.formId).getContainer().getElement('input[id=' + self.formId + '-' + self.name + ']');
                if (input == null)
                    return;

                var rInput = this.getElement('input');
                if (rInput == null)
                    rInput = this.getPrevious().getElement('input');

                input.value = rInput.value;

                // set visual effect
                var img = this.getElement('img[class=x-radio-group-img]');
                if (img == null)
                    img = this.getPrevious().getElement('img[class=x-radio-group-img]');
                if (img != null) {
                    itemHtml.getElements('img[class=x-radio-group-img]').each(function(its)
                    {
                        if (its.src.indexOf('radio-') > -1)
                            its.src = RC.getSkinnedRCLibXImageUrl('img/panel/form/radio.png');
                    });
                    img.set('src', RC.getSkinnedRCLibXImageUrl('img/panel/form/radio-checked.png'));
                }

                // fire item events
                if (typeof rec.handler == 'function')
                    rec.handler();

                // fire group events
                self.fireListener('change', input.value, self.formId);
            };

            if (!RC.isEmpty(self.value) && self.value == rec.value) rec.checked = true;

            if (rec.checked)
                checkedValue = rec.value;

            var clickHandler = !!rec.disabled ? function(){} : fnHandler;
            var radioGroupImgSrc = RC.getSkinnedRCLibXImageUrl('img/panel/form/radio' + (rec.checked ? '-checked' : '') + (rec.disabled ? '-disabled' : '') + '.png');
            new Element('td', {
                'class'     : 'x-radio-group-td ' + (rec.extraClass? rec.extraClass : ""),
                'tabindex'  : self.tabindex,
                'html'      : '<input type="hidden" id="' + rec.id + '" value="' + rec.value + '"/>' +
                        '<img class="x-radio-group-img" id="' + rec.id + '-icon" src="' + radioGroupImgSrc + '" alt=""/>',
                'events': {
                    'click': clickHandler,
                    'keyup': function(e){
                        if (e.key == 'space') {
                            e.stop();
                            this.fireEvent('click', e);
                        }
                    }
                }
            }).inject(tr);

            var tdLabel = new Element('td', {
                id: rec.id + '-label',
                title: (text.title != null ? text.title : ''),
                html: text.text,
                'class': 'x-radio-group-td x-radio-group-td-label',
                'events': {
                    'click': clickHandler
                }
            });

            /**
             * Gerenate sub items which will be rendered inside the component
             */
            if (rec.items !== undefined) {
                var placeholders = tdLabel.getElements('div.element_placeholder');
                for (var q = 0; q < rec.items.length; q++) {
                    var o = RC.getCmp(self.formId).addItem(rec.items[q]);
                    placeholders[q].set('html', '');
                    o.inject(placeholders[q]);
                }
                //tdLabel.removeEvent('click', fnHandler);
                //tdLabel.addClass('x-cursor-default');
            }

            // inject label into tr
            tdLabel.inject(tr);

            /**
             * Render tooltip object and inject it into parent cell
             */
            if (!RC.isEmpty(rec.hintText)) {
                new RC.form.ToolTip({
                    render  : new Element('span').inject(tdLabel),
                    id      : rec.id + '-hint',
                    text    : rec.hintText
                });
            }

            /**
             * Magic determine of single row positioning
             */
            if (RC.isTrue(self.eachRow)) {
                tr.inject(coItemHtml);
                if (self.layout == 'table')
                    tr = null;
            }

            radioIdx++;
        });

        if (tr != null) {
            tr.inject(coItemHtml);
        }

        var sCanvas = null;
        if (this.hasFieldLabel()) {

            sCanvas = this.renderFieldLabel();

            var toInject = itemHtml;
            if (this.scrolling != null) {
                this.scrolledArea = new RC.ScrolledArea(this.scrolling, itemHtml);
                toInject = this.scrolledArea;
            }

            toInject.inject(sCanvas);

        } else {
            if (this.scrolling != null) {
                this.scrolledArea = new RC.ScrolledArea(this.scrolling, itemHtml);
                sCanvas = this.scrolledArea;
            }
            else
                sCanvas = itemHtml;
        }

        if (!RC.isEmpty(this.height)) {
            sCanvas = new Element('div', {
                styles: {
                    'height': this.height + 'px'
                    ,'overflow-y': typeOf(this.scrolling) == 'object' && this.items.length > 6 ? '' : 'scroll'
                }
            }).adopt(itemHtml);
        }

        if (!RC.isTrue(this.visible) && this.visible !== undefined) {
            sCanvas.setStyle('display', 'none');
        }

        var hInput = new Element('input', {
            type    : "hidden",
            "class" : 'x-radiogroup-value',
            id      : this.formId + '-' + this.name,
            name    : this.name,
            value   : checkedValue
        });

        if (!RC.isEmpty(this.fieldLabel)) {
            sCanvas.adopt(hInput);
        } else {
            sCanvas = new Element('div', {
                'id'    : this.id
            }).adopt(sCanvas, hInput);
            if (!RC.isEmpty(this.labelStyle)) {
                sCanvas.set('style', this.labelStyle);
            }
        }

        this.setVisible(this.visible);

        // fire RENDER event
        if (self.hasListener('render')) {
            sCanvas.addEvent('domready', function(e)
            {
                self.fireListener('render');
            });
        }

        if(this.extraClass){
            sCanvas.addClass(this.extraClass + "-canvas");
        }

        return sCanvas;
    },
    filter: function(filter){

        var self = this;

        var parent = self.container.getParent();
        var children = self.container.getChildren('tr');

        self.container.dispose();

        this.items.each(function(item, index){

            var cell = children[index];
            if (!cell) return;
            cell.toggleClass('x-hidden', !filter(item));

        });

        parent.adopt(self.container);

    },
    hasVisibleRow: function() {
        return this.container.getChildren('tr:not(.x-hidden)').length > 0;
    },
    disable : function()
    {
        var currentDisabled = this.disabled;
        this.disabled = arguments[0] == undefined || arguments[0];

        if (currentDisabled == this.disabled) {
            return;
        }

        var self = this;

        var formInput = RC.getCmp(this.formId).getContainer().getElement('input[id=' + self.formId + '-' + self.name + ']');
        if (formInput == null)
            return;

        formInput.disabled = this.disabled;

        var el = this.getFieldCanvas();
        if (el == null) {
            return;
        }

        var value = formInput.value;

        el.getElements('img[class=x-radio-group-img]').each(function(img)
        {
            var input = img.getParent().getElement('input[type=hidden]');
            if (input.value == value) {
                img.set('src', RC.getSkinnedRCLibXImageUrl('img/panel/form/radio-checked' + (self.disabled ? '-disabled' : '') + '.png'));
            } else {
                img.set('src', RC.getSkinnedRCLibXImageUrl('img/panel/form/radio' + (self.disabled ? '-disabled' : '') + '.png'));
            }
        });
    }


});

RC.reg('x-form-radio', RC.form.Radio);
RC.reg('x-form-radiogroup', RC.form.RadioGroup);

/**
 * A text field with search icon.
 *
 * @class
 * @name RC.form.Search
 * @extends RC.form.Field
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-searchfield
 */
RC.form.Search = function(params)
{
    this.rendered = {};
    this.field = {};
    params._xtype = 'textfield';

    this.fullWidth = params.fullWidth === true;
    this._delay = null;

    RC.form.Search.superclass.constructor.call(this, params);
};

RC.extend(RC.form.Search, RC.form.Field, {
    render: function(){

        var self = this;
        this.rendered = RC.form.Search.superclass.render.call(this);
        this.field = this.rendered.getElement('input');

        var icon = new Element('div', {
            'id': this.id + '-icon',
            'class':    'x-form-search-icon'
        }).addEvent('click', function(){

            self.field.focus();
 
        });
        var clear = new Element('div', {
            'id': this.id + '-clear',
            'class':    'x-form-search-clear'
        }).addEvent('click', function(){

            self.field.value = '';
            self.field.fireEvent('keyup');
            self.field.fireEvent('change');
            self.field.fireEvent('clear');

        });

        var origRenderedElement = this.rendered.getElement('.x-form-textfield');
        origRenderedElement.dispose();

        var field = new Element('div', {
            'id': this.id + '-wrap',
            'class': 'x-form-search-wrap'
        }).inject(this.rendered);

        field.adopt(origRenderedElement, icon, clear);

        var canvas = this.rendered;
        canvas.addClass('x-form-search');

        if (this.fullWidth) {
            canvas.addClass('x-form-search-fullWidth');
        }

        self._toggleClearIcon();

        this.field.addEvent('keyup', function(e){
            self.valueChanged();
            self.fireListener('keyup', e);
        });

        this.addListener('change', function() {
            self.valueChanged();
        });

        return canvas;

    },
    get: function(){
        return this.field.get('value');
    },

    _toggleClearIcon: function(){
        this.rendered.toggleClass('x-form-search-empty', RC.isEmpty(this.get()));
    },

    valueChanged: function(){
        var self = this;
        execToggleClearIcon();

        function execToggleClearIcon(){
            clearTimeout(self._delay);
            self._delay = setTimeout(function(){
                self._toggleClearIcon();
            }, 200);
        }
    }
});

RC.reg('x-form-searchfield', RC.form.Search);

/**
 * @class
 * @name RC.form.Autocomplete
 * @extends RC.form.Field
 * A text field with search icon.
 * @constructor
 * @param {Object} params The config object
 * @xtype x-form-autocomplete
 */
RC.form.Autocomplete = function(params) {

    var self = this;

    params._xtype = 'textfield';

    RC.form.Search.superclass.constructor.call(this, params);

    this.store = params.store || new RC.data.JsonStore({data: []});

    this.store.addListener('sort', function() {

        this.renderOptions();

    }.bind(this));

    this.itemCanvas = null;
    this.itemContainer = null;
    this.itemOptions = null;
    this.itemField = null;
    this.strict = !!params.strict;
    this.hiddenValue = params.hiddenValue || '';
    this.visibleValue = params.visibleValue || 'id';

    /**
     * Renders the item in options
     * @type {*}
     */
    this.renderer = RC.isFunc(params.renderer) ? params.renderer : function(item, value) {
        return self.highlight(self.visibleValueRenderer(item), value);
    };

    /**
     * Returns visible value of item (displayed as value in text field)
     * @type {*}
     */
    this.visibleValueRenderer = function(item) {
        return item[self.visibleValue];
    };

    /**
     * Returns hidden value of item
     * @type {*}
     */
    this.hiddenValueRenderer = function(item) {
        return item[self.hiddenValue];
    };

    /**
     * Matches item against query
     * @type {*}
     */
    this.match = function(item, value) {
        return self.visibleValueRenderer(item).toLocaleLowerCase().indexOf(value.toLocaleLowerCase()) > -1;
    };

    this.selectedItem = null;
    this.openOptionsOnFocus = true;

};

RC.extend(RC.form.Autocomplete, RC.form.Field, {
    _filterCallback: function(item){

        var value = this.itemField.get('value');
        if (!value) return true;
        return this.match(item, value);

    },
    moveSelection: function(offset) {

        var index = -1;
        if (this.selectedItem) {
            index = this.store.indexOf(this.selectedItem);
        }

        index += offset;

        if (index < 0) return;
        if (index >= this.store.getCount()) return;

        this.setSelectedItem(this.store.getAt(index));

    },
    pregQuote: function(str) {
    },
    highlight: function(data, search) {
        return RC.utils.Text.highlight(data, search, '<span class="x-form-autocomplete-match">$1</span>');
    },
    highlightItem: function(item) {
        var options = this.itemOptions.getElements('div.x-form-autocomplete-option');
        options.removeClass('x-form-autocomplete-option-selected');
        var index = this.store.indexOf(item);
        if (options[index]) options[index].addClass('x-form-autocomplete-option-selected');
    },
    setSelectedItem: function(item) {
        this.selectedItem = item;
        this.itemField.set('value', this.visibleValueRenderer(item));
        this.highlightItem(item);
    },
    getSelectedItem: function() {
        return this.selectedItem;
    },
    getValue: function() {

        return this.strict ? this.hiddenValueRenderer(this.getSelectedItem()) : this.itemField.get('value')

    },
    setValue: function(value) {


    },
    performAutocomplete: function() {

        this.store.filter(this._filterCallback.bind(this));

    },
    renderOptions: function() {

        var self = this;

        if (!this.optionsVisible()) return;

        this.itemOptions.empty();

        var value = this.itemField.get('value');

        this.store.each(function(item, index) {

            var option = new Element('div', {
                'id': self.id + '-option-' + index,
                'class': 'x-form-autocomplete-option',
                'html': self.renderer(item, value),
                'events': {
                    click: function(e) {
                        e.stop();
                        self.setSelectedItem(item);
                        self.toggleOptions(false);
                    }
                }
            }).inject(self.itemOptions);

        });

        if (this.selectedItem) this.highlightItem(this.selectedItem);


    },
    toggleOptions: function(flag) {
        this.itemCanvas.toggleClass('x-form-autocomplete-focus', flag);
    },
    optionsVisible: function() {
        return this.itemCanvas.hasClass('x-form-autocomplete-focus');
    },
    render: function() {

        var self = this;

        this.itemCanvas = RC.form.Autocomplete.superclass.render.call(this);

        this.itemCanvas.addClass('x-form-autocomplete');

        this.itemContainer = this.itemCanvas.getElement('.x-form-textfield');
        this.itemField = this.itemCanvas.getElement(this.getInputElementSearchString());

        this.itemOptions = new Element('div', {
            'id': this.id + '-options',
            'class': 'x-form-autocomplete-options'
        }).inject(this.itemContainer);

        this.itemField.addEvent('keyup', function(e) {
            e.stop();
            this.toggleOptions(true);
            if (e.key == 'down' || e.key == 'up') {
                this.moveSelection(e.key == 'down' ? 1 : -1);
                return;
            }
            if (e.key == 'enter') {
                this.itemField.blur();
                return;
            }
            this.performAutocomplete();

        }.bind(this));

        this.itemField.addEvent('focus', function(e) {
            e.stop();
            if (this.openOptionsOnFocus) {
                this.toggleOptions(true);
                this.performAutocomplete();
            }
        }.bind(this));

        this.itemField.addEvent('blur', function(e) {
            e.stop();
            this.toggleOptions(false);
        }.bind(this));

        if (this.store.autoLoad) this.store.load();

        return this.itemCanvas;

    }
});

RC.reg('x-form-autocomplete', RC.form.Autocomplete);

(function() {

    var stack = [];
    var showingDelay = 1000;
    var hidingDelay = 1000;

    /**
     * A standard tooltip implementation for providing additional information when hovering over a target element.
     *
     * @class
     * @name RC.form.ToolTip
     * @extends RC.form.Field
     * @constructor
     * @param {Object} params The config object
     */
    RC.form.ToolTip = function(params) {
        this.render = params.render;
        this.embedElement = params.embedElement;
        this.width = [params.width, 200].pick();
        this.align = params.align;
        this.text = RC.strFromURLEnc(params.text, true);
        this.extraStyles = params.extraStyles || null;
        this.extraClass = params.extraClass || null;
        this.videoId = params.videoId || null;
        this.videoTitle = params.videoTitle || null;
        this.delayed = RC.isTrue(params.delayed);
        this.closable = RC.isTrue(params.closable);
        this.enabled = (typeof params.enabled == "undefined") || RC.isTrue(params.enabled);
        this.disableMouseEvents = RC.isTrue(params.disableMouseEvents);
        this.id = RC.genPrefixedId({id: params.id, idFromText: 'toolTip'});

        RC.form.ToolTip.superclass.constructor.call(this, params);

        this.itemCanvas = null;

        this.init();
    };

    RC.extend(RC.form.ToolTip, RC.utils.Observable, {
        init: function() {

            var self = this;
            var timeOut = null;
            var isClosing = false;

            var hint = new Element('div', {
                'id': this.id,
                'class': 'x-tooltip x-animation-invisible',
                'styles': {
                    'width': this.width,
                    'max-width': this.width
                },
                'html': this.text
            });

            this.itemCanvas = hint;

            if (this.videoId) {

                var videoLink = new Element('div', {
                    'class': 'x-tooltip-video'
                }).adopt(new Element('a', {
                        'href': '#',
                        'html': RC.Lang.Common.WATCH_VIDEO,
                        'events': {
                            click: function(e) {

                                e.stop();
                                RC.getOmniLog().logPageView('Video:' + self.videoTitle, RC.OmniConstants.FEATURE_TIP);
                                RC.utils.Video.openVideoWindow({
                                    videoId: self.videoId,
                                    title: self.videoTitle
                                });
                                self.hideHint();

                            }
                        }
                    }));

                videoLink.inject(hint);

            }

            if (this.closable) {

                var closeButton = new Element('span', {
                    'class': 'x-tooltip-close',
                    'html': '&times',
                    'events': {
                        click: function(e) {
                            e.stop();
                            if (isClosing) return;
                            isClosing = true;
                            self.hideHint();
                            self.fireListener('close');
                        }
                    }
                });

                closeButton.inject(hint);

            }

            var mouseenter = function() {

                var hasNotBeenShown = stack.length == 0;

                clearTimeout(timeOut);

                // hide each tooltip in stack that is not this one
                stack.each(function(tip) {
                    if (tip !== self) tip.hideHint();
                });

                // if no tips has been shown and this is a delayed tip - set timeout
                if (self.delayed && hasNotBeenShown) {
                    timeOut = setTimeout(function() {
                        self.showHint();
                    }, showingDelay);
                } else {
                    self.showHint();
                }

            };

            var mouseleave = function() {
                clearTimeout(timeOut);
                timeOut = setTimeout(function() {
                    self.hideHint();
                }, hidingDelay);
            };

            this.showHint = function() {

                clearTimeout(timeOut);
                if (!self.enabled) return;

                stack.push(this);

                hint.inject(document.getElement('body'));

                hint.setStyles({
                    'z-index': RC.idSeed * 100 // other way to ensure it's above windows  RC.Window.zIndex + 1
                }); //display before counting size

                hint.removeClass('x-tooltip-left');

                var embedCoords = self.embedElement.getCoordinates();
                var embedSize = self.embedElement.getSize();
                var windowSize = $(window).getSize();
                var windowScroll = $(window).getScroll();
                var tooltipSize = hint.getSize();
                var boundingBox = 10;

                //RC.Console.log('embedCoords', embedCoords, 'embedSize', embedSize, 'tooltipSize', tooltipSize);

                embedCoords.left += embedSize.x;
                embedCoords.top += (embedSize.y - tooltipSize.y) / 2;

                if (embedCoords.left + tooltipSize.x + 20 > windowSize.x) {
                    embedCoords.left -= embedSize.x + tooltipSize.x + boundingBox;
                    hint.addClass('x-tooltip-left');
                } else {
                    embedCoords.left += boundingBox;
                }

                hint.setStyle('left', embedCoords.left);
                hint.setStyle('top', embedCoords.top);

                hint.addClass('x-animation-visible');
                isClosing = false;

            };

            this.hideHint = function() {
                clearTimeout(timeOut);
                hint.removeClass('x-animation-visible');
                stack.erase(this);
                //hint.dispose();
            };

            if (!this.embedElement) {
                this.embedElement = new Element('img', {
                    src: RC.getSkinnedRCLibXImageUrl('img/common/hint.png'),
                    alt: '',
                    'class': 'x-tooltip-hint',
                    id: this.id
                });
                if (this.extraStyles) this.embedElement.setStyles(this.extraStyles);
                if (this.extraClass) this.embedElement.addClass(this.extraClass);

                this.embedElement.inject(this.render);

            }

            /**
             * This means tooltip show/hide is maintained from outside
             */
            if (!this.disableMouseEvents) {

                this.embedElement.addEvent('mouseenter', mouseenter);
                this.embedElement.addEvent('mouseleave', mouseleave);

                hint.addEvent('mouseenter', function() {
                    clearTimeout(timeOut);
                });

                hint.addEvent('mouseleave', mouseleave);

            }

            this.setText = function(text) {
                self.text = text;
                hint.set('html', text);
            };

            this.destroy = function() {
                hint.destroy();
                this.embedElement.removeEvent('mouseenter', mouseenter);
                this.embedElement.removeEvent('mouseleave', mouseleave);
            };

        },

        disable: function() {
            this.enabled = false;
        },

        enable: function(enabled) {
            this.enabled = (typeof enabled == "undefined") || !!enabled;
        }
    });

})();

RC.form.HintPanel = function(params)
{
    this.invoker = params.invoker;
    this.closable = params.closable;
    this.offset = params.offset;
    this.html = params.html;

    RC.form.HintPanel.superclass.constructor.call(this, params);
};

RC.extend(RC.form.HintPanel, RC.utils.Observable, {
    show: function() {
        var self = this;
        var isClosing = false;

        var hint = new Element('div', {
            'class': 'x-hintpanel x-animation-invisible',
            'styles': {
                'width': 180,
                'max-width': 300
            },
            'html': self.html
        });

        if (this.closable) {

            var closeButton = new Element('span', {
                'class': 'x-hintpanel-close',
                'html': '&times',
                'events': {
                    click: function(e) {
                        e.stop();
                        if (isClosing) return;
                        isClosing = true;
                        self.hideHint();
                        self.fireListener('close');
                    }
                }
            });

            closeButton.inject(hint);

        }

        hint.inject(document.getElement('body'));

        hint.setStyles({
            'z-index': RC.idSeed * 100 // other way to ensure it's above windows  RC.Window.zIndex + 1
        }); //display before counting size

        var embedCoords = self.invoker.getCoordinates();
        var embedSize = self.invoker.getSize();

        embedCoords.left += self.offset.x;
        embedCoords.top += embedSize.y + self.offset.y;


        hint.addClass('x-animation-visible');

        hint.setStyle('left', embedCoords.left);
        hint.setStyle('top', embedCoords.top);

        this.hideHint = function () {
            hint.removeClass('x-animation-visible');
            hint.destroy();
        }
    }
});

RC.reg('x-form-hintpanel', RC.form.HintPanel);

/*jslint */
/*global RC */

/**
 * @class
 * @name RC.form.Upload
 * @extends RC.form.Field
 * @param {Object} params
 * @constructor
 */
RC.form.Upload = function (params) {
    'use strict';
    RC.form.Upload.superclass.constructor.call(this, params);
    this.noAttachButton = !!params.noAttachButton;
    this.background = params.background; //TODO Temporary solution, should be removed when outer frame will be removed
    this.attachButtonText = params.attachButtonText || RC.Lang.Common.ATTACH;
    this.acceptType = params.acceptType || null;
    this.cancelable = (params.cancelable === true);
    this.disableBrowseClass = 'x-form-fileupload-disableBrowse';
    this.addDisposableListener('uploadReady');

    this.domElements = {
        canvas: null,
        form: null,
        field: null,
        submit: null,
        frame: null
    };

    this.file = null;
    this.hasChanged = null;

};

RC.extend(RC.form.Upload, RC.form.Field, {
    getFile: function() {
        return this.file;
    },
    getValue: function() {
        return this.getFile() ? JSON.encode(this.getFile()) : "";
    },
    setValue: function() {
        RC.Console.error('Value is read only');
    },
    upload: function() {
        this.domElements.fakeSubmit.handler();
    },
    fileUploaded: function(response) {

        var respErrorCode;

        if (response && response.status.success) {

            this.file = response.files[0];
            RC.Console.warn('File uploaded: %o', this.file);
            this.fireListener('upload', response);

        } else {
            respErrorCode = response.status.errorCode;
            RC.Console.error('Failed to upload a file: %s (%i)', response.status.message, respErrorCode);

            if (this.hasListener('uploadError')) {
                this.fireListener('uploadError', response.status);
            } else {
                var errorMsg = RC.Lang.Common.FILE_UPLOAD_ERRORS[respErrorCode] || response.status.message;
                if ('SIZE_LIMIT_EXCEEDED' === respErrorCode) {
                    errorMsg = RC.UI.Message(errorMsg, RC.Config.maxFileSizeMegaBytes);
                }
                RC.alert(errorMsg);
            }

        }

    },
    showAttachButton: function() {
        this.domElements.canvas.removeClass('x-form-fileupload-hideSubmit');
    },
    hideAttachButton: function() {
        this.domElements.canvas.addClass('x-form-fileupload-hideSubmit');
    },
    disableAttachButton: function() {
        this.domElements.fakeSubmit.disable();
    },
    enableAttachButton: function() {
        this.domElements.fakeSubmit.enable();
    },
    disableBrowseButton: function() {
        this.domElements.canvas.addClass(this.disableBrowseClass);
        this.domElements.fakeBrowse.disable();
    },
    enableBrowseButton: function() {
        this.domElements.canvas.removeClass(this.disableBrowseClass);
        this.domElements.fakeBrowse.enable();
    },
    createDOM: function() {

        var self = this;

        this.domElements.canvas = this.renderFieldLabel();

        this.domElements.frame = null;

        this.domElements.fakeInput = new RC.form.Field({
            extraClass: 'x-form-fileupload-fakeInput',
            xtype: 'textfield',
            id: this.id + 'fakeInput',
            name: 'fakeInput',
            labelAlign: 'left',
            tabindex: -1,
            formId: this.formId,
            width: '100%',
            text: 'Attach',
            readonly: true,
            listeners: {
                focus: function(){
                    this.blur();
                }
            }
        });

        this.domElements.fakeBrowse = new RC.form.Button({
            extraClass: 'x-form-fileupload-fakeBrowse',
            width: '100%',
            tabindex: -1,
            text: RC.Lang.Common.BROWSE
        });

        this.domElements.fakeSubmit = new RC.form.Button({
            extraClass: 'x-form-fileupload-fakeSubmit',
            width: '100%',
            text: self.attachButtonText
        });

        this.domElements.form = new Element('form', {
            'id': this.id + '-form',
            'target': this.id + '-frame',
            'method': 'post',
            'action': '/mobile/upload',
            'enctype': 'multipart/form-data',
            'class': 'x-form-fileupload-form'
        });

        this.domElements.field = new Element('input', {
            'type': 'file',
            'id': this.id + '-input',
            'name': 'file',
            'class': 'x-form-fileupload-input',
            'tabindex': 1,
            'accept': this.acceptType,
            'events': {
                focus: function(){
                    $(self.domElements.fakeBrowse.id + '-button').addClass('x-button-focus');
                },
                blur: function(){
                    $(self.domElements.fakeBrowse.id + '-button').removeClass('x-button-focus');
                },
                mouseenter: function(){
                    $(self.domElements.fakeBrowse.id + '-button').addClass('x-button-fake-hover');
                },
                mouseleave: function(){
                    $(self.domElements.fakeBrowse.id + '-button').removeClass('x-button-fake-hover');
                }
            }
        }).inject(this.domElements.form);

        this.domElements.form.adopt(this.domElements.fakeInput.compile(), this.domElements.fakeBrowse.render(), this.domElements.fakeSubmit.render());

        this.domElements.canvas.adopt(this.domElements.frame, this.domElements.form);

        this.hideAttachButton(); // hide by default

        this.domElements.field.addEvent('change', function(e) {

            e.stop();

            var value = (self.domElements.field.files && self.domElements.field.files[0]) ? self.domElements.field.files[0].name : self.domElements.field.value;

            self.hideAttachButton();

            self.domElements.fakeInput.setValue(value, null, true);
            self.hasChanged = value;
            self.fireListener('change', self.hasChanged);

            if (!self.noAttachButton && !RC.isEmpty(value)) self.showAttachButton();

        });

        if (Browser.name === "safari" || Browser.name === "chrome") this.domElements.form.addClass('x-form-fileupload-webkit');

    },

    getInputValue: function() {
        return this.domElements.fakeInput.getValue();
    },

    createHandlers: function(){

        var self = this;

        this.domElements.fakeSubmit.handler = createUploadHandlers;

        var statusTimeoutID;
        var statusTimeoutMilliseconds = 1000;

        function createUploadHandlers(e) {

            if (self.hasListener('beforeUpload') && !self.fireListener('beforeUpload')) {
                return;
            }

            if (!self.hasChanged) {

                RC.Loader.hide();
                RC.alert(RC.Lang.Common.FILE_REQUIRED);
                (new Event(e)).stop();
                return;

            }

            createUploadIFrame();
            startErrorCheck();

            self.cancelable || RC.Loader.show({});

            // First submit
            self.fireListener('uploadStart');
            self.domElements.form.submit();

            // Second attach
            self.domElements.frame.addEvent('load', function() {

                self.stopErrorCheck();

                self.cancelable || RC.Loader.hide();

                var doc = getDoc(self.domElements.frame);
                var response = getResponse(doc);

                try {

                    response = JSON.decode(response);
                    self.fileUploaded(response);

                } catch (e) {

                    processUploadError(doc);

                }

            });

        }

        function createUploadIFrame() {

            if (self.domElements.frame) {
                self.domElements.frame.dispose();
            }

            var name = self.id + '-upload-' + RC.genId();
            self.domElements.frame = new Element('iframe', {
                'name': name,
                'styles': {
                    'height': '1px',
                    'width': '1px',
                    'position': 'absolute',
                    'border': 'none'
                }
            });

            self.domElements.frame.inject(self.domElements.canvas);
            self.domElements.form.setProperty("target", name);

        }

        function getDoc(frame) {
            return frame.contentWindow ? frame.contentWindow.document :
                   frame.contentDocument ? frame.contentDocument : frame.document;
        }

        function getResponse(doc) {
            return doc.body && doc.body.innerHTML;
        }

        function startErrorCheck() {

            var checked = false;
            checkStatus();

            function startTimeout() {
                statusTimeoutID = setTimeout(checkStatus, statusTimeoutMilliseconds);
            }

            function checkStatus() {

                try {

                    var doc = getDoc(self.domElements.frame);
                    var response = getResponse(doc);

                    if (response) {

                        /*
                         for first time we just store info that answer is received,
                         if answer is not processed still - we have error
                         */
                        if (!checked) {

                            checked = true;
                            startTimeout();

                        }  else {

                            processUploadError(doc);

                        }

                    } else {

                        startTimeout();

                    }

                } catch (e) {

                    RC.alert(RC.UI.Message(RC.Lang.Common.UNKNOWN_ERROR, e.name));

                }

            }

        }

        self.stopErrorCheck = function () {
            statusTimeoutID && clearTimeout(statusTimeoutID);
        };
        function getUploadErrorMessage(doc) {

            var nginxRequestTooLargeError = "413 Request Entity Too Large";
            var nginxRequestTooLargeError400 = "Payload content length greater than maximum allowed:";
            var message
                , response = getResponse(doc);;

            if (doc.title == nginxRequestTooLargeError || response.indexOf(nginxRequestTooLargeError400) !== false) {

                /*
                 This message is duplicated in fileUploadServlet, in case request reaches JEDI
                 */
                message = RC.UI.Message(RC.Lang.Common.FILE_UPLOAD_ERRORS.SIZE_LIMIT_EXCEEDED, RC.Config.maxFileSizeMegaBytes);

            } else {

                /*
                 If request for some reason finished  even without JEDI proper reply
                 */
                message = RC.Lang.Common.UNKNOWN_ERROR_TRY_AGAIN;

            }

            return message;

        }

        function processUploadError(doc) {

            var message = getUploadErrorMessage(doc);

            var response = {
                status: {
                    success: false,
                    message: message,
                    errorCode: 0
                }
            };

            self.fileUploaded(response);

        }

    },
    render: function() {

        this.createDOM();
        this.createHandlers();

        this.fireListener('uploadReady');

        return this.domElements.canvas;

    },
    cancel:  function() {
        var self = this;
        self.clearListeners();
        self.stopErrorCheck();
        if (self.domElements.frame) {
            self.domElements.frame.dispose();
        }
    }
});

RC.reg('x-form-upload', RC.form.Upload);


RC.form.SwitchButton = function(config) {
    config = config || {};
    this.alignToRight = RC.isTrue(config.alignToRight);
    this.asyncFunction = config.asyncFunction;
    this.disabled = (config.disabled === true);
    RC.form.SwitchButton.superclass.constructor.call(this, config);
};

RC.extend(RC.form.SwitchButton, RC.form.Field, {
    render: function() {
        var self = this,
            btnElId = self.id + '-field',
            switchClasses = [
                'x-form-switch',
                self.extraClass,
                (self.alignToRight ? 'rightAlignment' : null),
                (self.disabled ? 'x-form-switch-disabled' : null)
            ].clean(),
            itemHtml = new Element('div', {
                'id': btnElId,
                'class': switchClasses.join(' ')
            }),
            isOn = (self.value === true);

        self._switchBtnEl = new Element('div', {
            'id': btnElId + '-switch',
            'class': isOn ? 'x-form-switch-on' : 'x-form-switch-off',
            'events': {
                'click': function(e) {
                    var btn = this;

                    if (!self.disabled) {
                        if (RC.isFunc(self.asyncFunction)) {
                            btn.addClass('x-form-switch-loading');
                            self.asyncFunction.call(self, function(isSuccess) {
                                if (isSuccess) {
                                    btn.removeClass('x-form-switch-loading');
                                    changeStatus();
                                }
                            });
                        } else {
                            changeStatus();
                        }
                    }

                    function changeStatus() {
                        self.setValue(!self.getValue());
                        self.fireListener('statusChanged', self.getValue());
                    }
                }
            }
        }).inject(itemHtml);

        self._itemWrapper = itemHtml;

        var sCanvas = self.renderFieldLabel();
        itemHtml && itemHtml.inject(sCanvas);
        self.fireListener('render');
        return sCanvas;
    },

    setValue: function(val) {
        var oldVal = this.value,
            currentClass = 'x-form-switch-' + (oldVal ? 'on' : 'off');
        this.value = val;
        this._switchBtnEl.removeClass(currentClass).addClass('x-form-switch-' + (val ? 'on' : 'off'));
    },

    getValue: function() {
        return this.value;
    },

    turnOn: function() {
        this.setValue(true);
    },

    turnOff: function() {
        this.setValue(false);
    },

    setEnable: function(enabled) {
        this.disabled = !enabled;
        this._itemWrapper.toggleClass('x-form-switch-disabled', !enabled);
    }
});

RC.reg('x-form-switch', RC.form.SwitchButton);

RC.form.MultipleFileUpload = function(config) {
    // you can pass in id or DOM element itself
    this.browseButton = config.browseButton; // required

    // id of the DOM element or DOM element itself to use as a container for uploader structures. Defaults to document.body
    this.container = config.container;

    // Maximum file size that the user can pick, in bytes. Optionally supports b, kb, mb, gb, tb suffixes. e.g. "10mb" or "1gb"
    this.maxFileSize = config.maxFileSize || '0';

    // List of file types to accept, each one defined by title and list of extensions
    // e.g. [{title: "Image files", extensions: "jpg,gif,png"}, {title: "Zip files", extensions: "zip"}]
    this.acceptTypes = config.acceptTypes;

    // Do not let duplicates into the queue
    this.preventDuplicates = !!config.preventDuplicates;

    // Enable ability to select multiple files at once in file dialog
    this.multiSelection = !!config.multiSelection;

    RC.form.MultipleFileUpload.superclass.constructor.call(this, config);

    // possible events
    this.addEvents(
        /**
         * @event init
         * Fires when the current RunTime has been initialized.
         */
        'init',
        /**
         * @event postInit
         * Fires after the init event in case you need to perform actions there.
         */
        'postInit',
        /**
         * @event filesAdded
         * Fires after files were filtered and added to the queue.
         * @param {Array} files Array of file objects that were added to queue by the user.
         */
        'filesAdded',
        /**
         * @event beforeUpload
         * Fires when just before a file is uploaded. This event enables you to override settings
         * on the uploader instance before the file is uploaded.
         * @param {plupload.File} file File to be uploaded.
         */
        'beforeUpload',
        /**
         * @event fileUploaded
         * Fires when a file is successfully uploaded.
         * @param {plupload.File} file File that was uploaded.
         * @param {Object} response Object with response properties.
         */
        'fileUploaded',
        /**
         * @event uploadProgress
         * Fires while a file is being uploaded. Use this event to update the current file upload progress.
         * @param {plupload.File} file
         */
        'uploadProgress',
        /**
         * @event UploadComplete
         * Fires when all files in a queue are uploaded.
         * @param {Array} files Array of file objects that was added to queue/selected by the user.
         */
        'uploadComplete',
        /**
         * @event filesRemoved
         * Fires when file is removed from the queue.
         * @param {Array} files Array of files that got removed.
         */
        'filesRemoved',
        /**
         * @event destroy
         * Fires when destroy method is called.
         */
        'destroy',
        /**
         * @event error
         * Fires when a error occurs.
         * @param {Object} err {code: plupload.FILE_SIZE_ERROR, message: 'File size error.', file: plupload.File}
         */
        'error'
    );

    this._initUploader();
};

RC.extend(RC.form.MultipleFileUpload, RC.utils.Observable, {
    _initUploader: function() {
        var self = this;
        this.uploader = new plupload.Uploader({
            runtimes: 'html5,flash,silverlight,html4',
            browse_button: self.browseButton,
            container: self.container,
            url: '/mobile/flashUpload',
            flash_swf_url: '/desktop/bower_components/Moxie.swf', // @todo RCLibX should not be depends on desktop
            silverlight_xap_url: '/desktop/bower_components/Moxie.xap', // @todo RCLibX should not be depends on desktop
            filters: {
                max_file_size: self.maxFileSize,
                mime_types: self.acceptTypes,
                prevent_duplicates: self.preventDuplicates
            },
            multi_selection: self.multiSelection,
            init: {
                Init: function(uploader) {
                    self.fireListener('init');
                },
                PostInit: function(uploader) {
                    self.fireListener('postInit');
                },
                FilesAdded: function(uploader, files) {
                    self.fireListener('filesAdded', files);
                },
                BeforeUpload: function(uploader, file) {
                    return self.fireListener('beforeUpload', file);
                },
                FileUploaded: function(uploader, file, response) {
                    var serverResponse = JSON.decode(response.response);
                    var status, error;
                    if (serverResponse) {
                        status = serverResponse.status;
                        if (status && !status.success) {
                            error = {
                                code: status.errorCode,
                                message: status.message,
                                file: file
                            };
                        }
                    }

                    if (error) {
                        self.fireListener('error', error);
                    } else {
                        self.fireListener('fileUploaded', file, serverResponse);
                    }
                },
                UploadProgress: function(uploader, file) {
                    self.fireListener('uploadProgress', file);
                },
                UploadComplete: function(uploader, files) {
                    self.fireListener('uploadComplete', files);
                },
                FilesRemoved: function(uploader, removedFiles) {
                    self.fireListener('filesRemoved', removedFiles);
                },
                Error: function(uploader, err) {
                    if (plupload.FILE_EXTENSION_ERROR == err.code) {
                        err.code = 'FILE_EXTENSION_ERROR';
                    }
                    if (plupload.HTTP_ERROR == err.code) {
                        err.code = 'INTERNAL_ERROR';
                    }
                    self.fireListener('error', err);
                },
                Destroy: function(uploader) {
                    self.fireListener('destroy');
                }
            }
        });

        this.uploader.init();
    },
    start: function() {
        this.uploader.start();
    },
    stop: function() {
        this.uploader.stop();
    },
    disableBrowse: function(disabled) {
        this.uploader.disableBrowse(disabled);
    },
    removeFile: function(file) {
        this.uploader.removeFile(file);
    },
    destroy: function() {
        this.uploader.destroy();
    }
});

/**
 * <p>This class represents the primary interface of a component based grid control to represent data in a tabular format of rows and columns. The GridPanel is composed of the following:</p>
 * <div class="mdetail-params"><ul>
 * <li><b>{@link RC.data.Store}</b> : The Model holding the data records (rows)<div class="sub-desc"></div></li>
 * <li><b>View</b> : Encapsulates the user interface<div class="sub-desc"></div></li>
 * <li><b>Column model</b> : Column makeup (TO BE IMPLEMENTED)<div class="sub-desc"></div></li>
 * <li><b>Selection model</b> : Selection behavior (TO BE IMPLEMENTED)<div class="sub-desc"></div></li>
 * </ul></div>
 *
 * @class
 * @name RC.grid.GridPanel
 * @extends RC.Element
 * @constructor
 * @param {Object} params The config object
 */
RC.grid.GridPanel = function(params)
{

    var self = this;

    // columns
    this.cols = params.columns || [];
    // title
    this.title = params.title || null;
    
    // data store
    /**@type {RC.data.JsonStore}*/
    this.store = params.store || null;
    //scrolling
    this.scrolling = RC.isTrue(params.scrolling);
    this.scrollingConfig = params.scrollingConfig || {
        height:150,
        shift:20
    };
    this.hidden = RC.isTrue(params.hidden);
    this.height = params.height !== undefined ? params.height + 'px' : null;
    this.drag = !RC.isEmpty(params.drag);
    this.extraRowStyle = params.extraRowStyle || null;
    this.lastRowStyle = params.lastRowStyle || null;

    this.multipleSelectable = params.multipleSelectable === true;
    this.selections = [];

    this.enableHistory = params.enableHistory !== undefined ? params.enableHistory : false;

    /**@type {RC.grid.History}*/
    this.history = new RC.grid.History();

    // top toolbar
    this.tbar = params.tbar || [];

    this.fixedLayout = params.fixedLayout === true;

    // handler
    // todo remove
    this.handler = (typeof params.handler == 'function' ? params.handler : null);
    if (typeof params.handler == 'function') {
        RC.Console.info('Property GridPanel.handler has been deprecated');
    }

    //view config
    var viewConfig = RC.isEmpty(params.viewConfig) ? {} : params.viewConfig;
    Object.each(
        {
            getNoDataMessage : function ()
            {
                return null;
            },
            getCellStyle : function (defaultCellStyle/*, collItem, cellIndex, cellValue, rowValue*/)
            {
                return defaultCellStyle;
            },
            getHeaderClass : function (defaultHeaderCalss/*, headerItem, headerIndex*/)
            {
                return defaultHeaderCalss;
            },
            getHeaderStyle : function (defaultHeaderStyle/*, headerItem, headerIndex*/)
            {
                return defaultHeaderStyle;
            },
            getBorderStyle : function (defaultBorderStyle/*, borderOrientation, borderType*/)
            {
                return defaultBorderStyle;
            },
            getRowClass : function (record, index)
            {
                return "";
            }
        },
        function (value, key) {
            if (!viewConfig.hasOwnProperty(key)) {
                viewConfig[key] = value;
            }
        }
    );

    this.viewConfig = viewConfig;

    this.store.addListener('loadRecord', this.renderRow, this);
    this.store.addListener('clear', this.removeRows, this);
    this.store.addListener('clear', this.history.clear, this.history);
    this.store.addListener('remove', this.history.remove, this.history);
    this.store.addListener('batchRemove', this.history.batchRemove, this.history);
    this.store.addListener('lastRecordRendered',this.lastRecordRendered,this);

    // We have to update scrollers on data load
    this.store.addListener('load', function()
    {

        self.refresh();

    });

    function reRender(){
        self.removeRows();
        self.renderRows();
        self.refresh();
    }

    // We have to update scrollers on data load
    this.store.addListener('sort', function() { reRender(); });
    this.store.addListener('changeRecord', function(rec, index) {
        self.isOdd = index%2;
        self.renderRow(rec, index, false).replaces(self.getTBody().getElements('tr')[index]);
    });

    // create superclass
    RC.grid.GridPanel.superclass.constructor.call(this, params);

    this._container = null;
};

RC.extend(RC.grid.GridPanel, RC.Element, {
    getTBodyId : function ()
    {
        return this.id + "-tbody";
    },
    getTBody : function ()
    {
        if (this.scrolledArea) {
            return this.scrolledArea.getElement('table[id=' + this.id + '] tbody');
        }
        var tbodyId = this.getTBodyId();
        if (!this._container.getElements) return null;
        var tbodies = this._container.getElements('tbody');
        for (var i = 0; i < tbodies.length; i++) {
            if (tbodies[i].get("id") == tbodyId) {
                return tbodies[i];
            }
        }
        return  null;
    },
    renderTitle : function ()
    {
        return new Element('tr', {
            'class': 'x-grid-title'
        }).grab(new Element('th', {
            colspan : this.cols.length,
            html    : RC.isEmpty(this.title) ? '&#160;' : this.title
        }));
    },
    renderHeaders : function (coCanvas)
    {
        for (var i = 0; i < this.cols.length; i++) {
            if (!RC.isEmpty(this.cols[i].text)) {
                this.renderCols().inject(coCanvas); // render head only if any col contain "text"
                return true;
            }
        }
        return false;
    },
    render : function()
    {
        var self = this;

        // if store is null, throw exception
        if (!(this.store instanceof RC.data.Store)) {
            throw ('Data store is not defined');
        }

        if (this.title != null)
            new Element('div', {
                html : RC.isEmpty(this.title) ? '&#160;' : this.title,
                'styles' : {
                    'font-weight' : 'bold'
                }
            });

        this._container = new Element('table', {
            id          : this.id,
            store_state : "init",
            cellpadding : 0,
            cellspacing : 0,
            border      : 0,
            width       : '100%',
            'class'     : 'x-grid',
            html        : '<thead></thead>',
            styles : {
                'display' : RC.isTrue(this.hidden) ? 'none' : '',
                'height'  : this.height != null ? this.height : null
            }/*,// todo check it
             'events': {
             'click': function(e)
             {
             if (self.handler != null)
             self.handler(e);
             }
             }*/
        });
        this.store.addListener("load", function(){
            this._container.setAttribute("store_state", "load");
        }.bind(this));
        this.store.addListener("add", function(){
            this._container.setAttribute("store_state", "add");
        }.bind(this));
        this.store.addListener("clean", function(){
            this._container.setAttribute("store_state", "clean");
        }.bind(this));
        this.store.addListener("remove", function(){
            this._container.setAttribute("store_state", "remove");
        }.bind(this));

        var coCanvas = this._container.getElement('thead');
        if (this.title != null) {
            this.renderTitle().inject(coCanvas);
        }

        // no columns => no render
        if (this.cols.length == 0) {
            return this._container;
        }

        // Support fixed table layout.
        if (this.fixedLayout) {
            this._container.addClass('x-grid-fixed-layout');
            var colgroupEl = new Element('colgroup').inject(this._container, 'top');
            for (var i = 0; i < this.cols.length; ++i) {
                new Element('col', {
                    styles: {
                        width: this.cols[i].width || 'auto'
                    }
                }).inject(colgroupEl);
            }
        }

        var emptyHeader = !this.renderHeaders(coCanvas);

        new Element('tbody', {id:this.getTBodyId()}).inject(coCanvas, 'after');

        coCanvas = this.getTBody();

        if (this.tbar.length > 0) {
            this.renderTopToolBar();
        }

        if (this.scrolling) {
            var headTable = this._container;
            var bodyTable = headTable.clone();

            headTable.getElement('tbody').dispose();
            bodyTable.getElement('thead').dispose();

            headTable.setStyle('margin-bottom', '0');
            bodyTable.setStyle('margin-top', '0');
            var id = headTable.get('id');
            headTable.erase('id');
            bodyTable.set('id', id);

            this.scrolledArea = new RC.ScrolledArea({
                vertical : this.scrollingConfig
            }, bodyTable);
            this._container = new Element('div', {
                'id' : this.id + '-scroll-wrapper',
                'class' : 'x-scroll-wrapper' + (this.scrollingConfig.extraClass ? ' ' + this.scrollingConfig.extraClass : '')
            });

            if(!emptyHeader) {
                headTable.inject(this._container);
                this.headTable = headTable;
            }
            this.scrolledArea.inject(this._container);
            this.bodyTable = bodyTable;
        }

        // load store if need
        // todo make it async
        if (this.store.autoLoad) {
            this.store.load();
        }

        this.fireListener('render');

        if (!this.visible) {
            this._container.setStyle('display', 'none');
        }

        return this._container;
    },

    refresh: function()
    {
        if (!this.scrolledArea)
            return;
        try {
            var headTableCols = this.headTable.getElements('td');
            var bodyTableCols = this.bodyTable.getElements('td');
            for (var i = 0; i < headTableCols.length; i++) {
                var width = headTableCols[i].getSize().x;
                bodyTableCols[i].erase('width');
                headTableCols[i].erase('width');
                bodyTableCols[i].setStyle('width', width);
                headTableCols[i].setStyle('width', width);
            }
        } catch (e) {
            RC.Console.warn('RC.grid.GridPanel: ' + e.message);
        }
        this.scrolledArea.scrolls().vertical.onChangeContentHeight();
    },
    _isNeedToDisplayElementInHeader : function (item, index)
    {
        return (item.xtype && item.text === undefined);
    },
    getColHtml : function(item, index)
    {
        var predefinedInnerHtml = '&#160;';
        if (RC.isEmpty(item.text)) {
            if (this._isNeedToDisplayElementInHeader(item, index)) {
                predefinedInnerHtml = '';
            }
        } else {
            predefinedInnerHtml = item.text;
        }
        return predefinedInnerHtml;
    },
    renderCol : function (item, index)
    {
        var self = this;

        var td = new Element('td', {
            html    : self.getColHtml(item, index),
            'class' : self.viewConfig.getHeaderClass(item.extraClass, item, index),
            'styles' : self.viewConfig.getHeaderStyle({
                'min-width' : RC.isEmpty(item.width) ? 'auto' : item.width + 'px',
                'text-align' : RC.isEmpty(item.align) ? 'center' : item.align
            }, item, index)
        });

        if (item.cellAlign != undefined || item.headAlign != undefined) {
            td.set('align', [item.cellAlign, item.headAlign].pick());
        }

        if (typeof item.extraHeaderStyles == 'object') {
            td.setStyles(item.extraHeaderStyles);
        }

        if (self._isNeedToDisplayElementInHeader(item, index)) {
            self.createFormElement(item).inject(td);
        }

        return td;
    },

    renderCols : function()
    {
        var self = this;
        var canvas = new Element('tr', {
            'class' : 'fixed x-grid-title'
        });

        this.cols.each(function(item, index)
        {
            self.renderCol(item, index).inject(canvas, 'bottom');
        });

        return canvas;
    },
    createFormElement : function (item)
    {
        var cebtPacked = RC.form.createElement(item);
        var object = cebtPacked.obj;
        var sCanvas = null;
        if (cebtPacked.built) {
            sCanvas = object.render();
        } else {
            sCanvas = object;
        }
        return sCanvas;
    },
    getCellValue : function (row, dataIndex)
    {
        return ( this.store ? this.store.read(row, dataIndex) : row[dataIndex] );
    },
    lastRecordRendered : function(recordLength) {
        if (RC.isEmpty(this.getTBody()) || RC.isEmpty(this.getTBody().getElement('.x-grid-line:last-child'))) {
            return;
        }
        this.getTBody().getElement('.x-grid-line:last-child').addClass('x-grid-line-last');
        if (!RC.isEmpty(this.lastRowStyle)) {
            this.getTBody().getElement('.x-grid-line:last-child').setStyles(this.lastRowStyle);
        }
    },
    renderTopToolBar: function() {
        var self = this;
        var canvas = new Element('tr', {
            'class': 'x-grid-line-first x-grid-line-tbar'
        });
        var td = new Element('td', {
            html: '',
            colspan: self.cols.length
        });

        var tbarContainer = new Element('div');
        this.tbar.each(function(item) {
            var tbarItemWrapper = new Element('div', {
                'class': 'x-grid-tbar-item'
            });
            self.createFormElement(item).inject(tbarItemWrapper);
            tbarItemWrapper.inject(tbarContainer);
        });
        tbarContainer.inject(td);
        td.inject(canvas);
        canvas.inject(this.getTBody());
    },

    selectRow: function(canvas, r, idx) {
        var self = this;

        canvas.addClass('x-grid-line-selected');
        this.selections.push(r);

        if (self.enableHistory){
            self.history.add(r);
        }

        this.fireListener('selected', r, idx);
    },
    unselectRow: function(canvas, r, idx) {
        var self = this;
        canvas.removeClass('x-grid-line-selected');
        var index = this.selections.indexOf(r);
        if (index != -1) {
            delete this.selections[index];
            this.selections = this.selections.clean();

            if (self.enableHistory){
                self.history.remove(r);
            }

            this.fireListener('unselected', r, idx);
        }
    },
    renderRow : function(r, idx, needInjectToTbody)
    {
        var self = this;

        this.isOdd = !this.isOdd;

        var rowId = 'row' + idx;
        var canvas = new Element('tr', {
            'class': 'x-grid-line ' + (this.isOdd ? 'x-grid-line-odd' :  'x-grid-line-even')  + (idx == 0 && self.tbar.length === 0 ? ' x-grid-line-first' : '')
        });

        if (this.multipleSelectable) {
            canvas.addClass('x-grid-line-selectable');
            canvas.addEvent('click', function(e) {
                if (canvas.hasClass('x-grid-line-selected')) {
                    self.unselectRow(canvas, r, idx);
                }
                else {
                    self.selectRow(canvas, r, idx);
                }
            });

            if (self.enableHistory && self.history.exists(r)){
                self.selectRow(canvas, r, idx);
            }
        }

        this.cols.each(function(item, index)
        {
            var cellValue = self.getCellValue(r, item.dataIndex);
            var wordBreakAll = ( item.wordBreakAll === true );
            var colWidth = (RC.isEmpty(item.width) ? 'auto' : (item.width.toString().match(/[0-9]$/)? item.width + 'px' : item.width));
            var cellContent =  item.xtype === undefined && typeOf(cellValue) == 'string' && typeof item.renderer != 'function' ? cellValue : '';

            var td = new Element('td', {
                'class' : 'x-grid-row' + ( wordBreakAll ? ' x-grid-cell-wordBreakAll' : ''),
                'styles': self.viewConfig.getCellStyle({
                    'min-width'      : colWidth,
                    'text-align'     : item.align
                }, item, idx, cellValue, r)
            });

            if (!RC.isEmpty(item.cellAlign)) {
                td.setStyle('text-align', item.cellAlign);
            }

            if (typeof r[item.dataIndex] == 'object' && r[item.dataIndex] != null && r[item.dataIndex].type == 'img') {
                new Element('img', {
                    src : r[item.dataIndex].src,
                    alt : '',
                    styles : {
                        height : r[item.dataIndex].height
                    }
                }).inject(td);
            }

            if (typeof item.extraStyles == 'object') {
                td.setStyles(item.extraStyles);
            }

            if (item.xtype !== undefined) {
                // workaround to fix empty cellValue
                if (self.store.mode == 'remote') {
                    cellValue = item;
                }
                cellValue.xtype = item.xtype;
                cellValue.id = "" + (item.id ? item.id : self.id) + "-" + ( cellValue.id ? cellValue.id + "-" : "") + rowId;
                cellContent = self.createFormElement(cellValue);
            } else if (RC.isMooElement(cellValue)) {
                cellContent = cellValue;
            }
            // if renderer exists
            if (typeof item.renderer == 'function') {
                cellContent = item.renderer(cellValue, r, idx, item.dataIndex);
            }

            if (item.needCut) {
                var wrapContainer = new Element('div', {
                    'class': 'needCut',
                    styles: {
                        width: colWidth
                    }
                });
                setContent(wrapContainer, cellContent);
                cellContent = wrapContainer;
                RC.utils.Text.showTitle(cellContent, td);
            }

            if (!RC.isEmpty(cellContent)) {
                setContent(td, cellContent);
            }

            td.inject(canvas, 'bottom');
            function setContent(target, content) {
                RC.isMooElement(content) ? target.adopt(content) : target.set('html', content);
            }

        });

        // apply class to row
        if (typeof self.getRowClass == 'function') {
            canvas.addClass(self.getRowClass(r, idx));
        }

        (typeof needInjectToTbody != 'undefined'? RC.isTrue(needInjectToTbody) : true) && canvas.inject(this.getTBody());
        return canvas;
    },
    getSelections: function() {
        var self = this;

        if (self.enableHistory) {
            return self.history.getAll();
        } else {
            return this.selections;
        }
    },
    selectAll: function() {
        var self = this;
        var tbody = this.getTBody();
        var rows = null;
        if (this.multipleSelectable) {
            rows = tbody.getElements('> tr.x-grid-line').addClass('x-grid-line-selected');
            self.selections = [];
            self.getStore().each(function(item){
                self.selections.push(item);
                if (self.enableHistory){
                    self.history.add(item);
                }
            });
        }
    },
    unSelectAll: function(preserveHistory) {
        var self = this;
        var tbody = this.getTBody();
        var rows = null;
        if (this.multipleSelectable) {
            tbody.getElements('tr.x-grid-line-selected').removeClass('x-grid-line-selected');
            self.selections = [];
            if (self.enableHistory && !preserveHistory) {
                self.history.clear();
            }
        }
    },
    renderNoDataMsg : function ()
    {
        var self = this;
        var noDataMessage = this.viewConfig.getNoDataMessage();
        if (!RC.isEmpty(noDataMessage)) {
            this.removeRows();
            var _noDataCanvas = new Element('tr',{
                'class': 'x-grid-line x-grid-line-odd x-grid-line-first x-grid-line-last x-grid-line-noData'
            });
            var td = new Element('td', {
                'colspan' : this.cols.length,
                'class' : 'x-grid-row',
                'html'  : typeof noDataMessage == 'object' ? '' : noDataMessage,
                'styles': self.viewConfig.getCellStyle({
                    'text-align'     : 'center'
                }, null, 0)
            });
            if (typeof noDataMessage == 'object') {
                noDataMessage.inject(td);
            }
            td.inject(_noDataCanvas, 'bottom');
            var body = this.getTBody();
            _noDataCanvas.inject(body);
        }
    },
    renderRows : function()
    {
        if (this.store.getCount() == 0) {
            this.renderNoDataMsg();
            return;
        }
        var idx = 0;
        var self = this;
        this.store.getRange().each(function(item)
        {
            self.renderRow(item, idx);
            idx++;
        });
        // add dnd functionality
        if (RC.isTrue(this.drag)) {
            var tableDnD = new TableDnD();
            tableDnD.init(this._container);
        }
        this.fireListener('change');
        this.lastRecordRendered(this.store.getCount());
    },

    /**
     * Get store object
     * @return RC.data.Store
     */
    getStore : function()
    {
        return this.store;
    },

    /**
     * Show component
     */
    show : function()
    {
        this._container.setStyle('display', '');
        this.fireListener('show');
    },

    /**
     * Hide component
     */
    hide : function()
    {
        this._container.setStyle('display', 'none');
        this.fireListener('hide');
    },

    /**
     * Remove rows from table
     */
    removeRows : function()
    {
        var body = this.getTBody();

        var selector = '> tr';
        if (RC.isArray(this.tbar) && this.tbar.length > 0) {
            selector = '> tr.x-grid-line';
        }

        body.getElements(selector).each(function(item) {
            if (item.firstChild != null && item.firstChild.tagName.toLowerCase() == "td") { // is necessary ??
                item.destroy();
            }
        });
        this.selections = [];
        this.fireListener('change');
    },

    reRender : function()
    {
        this.removeRows();
        this.renderRows();
        this.refresh();
    }
});

var currenttable = null;

document.onmousemove = function(ev)
{
    if (currenttable && currenttable.dragObject) {
        ev = ev || window.event;
        var mousePos = currenttable.mouseCoords(ev);
        var y = mousePos.y - currenttable.mouseOffset.y;
        if (y != currenttable.oldY) {
            // work out if we're going up or down...
            var movingDown = y > currenttable.oldY;
            // update the old value
            currenttable.oldY = y;
            // update the style to show we're dragging
            currenttable.dragObject.addClass('DraggingRow');
            // If we're over a row then move the dragged row to there so that the user sees the
            // effect dynamically
            var currentRow = currenttable.findDropTargetRow(y);
            if (currentRow) {
                if (movingDown && currenttable.dragObject != currentRow) {
                    currenttable.dragObject.parentNode.insertBefore(currenttable.dragObject, currentRow.nextSibling);
                } else if (! movingDown && currenttable.dragObject != currentRow) {
                    currenttable.dragObject.parentNode.insertBefore(currenttable.dragObject, currentRow);
                }
            }
        }

        return false;
    }
};

// Similarly for the mouseup
document.onmouseup = function(ev)
{
    if (currenttable && currenttable.dragObject) {
        var droppedRow = currenttable.dragObject;
        // If we have a dragObject, then we need to release it,
        // The row will already have been moved to the right place so we just reset stuff
        droppedRow.removeClass('DraggingRow');
        currenttable.dragObject = null;
        // And then call the onDrop method in case anyone wants to do any post processing
        currenttable.onDrop(currenttable.table, droppedRow);
        currenttable = null; // let go of the table too
    }
};


function getEventSource(evt)
{
    if (window.event) {
        evt = window.event; // For IE
        return evt.srcElement;
    } else {
        return evt.target; // For Firefox
    }
}

function TableDnD()
{
    this.dragObject = null;
    this.mouseOffset = null;
    this.table = null;
    this.oldY = 0;

    this.init = function(table)
    {
        this.table = table;
        var rows = this.table.tBodies[0].rows; //getElementsByTagName("tr")
        for (var i = 0; i < rows.length; i++) {
            var nodrag = rows[i].getAttribute("NoDrag");
            if (nodrag == null || nodrag == "undefined") { //There is no NoDnD attribute on rows I want to drag
                this.makeDraggable(rows[i]);
            }
        }
    };

    this.onDrop = function(table, row)
    {
        var rowId = parseInt(row.id.replace('row', ''));
        var rows = table.getElements('tr[id^=row]');
        for (var q = 0; q < rows.length; q++) {
            if (row.id == rows[q].id)
                break;
        }
        var grid = RC.getCmp(table.id);
        var curRows = grid.getStore().records;
        var r = grid.getStore().records[rowId];
        grid.getStore().records.erase(r);
        var newRows = [];
        var newRowId = q;
        // insert updated object into collection
        for (q = 0; q < curRows.length + 1; q++) {
            if (q == newRowId) {
                newRows[newRows.length] = r;
            } else if (q > newRowId) {
                newRows[newRows.length] = curRows[q - 1];
            } else {
                newRows[newRows.length] = curRows[q];
            }
        }
        grid.getStore().records = newRows;
        grid.rebuildRingDelays(newRowId);
        grid.removeRows();
        grid.renderRows();
    };

    this.getPosition = function(e)
    {
        var left = 0;
        var top = 0;
        if (e.offsetHeight == 0) {
            e = e.firstChild; // a table cell
        }

        while (e.offsetParent) {
            left += e.offsetLeft;
            top += e.offsetTop;
            e = e.offsetParent;
        }

        left += e.offsetLeft;
        top += e.offsetTop;

        return {x:left, y:top};
    };

    /** Get the mouse coordinates from the event (allowing for browser differences) */
    this.mouseCoords = function(ev)
    {
        if (ev.pageX || ev.pageY) {
            return {x:ev.pageX, y:ev.pageY};
        }
        return {
            x:ev.clientX + document.body.scrollLeft - document.body.clientLeft,
            y:ev.clientY + document.body.scrollTop - document.body.clientTop
        };
    };

    /** Given a target element and a mouse event, get the mouse offset from that element.
     To do this we need the element's position and the mouse position */
    this.getMouseOffset = function(target, ev)
    {
        ev = ev || window.event;

        var docPos = this.getPosition(target);
        var mousePos = this.mouseCoords(ev);
        return {x:mousePos.x - docPos.x, y:mousePos.y - docPos.y};
    };

    /** Take an item and add an onmousedown method so that we can make it draggable */
    this.makeDraggable = function(item)
    {
        if (!item) return;
        var self = this; // Keep the context of the TableDnd inside the function
        var el = item.getElement("td[class*=DraggableCell]");
        if (el == null)
            return;
        el.onmousedown = function(ev)
        {
            // Need to check to see if we are an input or not, if we are an input, then
            // return true to allow normal processing
            var target = getEventSource(ev);
            if (target.tagName == 'INPUT' || target.tagName == 'SELECT') return true;
            // look for ability to move row
            if (!RC.getCmp(self.table.id).canMoved) return true;
            currenttable = self;
            self.dragObject = item;
            self.mouseOffset = self.getMouseOffset(item, ev);
            item.addClass('DraggedRow');
            if (item.getNext() != null && item.getNext().hasClass('fmGroupedRow')) {
                var next = item.getNext();
                while (next.hasClass('fmGroupedRow')) {
                    next.addClass('DraggedRow');
                    next = next.getNext();
                }
                if (next.hasClass('fmGroupedRow'))
                    next.getNext().addClass('DraggedRow');
            }
            this.setStyle('cursor', 'move');
            return false;
        }
    };

    /** We're only worried about the y position really, because we can only move rows up and down */
    this.findDropTargetRow = function(y)
    {
        var rows = this.table.tBodies[0].rows;
        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            var nodrop = row.getAttribute("NoDrop");
            // look for current row in grid
            var rowId = parseInt(row.id.replace('row', ''));
            var grid = RC.getCmp(this.table.id);
            var r = grid.store.records[rowId];
            if (r.active === undefined)
                r.active = true;
            if ((nodrop == null || nodrop == "undefined") && r.active) {
                var rowY = this.getPosition(row).y;
                var rowHeight = parseInt(row.offsetHeight) / 2;
                if (row.offsetHeight == 0) {
                    rowY = this.getPosition(row.firstChild).y;
                    rowHeight = parseInt(row.firstChild.offsetHeight) / 2;
                }
                // Because we always have to insert before, we need to offset the height a bit
                if ((y > rowY - rowHeight) && (y < (rowY + rowHeight))) {
                    // that's the row we're over
                    return row;
                }
            }
        }
        return null;
    }
}

RC.grid.History = function(){
    var self = this;

    var selectionsHistory = [];

    self.clear = function(){
        selectionsHistory = [];
    };

    self.remove = function(r, skipClean){
        var index = self.indexOf(r);
        if (index != -1) {
            delete selectionsHistory[index];
            if (!skipClean) {
                selectionsHistory = selectionsHistory.clean();
            }
        }
    };

    self.batchRemove = function(records){
        if (RC.isArray(records)) {
            records.each(function (r) {
                    self.remove(r, false);
                }
            );
            selectionsHistory = selectionsHistory.clean();
        }
    };

    self.indexOf = function(r){
        return selectionsHistory.indexOf(r);
    };

    self.exists = function(r){
        return self.indexOf(r) != -1;
    };

    self.add = function(r){
        if (!self.exists(r)) {
            selectionsHistory.push(r);
        }
    };

    self.getAll = function (){
        return selectionsHistory;
    }

};

RC.reg('grid', RC.grid.GridPanel);


/**
 * A specialized grid implementation to display the list of extensions.
 *
 * @class
 * @name RC.grid.Extensions
 * @extends RC.grid.GridPanel
 * @constructor
 * @param {Object} params The config object
 */

RC.grid.Extensions = function(params) {
    this.isOdd = false;
    this.rowId = 0;
    this.uniqueDataIndex = RC.isEmpty(params.uniqueDataIndex) ? null : params.uniqueDataIndex;
    this.highlightDataIndex = RC.isEmpty(params.highlightDataIndex) ? null : params.highlightDataIndex;
    this.showAddButtons = RC.isEmpty(params.showAddButtons) ? null : params.showAddButtons;
    this.showMessagesCount = params.showMessagesCount === true;
    this.showStatusIcons = params.showStatusIcons === true;
    this.hideExtensionGroupTitle = params.hideExtensionGroupTitle === true;
    params.fixedLayout = true;
    RC.grid.Extensions.superclass.constructor.call(this, params);

    this.filterCallback = params.filterCallback;

};

RC.extend(RC.grid.Extensions, RC.grid.GridPanel, {
    filter: function(callback){

        this.filterCallback = callback;
        this.reRender();

    },
    renderCols : function() {
        return new Element('tr', {});
    },

    getCellValue : function (row, dataIndex) {
        return ( this.store ? this.store.read(row, dataIndex) : row[dataIndex] );
    },
    renderRow : function(r, idx) {
        var self = this;
        var currentType = this.store.read(r, 'type');
        var hideMessages = this.store.read(r, 'hideMessages') === true;

        if (!self.hideExtensionGroupTitle) {
            var canvas = new Element('tr');
            var currentType = this.store.read(r, 'type');
            var td = new Element('td', {
                colSpan : this.cols.length,
                'class': 'system-extensions-title',
                html : '<div class="system-extensions-title">' + this.store.read(r, 'name') + '</div>'
            });

            if (this.showAddButtons) {
                var addButton = new Element('div', {
                    //href:'#',
                    'class': 'system-extensions-title-button',
                    'html': RC.Lang.Common.ADD,
                    'idSuffix': 'add'
                });

                if (this.hasListener('addButtonClick')) {
                    addButton.addEvent('click', function(e) {
                        e.stop();
                        self.fireListener('addButtonClick', currentType);
                    });
                }
                addButton.inject(td, 'top');
            }

            td.inject(canvas);
            canvas.inject($(this.id).getElement('tbody'));
        }
        

        var items = self.getCellValue(r, 'items');

        if (RC.isArray(items)) {

            var showed = 0;

            items.each(function (r) {
                if (!self.filterCallback || self.filterCallback(r)) {
                    showed++;
                    showItem(r);
                }
            });

            if (!showed) showTypeText();

        } else {
            showTypeText();
        }

        function showTypeText() {
            var tr = new Element('tr', {
                'class': 'x-grid-extensionRow'
            });
            var td = new Element('td', {
                'class' : 'x-grid-row x-grid-somecell system-extensions-stub',
                'colSpan': self.cols.length,
                'html'  : self.store.read(r, 'text')
            });
            td.inject(tr, 'bottom');
            tr.inject($(self.id).getElement('tbody'));
        }

        function showItem(item) {
            var tr = new Element('tr', {
                id:'row-' + item.id,
                'class': 'system-extensions-extension x-grid-extensionRow x-grid-row-' + currentType + (item.id == self.highlightDataIndex ? ' system-extensions-extension-selected' : '')
            });
            self.isOdd = !self.isOdd;

            self.cols.each(function(column) {
                if(column.hasOwnProperty('showOnlyForType') && column.showOnlyForType != currentType) return;

                var td,
                    value = item[column.dataIndex] || "",
                    isCallQueue = currentType == 'Department',
                    colSpan = column.colSpan || 1,
                    maxLength = 40,
                    itemValue = truncate(value, maxLength),
                    html = [],
                    tdTitle = value.length > maxLength ? RC.strFromURLEnc(value) : '';

                if (column.dataIndex == 'pin') {
                    var additionalInfo = "";
                    if (item.type == 'Application') {
                        additionalInfo = '<br/>' + (item.tapApplication && truncate(item.tapApplication.name, 10) || RC.Lang.Common.UNASSIGNED);
                    } else {
                        var messages = item['messagesAsString'];

                        var messagesInfo = "";
                        if(self.showMessagesCount) {
                            messagesInfo = (!hideMessages && messages != '&#160;' && !RC.isEmpty(messages) ? ('<div class="x-grid-dataIndex-pin-messages x-messages-small-text">' + RC.Lang.Common.PIN_WITH_MSG + messages + '</div>') : '');
                        } else {
                            var src;
                            var cls, styleDisplay = 'inline';
                            if(item['unreadMessages']) {
                                cls = ' class="msg"';
                                src = RC.getSkinnedRCLibXImageUrl('img/panel/' + (item.id == self.highlightDataIndex ? 'ico_user_msgs_focus.png' : 'ico_user_msgs_normal.png'));
                            } else {
                                cls = '';
                                src = RC.getSkinnedRCLibXImageUrl("img/panel/dot.gif");
                                styleDisplay = 'none';
                            }
                            messagesInfo = ' <img ' + cls + ' src="' + src + '" width="17" height="10" style="display: ' + styleDisplay + '" />';
                        }

                        additionalInfo = messagesInfo;
                    }

                    itemValue && html.push(RC.UI.Message(RC.Lang.Common.PIN_PREFIX, itemValue + additionalInfo));
                } else if (column.dataIndex == 'name') {
                    colSpan = isCallQueue ? 1 : colSpan;

                    var statusImg = 'reddot.png';
                    var statusText = "";
                    switch (item.mailboxState) {
                        case 0:
                            if (item.type == 'Application' && !item.tapApplication) {
                                statusText = RC.Lang.Common.APP_NOT_ASSIGNED;
                                statusImg = "orangedot.png";
                            }
                            else {
                                statusText = RC.Lang.Common.ENABLED;
                                statusImg = "greendot.png";
                            }
                            break;
                        case 1:
                            statusText = RC.Lang.Common.DISABLED;
                            statusImg = "yellowdot.png";
                            break;
                        case 2:
                            statusText = RC.Lang.Common.FROZEN;
                            statusImg = "reddot.png";
                            break;
                        case 3:
                            statusText = RC.Lang.Common.NOT_ACTIVATED;
                            statusImg = "graydot.png";
                            break;
                    }
                    var iconDiv = "";
                    if (self.showStatusIcons) {
                        html.push('<img class="x-grid-extension-dataIndex-name-icon" src="' + RC.getSkinnedRCLibXImageUrl('img/common/' + statusImg) + '" title="' + statusText + '"/>');
                    }
                    var name = itemValue + (item.system ? ' ' + RC.Lang.Common.SUPER_ADMIN:'');
                    if (item.system) {
                        if (itemValue.length > 14) {
                            name = itemValue.substr(0,13) + "..." +(item.system ? ' ' + RC.Lang.Common.SUPER_ADMIN:'');
                        } else {
                            name = itemValue + (item.system ? ' ' + RC.Lang.Common.SUPER_ADMIN:'');
                        }
                    }
                    var nameContentId = 'row-' + item.id + '-name-content';
                    var name = '<div id="' + nameContentId + '" class="x-grid-extension-dataIndex-name-content">' + name + '</div>';
                    html.push("<div class='x-grid-extension-dataIndex-name-wrap'>") ;
                    html.push(name);
                    html.push(getDirectNumbers());
                    html.push("</div>");
                }

                var cellText = html.join('') || "&nbsp;"
                if(RC.isFunc(column.highlightRenderer)){
                    cellText = column.highlightRenderer(cellText);
                }
                td = new Element('td', {
                    'class' : 'x-grid-row x-grid-somecell  x-grid-dataIndex-' + column.dataIndex,
                    'html'  : cellText,
                    'title' : tdTitle,
                    'styles': {
                        'text-align': column.align,
                        'font-size' : column.dataIndex == 'pin' ? '10px' : '12px'
                    },
                    'colSpan': colSpan
                });

                var pinMessages = td.getElement('.x-grid-dataIndex-pin-messages');
                pinMessages && RC.utils.Text.showTitle(pinMessages, td);

                if (column.dataIndex == "membersAvailable" && currentType == 'Department') {
                    var agents = item.agents || [], l = agents.length, cnt = 0;
                    $each(agents, function(agent) {
                       agent.agentStatus == "Available" && cnt++;
                    });
                    td.innerHTML = "";
                    new Element("span", {
                        'class' : "x-locator-link-departmentMembersAvailable x-grid-extension-dataIndex-membersAvailable-content",
                        'html' : RC.UI.Message(RC.Lang.Common.MEMBERS_STATUS, cnt, (l - cnt)),
                        events : {
                            click : function(e) {
                                self.fireListener("onClickToMembersAvailability", {mailboxId : item.id});
                                e.stopPropagation();
                            }
                        }
                    }).inject(td);
                }

                if (column.extraStyle !== undefined) {
                    td.set('style', td.get('style') + ';' + column.extraStyle);
                }

                td.inject(tr, 'bottom');

                function getDirectNumbers() {
                    var directNumbersList = item['directNumbers'];
                    var numHtml = [item['emptyDirectNumberLabel'] || ''];
                    if (!RC.isEmpty(directNumbersList) && directNumbersList != "&#160;" && directNumbersList != "&nbsp;") {
                        directNumbersList.each(function (numberInfo) {
                            var directNumber = numberInfo.directNumber;
                            !RC.isEmpty(directNumber) && numHtml.push('<div class="x-messages-small-text">' + directNumber + '</div>');
                        });
                    }
                    return numHtml.join('');
                }
            });

            tr.inject($(self.id).getElement('tbody'));

            if (self.hasListener('rowclick')) {
                tr.addEvent('click', function() {
                    self.fireListener('rowclick', item, item.id, self);
                });
                tr.setStyle('cursor', 'pointer');
            }

            // See UIA-3565
            //tr.getFirst('td').setStyle('border-left', '1px solid #D8D8D8');
        }

        if (idx == this.store.getCount() - 1) {
            this.fireListener('change');
        }
    },

    /**
     * Used by STORE
     * To clear record in both places, use grid.store.clear();
     */
    removeRows : function() {
        // remove rows from DOM
        this.getTBody() && this.getTBody().empty();
    },
    
    lastRecordRendered: function() {
        if (RC.isEmpty(this.getTBody()) || RC.isEmpty(this.getTBody().getElement('.x-grid-extensionRow:last-child'))) {
            return;
        }
        this.getTBody().getElement('.x-grid-extensionRow:last-child').addClass('x-grid-extensionRow-last');
    },

    markRowAsSelected : function(idx) {
        this.clearSelection();
        var extRow = $("row-" + idx);
        if (extRow == null) return;
        extRow.addClass('system-extensions-extension-selected');
        extRow.getChildren('td').each(function (cell) {
            var msgIcon = cell.getElement('.msg');
            if(msgIcon) {
                msgIcon.src = RC.getSkinnedRCLibXImageUrl('img/panel/ico_user_msgs_focus.png');
            }
        });
        this.highlightDataIndex = idx; // high light the last selected record when store.reload() invoked.
    },

    clearSelection : function() {

        $(this.id).getElements('tr').removeClass('system-extensions-extension-selected');
        $(this.id).getElements('tr').each(function (row) {
            if (!RC.isEmpty(row.get('id'))) {
                row.getChildren('td').each(function (cell) {

                    var msgIcon = cell.getElement('.msg');
                    if(msgIcon) {
                        msgIcon.src = RC.getSkinnedRCLibXImageUrl('img/panel/ico_user_msgs_normal.png');
                    }
                });
            }
        });

        this.highlightDataIndex = null;
    }
});


/**
 * A specialized grid implementation to diplay list of blocked phones.
 *
 * @class
 * @name RC.grid.BlockedPhones
 * @extends RC.grid.GridPanel
 * @constructor
 * @param {Object} params The config object
 */
RC.grid.BlockedNumbers = function(params) {
    this.isOdd = false;
    // todo Remove it
    this.truncateTextToLen = params.truncateTextToLen || params.truncateTextToLen === 0 ? params.truncateTextToLen : 25;
    // ie7 combobox layout problem
    this.layoutLevel = params.layoutLevelMax || 10;
    // create superclass
    RC.grid.BlockedNumbers.superclass.constructor.call(this, params);
};

RC.extend(RC.grid.BlockedNumbers, RC.grid.GridPanel, {
    renderCols : function() {
        var canvas = new Element('tr', {
            'class' : 'fixed'
        });

        this.cols.each(function(item) {
            new Element('th', {
                width   : (RC.isEmpty(item.width) ? 'auto' : item.width + 'px'),
                html    : RC.isEmpty(item.text) ? '&#160;' : item.text,
                'class' : item.extraClass
            }).inject(canvas, 'bottom');
        });

        return canvas;
    },

    renderRow : function(r, idx) {
        var rowId = 'row' + idx;
        var canvas = new Element('tr');
        canvas.addClass("x-grid-numbersRow");

        var self = this;

        this.isOdd = !this.isOdd;

        this.cols.each(function(item) {
            var o = null;
            var html = "";
            var title = "";

            if (item.xtype == 'button') {
                o = new Element('img', {
                    src : item.image,
                    styles : {
                        'cursor' : 'pointer'
                    },
                    events : {
                        'click' : function() {
                            item.handler(r, idx);
                        }
                    }
                });
                if (!(typeof item.visible == 'undefined') && !item.visible)
                    o.setStyle("display", "none");
            }

            if (item.xtype == 'label') {
                html = r[item.dataIndex];
                if (html.length > self.truncateTextToLen) {
                    title = RC.strFromURLEnc(html);
                    var arr = title.split('<br/>');
                    arr.each(function(a, i) {
                        //RC.Console.warn(a);
                        if (a.length > self.truncateTextToLen) arr[i] = a.substr(0, self.truncateTextToLen) + '...';
                    });
                    html = arr.join('<br/>');

                } else {
                    html = RC.strFromURLEnc(html);
                }
                o = new Element('span', {
                    html : html ,
                    'class' : item.labelExtraClass
                });
            }

            if (item.xtype == 'combo') {
                var store = r[item.storeIndex];
                for (var q = 0; q < store.length; q++) {
                    if (r[item.dataIndex] == store[q][0]) {
                        store[q].push('selected');
                        break;
                    }
                }
                o = new RC.form.Combobox({
                    id              : r.id != null ? r.id : rowId + '-combo',
                    store           : store,
                    width           : 190
                }).render();
                // fix ie7 combobox problem with injecting special style
                // max lines = 10
                canvas.setStyles({
                    'position' : 'relative',
                    'z-index'  : self.layoutLevel * 10
                })
                self.layoutLevel = self.layoutLevel > 0 ? self.layoutLevel - 1 : self.layoutLevel;
            }

            if (item.xtype === 'custom') {
                html = item.renderer(r, idx);
                o = new Element('div', {html: html});
                var showTitleElement = o.getElement('.showTitle');
                if (!RC.isEmpty(showTitleElement)) {
                    showTitleElement.addClass('needCut');
                    RC.utils.Text.showTitle(showTitleElement, canvas);
                }
            }

            if (item.xtype === undefined) {
                html = self.store.read(r, item.dataIndex);
                if (html.length > self.truncateTextToLen) {
                    title = RC.strFromURLEnc(html);
                    html = RC.strFromURLEnc(html.substr(0, self.truncateTextToLen) + '...');
                } else {
                    html = RC.strFromURLEnc(html);
                }
            }

            var td = new Element('td', {
                'class' : 'x-grid-row x-grid-somecell x-grid-dataIndex-' + (item.dataIndex ? item.dataIndex : item.xtype),
                'html'  : item.xtype === undefined ? html : '',
                'title' : title.split('<br/>').join(', '),
                'styles': {
                    'width'         : (RC.isEmpty(item.width) ? 'auto' : item.width + "px"),
                    'text-align'    : item.align
                }
            });

            if (o != null)
                td.adopt(o);

            td.inject(canvas, 'bottom');
        });

        canvas.inject(this.getTBody());
    }
});

/**
 * A specialized grid implementation to display the list of forwarding numbers.
 *
 * @class
 * @name RC.grid.Phones
 * @extends RC.grid.GridPanel
 * @constructor
 * @param {Object} params The config object
 */
RC.grid.Phones = function(params)
{
    // create superclass
    RC.grid.Phones.superclass.constructor.call(this, params);
    var self = this;

    var getMinDelay = function()
    {
        var rows = self.store;
        var min_delay = 999999999999;
        if (rows == null) {
            return min_delay;
        }
        for (var i = 0; i < rows.length; i++) {
            if (rows[i].ringDelay >= 0 && rows[i].ringDelay < min_delay) {
                min_delay = rows[i].ringDelay;
            }
        }
        return min_delay;
    };

    this.ringOffset = getMinDelay();
    this.curr_ring_delay = 0;
    this.groupSingle = 0;
    this.groupMember = 1;
    this.groupBegin = 2;
    this.groupEnd = 4;
    this.hasGroups = false;
    this.canMoved = true;

    this.firstGroupedRow = null;
    this.groupedRows = 0;
    this.firstOrderBy = 0;

    this.filter = RC.isFunc(params.filter) ? params.filter : null;

    this.store.addListener('load', this.renderRows, this);
    this.store.removeListener('loadRecord');
    this.store.removeListener('clear');
};

RC.extend(RC.grid.Phones, RC.grid.GridPanel, {
    renderRows : function()
    {
        this.removeRows();
        if (this.store.records.length == 0) {
            return;
        }

        var idx = 0;
        var rows = this.store.records;

        this.hasGroups = false;

        // check for grouping
        // first orderBy2 should be 1 by default
        rows[0].orderBy2 = 1;
        for (idx = 0; idx < rows.length; idx++) {
            var r = rows[idx];
            if (RC.isTrue(r.enabled)) {
                if (r.ringDelay == this.curr_ring_delay) {
                    if (idx > 0) {
                        rows[idx - 1]._gmode = rows[idx - 1]._gmode == this.groupSingle ? this.groupMember | this.groupBegin : this.groupMember;
                        r._gmode = this.groupMember | this.groupEnd;
                        r.orderBy2 = rows[idx - 1].orderBy2;
                        this.hasGroups = true;
                    } else {
                        r._gmode = this.groupSingle;
                    }
                } else {
                    this.curr_ring_delay = r.ringDelay;
                    r._gmode = this.groupSingle;
                    r.orderBy2 = rows[idx - 1] !== undefined ? parseInt(rows[idx - 1].orderBy2) + 1 : 1;
                }
            } else {
                r._gmode = this.groupSingle;
                r.orderBy2 = rows[idx - 1] !== undefined ? parseInt(rows[idx - 1].orderBy2) + 1 : 1;
            }
            r.orderBy = idx + 1;
            rows[idx] = r;
        }

        var self = this;

        rows.each(function(item, idx)
        {
            if (self.filter == null || self.filter(item, idx)) {
                self.renderRow(item, idx).inject(self.getTBody());
            }
        });

        // add dnd functionality
        if (RC.isTrue(this.drag)) {
            var tableDnD = new TableDnD();
            tableDnD.init(this._container);
        }

    },

    doFilter : function(fnCallback)
    {
        this.filter = fnCallback;
        this.renderRows();
    },

    renderCols : function()
    {
        var canvas = new Element('tr', {

        });

        this.cols.each(function(item)
        {
            new Element('th', {
                width   : (RC.isEmpty(item.width) ? 'auto' : item.width + 'px'),
                html    : RC.isEmpty(item.text) ? '&#160;' : item.text,
                'class' : item.extraClass
            }).inject(canvas, 'bottom');
        });

        canvas.getLast('th').setStyle('border-right', '0');

        return canvas;
    },

    renderRow : function(r, idx)
    {
        var rowId = 'row' + idx;
        var canvas = new Element('tr', {
            id : rowId
        });
        var self = this;
        var rows = this.store.records;

        this.cols.each(function(item)
        {
            var o = null;
            var xtype = item.xtype;

            if (xtype === undefined)
                xtype = 'label';

            var text = {};
            if (RC.isFunc(item.renderer)) {
                text = {
                    text : item.renderer(r[item.dataIndex], r)
                }
            } else {
                text = self.cutText(r[item.dataIndex], 20);
            }

            var itemDisabled = RC.isEmpty(item.disabled) ? false : RC.isTrue(item.disabled);

            switch (xtype) {

                default:
                    o = new Element('table', {
                        cellspacing : 0,
                        cellpadding : 0,
                        width       : '100%',
                        html : '<tbody></tbody>'});

                    var value = RC.isEmpty(r[item.dataIndex]) ? '&#160;' : text.text;

                    new Element('tr').adopt(
                        new Element('td', {
                            html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/form/input-left.gif') + '" alt="" style="display: block;"/>'
                        }),
                        new Element('td', {
                            width : '100%',
                            title : text.title,
                            html  : value,
                            styles : {
                                background      : '#e0e0e0',
                                color           : '#666666',
                                'vertical-align': 'middle',
                                'text-align' : RC.isEmpty(item.align) ? 'left' : item.align
                            }
                        }),
                        new Element('td', {
                            html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/form/input-right.gif') + '" alt="" style="display: block;"/>'
                        })).inject(o.getElement('tbody'));
                    break;

                case 'boolean':
                    o = new Element('a', {
                        id   : rowId + '-status',
                        html : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/buttons/default/' + RC.Config.lngCode + '/btn_' + (r[item.dataIndex] ? 'on' : 'off') + '_small.gif') + '" alt="" />',
                        events : {
                            'click' : function()
                            {
                                if (itemDisabled) {
                                    return;
                                }
                                var enabled = !(this.getElement('img').src.indexOf('_on') > -1);
                                this.getElement('img').set('src', RC.getSkinnedRCLibXImageUrl('img/buttons/default/' + RC.Config.lngCode + '/btn_' + (enabled ? 'on' : 'off') + '_small.gif'));
                                if (r._gmode & self.groupMember) {
                                    self.ungroupPhones();
                                } else {
                                    var selectElement = this.getParent().getParent().getElement('select');
                                    if (selectElement != null) {
                                        selectElement.set('disabled', !enabled);
                                    }
                                }

                                if (!enabled) {

                                    function rowIsEmptyOrNoPhoneNumber(row)
                                    {
                                        return (RC.isEmpty(row) || !row.phoneNumberInfo || RC.isEmpty(row.phoneNumberInfo.number));
                                    }

                                    curRows = self.store.records;
                                    var rowsCount = curRows.length;
                                    curRows.erase(r);
                                    r._gmode = self.groupSingle;
                                    r.enabled = false;
                                    r.ringDelay = 0;
                                    r.ringCycle = 4;

                                    newRows = [];
                                    var inserted = false;
                                    for (var i = 0; i < rowsCount; i++) {
                                        if (!inserted && rowIsEmptyOrNoPhoneNumber(curRows[i])) {
                                            newRows.push(r);
                                            inserted = true;
                                        }
                                        if (!RC.isEmpty(curRows[i])) {
                                            newRows.push(curRows[i]);
                                        }
                                    }
                                    self.store.records = newRows;

                                } else if (r.phoneNumberInfo !== undefined && !RC.isEmpty(r.phoneNumberInfo.number)) {
                                    var findLastActiveRow = function()
                                    {
                                        var isActive = false;
                                        for (var q = 0; q < self.store.records.length; q++) {
                                            if (self.store.records[q].enabled && !isActive)
                                                isActive = true;
                                            else if (!self.store.records[q].enabled && isActive)
                                                return parseInt(q - 1);
                                        }
                                        return -1;
                                    };


                                    // set ring delay
                                    var lastActiveRowId = parseInt(findLastActiveRow());
                                    var lastRingDelay;
                                    if (self.store.records[lastActiveRowId] !== undefined)
                                        lastRingDelay = parseInt(self.store.records[lastActiveRowId].ringDelay) + parseInt(self.store.records[lastActiveRowId].ringCycle);
                                    else
                                        lastRingDelay = 0;
                                    lastActiveRowId++;
                                    // move active row to this position
                                    var curRows = self.store.records;
                                    // delete from current collection
                                    self.store.records.erase(r);
                                    // set new parameters to row
                                    r.enabled = true;
                                    r.ringDelay = lastRingDelay;
                                    r._gmode = self.groupSingle;
                                    var newRows = [];
                                    // insert updated object into collection
                                    for (q = 0; q < curRows.length + 1; q++) {
                                        if (q == lastActiveRowId) {
                                            newRows[newRows.length] = r;
                                        } else if (q > lastActiveRowId) {
                                            newRows[newRows.length] = curRows[q - 1];
                                        } else {
                                            newRows[newRows.length] = curRows[q];
                                        }
                                    }
                                    self.store.records = newRows;
                                }
                                self.renderRows();

                                // fire handler
                                if (RC.isFunc(item.handler)) {
                                    item.handler(enabled, self, idx);
                                }
                            }
                        },
                        styles : {
                            'cursor' : itemDisabled ? 'auto' : 'pointer'
                        }
                    });
                    break;

                case 'phone':
                    o = new Element('table', {
                        cellspacing : 0,
                        cellpadding : 0,
                        width       : '100%',
                        html : '<tbody></tbody>'});

                    if (RC.isTrue(r.forwarding) && !itemDisabled) {
                        new Element('tr').adopt(
                            new Element('td', {
                                html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/form/input-left.gif') + '" alt="" style="display: block;"/>'
                            }),
                            new Element('td', {
                                width : '100%',
                                styles : {
                                    background      : '#e0e0e0',
                                    color           : '#666666',
                                    'vertical-align': 'middle'
                                }
                            }).adopt(new Element('input', {
                                id      : rowId + '-phone',
                                maxLength : 20,
                                value   : r.phoneNumberInfo.formattedNumber,
                                styles  : {
                                    'width'         : '100%',
                                    'background'    : 'none',
                                    'border'        : 0,
                                    'color'         : '#666'
                                },
                                events  : {
                                    'blur' : function(v)
                                    {
                                        if (typeof item.handler == 'function') {
                                            item.handler(v, self, idx);
                                        }
                                    }
                                }
                            })),
                            new Element('td', {
                                html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/form/input-right.gif') + '" alt="" style="display: block;"/>'
                            })).inject(o.getElement('tbody'));
                    } else {
                        new Element('tr').adopt(
                            new Element('td', {
                                html    : r.phoneNumberInfo.formattedNumber,
                                styles  : {
                                    textAlign   : 'left',
                                    padding     : '6px'
                                }
                            })).inject(o.getElement('tbody'));
                    }

                    break;

                case 'combo':
                    o = new Element('select', {
                        id     : rowId + '-combo',
                        styles : {
                            width       : '100%',
                            'text-align': RC.isEmpty(item.align) ? 'left' : item.align
                        },
                        events : {
                            'change' : function()
                            {
                                self.store.records[idx][item.dataIndex] = this.value;
                                // check if in group
                                if (self.store.records[idx]._gmode & self.groupBegin) {
                                    for (var t = idx + 1; t < self.store.records.length; t++) {
                                        if (self.store.records[t]._gmode & self.groupMember && !(self.store.records[t]._gmode & self.groupBegin))
                                            self.store.records[t].ring = this.value;
                                        else
                                            break;
                                    }
                                }
                                self.rebuildRingDelays();

                                // fire handler
                                if (RC.isFunc(item.handler)) {
                                    item.handler(this.value, self, idx);
                                }
                            }
                        }
                    });

                    item.store.each(function (s)
                    {
                        var opt = new Element('option', {
                            value : s.value,
                            html : RC.isEmpty(s.label) ? '&#160;' : s.label
                        });
                        if (r[item.dataIndex] == s.value)
                            opt.set('selected', 'selected');
                        opt.inject(o);
                    });

                    o.set('disabled', !r.active);
                    break;

                case 'checkbox':
                    o = new Element('input', {
                        value : rowId,
                        type : 'checkbox'
                    });
                    o.set('disabled', !r.active);
                    break;

                case 'textfield':
                    o = new Element('div', {
                        html    : /*r.orderBy + ' ' + r.ringDelay + ' ' + r.ring + ' ' + */text.text,
                        title   : text.title,
                        styles  : {
                            'padding'       : '3px',
                            'text-align' : RC.isEmpty(item.align) ? 'left' : item.align
                        }
                    });
                    break;

                case 'image':
                    o = new Element('img', {
                        src     :  item.src,
                        id      : "MoveIcon" + rowId,
                        styles  : {
                            'margin' : RC.isEmpty(item.align) || item.align != 'center' ? '0' : '0 auto'
                        }
                    });
                    break;

                case 'sorting':
                    o = new Element('table', {
                        cellspacing : 0,
                        cellpadding : 0,
                        width       : '100%',
                        id          : "SortTable" + rowId,
                        html : '<tbody></tbody>'});
                    if (self.store.records[idx].enabled) {
                        new Element('tr').adopt(
                            new Element('td', {
                                html  : '<img src="' + item.src.down + '" alt="" style="display: block; cursor:pointer"/>',
                                events : {
                                    'click' : function()
                                    {
                                        var curNew = self.store.records[idx];
                                        var nextNew = self.store.records[idx + 1];
                                        var temp = curNew;
                                        curNew.orderBy = nextNew.orderBy;
                                        nextNew.orderBy = temp.orderBy;

                                        // build new arr of records
                                        var newRows = [self.store.records.length];
                                        for (var i = 0; i < self.store.records.length; i ++) {
                                            if (i != idx && (i != (idx + 1))) {
                                                newRows[i] = self.store.records[i];
                                            }
                                        }
                                        newRows[idx] = nextNew;
                                        newRows[idx + 1] = curNew;
                                        self.store.records = newRows;
                                        self.rebuildRingDelays();
                                        self.renderRows();

                                        // fire handler
                                        if (RC.isFunc(item.handler)) {
                                            item.handler('up', self, idx);
                                        }
                                    }
                                },
                                styles : {
                                    visibility : ((idx == rows.length - 1) || (!(rows[idx + 1]).enabled) || !(self.canMoved)) ? 'hidden' : ''
                                }
                            }),
                            new Element('td', {
                                html  : '<img src="' + item.src.up + '" alt="" style="display: block; cursor:pointer"/>' ,
                                events : {
                                    'click' : function()
                                    {
                                        var curNew = self.store.records[idx];
                                        var prevNew = self.store.records[idx - 1];
                                        var temp = curNew;
                                        curNew.orderBy = prevNew.orderBy;
                                        prevNew.orderBy = temp.orderBy;

                                        // build new arr of records
                                        var newRows = [self.store.records.length];
                                        for (var i = 0; i < self.store.records.length; i ++) {
                                            if (i != idx && (i != (idx - 1))) {
                                                newRows[i] = self.store.records[i];
                                            }
                                        }
                                        newRows[idx] = prevNew;
                                        newRows[idx - 1] = curNew;
                                        self.store.records = newRows;
                                        self.rebuildRingDelays();
                                        self.renderRows();

                                        // fire handler
                                        if (RC.isFunc(item.handler)) {
                                            item.handler('down', self, idx);
                                        }
                                    }
                                },
                                styles : {
                                    visibility : (idx == 0 || !(self.canMoved)) ? 'hidden' : ''
                                }
                            })).inject(o.getElement('tbody'));
                    }
                    break;
            }

            var td = new Element('td', {
                'class'   : 'x-grid-row',
                styles  : {
                    width : (RC.isEmpty(item.width) ? 'auto' : item.width + "px")
                }
            });

            if (item.dataIndex == 'move') {
                td.addClass('DraggableCell');
                if (item.disabled_src === undefined && item.enabled_src === undefined) {
                    o.set('src', item.src);
                } else {
                    // pray that this element goes after those that determine the 'active' field
                    if (r.active !== undefined && !r.active || !self.canMoved) {
                        o.set('src', item.disabled_src);
                    } else {
                        o.set('src', item.enabled_src);
                    }
                }
            }

            if (item.extraStyle !== undefined)
                td.set('style', td.get('style') + ';' + item.extraStyle);

            if ((r._gmode & self.groupMember || r._gmode & self.groupEnd) &&
                (item.dataIndex == 'move' || item.xtype == 'checkbox' || item.dataIndex == 'orderBy2' || item.dataIndex == 'ring') &&
                !(r._gmode & self.groupBegin)) {
                o = null;
            }

            if (o != null) {
                td.adopt(o);
                if (item['disabled'] !== undefined) {
                    td.set('disabled', item['disabled']);
                }
                if (r._gmode & self.groupMember || r._gmode & self.groupEnd) {
                    td.addClass(item['groupingClass']);
                }
                td.inject(canvas, 'bottom');
            }
        });

        if (r.enabled !== undefined && !r.enabled)
            canvas.set("NoDrag", "YES");


        if (r._gmode & this.groupMember) {
            canvas.addClass('fmGroupedRow');
            this.groupedRows++;
        }

        if (r._gmode & this.groupBegin) {
            this.firstGroupedRow = rowId;
            this.firstOrderBy = r.orderBy;
        }

        if (r._gmode & this.groupEnd) {
            var trs = this._container.getElement('tr[id=' + this.firstGroupedRow + ']');
            var tds = trs.getElements('td[class^=x-grid-row]');

            tds.each(function (cell)
            {
                if (cell.get('class').indexOf('fmGroupedRowEnd') != -1) {
                    cell.set('rowspan', self.groupedRows);
                }
            });

            canvas.addClass('fmGroupedRowBoth');

            trs.removeClass('fmGroupedRow');

            // set class to previous row
            if (trs.getPrevious() != null && !trs.getPrevious().hasClass('fmGroupedRow'))
                trs.getPrevious().addClass('fmGroupedRowBegin');

            this.groupedRows = 0;
            this.firstOrderBy = 0;
        }


        return canvas;
    },

    rebuildRingDelays : function()
    {
        var flagRingDelay = null;
        var flagRingCycle = 0;
        var rows = this.store.records;
        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            if (!row.active)
                continue;
            var prevRow = rows[i - 1];

            // start grouping
            if (row._gmode & this.groupBegin) {
                flagRingDelay = prevRow === undefined ? 0 : parseInt(prevRow.ringDelay) + parseInt(prevRow.ring);
            }

            if (flagRingDelay != null)
                rows[i].ringDelay = flagRingDelay;
            else
                rows[i].ringDelay = prevRow === undefined ? 0 : parseInt(prevRow.ringDelay) + parseInt(prevRow.ring);

            // end grouping
            if (row._gmode & this.groupEnd)
                flagRingDelay = null;
        }
    },


    // Notice: is not using for now
    groupPhones : function()
    {
        var inputs = $(this.id).getElements('input[type=checkbox]');
        if (inputs.length == 0)
            return false;

        var firstRingDelay = null;
        var firstRingCycle = null;
        var firstOrderBy = null;
        var orderBy = null;
        var self = this;
        var groupedArr = [];
        var rows = this.store.records;
        var wasGrouped = 0;

        // fast check for checked inputs
        inputs.each(function(r)
        {
            if (r.checked)
                wasGrouped++;
        });

        if (wasGrouped <= 1)
            return false;

        inputs.each(function(r)
        {
            if (!r.checked) {
                return;
            }

            var idx = r.value.replace('row', '');
            var totalIdx = parseInt(idx) + 1;

            // check for grouped row
            if ($(self.id).getElement('tr[id=row' + totalIdx + ']') != null &&
                $(self.id).getElement('tr[id=row' + totalIdx + ']').hasClass('fmGroupedRow')) {
                if ($(self.id).getElement('tr[id=row' + totalIdx + ']').hasClass('fmGroupedRowBoth'))
                    totalIdx++;
                else {
                    while (!$(self.id).getElement('tr[id=row' + totalIdx + ']').hasClass('fmGroupedRowBoth')) {
                        totalIdx++;
                    }
                }
            }

            for (var q = idx; q < totalIdx; q++) {
                var row = rows[q];
                if (row === undefined)
                    continue;
                // remember first entrance
                if (firstRingDelay == null) {
                    firstRingDelay = parseInt(row.ringDelay);
                    firstRingCycle = parseInt(row.ring);
                    firstOrderBy = row.orderBy;
                    orderBy = firstOrderBy;
                }

                row.ringDelay = firstRingDelay;
                row.ring = firstRingCycle;
                row.orderBy = orderBy;

                groupedArr[groupedArr.length] = row;
                orderBy++;

                // delete this element from common array
                delete self.store.records[q];
            }
        });


        if (groupedArr.length <= 1)
            return false;

        var newRows = [];
        var rowsInserted = false;

        if (groupedArr[0].orderBy == 1) {
            groupedArr.each(function(t)
            {
                newRows[newRows.length] = t;
            });
            rowsInserted = true;
        }

        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            if (row == undefined)
                continue;
            // change orderby
            if (rowsInserted) {
                var ringDelay = newRows[newRows.length - 1].ringDelay;
                if (parseInt(row.ringDelay) > parseInt(newRows[newRows.length - 1].ringDelay)) {
                    var prevMode = newRows[newRows.length - 1]._gmode;
                    if (prevMode == this.groupSingle ||
                        prevMode & this.groupEnd ||
                        (prevMode & this.groupEnd && row._gmode & this.groupBegin))
                        ringDelay = parseInt(newRows[newRows.length - 1].ringDelay) + parseInt(newRows[newRows.length - 1].ring);
                }
                row.ringDelay = ringDelay;
                row.orderBy = newRows[newRows.length - 1].orderBy + 1;
            }
            // we don't want set ring delay for disabled phones
            if (!row.active)
                row.ringDelay = 0;
            newRows[newRows.length] = row;
            if (!rowsInserted && row.orderBy == firstOrderBy - 1) {
                groupedArr.each(function(t)
                {
                    newRows[newRows.length] = t;
                });
                rowsInserted = true;
            }
        }

        this.store.records = newRows;
        this.renderRows();

        return true;
    },

    ungroupPhones : function()
    {
        var wasUnGrouped = false;
        var firstRingDelay = null;
        var firstRingCycle = null;
        var firstOrderBy = null;
        var orderBy = null;
        var self = this;
        var idx = 0;

        var rows = this.store.records;

        self.store.records.each(function(r)
        {
            if (!r.active) {
                return;
            }

            var row = r;
            if (!(row._gmode & self.groupBegin))
                return;

            wasUnGrouped = true;

            var totalIdx = parseInt(idx) + 1;

            // check for grouped row
            if ($(self.id).getElement('tr[id=row' + totalIdx + ']') != null &&
                $(self.id).getElement('tr[id=row' + totalIdx + ']').hasClass('fmGroupedRow')) {
                while (!$(self.id).getElement('tr[id=row' + totalIdx + ']').hasClass('fmGroupedRowBoth')) {
                    totalIdx++;
                }
                if ($(self.id).getElement('tr[id=row' + totalIdx + ']').hasClass('fmGroupedRowBoth'))
                    totalIdx++;
            }

            for (var q = idx; q < totalIdx; q++) {
                row = self.store.records[q];

                // remember first entrance
                if (q == idx) {
                    firstRingDelay = parseInt(row.ringDelay);
                    firstRingCycle = parseInt(row.ring);
                    orderBy = parseInt(row.orderBy);
                } else {
                    row.ringDelay = parseInt(self.store.records[q - 1].ringDelay) + firstRingCycle;
                }

                row.ring = firstRingCycle;
                row.orderBy = orderBy;

                orderBy++;

                self.store.records[q] = row;
            }

            // set other ringDelay
            for (var i = q; i < self.store.records.length; i++) {
                row = self.store.records[i];
                if (row._gmode == self.groupSingle || row._gmode & self.groupBegin)
                    row.ringDelay = parseInt(self.store.records[i - 1].ringDelay) + parseInt(self.store.records[i - 1].ring);
                if (row._gmode & self.groupMember && !(row._gmode & self.groupBegin))
                    row.ringDelay = parseInt(self.store.records[i - 1].ringDelay);
                self.store.records[i] = row;
            }

            idx++;
        });

        if (wasUnGrouped) {
            this.renderRows();
        }

        return wasUnGrouped;
    },

    disableRowsMovement : function()
    {
        this.canMoved = false;
        var item;
        this.cols.each(function(column)
        {
            if (column.dataIndex == 'move') {
                item = column;
            }
        });

        var rowNum = 0;
        var self = this;
        var rows = this.store.records;
        rows.each(function(row)
        {
            var moveImg = $(self.id).getElement('img[id="MoveIconrow' + rowNum + '"]');
            moveImg.set('src', item.disabled_src);
            rowNum++;
        });
    },

    enableRowsMovement : function()
    {
        this.canMoved = true;
        var item;
        this.cols.each(function(column)
        {
            if (column.dataIndex == 'move') {
                item = column;
            }
        });

        var rowNum = 0;
        var self = this;
        var rows = this.store.records;
        rows.each(function(row)
        {
            var moveImg = $(self.id).getElement('img[id="MoveIconrow' + rowNum + '"]');
            if (row.enabled !== undefined && !row.enabled) {
                moveImg.set('src', item.disabled_src);
            } else {
                moveImg.set('src', item.enabled_src);
            }

            rowNum++;
        });
    },

    enableRowsSorting : function()
    {
        this.canMoved = true;
        var item;
        this.cols.each(function(column)
        {
            if (column.dataIndex == 'sorting') {
                item = column;
            }
        });

        var rowNum = 0;
        var self = this;
        var rows = this.store.records;
        rows.each(function(row)
        {
            var sortTable = self.getTBody().getElements('table[id="SortTablerow' + rowNum + '"]');
            if (row.enabled !== undefined && !row.enabled) {
                sortTable.set('style', 'visibility:hidden');
            } else {
                sortTable.set('style', 'visibility:');
            }

            rowNum++;
        });
    },

    disableRowsSorting : function()
    {
        this.canMoved = false;
        var item;
        this.cols.each(function(column)
        {
            if (column.dataIndex == 'sorting') {
                item = column;
            }
        });

        var rowNum = 0;
        var self = this;
        var rows = this.store.records;
        rows.each(function(row)
        {
            var sortTable = self.getTBody().getElements('table[id="SortTablerow' + rowNum + '"]');
            sortTable.set('style', 'visibility:hidden');
            rowNum++;
        });
    }

});


/**
 * A specialized grid implementation to display the list of extensions/numbers during upgrade procedure.
 *
 * @class
 * @name RC.grid.Upgrade
 * @extends RC.grid.GridPanel
 * @constructor
 * @param {Object} params The config object
 */
RC.grid.Upgrade = function(params)
{
    this.isOdd = false;
    // create superclass
    RC.grid.Upgrade.superclass.constructor.call(this, params);
    this.scrolling = params.scrolling;
    this.highlightFlag = params.highlightFlag;

    this.maxSelectedRows = RC.isEmpty(params.maxSelectedRows) ? null : params.maxSelectedRows
};

RC.extend(RC.grid.Upgrade, RC.grid.GridPanel, {
    renderCols : function()
    {
        var canvas = new Element('tr', {
            'class' : 'fixed'
        });

        this.cols.each(function(item)
        {
            new Element('td', {
                width   : (RC.isEmpty(item.width) ? 'auto' : item.width + 'px'),
                html    : RC.isEmpty(item.text) ? '&#160;' : item.text,
                'class' : item.extraClass,
                'styles' : {
                    'height'     : '38px',
                    'color'      : '#fff',
                    'background-color'    : '#6e6e6e',
                    'text-align' : 'center',
                    'border-top' : '1px solid #D8D8D8',
                    'border-right' : '1px solid #D8D8D8',
                    'vertical-align' : 'middle',
                    'font-weight': 'bold',
                    'padding-left' : '5px'
                }
            }).inject(canvas, 'bottom');
        });

        canvas.getFirst('td').setStyle('border-left', '1px solid #D8D8D8');
        canvas.getLast('td').setStyle('border-right', '1px solid #D8D8D8');

        if (this.store.size() == 0)
            canvas.getElements('td').each(function(item)
            {
                item.setStyle('border-bottom', '1px solid #D8D8D8');
            });

        return canvas;
    },

    renderRow : function(r, idx)
    {
        var rowId = 'row' + idx;
        var canvas = new Element('tr');

        var self = this;

        var bgColor = this.isOdd ? '#e5e5e5' : '#f2f2f2';
        this.isOdd = !this.isOdd;

        this.cols.each(function(item)
        {
            var o = null;
            var checked = false;
            if (!RC.isEmpty(item.value)) {
                if (RC.isArray(item.value)) {
                    for (var c = 0; c < item.value.length; c++) {
                        if (r[item.dataIndex] == item.value[c]) {
                            checked = true;
                            break;
                        }
                    }
                } else {
                    checked = r[item.dataIndex] == item.value;
                }
            }

            if (item.xtype == 'checkbox') {
                var clickEvent = function()
                {
                    var elmt = this;
                    while(true) {
                        elmt = elmt.getParent();
                        if(elmt == null) {
                            return;
                        }
                        if(elmt.tagName == 'TR') {
                            break;
                        }
                    }

                    var input = elmt.getElement('input[id=' + item.dataIndex +']');
                    if(input == null) {
                        return;
                    }

                    if(RC.isTrue(input.disabled)) {
                        return;
                    }

                    input.checked = !input.checked;

                    var imgs = elmt.getElements('img[id=' + item.dataIndex + '_img]');
                    if(!RC.isEmpty(imgs)) {
                        imgs.each(function(img) {
                            img.set('src', RC.getSkinnedRCLibXImageUrl('img/panel/form/checkbox' + (input.checked ? '-checked' : '') + '.gif'));
                        });
                    }

                    imgs = elmt.getElements('img[id=' + item.dataIndex + '_img_inverted]');
                    if(!RC.isEmpty(imgs)) {
                        imgs.each(function(img) {
                            img.set('src', RC.getSkinnedRCLibXImageUrl('img/panel/form/checkbox' + (!input.checked ? '-checked' : '') + '.gif'));
                        });
                    }

                    self.doMaxSelectedRowsCheck();

                    self.fireListener('change', input.checked);
                };

                var inverted = RC.isTrue(item.inverted);

                var renderInput = canvas.getElement('input[id=' + item.dataIndex +']') == null;
                var checkboxImgSrc = RC.getSkinnedRCLibXImageUrl('img/panel/form/checkbox' + ((inverted ? !checked : checked) ? '-checked' : '') + '.gif');
                o = new Element('span', {
                    html: (renderInput ? ('<input type="checkbox" id="' + item.dataIndex + '" name="' + item.dataIndex + '" value="' + r[item.dataIndex] + '" ' + (checked ? 'checked="true"' : '') + ' style="display: none;"/>') : '') +
                          '<img  id="' + item.dataIndex + '_img' + (inverted ? '_inverted' : '') +  '" src="' + checkboxImgSrc + '" alt="" />',
                    events : {
                        'click' : clickEvent
                    }
                });
            }

            if (item.xtype == 'radio') {
                var fnHandler = function()
                {
                    // set hidden field
                    var input = this.getElement('input');
                    if (input == null)
                        input = this.getPrevious().getElement('input');
                    input.checked = true;

                    // set visual effect
                    var img = this.getElement('img[class=x-radio-group-img]');
                    if (img == null)
                        img = this.getPrevious().getElement('img[class=x-radio-group-img]');
                    if (img != null) {
                        $(self.id).getElements('img[class=x-radio-group-img]').each(function(its)
                        {
                            if (its.src.indexOf('radio-') > -1)
                                its.src = RC.getSkinnedRCLibXImageUrl('img/buttons/radio-off.gif');
                        });
                        img.set('src', RC.getSkinnedRCLibXImageUrl('img/buttons/radio-' + (input.checked ? 'on' : 'off') + '.gif'));
                    }

                    // fire item events
                    if (typeof item.handler == 'function')
                        item.handler();

                    // fire group events
                    self.fireListener('change', input.value, self.formId);
                };

                var radHtml = '<input type="radio" id="' + item.dataIndex + '" name="' + item.dataIndex + '" value="' + r[item.dataIndex] + '" ' + (checked ? 'checked="true"' : '') + ' style="display: none;"/>' +
                        '<img class="x-radio-group-img" src="' + RC.getSkinnedRCLibXImageUrl('img/buttons/radio-' + (checked ? 'on' : 'off') + '.gif') + '" alt="" style="margin: 0 10px;"/>'

                if (!RC.isEmpty(item.markerImg) && r[item.dataIndex] == item.markerId) {
                    o = new Element('table', {
                        html:   '<tr><td style="padding:0;width:99%;font-weight:bold;text-align:left;color:#fff;vertical-align:middle;background:url(' +
                                item.markerImg + ') left no-repeat;"><span style="padding-left:10px;">' + item.markerText + '</span></td>' +
                                '<td style="padding:0;margin:0;width:1%;vertical-align:middle;text-align: right;">' + radHtml + '</td></tr>',
                        styles: {
                            'border-top': RC.isTrue(self.border) ? '1px solid #cccccc' : '',
                            'padding': RC.isTrue(self.border) ? '10px 0' : '',
                            'margin': '0',
                            'height': + item.markerImgHeight + 2,
                            'vertical-align' : 'top'
                        },
                        'events': {
                            'click': fnHandler
                        }
                    });
                } else {
                    o = new Element('div', {
                        html:   radHtml,
                        styles: {
                            'border-top': RC.isTrue(self.border) ? '1px solid #cccccc' : '',
                            'padding': RC.isTrue(self.border) ? '10px 0' : '',
                            'vertical-align' : 'top'
                        },
                        'events': {
                            'click': fnHandler
                        }
                    });
                }

            }

            var td = new Element('td', {
                'class' : 'x-grid-row',
                'html'  : item.xtype === undefined ? self.store.read(r, item.dataIndex) : '',
                'styles': {
                    'width'          : (RC.isEmpty(item.width) ? 'auto' : item.width + "px"),
                    'text-align'     : item.align,
                    'border-right'   : '1px solid #D8D8D8',
                    'vertical-align' : 'middle',
                    'background'     : bgColor
                }
            });

            if (self.extraRowStyle != null)
                td.set('style', td.get('style') + '; ' + self.extraRowStyle);
            if((!RC.isEmpty(self.highlightFlag) && RC.isTrue(r[self.highlightFlag])) && !RC.isEmpty(item.highlightStyle))
                td.set('style', td.get('style') + '; ' + item.highlightStyle);

            if (o != null)
                td.adopt(o);

            td.inject(canvas, 'bottom');
        });

        canvas.getFirst('td').setStyle('border-left', '1px solid #D8D8D8');
        canvas.getLast('td').setStyle('border-right', '1px solid #D8D8D8');


        canvas.inject(this.getTBody());
    },

    doMaxSelectedRowsCheck : function() {
        if(this.maxSelectedRows == null) {
            return;
        }
        var selectedRowsCount = 0;
        var idCol = null;
        for (var i = 0; i < this.cols.length; i++) {
            if ('checkbox' == this.cols[i].xtype) {
                idCol = this.cols[i];
                break;
            }
        }
        if (idCol == null) {
            return;
        }

        var inputs = $(this.id).getElements('input');
        if (RC.isEmpty(inputs)) {
            return;
        }

        var grid = this;

        inputs.each(function(input)
        {
            if (input.type == idCol.xtype && input.name == idCol.dataIndex && input.checked) {
                selectedRowsCount++;
            }
        });

        var disableUncheckedRows = selectedRowsCount >= this.maxSelectedRows;

        inputs.each(function(input)
        {
            if (input.type == idCol.xtype && input.name == idCol.dataIndex) {
                if(!input.checked) {
                    input.disabled = disableUncheckedRows;
                    input.getNext().set('src', RC.getSkinnedRCLibXImageUrl('img/panel/form/checkbox' + (disableUncheckedRows ? '-disabled' : '') + '.gif'));
                }
            }
        });
    },

    getSelectedRows : function()
    {
        var selectedRows = [];
        var idCol = null;
        for (var i = 0; i < this.cols.length; i++) {
            if ('radio' == this.cols[i].xtype || 'checkbox' == this.cols[i].xtype) {
                idCol = this.cols[i];
                break;
            }
        }
        if (idCol == null) {
            return selectedRows;
        }

        var inputs = $(this.id).getElements('input');
        if (RC.isEmpty(inputs)) {
            return selectedRows;
        }

        var grid = this;

        inputs.each(function(input)
        {
            if (input.type == idCol.xtype && input.name == idCol.dataIndex && input.checked) {
                for (var j = 0; j < grid.store.records.length; j++) {
                    var rec = grid.store.records[j];
                    if (rec[idCol.dataIndex] == input.value) {
                        selectedRows[selectedRows.length] = rec;
                        break;
                    }
                }
            }
        });

        return selectedRows;
    }
});

/**
 * Implements accordion panel
 *
 * @class
 * @name RC.grid.List
 * @extends RC.Element
 * @constructor
 * @xtype accordian
 */
RC.grid.List = function(params) {

    // create superclass
    RC.grid.List.superclass.constructor.call(this, params);

    var self = this;

    /**
     * @cfg {RC.data.Store} store
     * Data store
     */
    this._store = params.store;

    /**
     * @cfg {RC.Element|Element|String} placeholder
     * Placeholder when no items are found/filtered
     * May be a RC.Element instance, MooTools Element instance or a simple HTML string
     */
    this.placeholder = params.placeholder;

    /**
     * @cfg {Boolean} selectable
     */
    this.selectable = RC.isDefined(params.selectable) ? params.selectable : true;

    /**
     * @cfg {RC.Element|Element|String} template
     * Template container for list items
     * May be a RC.Element instance, MooTools Element instance or a simple HTML string
     * (!) Markup should contain element with a class "x-grid-list-content", which will be used as a content area
     */
    this.template = params.template;

    /**
     * @cfg {RC.Element|Element|String} template
     * Template container for list stub items
     * May be a RC.Element instance, MooTools Element instance or a simple HTML string
     * These elements will be replaced by progressive on-scroll rendering watcher
     * If no stub provided, the list will be rendered on startup and no watching will be enabled
     */
    this.stub = params.stub;

    /**
     * @cfg {Function} groupBy
     * Callback function to determine group of an item, function must return a string
     * It's important to keep this parameter up to date with groupBy to reflect current grouping method
     * Usage:
     *   groupBy: function(item){ return item.name.substr(0, 1); }
     */
    this._groupBy = params.groupBy;

    /**
     * @cfg {Function} groupRenderer
     * Callback function to create a HTML element when new group is started
     * Should return a RC.Element instance, MooTools Element instance or a simple HTML string
     * It's important to keep this parameter up to date with groupBy to reflect current grouping method
     * Usage:
     *   groupRender: function(item){ return item.name.substr(0, 1); }
     */
    this.groupRenderer = params.groupRenderer;

    /**
     * @cfg {Function} renderer
     * Callback function to create a HTML element for each element of a list
     * Should return a RC.Element instance, MooTools Element instance or a simple HTML string
     * Usage:
     *   renderer: function(item){ return item.name; }
     */
    this.renderer = params.renderer;

    /**
     * @cfg {int} estimatedHeight
     * The estimated height of the item
     * In general, all items must tend to have equal height
     * This property will be updated every time new real node is rendered
     */
    this.estimatedHeight = RC.isEmpty(params.estimatedHeight) ? 20 : params.estimatedHeight;

    /**
     * @cfg {int} preRenderCount
     * Number of items to render at the top of the list on start up
     */
    this.preRenderCount = RC.isEmpty(params.preRenderCount) ? 20 : params.preRenderCount;

    this._itemNodes = [];
    this._selectedItem = null;

    this.addDisposableListener('ready');

    this.initRender();

    /**
     * Store is designed to update itself after each action (clean/add/remove/insert), so only one event handler is needed
     */
    this.getStore().addListener('sort', function() {
        self.update();
    });

};

RC.extend(RC.grid.List, RC.Element, {
    progressiveRenderingEnabled: function(){

        return (!RC.Console.isProgressiveRenderingDisabled() && !RC.isEmpty(this.stub));

    },
    attachScrollBox: function(scrollbox){

        if (!(scrollbox instanceof RC.ScrollBox)) throw 'RC.Scrollbox instance must be provided';

        if (this.progressiveRenderingEnabled()) scrollbox.onScroll(this.updateNodes.bind(this));

    },
    /**
     * Add item into a node
     * Note that only BLOCK or INLINE elements are handled properly when written as pure HTML (no TR, TD, TBODY, etc.)
     * If you are building a table  please use
     *   new Element('tr', {html: '<td>anything</td>'});
     * @param item
     */
    _createContent: function(item) {

        var rendered;

        if (item instanceof RC.Element) {

            rendered = item.compile();

        } else if (RC.isMooElement(item)) {

            rendered = item;

        } else {

            var div = new Element('div', {
                'html': item
            });

            rendered = div.getChildren();
            div.dispose();

            if (rendered.length == 0) { // pure text node
                rendered = document.createTextNode(item);
            }

            if (rendered.length == 1) rendered = rendered[0];

        }

        return rendered;

    },
    _selectNode: function(node){
        node.addClass('x-grid-list-selected');
    },
    unselect: function(){

        this._selectedItem = null;
        this.itemContent.getElements('.x-grid-list-selected').removeClass('x-grid-list-selected');

    },
    select: function(item){

        /**
         * Node selection is only available when storage is fully loaded and grid has been updated at least once
         */
        this.addListener('ready', function(){

            if (!this.selectable) return;

            var index = this.getStore().indexOf(item);

            if (index < 0) return; // Making sure, that item exists in storage

            this.updateNode(index);

            var node = this._itemNodes[index];

            this.fireListener('beforeSelect', item, node, index);
            this.unselect();
            this._selectedItem = item;
            this._selectNode(node);
            this.fireListener('select', item, node, index);

        }.bind(this));

    },
    /**
     * Refresh the list (even when no new filter/sort/group methods)
     */
    update: function() {

        //var profile = 'RC.grid.List.update';
        //RC.Console.profile(profile);

        var self = this;
        var hasRecords = this.getStore().getCount() > 0;

        this.itemPlaceholder.setStyle('display', hasRecords ? 'none' : '');
        this.itemContainer.setStyle('display', !hasRecords ? 'none' : '');
        this.itemContent.empty();

        var getGroup;

        if (!RC.isEmpty(self._groupBy)) {

            getGroup = RC.isFunc(self._groupBy) ? self._groupBy : function(item) {
                return item[self._groupBy.toString()]; // Treat groupBy as a field name
            };

        }

        var lastGroup = '';

        var tempNode = new Element('div');
        this.itemContent.getParent().adopt(tempNode, 'after', this.itemContent);
        this.itemContent.dispose();

        this._itemNodes = [];
        this.getStore().each(function(item, index) {

            if (RC.isFunc(getGroup)) {

                var currentGroup = getGroup(item).toString();

                if (currentGroup != lastGroup) {
                    self.itemContent.adopt(self._createContent(self.groupRenderer(item, index)));
                    lastGroup = currentGroup;
                }

            }

            var node;

            if (!self.progressiveRenderingEnabled() || index < self.preRenderCount) {

                node = self.createRealNode(index);

            } else {

                node = self._createContent(self.stub);
                node.set('id', self.id + '-stub-' + index);
                node.setStyle('height', self.estimatedHeight);

            }

            self._itemNodes[index] = node;
            self.itemContent.adopt(node);

        });

        tempNode.getParent().adopt(this.itemContent, 'after', tempNode);
        tempNode.destroy();

        this.fireListener('ready');

        //RC.Console.profileEnd(profile);

    },
    /**
     * Set new groupBy method
     * @param callback
     * @param groupRenderCallback (optional)
     */
    groupBy: function(callback, groupRenderCallback) {

        this._groupBy = callback;
        if (!RC.isEmpty(groupRenderCallback)) this.groupRenderer = groupRenderCallback;

        this.fireListener('group');

    },
    getStore: function(){

        return this._store;

    },
    createRealNode: function(index){

        var item = this.getStore().getAt(index);
        var node = this._createContent(this.renderer(item, index));

        if (this._selectedItem == item) this._selectNode(node);

        node.addEvent('click', function(e){
            this.select(item);
        }.bind(this));

        node.isRendered = true;

        return node;

    },
    /**
     * Method replaces the stub node with its real equivalent
     * @param index
     */
    injectRealNode: function(index){

        var estimatedHeightChanged = false;
        var stubNode = this._itemNodes[index];
        var node = this.createRealNode(index);

        this._itemNodes[index] = node;

        stubNode.grab(node, 'after');
        stubNode.destroy();

        var size = node.getSize();

        if (size.y) {

            estimatedHeightChanged = this.estimatedHeight != size.y;
            this.estimatedHeight = size.y;

        }

        if (estimatedHeightChanged) this.updateStubNodesHeight();

    },
    /**
     * Check if node is visible, e.g. not hidden, not scrolled out of view, etc.
     * @param node
     * @returns {boolean}
     */
    checkNodeVisibility: function(node){

        var pos = node.getBoundingClientRect();

        var nodeAtPosition = document.elementFromPoint(pos.left, pos.top);

        if (node == nodeAtPosition) return true;

        nodeAtPosition = document.elementFromPoint(pos.left, pos.top + pos.height);

        return (node == nodeAtPosition);

    },
    /**
     * Method updates the height of stub nodes, may be resource-greedy
     */
    updateStubNodesHeight: function(){

        RC.Console.log('RC.grid.List.updateStubNodesHeight(): Stub nodes will be updated');

        this._itemNodes.each(function(node, index){

            if (node.isRendered) return;
            node.setStyle('height', this.estimatedHeight);

        }.bind(this));

    },
    /**
     * Method checks whether stub node require to be updated and update it if necessary
     */
    updateNode: function(index){

        var node = this._itemNodes[index];
        if (node.isRendered) return;
        if (this.checkNodeVisibility(node)) this.injectRealNode(index);

    },
    /**
     * Method checks whether stub nodes require to be updated and update them if necessary
     */
    updateNodes: function(){

        this._itemNodes.each(function(node, index){

            this.updateNode(index);

        }.bind(this));

    },
    initRender: function(){

        this.itemCanvas = new Element('div', {
            'id': this.id,
            'class': 'x-grid-list'
        });

        // Create placeholder
        this.itemPlaceholder = new Element('div', {
            'class': 'x-grid-list-placeholder'
        }).inject(this.itemCanvas);

        this.itemPlaceholder.adopt(this._createContent(this.placeholder));

        // Create container for template
        this.itemContainer = new Element('div', {
            'class': 'x-grid-list-container'
        }).inject(this.itemCanvas);

        this.itemContainer.adopt(this._createContent(this.template));

        // Try to find content element within the template
        this.itemContent = this.itemContainer.getElement('.x-grid-list-content');

        if (!this.itemContent) {

            RC.Console.error('RC.grid.List.render(): Cant find element with class "x-grid-list-content" inside template.');

            // Stub for safety
            new Element('div', {
                'class': 'x-grid-list-content'
            }).inject(this.itemContainer);

        }

    },
    /**
     * Render the component
     */
    render : function() {

        if (this.getStore().autoLoad) { //TODO Maybe store should load itself?
            this.getStore().load();
        }

        this.fireListener('render');

        return this.itemCanvas;

    },

    setPlaceholder: function(item) {
        this.itemPlaceholder.empty();
        this.itemPlaceholder.adopt(this._createContent(item));
    }
});

RC.reg('x-grid-list', RC.grid.List);

RC.grid.Scrollable = function(params) {

    var self = this;

    this.domElements = {
        canvas: null
    };

    this.scrollWidth = params.scrollWidth || '100%';
    this.scrollHeight = params.scrollHeight || '';

    RC.grid.Scrollable.superclass.constructor.call(this, params);

    this.width = '100%';
    this.height = '';

};

RC.extend(RC.grid.Scrollable, RC.grid.GridPanel, {
    render: function() {

        function getScrollBarWidth() {

            var inner = document.createElement('p');
            inner.style.width = "100%";
            inner.style.height = "200px";

            var outer = document.createElement('div');
            outer.style.position = "absolute";
            outer.style.top = "0px";
            outer.style.left = "0px";
            outer.style.visibility = "hidden";
            outer.style.width = "200px";
            outer.style.height = "150px";
            outer.style.overflow = "hidden";
            outer.appendChild(inner);

            document.body.appendChild(outer);
            var w1 = inner.offsetWidth;
            outer.style.overflow = 'scroll';
            var w2 = inner.offsetWidth;
            if (w1 == w2) w2 = outer.clientWidth;

            document.body.removeChild(outer);

            return (w1 - w2);

        }

        var self = this;

        var scrollWidth = getScrollBarWidth();

        var canvas = new Element('div', {
            'id': this.id + '-scrollableCanvas',
            'class': 'x-grid-scrollable'
        });

        canvas.adopt(RC.grid.Scrollable.superclass.render.call(this, []));

        var table = canvas.getElement('table'),
            shim = new Element('div', {
                'html': '&nbsp;',
                'class': 'x-grid-scrollable-shim'
            }).inject(canvas);

        function redraw() {

            var hasData = self.getStore().getCount() > 0;

            var table = canvas.getChildren('table')[0],
                header = table.getChildren('thead')[0],
                body = table.getChildren('tbody')[0],
                firstRow = body.getChildren('tr')[0],
                headerTDs = header.getChildren('tr')[0].getChildren('td, th'),
                rowTDs = firstRow ? firstRow.getChildren('td, th') : [];

            canvas.toggleClass('x-grid-scrollable-hasData', hasData);

            canvas.setStyle('width', self.scrollWidth);
            body.setStyle('width', self.scrollWidth);
            self.scrollHeight && body.setStyle('height', self.scrollHeight);

            if (!hasData) return;

            header.addClass('x-grid-scrollable-computed');

            headerTDs.each(function(headerTD, i) {

                var rowTD = rowTDs[i];

                if (!rowTD) return;

                rowTD.setStyle('min-width', '');
                headerTD.setStyle('min-width', '');

                var headerTDSize = headerTD.getSize();
                var rowTDSize = rowTD.getSize();

                if (headerTDSize.x > rowTDSize.x) rowTD.setStyle('min-width', headerTDSize.x);
                if (rowTDSize.x > headerTDSize.x) headerTD.setStyle('min-width', rowTDSize.x);

            });

            shim.setStyle('height', headerTDs[0].getSize().y + 1);
            shim.setStyle('width', scrollWidth);

            body.addEvent('scroll', function() {

                var scroll = body.getScroll();
                header.getElement('tr').setStyle('marginLeft', -scroll.x);

            });

        }

        this.addListener('change', redraw);
        this.getStore().addListener('load', redraw);

        return canvas;

    }
});

RC.reg('scrollableGrid', RC.grid.Scrollable);

RC.grid.MultiSelector = RC.extend(RC.utils.Observable, {
    events : {
        beforemove: 'beforemove',
        move: 'move',
        ready: 'ready'
    },
    constructor: function(config) {
        RC.grid.MultiSelector.superclass.constructor.call(this, config);

        var self = this;

        this.gridHeight = config.gridHeight;
        this.visible = config.visible !== false;

        this.id = config.id || RC.genId();

        this.enableHistory = config.enableHistory !== undefined ? config.enableHistory : false;

        this.columns = config.columns || [];
        this.identicalColumns = config.identicalColumns !== false;
        this.leftColumns = config.leftColumns || [];
        this.rightColumns = config.rightColumns || [];

        if (this.identicalColumns) {
            this.leftColumns = this.columns;
            this.rightColumns = this.columns;
        }

        this.noDataMessage = config.noDataMessage;

        this.gridWidth = RC.isNumeric(config.gridWidth) ? config.gridWidth : 300;
        this.gridViewConfig = {
            getNoDataMessage: function() {
                return self.noDataMessage;
            }
        };

        this.leftGridStore = config.leftGridStore;
        this.leftCaption = config.leftCaption || '&nbsp;';
        
        this.rightGridStore = config.rightGridStore;
        this.rightCaption = config.rightCaption || '&nbsp;';

        this.tableLayoutFixed = config.tableLayoutFixed === true;

        this._renderCanvas();
    },

    _renderCanvas: function() {
        var self = this;

        var leftAllSelected = false;
        var rightAllSelected = false;

        var selectAllText = RC.Lang.Common.SELECT_ALL;
        var unselectAllText = RC.Lang.Common.UNSELECT_ALL;

        var leftSelectAllButton = new RC.form.Button({
            text: selectAllText,
            handler: function() {
                leftAllSelected = !leftAllSelected;
                if (leftAllSelected) {
                    self.leftGrid.selectAll();
                    self.setRightArrowEnabled(self.leftGrid.getSelections().length > 0);
                    this.set(unselectAllText);
                } else {
                    self.leftGrid.unSelectAll();
                    self.setRightArrowEnabled(false);
                    this.set(selectAllText);
                }
            }
        });

        var rightSelectAllButton = new RC.form.Button({
            text: selectAllText,
            handler: function() {
                rightAllSelected = !rightAllSelected;
                if (rightAllSelected) {
                    self.rightGrid.selectAll();
                    self.setLeftArrowEnabled(self.rightGrid.getSelections().length > 0);
                    this.set(unselectAllText);
                } else {
                    self.rightGrid.unSelectAll();
                    self.setLeftArrowEnabled(false);
                    this.set(selectAllText);
                }
            }
        });

        var leftCaption = new RC.Div({
            id: self.id + '-leftCaption',
            extraClass: 'x-grid-multiselector-caption',
            html: formatCaptionCount(self.leftCaption, 0)
        });

        var rightCaption = new RC.Div({
            id: self.id + '-rightCaption',
            extraClass: 'x-grid-multiselector-caption',
            html: formatCaptionCount(self.rightCaption, 0)
        });

        this.leftGridStore.addListener('sort', function() {
            self._setButtonEnabled(leftSelectAllButton, this.getCount() > 0);
            leftAllSelected = false;
            leftSelectAllButton.set(selectAllText);

            leftCaption.setText(formatCaptionCount(self.leftCaption, this.getCount()));
        });

        this.rightGridStore.addListener('sort', function() {
            self._setButtonEnabled(rightSelectAllButton, this.getCount() > 0);
            rightAllSelected = false;
            rightSelectAllButton.set(selectAllText);

            rightCaption.setText(formatCaptionCount(self.rightCaption, this.getCount()));
        });

        this.leftGrid = new RC.grid.GridPanel({
            columns: self.leftColumns,
            store: self.leftGridStore,
            multipleSelectable: true,
            viewConfig: self.gridViewConfig,
            enableHistory : self.enableHistory,
            tbar: [
                leftSelectAllButton
            ],
            listeners: {
                selected: function(r, idx) {
                    self.setRightArrowEnabled(true);
                    if (this.getSelections().length === this.getStore().getCount()) {
                        leftAllSelected = true;
                        leftSelectAllButton.set(unselectAllText);
                    }
                },
                unselected: function(r, idx) {
                    self.setRightArrowEnabled(self.leftGrid.getSelections().length > 0);
                    leftAllSelected = false;
                    leftSelectAllButton.set(selectAllText);
                }
            }
        });

        this.rightGrid = new RC.grid.GridPanel({
            columns: self.rightColumns,
            store: self.rightGridStore,
            multipleSelectable: true,
            enableHistory : self.enableHistory,
            tbar: [
                rightSelectAllButton
            ],
            listeners: {
                selected: function(r, idx) {
                    self.setLeftArrowEnabled(true);
                    if (this.getSelections().length === this.getStore().getCount()) {
                        rightAllSelected = true;
                        rightSelectAllButton.set(unselectAllText);
                    }
                },
                unselected: function(r, idx) {
                    self.setLeftArrowEnabled(self.rightGrid.getSelections().length > 0);
                    rightAllSelected = false;
                    rightSelectAllButton.set(selectAllText);
                }
            }
        });

        this.rightArrow = new RC.Button({
            iconLeft: RC.getSkinnedRCLibXImageUrl('img/panel/arrow_right_enabled.png'),
            iconLeftDisabled: RC.getSkinnedRCLibXImageUrl('img/panel/arrow_right_disabled.png'),
            text: '&nbsp;',
            width: 30,
            disabled: true,
            handler: function() {
                RC.Loader.show({
                    handler: function() {
                        moveSelectedRecords({
                            startGrid: self.leftGrid,
                            endGrid: self.rightGrid
                        });
                        RC.Loader.hide();
                    }
                });
            }
        });

        this.leftArrow = new RC.Button({
            iconLeft: RC.getSkinnedRCLibXImageUrl('img/panel/arrow_left_enabled.png'),
            iconLeftDisabled: RC.getSkinnedRCLibXImageUrl('img/panel/arrow_left_disabled.png'),
            width: 30,
            disabled: true,
            text: '&nbsp;',
            handler: function() {
                RC.Loader.show({
                    handler: function() {
                        moveSelectedRecords({
                            startGrid: self.rightGrid,
                            endGrid: self.leftGrid
                        });
                        RC.Loader.hide();
                    }
                });
            }
        });
        
        this.canvas = new RC.form.FormPanel({
            id: self.id,
            formContainerClass: 'x-grid-multiselector' + (self.tableLayoutFixed ? ' x-grid-multiselector-tableLayoutFixed' : ''),
            visible: self.visible,
            items: [
                {
                    xtype: 'fieldgroup',
                    items: [
                        {
                            xtype: 'div',
                            items: [
                                leftCaption,
                                new RC.ScrollBox({
                                    id: self.id + '-leftScrollbox',
                                    height: self.gridHeight,
                                    width: self.gridWidth,
                                    allowResize: false,
                                    items: [
                                        self.leftGrid
                                    ]
                                })
                            ]
                        },
                        {
                            xtype: 'div',
                            id: 'buttonsArea',
                            extraClass: 'x-grid-multiselector-buttonsArea',
                            items: [
                                self.rightArrow,
                                self.leftArrow
                            ]
                        },
                        {
                            xtype: 'div',
                            items: [
                                rightCaption,
                                new RC.ScrollBox({
                                    id: self.id + '-rightScrollbox',
                                    height: self.gridHeight,
                                    width: self.gridWidth,
                                    allowResize: false,
                                    items: [
                                        self.rightGrid
                                    ]
                                })
                            ]
                        }
                    ]
                }
            ],
            listeners : {
                domready : function (){
                    self.fireListener(self.events.ready);
                }
            }
        });

        function moveSelectedRecords(cfg) {
            var records = cfg.startGrid.getSelections();
            var startGridStore = cfg.startGrid.getStore();
            var endGridStore = cfg.endGrid.getStore();
            
            if (records.length > 0) {
                var canContinue = true;

                if (self.hasListener(self.events.beforemove)) {
                    canContinue = self.fireListener(self.events.beforemove, records, cfg.startGrid, cfg.endGrid) !== false;
                }

                if (canContinue) {
                    cfg.endGrid.unSelectAll(true);

                    self.setLeftArrowEnabled(false);
                    self.setRightArrowEnabled(false);

                    endGridStore.batchAdd(records);
                    startGridStore.batchRemove(records);

                    self.fireListener(self.events.move, records, cfg.startGrid, cfg.endGrid);
                }
            }
        }

        function formatCaptionCount(caption, count) {
            return RC.UI.Message(caption, count);
        }
    },

    getCanvas: function() {
        return this.canvas;
    },

    _setButtonEnabled: function(btn, enabled) {
        if (!!enabled) {
            btn.enable();
        } else {
            btn.disable();
        }
    },

    setNoDataMessage: function(noDataMessage) {
        this.leftGrid.viewConfig.getNoDataMessage = function() {
            return noDataMessage;
        };
    },

    setRightArrowEnabled: function(enabled) {
        this._setButtonEnabled(this.rightArrow, enabled);
    },

    setLeftArrowEnabled: function(enabled) {
        this._setButtonEnabled(this.leftArrow, enabled);
    },

    getSelections: function() {
        if (!this.rightGridStore) {
            RC.Console.error('The store of right grid is required!');
        }
        return this.rightGridStore;
    },

    setVisible: function(visible) {
        if (!!visible) {
            this.canvas && this.canvas.show();
        } else {
            this.canvas && this.canvas.hide();
        }
    },

    onReady : function(fn){
        var self = this;
        self.addListener(self.events.ready, fn);
    },

    onBefoRemove : function(fn){
        var self = this;
        self.addListener(self.events.beforemove, fn);
    },

    onMove : function(fn){
        var self = this;
        self.addListener(self.events.move, fn);
    }
});

RC.grid.FilterableMultiSelector = RC.extend(RC.utils.Observable, {
    events : {
        beforemove: 'beforemove',
        move: 'move',
        ready : 'ready',
        search: 'search'
    },
    constructor: function(config) {
        this.config = config || {};
        this.id = config.id || RC.genId();
        
        /**@type {RC.form.FormPanel}*/
        this.filterForm = null;

        RC.grid.FilterableMultiSelector.superclass.constructor.call(this, config);

        this.columns = config.columns || [];
        this.leftColumns = RC.clone(this.columns);
        this.rightColumns = RC.clone(this.columns);

        this.filterFunction = RC.isFunc(config.filterFunction) ? config.filterFunction : null;
        this.filterVisible = config.filterVisible !== false;
        this.filterWidth = RC.isNumeric(config.filterWidth) ? config.filterWidth : 300;

        this.searchFieldId = 'search';

        this.clearFilterOnMoving = config.clearFilterOnMoving !== false;

        this.timeout = null;

        // text between search box and multi-selector
        this.promptText = config.promptText;
        this.promptHintText = config.promptHintText;

        this.noDataMessage = config.noDataMessage;
        this.visible = config.visible !== false;

        this.tableLayoutFixed = config.tableLayoutFixed === true;

        this.additionalFilters = config.additionalFilters || [];

        this._renderCanvas();
    },

    _renderCanvas: function() {
        var self = this;

        self.leftColumns.each(function(item) {
            var highlightInSearching = RC.isTrue(item.highlightMatches);
            if (highlightInSearching) {
                var oriRenderer = item.renderer;
                item.renderer = function(v, r, idx, dataIndex) {
                    var html = RC.isFunc(oriRenderer) ? oriRenderer(v, r, idx, dataIndex) : v;
                    return RC.utils.Text.highlightHTML(self.getFilterQuery(), html);
                };
            }
        });

        renderMultiSelector();
        renderFilterForm();

        this.canvas = new RC.Div({
            id: self.id,
            visible: self.visible,
            extraClass: 'x-grid-filterable-multiselector',
            items: function(){
                var items = [];
                items.push(self.filterForm);
                if (!RC.isEmpty(self.promptText)) {
                    items.push({
                        xtype: 'div',
                        html: self.promptText,
                        hintText: self.promptHintText,
                        extraClass: 'x-grid-filterable-multiselector-gap'
                    });
                }
                items.push(self.multiSelector.getCanvas());
                return items;
            }()
        });

        function renderMultiSelector() {
            var multiSelectorId = self.id + '-multiSelector';
            self.multiSelector = new RC.grid.MultiSelector(RC.apply(self.config, {
                id: multiSelectorId,
                visible: true,
                columns: self.columns,
                identicalColumns: false,
                leftColumns: self.leftColumns,
                rightColumns: self.rightColumns,
                noDataMessage: self.noDataMessage,
                tableLayoutFixed: self.tableLayoutFixed,
                listeners: {
                    beforemove: function(records, startGrid, endGrid) {
                        return self.fireListener(self.events.beforemove, records, startGrid, endGrid);
                    },
                    move: function(records, startGrid, endGrid) {
                        var searchField;
                        if (self.clearFilterOnMoving && !RC.isEmpty(self.getFilterQuery())) {
                            searchField = self.filterForm.findField(self.searchFieldId);
                            searchField.setValue('');
                            searchField.fireListener('keyup');
                        }
                        self.fireListener(self.events.move, records, startGrid, endGrid);
                    },
                    ready : function (){
                        self.fireListener(self.events.ready);
                    }
                }
            }));
        }

        function renderFilterForm() {
            self.filterForm = new RC.form.FormPanel({
                id: self.id + '-filterForm',
                visible: self.filterVisible,
                items: [
                    {
                        xtype: 'searchfield',
                        name: self.searchFieldId,
                        id: self.searchFieldId,
                        fieldWidth: self.filterWidth,
                        extraStyle : 'display: inline-block;',
                        listeners: {
                            keyup: function(e) {
                                if (!!self.filterFunction) {
                                    self.multiSelector.setRightArrowEnabled(false);
                                    self.refreshFilter();
                                }
                                self.fireListener(self.events.search, this.getValue());
                            }
                        }
                    }
                ].concat(self.additionalFilters)
            });
        }
    },

    refreshFilter: function() {
        var self = this;
        self.setFilter(self.getFilterQuery());
    },

    applyFilter: function(query) {
        this.filterForm && this.filterForm.findField(this.searchFieldId).setValue(query);
        this.refreshFilter();
    },

    setFilter: function(query) {
        var self = this;
        clearTimeout(self.timeout);
        self.timeout = setTimeout(function() {
                var msg = RC.isEmpty(query) ? self.noDataMessage : RC.Lang.Common.NO_RESULTS;
                self.multiSelector.setNoDataMessage(msg);

                /*
                    Even in case of empty query - the filter makes sense,
                    because it may have other conditions
                 */

                self.multiSelector.leftGridStore.filter(function(item){
                    return self.filterFunction(item, query);
                });
        }, 200);
    },

    getFilterQuery: function(){
        var self = this;
        return self.filterForm && self.filterForm.findField(self.searchFieldId).getValue();
    },

    getCanvas: function() {
        return this.canvas;
    },

    /**
     * Gets {@link RC.grid.MultiSelector} object
     * @return RC.grid.MultiSelector
     */
    getMultiSelector: function() {
        return this.multiSelector;
    },

    getSelections: function() {
        return this.multiSelector ? this.multiSelector.getSelections() : null;
    },
    
    setVisible: function(visible) {
        if (this.canvas) {
            this.canvas.setVisible(!!visible);
        }
    },

    setFilterVisible : function(visible){
        var self = this;
        visible = !!visible; //formPanel API is sensitive to variable type
        self.filterForm.setVisible(visible)
    },

    onReady : function(fn){
        var self = this;
        self.addListener(self.events.ready, fn);
    },

    onBefoRemove : function(fn){
        var self = this;
        self.addListener(self.events.beforemove, fn);
    },

    onMove : function(fn){
        var self = this;
        self.addListener(self.events.move, fn);
    }
});

/**
 * Implements renndering of panel's component
 *
 * @class
 * @name RC.panel.BasePanel
 * @extends RC.Element
 * @param {Array} config The config object
 * @constructor
 * @xtype panel
 */
RC.panel.BasePanel = function(config)
{
    RC.apply(this, config);

    /**
     * @cfg {String/Object} title The title of the panel.
     */
    /**
     * @cfg {Number} titleWidth Will be used when {@link #title} is object
     */
    /**
     * @cfg {Number} titleHeight Will be used when {@link #title} is object
     */
    /**
     * @cfg {String} titleBg Will be used using when {@link #title} is object
     */
    this.title = "";
    this.titleWidth = 328;
    this.titleHeight = 45;
    this.titleBg = "bg-top.gif";

    //todo What we need doing if title is number? @ask denist

    // if title is a string
    if (typeof config.title == 'string')
        this.title = config.title;

    // if title is an object
    if (typeof config.title == 'object') {
        var title = config.title;
        if (!RC.isEmpty(title.title))
            this.title = title.title;
        if (title.width !== undefined)
            this.titleWidth = title.width;
        if (title.height !== undefined)
            this.titleHeight = title.height;
        if (title.background !== undefined)
            this.titleBg = title.background;
    }

    /**
     * @cfg {String} ico The path to icon for title box
     */
    this.ico = RC.isEmpty(config.ico) ? null : config.ico;
    /**
     * @cfg {String} id
     */
    this.id = RC.genPrefixedId({id: config.id, idFromText: this.title});
    /**
     * @cfg {Number} width Width of the panel
     */
    this.width = RC.isEmpty(config.width) ? RC.utils.Layout.mRightPanelWidth : config.width;
    /**
     * @cfg {Number} height Height of the panel
     */
    this.height = RC.isEmpty(config.height) ? null : config.height;
    /**
     * @cfg {Array} filter The filter buttons into header of the panel
     */
    this.filter = RC.isEmpty(config.filter) ? null : config.filter;
    /**
     * @cfg {Boolean} closable True if you want to display 'close' button
     */
    this.closable = RC.isTrue(config.closable);
    /**
     * @cfg {Function} closeHanlder The callback function which will be called when panel was closed
     */
    this.closeHandler = RC.isEmpty(config.closeHandler) ? null : config.closeHandler;
    /**
     * @cfg {Boolean} isGray True if apperance of the panel is gray
     */
    this.isGray = RC.isTrue(config.isGray);
    /**
     * @cfg {Array} bbar The array of buttons for bottom bar
     */
    this.bbar = config.bbar === undefined ? null : config.bbar;
    /**
     * @cfg {String/Object} html Content which will be included into panel
     */
    this.html = RC.isEmpty(config.html) ? null : config.html;

    this.learnMore = config.learnMore || null;
    this.noVerticalPadding = !!config.noVerticalPadding || false;
    this.noHorizontalPadding = !!config.noHorizontalPadding || false;
    this.floating = !!config.floating || false;

    // create superclass
    RC.panel.BasePanel.superclass.constructor.call(this, config);

    this._titleNode = null;
};

RC.extend(RC.panel.BasePanel, RC.Element, {
    removeLearnMore: function(){
        this.setLearnMore(null);
    },
    setLearnMore: function(handler){

        var self = this;
        self.learnMore = handler;

        self._learnMoreNode.empty();

        if (self.learnMore) {
            new Element('a', {
                id    : this.id + '-learnMore',
                'class': 'x-learnMore',
                html: RC.Lang.Common.WINDOW_LEARMORE,
                href: '#',
                events: {
                    click: function(e)
                    {
                        e.stop();
                        self.learnMore();
                        return false;
                    }
                }
            }).inject(self._learnMoreNode);
        }

    },
    /**
     * Render the Element
     * @return {Object} Generated HTMLObject
     */
    render : function()
    {
        var self = this;

        // bottom bar parsing
        if (this.bbar != null) {
            this.bbar = RC.toArray(this.bbar);
            var bbar = new Element('tr').adopt(new Element('td', {
                'class'     : 'x-panel-bbar',
                'colspan'   : 3
            }));

            bbar.getElement('td').adopt(RC.panel.BasePanel.createBBar(this.bbar, this));
        }

        var canvas = new Element('div', {
            'id': this.id + '-canvas',
            'class': 'x-panel-canvas',
            'styles' : {
                width : this.width + 'px'
            }
        }).adopt(
            new Element('table', {
                id          : this.id,
                cellspacing : 0,
                cellpadding : 0,
                'class'     : 'x-panel',
                html        : '<tbody></tbody>',
                styles      : {
                    width   : '100%',
                    height   : RC.isEmpty(this.height)? '610px' : 'auto'
                }
            }));


        var titleCell = new Element('span', {
            id    : this.id + '_title_cell'
        });

        if (this.ico != null) {
            new Element('img', {
                src   : this.ico,
                alt   : '',
                style : "margin: 7px 10px 0 0; float: left;"
            }).inject(titleCell);
        }

        this._titleNode = new Element('div', {
            'class' : 'x-panel-title',
            html  : this.title
        }).inject(titleCell);

        self._learnMoreNode = new Element('div.x-panel-learnMore-container').inject(titleCell, 'top');
        this.setLearnMore(this.learnMore);

        if (this.filter != null) {
            var tRow = new Element('tr');
            var idx = 1;
            this.filter.each(function(r)
            {
                var cState = false;
                if (RC.isTrue(r.active)) {
                    cState = true;
                }
                if (idx == 3) {
                    if (RC.utils.History.getTokenIndexOf(0) == 'all') {
                        cState = true;
                    }
                }
                new Element('td', {
                    html    : RC.strFromURLEnc(r.text),
                    'class'   : 'x-panel-title-filter-cell' + (cState ? ' x-panel-title-filter-cell-selected' : ''),
                    events : {
                        'click' : r.handler
                    }
                }).inject(tRow);
                idx++;
            });

            new Element('table', {
                cellspacing : 0,
                cellpadding : 0,
                'class': 'x-panel-title-filter'
            }).adopt(new Element('tbody').adopt(tRow)).inject(titleCell);
        }

        if (this.closable) {
            new Element('div', {
                id    : "x-close-btn",
                'class': 'x-panel-close',
                html  : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/collapsable/blue-cross.png') + '" alt="" style="cursor: pointer;" />'
            }).inject(titleCell);
        }

        new Element('tr',{'height':'30px'}).adopt(new Element('td').adopt(
            new Element('table', {
                cellspacing : 0,
                cellpadding : 0,
                width        : "100%"
            }).adopt(
                new Element('tbody').adopt(new Element('tr').adopt(new Element('td', {
                    'class': 'x-panel-title-left x-hidden'
                }), new Element('td', {
                    'class': 'x-panel-title-fill',
                    id            : this.id + '-title'
                }), new Element('td', {
                    'class': 'x-panel-title-right x-hidden'
                }))))
            )).inject(canvas.getElement('tbody'), 'bottom');

        canvas.getElements('td[id=' + this.id + '-title]')[0].adopt(titleCell);

        var tdPanel = new Element('td', {
            'id'    : this.id + '-content',
            'html'  : (this.html != null ? '<div>' + this.html + '</div>' : ''),
            'class' : 'x-panel-body-border' + ((RC.isTrue(this.isGray) ? ' x-panel-body-border-gray' : '')),
            'styles': {
                height  : RC.isNumeric(this.height) ? this.height + 'px' : 'auto'
            }
        });

        new Element('tr').adopt(tdPanel).inject(canvas.getElement('tbody'), 'bottom');

        if (this.bbar != null) {
            bbar.inject(canvas.getElement('tbody'), 'bottom');
        }

        new Element('tr',{'height':'10px'}).adopt(
            new Element('td').adopt(
                new Element('table', {
                    cellspacing : 0,
                    cellpadding : 0,
                    width        : "100%"
                }).adopt(
                    new Element('tbody').adopt(new Element('tr', {'class': 'x-panel-bottom' + (this.bbar != null ? ' x-panel-bottom-gray' : '')}).adopt(new Element('td', {
                        'class': 'x-panel-bottom-left x-hidden'
                    }), new Element('td', {
                        'class': 'x-panel-bottom-fill',
                        width        : "100%"
                    }), new Element('td', {
                        'class': 'x-panel-bottom-right x-hidden'
                    })))))).inject(canvas.getElement('tbody'), 'bottom');

        // add action for closable button
        if (this.closable) {
            this.addListener('render', function()
            {
                $('x-close-btn').addEvent('click', function()
                {
                    if (self.closeHandler != null && typeof self.closeHandler == 'function') {
                        self.closeHandler();
                    }
                    self.destroy();
                });
            });
        }

        if (this.noVerticalPadding || this.noHorizontalPadding) {

            var className = '';
            if (this.noVerticalPadding) className += ' x-panel-noVerticalPadding';
            if (this.noHorizontalPadding) className += ' x-panel-noHorizontalPadding';

            canvas.addClass(className);

        }

        if (this.floating) canvas.addClass('x-panel-custom');

        return canvas;
    },

    /**
     * Destroys the element from DOM and registry and fires a {@link #removed} event
     */
    destroy : function()
    {
        $(this.id) && $(this.id).getParent() && $(this.id).getParent().destroy();
        RC.ComponentMgr.unregister(this);
        this.fireListener('removed');
    },

    /**
     * Destroys the element and fires a {@link #removed} event.
     *
     * TODO: Remove this method
     *
     * @param {String} orangeArrow ID of the arrow
     * @param {Function} callback The callback function which will be called after
     */
    hide : function(callback)
    {
        if (typeof callback == 'function') callback();
        this.destroy();
    },

    /**
     * Sets the title of panel
     * @param {String} title
     * @return {Boolean} Result of action
     */
    setTitle : function(title)
    {
        if (typeof title != 'string' || !title) return false;
        this._titleNode.innerHTML = title.substr(0, 40);
        return true;
    },

    /**
     * Sets the title of panel without length constraints
     * @param {String} title
     * @return {Boolean} Result of action
     */
    setUnlimitedTitle : function(title)
    {
        if (typeof title != 'string' || !title) return false;
        this._titleNode.innerHTML = title;
        return true;
    },

    setIcon : function(path)
    {
        if ($(this.id + '_title_icon'))
            $(this.id + '_title_icon').src = path;
        else
            if ($(this.id + '_title_cell')) {
                new Element('img', {
                    id    : this.id + '_title_icon',
                    src   : path,
                    alt   : '',
                    style : "margin: 7px 10px 0 0; float: left;"
                }).inject($(this.id + '_title_cell'), 'top');
            }
    }
});

RC.panel.BasePanel.createBBar = function(items, parentPanel) {

    // bottom bar parsing
    if (!items) return false;

    var self = this;

    items = RC.toArray(items);

    var content = new Element('div');

    var bbarCount = items.length;

    items.each(function(r, index) {

        var botContent = null;

        var elId = RC.genPrefixedId({id: r.id, prefix: parentPanel.id, idFromText: r.text});

        if (r.xtype == 'button') {

            botContent = new RC.GroupButton({
                id: elId,
                text: r.text,
                visible: r.visible,
                enabled: r.enabled,
                extraClass: (index == 0 ? 'x-bbar-first' : '') +
                            (index == bbarCount - 1 ? 'x-bbar-last' : ''),
                handler: function() {
                    if (RC.isFunc(r.handler)) {
                        r.handler();
                    }
                }
            });

        }

        if (r.xtype == 'div') {

            botContent = new RC.Div({
                id: elId,
                html: r.html,
                items: r.items,
                handler: function() {
                    if (RC.isFunc(r.handler)) {
                        r.handler();
                    }
                }
            });

        }


        if (botContent) {

            botContent.compile().inject(content);

        }

    });

    return content;

};

/**
 * Extended Panel
 *
 * @class
 * @name RC.panel.Panel2
 * @extends RC.Element
 * @param {Object} config The config object
 * @contructor
 * @xtype panel2
 */
RC.panel.Panel2 = function(config)
{
    /**
     * @cfg {String} ico The path to icon for title box
     */
    this.ico = RC.isEmpty(config.ico) ? null : config.ico;
    /**
     * @cfg {Number} width Width of the panel
     */
    this.width = RC.isEmpty(config.width) ? null : config.width;
    /**
     * @cfg {Array} bbar The array of buttons for bottom bar
     */
    this.bbar = RC.isEmpty(config.bbar) ? null : config.bbar;

    // todo What is it? Remove?
    this.topStyle = RC.isEmpty(config.topStyle) ? null : config.topStyle;
    this.middleStyle = RC.isEmpty(config.middleStyle) ? null : config.middleStyle;
    this.bottomStyle = RC.isEmpty(config.bottomStyle) ? null : config.bottomStyle;
    /**
     * Customize view of panel
     *
     * Example Usage:
     * object.viewConfig : {
     *      top : null,
     *      middle : null,
     *      bottom : null
     * }
     * @cfg {Object} viewConfig
     */
    this.viewConfig = {
        top : RC.isEmpty(config.topStyle) ? null : config.topStyle,
        middle : RC.isEmpty(config.middleStyle) ? null : config.middleStyle,
        bottom : RC.isEmpty(config.bottomStyle) ? null : config.bottomStyle
    };

    // calling parent constructor
    RC.panel.Panel2.superclass.constructor.call(this, config);
};

RC.extend(RC.panel.Panel2, RC.Element, {
    /**
     * Render the component
     * @return {Object} Generated HTMLObject
     */
    render : function()
    {
        var self = this;
        var canvas = new Element('div', {
            'id'  : this.id + '-panel',
            'html': (this.ico != null || this.title != null || this.topStyle != null ?
                '<div style="' + (this.topStyle == null ? '' : this.topStyle) + '">' +
                    (this.ico != null ? '<img src="' + this.ico + '" alt="" style="margin: 7px 10px 0 18px; float: left;"/>' : '') +
                    (this.title != null ? '<div class="x-panel-title">' + this.title + '</div>' : '') +
                    '</div>' : '') +
                '<div id="' + this.id + '" style="' + (this.middleStyle == null ? '' : this.middleStyle) + '"></div>' +
                (this.bottomStyle != null ? '<div style="' + (this.bottomStyle == null ? '' : this.bottomStyle) + '"></div>' : '')
        });

        if (this.width != null) {
            canvas.setStyle('width', this.width);
        }

        if (this.bbar != null) {
            this.bbar = RC.toArray(this.bbar);

            var bbar = RC.panel.BasePanel.createBBar(this.bbar, this);
            bbar.addClass('x-basepanel-bbar')
            if (self.buttons && self.buttons.length > 0) bbar.addClass('x-basepanel-bbar-with-buttons');


            this.addListener('render', function()
            {
                bbar.inject(canvas.getElementById(self.id + '-buttons'), 'before');
            });
        }

        return canvas;
    },

    /**
     * Destroys the element from DOM and registry and fires a {@link #removed} event
     */
    destroy : function()
    {
        var oldPanel = $(this.id + '-panel');
        if (oldPanel != null) {
            oldPanel.destroy();
        }
        RC.ComponentMgr.unregister(this);
        this.fireListener('removed');
    }
});

RC.reg('panel', RC.panel.BasePanel);
RC.reg('panel2', RC.panel.Panel2);

(function() {

    var pageContentId = 'PageContent';
    var centralPanelIndex = 1;
    var rightPanelIndex = 2;
    var firstDisplay = true;

    var events = {
        display: 'display',
        destroyAll: 'destroyAll',
        destroyRight: 'destroyRight',
        firstDisplay: 'firstDisplay'
    };

    var Class = function(config) {
        config = config || {};
        this.debug = RC.isTrue(config.debug);
        Class.superclass.constructor.call(this, config);
        this.addDisposableListener(events.firstDisplay);
    };

    RC.extend(Class, RC.utils.Observable, {
        clearPageContent: function(){
            this.destroyAll();
            this.getPageContent().empty();
        },
        getPageContent: function() {
            return document.getElement('#' + pageContentId);
        },
        getDOMs: function() {
            return this.getPageContent().getElements('> div');
        },
        getIDs: function() {
            var ids = [];
            this.getDOMs().each(function(panel) {
                var id;
                if (panel.hasClass('x-panel-canvas')) { // Workaround for panels
                    id = panel.getChildren()[0].get('id');
                } else {
                    id = panel.get('id');
                }
                ids.push(id);
            });
            if (this.debug) RC.Console.warn('RC.panel.Manager.getIDs: Existing Panel IDs %a', ids);
            return ids;
        },
        getPanels: function() {
            var panels = [];
            this.getIDs().each(function(id) {
                panels.push(RC.getCmp(id));
            });
            return panels;
        },
        destroyAt: function(indexFrom){
            var panels = this.getPanels();
            for (var index = panels.length - 1; index >= indexFrom; index--) {
                var panel = panels[index];
                if (panel) {
                    if (this.debug) RC.Console.warn('RC.panel.Manager.destroyAt(): Panel id=%s[%i] is about to be destroyed', panel.id, index);
                    if ('destroy' in panel) panel.destroy();
                } else {
                    if (this.debug) RC.Console.error('RC.panel.Manager.destroyAt(): Panel at index[%i] cannot be destroyed', index);
                }
            }
        },
        destroyAll: function(showHelp) {

            this.destroyAt(centralPanelIndex);
            this.fireListener(events.destroyAll, showHelp);
        },
        destroyRight: function(showHelp) {
            this.destroyAt(rightPanelIndex);
            this.fireListener(events.destroyRight, showHelp);
        },
        display: function(panel) {
            panel.display(this.getPageContent());
            if (this.debug) RC.Console.warn('RC.panel.Manager.display: Panel id=%s has been displayed', panel.id);
            this.fireListener(events.display, panel);
            if (firstDisplay) {
                firstDisplay = false;
                this.fireListener(events.firstDisplay, panel);
            }
        },
        onDestroyRight: function(callback){
            this.addListener(events.destroyRight, callback);
        },
        onDestroyAll: function(callback){
            this.addListener(events.destroyAll, callback);
        },
        helpPanel: function(event, openHelpCallback){
            this.removeListener(event);
            this.addListener(event, function(showHelp){
                if (showHelp) openHelpCallback();
            });
            openHelpCallback();
        },
        rightHelpPanel: function(openHelpCallback){
            this.helpPanel(events.destroyRight, openHelpCallback);
        },
        centerHelpPanel: function(openHelpCallback){
            this.helpPanel(events.destroyAll, openHelpCallback);
        },
        onFirstDisplay: function(callback){
            this.addListener(events.firstDisplay, callback);
        }
    });

    RC.panel.Manager = new Class({
        debug: false
    });

})();

/**
 * @class
 * @name RC.panel.TabPanel
 * @extends RC.Element
 * Implements tabbed panel
 * @constructor
 * @xtype tabpanel
 */
RC.panel.TabPanel = function(params)
{
    /**
     * @cfg {String} title The title of the panel.
     */
    this.title = RC.isEmpty(params.title) ? "" : params.title;
    /**
     * @cfg {String} activeTab Id of the active tab
     */
    this.activeTab = RC.isEmpty(params.activeTab) ? null : params.id + '-' + params.activeTab;
    /**
     * @cfg {Number} width Width of the panel
     */
    this.width = RC.isEmpty(params.width) ? null : params.width;
    /**
     * @cfg {Number} totalTabWidth Width of the all tabs
     */
    this.totalTabWidth = params.totalTabWidth || null;
    this.autoAdjustTabWidth = params.autoAdjustTabWidth || false;
    /**
     * @cfg {String} background The path to background of panel
     */
    this.background = RC.isEmpty(params.background) ? '' : params.background;
    /**
     * @cfg {Boolean} isGreeting True if panel is using for greeting controls
     */
    this.isGreeting = params.isGreeting !== undefined ? RC.isTrue(params.isGreeting) : false;

    this.tabItemsAlign = RC.isEmpty(params.tabItemsAlign) ? 'left' : params.tabItemsAlign;
    /**
     * Current active item id. Read-only.
     * @type {String}
     */
    this.currentItemId = null;
    /**
     * Tabs collection
     * @type {Array}
     * @ignore
     */
    this._tabs = [];
    /**
     * Flag to determine hidden tabs
     * @type {Boolean}
     * @ignore
     */
    this.tabsWasHidden = false;

    // create superclass
    RC.panel.TabPanel.superclass.constructor.call(this, params);

    this.addEvents(
        /**
         * @event tabChange
         * Fires when the tab was changes
         * @param {RC.Element} this
         * @param {String} Id of the activated tab
         */
        'tabChange',
        /**
         * @event beforeTabChange
         * Fires before the tab will be changed
         * @param {RC.Element} this
         * @param {String} Id of the activated tab
         */
        'beforeTabChange'
    );
};

RC.extend(RC.panel.TabPanel, RC.Element, {
    /**
     * Render the component
     * @param tabs
     */
    render : function(tabs)
    {
        var self = this;
        var canvas = new Element('div', {
            'id'  : this.id
        });

        if (tabs !== undefined)
            this._tabs = tabs;

        //scrollable tabs
        var SCROLL_WIDTH = 50;
        var SCROLL_MAX_KOEF = 0.8;
        var SCROLL_CHECK_TIME = 400;
        var SCROLL_STEP = 100;
        var SCROLL_DIR_LEFT = 1;
        var SCROLL_DIR_RIGHT = -SCROLL_DIR_LEFT;
        var SCROLL_ANIMATION_DURATION = 500;

        function isPNGSupportedByBrowser()
        {
            return Browser.name !== "ie" || (Browser.name === "ie" && Browser.version > 4 );
        }

        var tabScroller = new Element('table', {
            'id'            : this.id + '-tab-scroller-holder',
            'class'         : 'x-tab-holder',
            'cellpadding'   : '0',
            'cellspacing'   : '0',
            'border'        : '0',
            'width'         : '100%',        //for IE 6
            'html'          : '<tr></tr>'
        }).inject(canvas);
        var tabScrollerTR = tabScroller.getElement('tr');

        //left scroll button
        var btnScrollLeft = new Element('img', {
            'src' : RC.getSkinnedRCLibXImageUrl('img/panel/tabpanel/btn_scroll_left' + (isPNGSupportedByBrowser() ? '.png' : '.gif')),
            'styles' : {
                'cursor' : 'pointer',
                'width' : '25px',
                'height' : '28px'
            }
        }).inject(
            new Element('td', {
                'styles': {
                    'width' : SCROLL_WIDTH / 2 + 'px',
                    'background' :this.background,
                    'display' : 'none'
                }
            }).inject(tabScrollerTR));
        btnScrollLeft.addEvent('click', function ()
        {
            scrollTabs(SCROLL_DIR_LEFT);
        });

        //scrolled area
        var tdScrollerMiddle = new Element('td', {
            'styles': {
                'background' : this.background
            }
        }).inject(tabScrollerTR);

        //right scrolled button
        var btnScrollRight = new Element('img', {
            'src' : RC.getSkinnedRCLibXImageUrl('img/panel/tabpanel/btn_scroll_right' + (isPNGSupportedByBrowser() ? '.png' : '.gif' )),
            'styles' : {
                'cursor' : 'pointer',
                'width' : '25px',
                'height' : '28px'
            }
        }).inject(
            new Element('td', {
                'styles': {
                    'width' : SCROLL_WIDTH / 2 + 'px',
                    'background' :this.background,
                    'display' : 'none'
                }
            }).inject(tabScrollerTR));

        btnScrollRight.addEvent('click', function ()
        {
            scrollTabs(SCROLL_DIR_RIGHT);
        });

        //scrolling function
        function scrollTabs(direction)
        {
            var step = SCROLL_STEP * direction;
            var oldLeft; 								//used to correct animation during multiple clicks
            if (tabsBlock.oldLeft === undefined) {
                oldLeft = tabsBlock.getStyle('left');
                oldLeft = oldLeft.replace("px", "");
                tabsBlock.oldLeft = oldLeft;
            } else {
                oldLeft = tabsBlock.oldLeft;
            }
            var newLeft;
            if (isNaN(oldLeft)) {
                newLeft = step;
            } else {
                newLeft = Number(oldLeft) + step;
            }
            if (newLeft > SCROLL_STEP / 2 && newLeft <= SCROLL_STEP / 2) {
                newLeft = 0;
            }
            var bInBorders = newLeft <= 0 && newLeft > -tabsBlock.offsetWidth + tabHolder.offsetWidth * SCROLL_MAX_KOEF - SCROLL_STEP / 2;
            if (bInBorders) {
                tabsBlock.tween('left', oldLeft, newLeft);
                tabsBlock.oldLeft = newLeft;
            }
        }

        //recheck if scrollbar needed after display

        function checkIfScrollBarNeeded()
        {
            //            var bDisplayed = tabsBlock.offsetWidth > SCROLL_WIDTH;
            // TODO hardcoded width
            //var bDisplayed = tabsBlock.offsetWidth > 250;
            var bDisplayed = false; //TODO Temporary fixed for UIA-1916 (we don't have scrollable tabs)
            if (bDisplayed) {
                tabsBlock.tween('left', 0);	//first animation does not have effect
                SCROLL_STEP = tabHolder.offsetWidth / 2; //correct SCROLL step to actual width

                var bordersCheck = -tabsBlock.offsetWidth + tabHolder.offsetWidth * SCROLL_MAX_KOEF;
                var bSrollNeeded = bordersCheck < 0;
                if (bSrollNeeded) {
                    if (Browser.name === "ie") {
                        btnScrollLeft.parentNode.setStyle('display', '');
                        btnScrollRight.parentNode.setStyle('display', '');
                        var IE_BUG_MARGINS = 40;											//IE creates additional margins to tabHolderElement
                        var IE_INVERSE_MARGIN = -IE_BUG_MARGINS / 2;							//to solve this we create inverse margins
                        tabHolder.setStyles({'margin-left': IE_INVERSE_MARGIN + 'px',        //bug_margin + inverse_margin = 0
                            'margin-right': IE_INVERSE_MARGIN + 'px'});
                    } else {
                        btnScrollLeft.parentNode.setStyle('display', 'table-cell');
                        btnScrollRight.parentNode.setStyle('display', 'table-cell');
                    }


                    //faders
                    var bDisplayFaders = isPNGSupportedByBrowser();
                    if (bDisplayFaders) {
                        var ONE_LINE_TAB_HEIGHT = 45;
                        var bTwoLinesTabs = $(self.id + '-tab-scroller-holder').offsetHeight > ONE_LINE_TAB_HEIGHT;
                        new Element('img', {
                                'src' : RC.getSkinnedRCLibXImageUrl('img/panel/tabpanel/' + (bTwoLinesTabs ? 'fade_left_2l.png' : 'fade_left.png' )),
                                'styles' : {
                                    'position' : 'relative',
                                    'top' : (bTwoLinesTabs ? '-50px' : '-44px' ),
                                    'left' : '22px'
                                }
                            }
                        ).inject(divFadersHolder);
                        new Element('img', {
                                'src' : RC.getSkinnedRCLibXImageUrl('img/panel/tabpanel/' + (bTwoLinesTabs ? 'fade_right_2l.png' : 'fade_right.png' )),
                                'styles' : {
                                    'position' : 'relative',
                                    'top' : (bTwoLinesTabs ? '-50px' : '-44px' ),
                                    'left' : (tabHolder.offsetWidth - 1) + 'px'
                                }
                            }
                        ).inject(divFadersHolder);
                    }
                }
            } else {
                setTimeout(checkIfScrollBarNeeded, SCROLL_CHECK_TIME);
            }
        }

        setTimeout(checkIfScrollBarNeeded, SCROLL_CHECK_TIME);

        var isGreeting = "";
        if (RC.isTrue(self.isGreeting))
            isGreeting = '-gr';

        var tabHolder = new Element('div', {
            'id'  : this.id + '-tabs-holder',
            'class': 'x-tabs-items-align-' + self.tabItemsAlign,
            'html' : (isGreeting ? '<div style="border-right: 1px solid #dfdfdf; position: absolute; top: 31px; left: ' + (Browser.name === "ie" ? '431' : '409') + 'px; height: 11px;"></div><div style="border-left: 1px solid #dfdfdf; position: absolute; top: 31px; height: 11px; left: 0;"></div>' : ''),
            'styles': {
                'width'      : RC.isEmpty(this.width) ? 'auto' : (this.width - SCROLL_WIDTH) + 'px',
                'overflow'   : 'hidden',
                'position'   : 'relative' //this magic string do nothing, but fix IE6-IE7 bug with displaying hidden overflow
            }
        });

        var tabsBlock = new Element('table', {
            'id'     : this.id + '-tabs',
            'class'  : 'x-tabs-holder-tabs',
            'html'   : '<tr></tr>',
            'cellspacing': 0,
            'cellpadding': 0,
            'styles' : {
                'position' : 'relative',
                'width' : this.autoAdjustTabWidth ? this.totalTabWidth : 'auto'
            },
            'tween': {
                'transition': Fx.Transitions.Quad.easeOut,
                'duration'  : SCROLL_ANIMATION_DURATION
            }
        });

        this._tabContent = new Element('div');
        this._tabHolder = tabsBlock.getElement('tr');

        if (typeof tabs != 'undefined') {
            tabs.each(function(item)
            {
                if (item == null) return;
                if (typeof item['+'] == 'function')
                    self.addPlusTab(item['+']);
                else
                    self.addTab(item);
            });
        }

        this.currentItemId = this.activeTab;

        tabsBlock.inject(tabHolder);
        tabHolder.inject(tdScrollerMiddle);

        //holder for faders
        if (isPNGSupportedByBrowser()) {
            var divFadersHolder = new Element('div', {
                styles : {
                    'position' : 'absolute'
                }
            }).inject(canvas);
        }

        this._tabContent.inject(canvas);

        if (!this.visible)
            canvas.setStyle('display', 'none');

        return canvas;
    },

    /**
     * Adds "+" tab
     * @param {Function} handler The callback function which will be called after clicks
     */
    addPlusTab: function(handler)
    {
        new Element('img', {
            'alt':'',
            'src': RC.getSkinnedRCLibXImageUrl('img/panel/tabpanel/newtab.gif'),
            events:{
                'click':handler
            },
            'styles': {
                'cursor':'pointer',
                'position' : 'relative',
                'top' : '-8px'
            }
        }).inject(new Element('td', {
            'styles': {
                'padding-top':'7px',
                'padding-left':'3px',
                'padding-right':'3px'
            }
        }).inject(this._tabHolder));
    },

    /**
     * Adds tab into panel
     * @param {Object} item The config object
     */
    addTab: function(item)
    {
        var self = this,
            titleWidth = item.titleWidth;
        self._tabs.include(item);
        var id = this.id + '-' + (RC.isEmpty(item.id) ? RC.genId() : item.id);
        new Element('table', {
            'id' : id,
            'border': 0,
            'cellpadding' : 0,
            'cellspacing' : 0,
            'class' : "x-tab-item" + (self.isGreeting ? " x-tab-item-greeting" : "") + (id == self.activeTab ? " x-tab-item-active" : ""),
            'styles': {
                'width': titleWidth ? (titleWidth + 'px') : (this.autoAdjustTabWidth ? '100%' : 0)
            },
            'html' :
                '<tr class="x-tab-item-top"><td class="x-tab-item-left"></td>' +
                    (item.titleWidth ? ('<td class="x-tab-item-mid" style="width:'+item.titleWidth +'px">' + item.title + '</td>') : ('<td class="x-tab-item-mid">' + item.title + '</td>')) +
                '<td class="x-tab-item-right"></td></tr>' +
                '<tr class="x-tab-item-bottom"><td class="x-tab-item-left"></td>' +
                '<td id="' + id + '-bot" class="x-tab-item-mid"></td>' +
                '<td class="x-tab-item-right"></td></tr>',
            'events': {
                'click': function()
                {
                    self.setActive(id.replace(self.id + '-', ''));
                    if (RC.getCmp('PanelId')) {
                        RC.getCmp('PanelId').setTitle(item.title);
                    }
                    if (typeof item.handler == 'function')
                        item.handler();
                }
            }
        }).inject(new Element('td').inject(this._tabHolder));

        var ttt = new Element('div', {
            id : id + '-tab',
            'class' : 'x-tabpanel-bg',
            styles : {
                'display'       : (self.activeTab != null && self.activeTab == id ? 'block' : 'none')
            }
        }).inject(this._tabContent);

        if (!RC.isEmpty(item.tabStyle)) {
            ttt.set('style', ttt.get('style') + ';' + item.tabStyle);
        }

        if (!RC.isEmpty(item.tabClass)) {
            ttt.addClass(item.tabClass);
        }

        item.items.each(function(r)
        {
            if (r == '-') {
                new Element('div', {
                    'id'     : RC.genId(r),
                    'html'   : '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/sp.gif') + '" alt="" height="2" width="100%"/>',
                    'styles' : {
                        'margin': '15px 4px'
                    }
                }).inject(ttt);
                RC.ComponentMgr.register(r);
            } else {
                var o = RC.createComponent(r);
                if (o != null)
                    o.compile().inject(ttt);
            }
        });

        var tabs = this._tabHolder.getElements('.x-tab-item');
        if (tabs) tabs.each(function(tab, i){
            tab.removeClass('x-tab-item-first');
            tab.removeClass('x-tab-item-last');
            if (i == 0) tab.addClass('x-tab-item-first');
            if (i == tabs.length - 1) tab.addClass('x-tab-item-last');
        });

    },

    /**
     * Activates tab by passed index and fires {@link #tabChange} event
     * @param {Number} idx
     */
    setActiveByIdx : function(idx)
    {
        if (idx < 0) {
            return;
        }
        if (this._tabs[idx] !== undefined) {
            return this.setActive(this._tabs[idx].id);
        }
    },

    /**
     * Get Activates tab index
     * @param {Number} idx
     */
    getActiveIdx : function()
    {
    	var i = 0, activeIdx = -1, len = this._tabs.length;
    	if(this.currentItemId){
    		for(i = 0; i<len; i++) {
        		if(this.id + '-' + this._tabs[i].id === this.currentItemId) {
        			activeIdx = i;
        			break;
        		}
        	}
    	}
    	return activeIdx;
    },

    /**
     * Activates tab by passed <tt>id</tt>  and fires {@link #beforeTabChange}, {@link #tabChange}  events
     * @param {String} tabid Id of the tab item
     */
    setActive : function(tabid)
    {
        var oriTabId = tabid;
        tabid = this.id + '-' + tabid;
        if ($(tabid) == null) {
            return;
        }

        var self = this;

        if (self.hasListener('beforeTabChange') && !self.fireListener('beforeTabChange', oriTabId)) {
            return;
        }

        // remove current selection
        if (self.currentItemId != null) {
            var cId = self.currentItemId;
            self.currentItemId = null;
            $(cId + '-tab').setStyle('display', 'none');
        }

        // set new selection;
        if ($(tabid + '-img') == null) {
            self.currentItemId = tabid;
            $(tabid + '-tab').setStyle('display', 'block');
        }

        $(this.id).getElements('.x-tab-item-active').removeClass('x-tab-item-active');
        $(tabid).addClass('x-tab-item-active');

        self.fireListener('tabChange', tabid);
    },

    /**
     * Returns id of current tab
     * @return {String} Id of the tab item
     */
    getActive : function()
    {
        return this.currentItemId == null ? null :
            this.currentItemId.replace(this.id + '-', '');
    },
    /**
     * Return current tab item
     */
    getActiveTab : function()
    {
    	var index = this.getActiveIdx();
    	if(index >= 0){
    		return this._tabs[index];
    	}
    },

    /**
     * Hides all tabs
     */
    hideTabs : function()
    {
        if (this._tabs === undefined || this._tabs.length > 1)
            return;
        $(this.id + '-tab-scroller-holder').setStyle('display', 'none');
        var tabPanel = $(this.id);
        // remove gray bg if need in parent element
        if (tabPanel.getParent() != null && tabPanel.getParent().get('style').indexOf('_gray') > -1)
            tabPanel.getParent().set('style', tabPanel.getParent().get('style').replace('_gray', ''));
        this.tabsWasHidden = true;
    }
});

RC.reg('tabpanel', RC.panel.TabPanel);

/**
 * Implements accordion panel
 *
 * @class
 * @name RC.panel.EntryPanel
 * @extends RC.Element
 * @constructor
 * @xtype accordian
 */
RC.panel.EntryPanel = function(params) {

    RC.apply(this, params);

    /**
     * @cfg {Array} items The items of the accordion
     */
    this._items = params.items;
    delete params.items;

    // create superclass
    RC.panel.EntryPanel.superclass.constructor.call(this, params);

    this.allowMultipleSelections = !!params.allowMultipleSelections;
    this.allowToggle = !!params.allowToggle;
    this.centered = !!params.centered;
    this.height = params.height || false;
    RC.isInt(this.height) && (this.height += 'px');

};

RC.extend(RC.panel.EntryPanel, RC.Element, {
    updatePositions: function() {

        var rows = this.itemCanvas.getElements('.x-entryPanel-row');

        rows.removeClass('x-entryPanel-first').removeClass('x-entryPanel-last');
        rows[0].addClass('x-entryPanel-first');
        rows[rows.length - 1].addClass('x-entryPanel-last');

    },
    selectItemById: function(id) {

        this.itemsCache[id].select(true);

    },
    unselect: function(){
        Object.each(this.itemsCache, function(itemCached) {
            itemCached.select(false);
        });
    },
    unselectExceptItem: function(item) {

        if (item.isSelected) {
            Object.each(this.itemsCache, function(itemCached) {

                if (itemCached != item) itemCached.select(false);

            });
        }

    },
    center: function(flag) {

        this.itemCanvas.toggleClass('x-entryPanel-centered', flag);

    },
    setVisible: function(flag){
        this.itemCanvas.setStyle('display', flag ? '' : 'none');
    },
    /**
     * Render the component
     */
    render: function() {

        this.itemCanvas = new Element('div', {
            'id': this.id,
            'class': 'x-entryPanel' + (this.centered ? ' x-entryPanel-centered' : '')
        });
        this.height && this.itemCanvas.setStyle('height', this.height);

        var self = this;

        self.itemsCache = {};

        this._items.each(function(item, index) {

            var row = new Element('div', {
                'class': 'x-entryPanel-row'
            }).inject(self.itemCanvas);

            if (!(item instanceof RC.Element)) {

                item.allowToggle = self.allowToggle;
                item = new RC.panel.EntryPanelContainer(item);

            }

            RC.ComponentMgr.register(item);

            if (item instanceof RC.panel.EntryPanelContainer) {

                item.addListener('select', function(item, selected) {

                    self.updatePositions();

                    // Unselect all other nodes
                    if (!self.allowMultipleSelections) self.unselectExceptItem(item);

                    self.fireListener('select', item, selected);


                });

                item.addListener('focus', function() {
                    self.fireListener('focus', item);
                });

                item.addListener('blur', function() {
                    self.fireListener('blur', item);
                });

                item.addListener('itemAdded', function(item) {

                    self.itemsCache[item.id] = item;

                });

                if (item.isMultiple()) {
                    row.addClass('x-entryPanel-row-multiple');
                }

            }

            // If after creation or not item is not an instance of CollapsibleItem  break
            if (!(item instanceof RC.panel.EntryPanelContainer)) {
                RC.Console.error('Only instances of RC.panel.EntryPanel* can be passed as items to RC.panel.EntryPanel (xtype %s passed)', item.xtype);
                return;
            }

            item.compile(row);

        });

        // insert a 1 pixel height div with white background following the last item
        if (0 < this._items.length) {
            new Element('div', {
                'class': 'x-entryPanel-last-whitespace'
            }).inject(self.itemCanvas);
        }

        self.updatePositions();

        this.itemCanvas.addEvent('domready', function() {
            self.updatePositions();
        });

        return this.itemCanvas;

    }
});

RC.panel.EntryPanel.Tooltips = function() {

    var cookie = 'RC.EntryPanel.Tooltips';
    var cookieDurationDays = 180; //this cookie will leave half a year
    var options = {duration: cookieDurationDays};

    var list = [];
    var isEnabledValue = Cookie.read(cookie);
    isEnabledValue = isEnabledValue === null || isEnabledValue == "1"; //null means cookie is not set

    function isEnabled() {
        return isEnabledValue;
    }

    function enable() {
        isEnabledValue = true;
        Cookie.write(cookie, 1, options);
        updateAllStatus(isEnabledValue);
    }

    function disable() {
        isEnabledValue = false;
        Cookie.write(cookie, 0, options);
        updateAllStatus(isEnabledValue);
    }

    function setEnabled(setEnabled){
        if (setEnabled){
            enable();
        }
        else{
            disable();
        }
    }

    function toogleEnabled(){
        setEnabled(!isEnabled());
    }

    function updateAllStatus(enabled) {
        list.forEach(function(tooltip) {
            tooltip && tooltip.enable && tooltip.enable(enabled);
        });
    }

    function disableTooltipsConfirmation() {

        var featureTipsOnDiv = new RC.Div({
            html: RC.Lang.Common.FEATURETIPS_ON_TEXT,
            visible: isEnabled()
        });

        var featureTipsOffDiv = new RC.Div({
            html: RC.Lang.Common.FEATURETIPS_OFF_TEXT,
            visible: !isEnabled()
        });

        var enabled = isEnabled();
        var radioSwitch = new RC.form.RadioGroup({
            extraClass : 'x-featureTips-radioGroup',
            items:[
                {
                    name: 'switchOn',
                    value:'on',
                    checked:isEnabled(),
                    boxLabel:RC.Lang.Common.ON
                },
                {
                    name: 'switchOff',
                    value:'off',
                    checked:!isEnabled(),
                    boxLabel:RC.Lang.Common.OFF
                }
            ],
            listeners:{
                change:function (v) {
                    enabled = v == "on";
                    featureTipsOnDiv.setVisible(enabled);
                    featureTipsOffDiv.setVisible(!enabled);

                    var menu = RC.UI.HelperMenuPicker;
                    if (enabled){
                        menu.hide();
                    }
                    else{
                        menu.enableInteraction(false);
                        menu.enableHide(false);
                        menu.showOnTimeout(1000, true);
                    }
                }
            }
        });

        var form = new RC.form.FormPanel({
            items: [
                featureTipsOnDiv,
                featureTipsOffDiv,
                radioSwitch
            ]
        });

        var disableTooltipsWin = new RC.Window({
            title: RC.Lang.Common.FEATURE_TIPS,
            closable: true,
            width: 500,
            items: [form],
            buttons: [
                {
                    text: RC.Lang.Common.SAVE,
                    width: 100,
                    handler: function() {
                        disableTooltipsWin.close();
                        setEnabled(enabled);
                    }
                }
            ],
            listeners: {
                close: function(){
                    RC.UI.HelperMenuPicker.hide();
                }
            }
        });

        disableTooltipsWin.show();

    }

    function addToList(tooltip){
        list.push(tooltip);
    }

    return {
        isEnabled: isEnabled,
        enable: enable,
        disable: disable,
        removeAll: updateAllStatus,
        disableTooltipsConfirmation: disableTooltipsConfirmation,
        addToList: addToList,
        toogleEnabled: toogleEnabled
    };

}();

RC.reg('entryPanel', RC.panel.EntryPanel);

RC.panel.EntryPanelContainer = function(params, parent) {

    RC.apply(this, params);

    /**
     * @cfg {Array} items The items of the accordion
     */
    this._items = params.items;
    delete params.items;

    // create superclass
    RC.panel.EntryPanelContainer.superclass.constructor.call(this, params);

};

RC.extend(RC.panel.EntryPanelContainer, RC.Element, {
    isMultiple: function() {
        return this._items.length > 1;
    },
    /**
     * Render the component
     */
    render: function() {

        var self = this;

        self.itemCanvas = new Element('table', {
            'class': 'x-entryPanel-container'
        });

        self.itemTbody = new Element('tbody').inject(self.itemCanvas);
        self.itemTr = new Element('tr').inject(self.itemTbody);


        var counter = 0;
        var total = this._items.length;

        this._items.each(function(item, index) {

            counter++;
            var isLeft = (self.isMultiple) ? counter == 1 : false;
            var isRight = (self.isMultiple) ? counter == total : false;

            item.xtype = 'entryPanel-item';
            item.allowToggle = self.allowToggle;
            item = new RC.panel.EntryPanelItem(item);
            RC.ComponentMgr.register(item);

            var td = new Element('td', {
                'id': this.id,
                'class': 'x-entryPanel-cell' +
                         (isLeft ? ' x-entryPanel-cell-left' : '') +
                         (isRight ? ' x-entryPanel-cell-right' : '') +
                         (!isLeft && !isRight ? ' x-entryPanel-cell-middle' : '')
            }).inject(self.itemTr);

            item.addListener('select', function(selected) {
                self.fireListener('select', item, selected);
            });

            item.addListener('focus', function() {
                self.fireListener('focus', item);
            });

            item.addListener('blur', function() {
                self.fireListener('blur', item);
            });

            item.compile(td);

            self.fireListener('itemAdded', item); // Notify parent that new item has been added

        });

        return self.itemCanvas;

    }
});

RC.reg('entryPanel-container', RC.panel.EntryPanelContainer);

RC.panel.EntryPanelItem = function(params) {

    RC.apply(this, params);

    /**
     * @cfg {Array} items The items of the accordion
     */
    this._items = params.items;
    delete params.items;

    // create superclass
    RC.panel.EntryPanelItem.superclass.constructor.call(this, params);

    this.isSelected = !!params.isSelected;
    this.contentId = params.contentId;
    this.hintText = params.hintText;
    this.hintVideoId = params.hintVideoId;
    this.hintVideoTitle = params.hintVideoTitle;

};

RC.extend(RC.panel.EntryPanelItem, RC.Element, {
    focus: function() {
        this.select(true);
    },
    blur: function() {
        this.select(false);
    },
    select: function(isSelected, silent) {

        this.isSelected = !!isSelected;

        this.itemCanvas[this.isSelected ? 'addClass' : 'removeClass']('x-entryPanel-selected');

        if (!silent) {
            this.fireListener('select', this.isSelected); // Works every time
            if (this.isSelected) this.fireListener('focus');
            if (!this.isSelected) this.fireListener('blur');
        }

    },
    toggleSelect: function() {

        this.select(!this.isSelected);

    },
    setTitle: function(title) {

        this.title = title;
        this.itemTitle.set('html', this.title);

    },
    /**
     * Render the component
     */
    render: function() {

        var self = this;

        this.itemTitle = null;
        this.itemIcon = null;
        this.itemIconSelected = null;
        this.itemCanvas = null;
        this.isSelected = false;

        var html = [];

        html.push('    <span class="x-entryPanel-icon" id="' + this.id + '-icon"><img class="x-entryPanel-icon-img" src="" /><img class="x-entryPanel-icon-img-selected" src="" /></span>');
        html.push('    <span class="x-entryPanel-text" id="' + this.id + '-text">title placeholder</span>');
        html.push('    <span class="x-entryPanel-iefix"></span>');

        this.itemCanvas = new Element('div', {
            'class': 'x-entryPanel-item',
            'id': this.id,
            'html': html.join('')
        });

        this.itemTitle = this.itemCanvas.getElement('span.x-entryPanel-text');
        this.itemIcon = this.itemCanvas.getElement('img.x-entryPanel-icon-img');
        this.itemIconSelected = this.itemCanvas.getElement('img.x-entryPanel-icon-img-selected');

        this.itemIcon.set('src', this.icon);
        if (!this.iconSelected) this.iconSelected = this.icon;
        this.itemIconSelected.set('src', this.iconSelected);

        this.setTitle(this.title);

        this.itemCanvas.addEvent('click', function() {

            if (self.allowToggle) self.toggleSelect(); else self.focus();

        });

        if (this.isSelected) { //TODO Doesn't work, should be fixed
            RC.Console.log('selected');
            this.addListener('domready', function() {
                self.select(true);
            });
        }

        if (this.hintText) {
            
            var tooltip = new RC.form.ToolTip({
                embedElement: this.itemCanvas,
                text: this.hintText,
                videoId: this.hintVideoId,
                videoTitle: this.hintVideoTitle,
                delayed: true,
                width: 310,
                closable: true,
                enabled: RC.panel.EntryPanel.Tooltips.isEnabled(),
                id: this.id + '-toolTip',
                listeners: {
                    close: function() {
                        RC.panel.EntryPanel.Tooltips.disableTooltipsConfirmation();
                    }
                }
            });

            RC.panel.EntryPanel.Tooltips.addToList(tooltip);

        }

        return this.itemCanvas;

    }
});

RC.reg('entryPanel-item', RC.panel.EntryPanelItem);



/**
 * Implements accordion panel
 *
 * @class
 * @name RC.panel.Collapsable
 * @extends RC.Element
 * @constructor
 * @xtype accordian
 */
RC.panel.Collapsable = function(params) {

    RC.apply(this, params, {});

    /**
     * @cfg {Array} items The items of the accordion
     */
    this._items = params.items;
    delete params.items;

    // create superclass
    RC.panel.Collapsable.superclass.constructor.call(this, params);

    this.floating = !!params.floating;
    this.allowMultipleSelections = !!params.allowMultipleSelections;
    this.allowToggle = !!params.allowToggle;
    this.contentPadding = !!params.contentPadding;
    this.closable = !!params.closable;

};

RC.extend(RC.panel.Collapsable, RC.Element, {
    collapse: function(){

        this.itemsCache.each(function(item){
            item.select(false);
        });

    },
    /**
     * Render the component
     */
    render: function() {

        var self = this;

        this.itemCanvas = new Element('div', {
            'id': this.id,
            'class': 'x-collapsable' + (this.contentPadding ? ' x-collapsable-contentPadding' : '') + (this.floating ? ' x-collapsable-inlineBlock' : '') + (this.title ? '' : ' x-collapsable-notitle')
        });

        this.itemClose = new Element('span', {
            'id': this.id + '-close',
            'class': 'x-collapsable-close',
            'html': '&nbsp;',
            'events': {
                click: function(e){
                    e.stop();
                    self.destroy();
                    self.fireListener('close');
                }
            }
        });

        if (this.closable) this.itemClose.inject(this.itemCanvas);
        
        if(this.title){
            this.panelTitle = new Element('div', {
                'id': this.id + '-title',
                'class': 'x-collapsable-header',
                'html': self.title || '&nbsp;'
            });
            this.panelTitle.inject(this.itemCanvas);
        }

        self.itemsCache = [];

        this._items.each(function(item, index) {

            item.allowToggle = self.allowToggle;
            item.items = item.items || [];

            var itemObject = new RC.panel.CollapsableItem(item);

            itemObject.compile(self.itemCanvas);
            self.itemsCache.push(itemObject);

            if (!self.allowMultipleSelections) itemObject.addListener('expand', function(canvas) {

                self.itemsCache.each(function(cachedItem) {

                    cachedItem.select(cachedItem == itemObject, true);

                });

            });

            // Pre-select
            if (item.selected) {
                self.addListener('render', function() {
                    itemObject.select(true); 
                });
            }

        });

        return this.itemCanvas;

    }
});

RC.reg('collapsable', RC.panel.Collapsable);

RC.panel.CollapsableItem = function(params) {

    RC.apply(this, params, {});

    /**
     * @cfg {Array} items The items of the accordion
     */
    this._items = params.items;
    delete params.items;

    // create superclass
    RC.panel.CollapsableItem.superclass.constructor.call(this, params);

};

RC.extend(RC.panel.CollapsableItem, RC.Element, {
    isSelected: function() {

        return this.itemCanvas.hasClass('x-collapsable-selected');

    },
    toggleSelect: function() {

        this.select(!this.isSelected());

    },
    select: function(state, silent) {

        if (!(state && this.isSelected())){

            this.itemCanvas.toggleClass('x-collapsable-selected', state);

            if (!silent) {
                this.fireListener('select', this.itemContent, state);
                this.fireListener(state ? 'expand' : 'collapse', this.itemContent);
            }
        }
    },
    /**
     * Render the component
     */
    render: function() {

        this.itemCanvas = new Element('div', {
            'id': this.id,
            'class': 'x-collapsable-row'
        });

        var self = this;

        this.itemTitle = new Element('div', {
            'class': 'x-collapsable-title',
            'id': this.id + '-title',
            'html': self.title,
            'events': {
                click: function(e) {

                    e.stop();
                    if (self.allowToggle) self.toggleSelect(); else self.select(true);

                }
            }
        }).inject(self.itemCanvas);

        var div = new RC.Div({
            items: self._items,
            id: this.id + '-content',
            extraClass: 'x-collapsable-content'
        });

        div.compile(self.itemCanvas);
        this.itemContent = self.itemCanvas.getElement('div.x-collapsable-content');

        return this.itemCanvas;

    }
});

RC.reg('collapsableItem', RC.panel.CollapsableItem);




/**
 * Help Panel
 * @class
 * @param config
 * @constructor
 */
RC.panel.HelpPanel = function(config) {
    config.extraClass = config.extraClass || '';
    config.extraClass += ' x-panel-helpPanel';

    if (config.additionalHelpLink) {

        config.extraClass += ' x-panel-helpPanel-additionalHelp';

        config.items.push({
            xtype: 'div',
            extraClass: 'x-panel-helpPanel-additionalHelpLink',
            html: new Element('a', {
                html: RC.Lang.Common.ADDITIONAL_HELP,
                href: config.additionalHelpLink,
                'target': '_blank',
                events : {
                    click : function(e) {
                        RC.getOmniLog().logPageView("AdditionalHelp", config.navigationMethod);
                    }
                }
            })
        });

    }

    RC.panel.HelpPanel.superclass.constructor.call(this, config);
};

RC.extend(RC.panel.HelpPanel, RC.Div, {
});

RC.reg('helpPanel', RC.panel.HelpPanel);

/**
 * Help Panel Title
 * @class
 * @param config
 * @constructor
 */
RC.panel.HelpPanelTitle = function(config) {
    config.extraClass = config.extraClass || '';
    config.extraClass += ' x-panel-helpPanel-title';
    RC.panel.HelpPanelTitle.superclass.constructor.call(this, config);
};

RC.extend(RC.panel.HelpPanelTitle, RC.Div, {
});

RC.reg('helpPanelTitle', RC.panel.HelpPanelTitle);

/**
 * @class
 * @name RC.panel.HelpPanelShortcuts
 * @extends Element
 * @constructor
 * @param {Object} config The config object
 */
RC.panel.HelpPanelShortcuts = function(config) {
    config = config || {};
    this.baseUrl = config.baseUrl || '';
    this.navigationMethod = config.navigationMethod;
    this.size = config.size || 'small';
    RC.panel.HelpPanelShortcuts.superclass.constructor.call(this, config);
};

RC.extend(RC.panel.HelpPanelShortcuts, RC.Element, {

    render : function(items) {
        items = items || [];
        var self = this ,
            baseCss = 'x-panel-helpPanel-shortcuts',
            navigationMethod = self.navigationMethod;
        var canvas = new Element('div', {
            'class': baseCss
        });
        if (items.length == 1) {
            canvas.addClass(baseCss + '-single');
        } else if (items.length < 4) {
            canvas.addClass(baseCss + '-left');
        }
        var iconCSS = baseCss + '-icon ';
        if (this.size == 'small') {
            iconCSS += baseCss + '-small-icon'
        }
        items.each(function(item) {

            var html = [], isRedirect = item.isRedirect;
            html.push('    <span class="' + iconCSS + '">');
            html.push('        <span class="' + baseCss + '-icon-hover"></span>');
            html.push('        <span class="' + baseCss + '-icon-image" style="background-image: url(' + item.icon + ');"></span>');
            html.push('    </span>');
            html.push('    <span class="' + baseCss + '-title">' + item.title + '</span>');

            var link = new Element('a', {
                'class': baseCss + '-item',
                'href': isRedirect ? item.href : (self.baseUrl + item.href),
                'html': html.join(''),
                'events': {
                    click: function(e) {
                        //setup omniture context, so the first two panel will not be tracked
                        RC.getOmniLog().setNavigationContext({
                            method: navigationMethod,
                            target: item.targetPageName,
                            needTraceCookie : isRedirect
                        });
                        if (!isRedirect) {
                            e.stop();
                            RC.utils.History.add(item.href);
                            RC.utils.History.init();
                        }
                    }
                }

            });

            canvas.adopt(new Element('span', {'html': '&nbsp;' , 'class' : baseCss + '-spacer'})); // spaces needed!
            canvas.adopt(link);

        });

        canvas.adopt(new Element('span', {'class': baseCss + '-justify'}));

        return canvas;
    }
});

RC.reg('helpPanelShortcuts', RC.panel.HelpPanelShortcuts);

/**
 * @class
 * @name RC.panel.HelpPanelHowToDo
 * @extends Element
 * @constructor
 * @param {Object} config The config object
 */
RC.panel.HelpPanelHowToDo = function(config) {
    config = config || {};
    this.navigationMethod = config.navigationMethod;

    RC.panel.HelpPanelHowToDo.superclass.constructor.call(this, config);
};

RC.extend(RC.panel.HelpPanelHowToDo, RC.Element, {

    render : function(items) {
        items = items || [];
        var self = this ,
            baseCss = 'x-panel-helpPanel-howToDo',
            navigationMethod = self.navigationMethod,
            timeout;

        var canvas = new Element('div', {
            'class' : baseCss
        });

        var shimContainer = new Element('div', {
            'class': baseCss + '-shim'
        });

        var playerContainer = new Element('div', {
            'class': baseCss + '-player'
        });

        var itemsContainer = new Element('ul', {
            'class': baseCss + '-items'
        });

        items.each(function(item) {
            renderItem(item);
        });

        //TODO To be refactored - replace Array with Store and pure HTML with GridList
        function renderItem(item) {
            var thumbContainer = new Element('div', {
                'class': baseCss + '-player-item'
            });

            var itemType = 'LINK';
            (!RC.isEmpty(item.videoId)) && (itemType = 'VIDEO');
            (!RC.isEmpty(item.pdfLink)) && (itemType = 'PDF');

            var commonThumbnailConfig = {
                title: item.title,
                img: item.img,
                size: 'medium',
                navigationMethod: navigationMethod
            };

            var typeConifg = {
                'VIDEO' : {
                    listItemIconClass : baseCss + '-item-video',
                    listItemTypeText : item.duration || '&minus;:&minus;&minus;',
                    pageViewPrefix: 'Video:',
                    clickFn: function() {
                        RC.utils.Video.openVideoWindow({
                            videoId: item.videoId,
                            title: item.title
                        });
                    },
                    createThumbnail: function() {
                        return  new RC.media.VideoThumbnail(RC.apply(commonThumbnailConfig, {
                            videoId: item.videoId,
                            duration: item.duration,
                            imgText: item.imgText
                        }));
                    }
                },
                'PDF' : {
                    listItemIconClass : baseCss + '-item-pdf',
                    listItemTypeText : 'PDF',
                    pageViewPrefix: 'PDF:',
                    clickFn: function() {
                        window.open(item.pdfLink, '_blank');
                    },
                    createThumbnail: function() {
                        return  new RC.media.PdfThumbnail(RC.apply(commonThumbnailConfig, {
                            href: item.pdfLink
                        }));
                    }
                },
                'LINK' : {
                    listItemIconClass : '',
                    listItemTypeText : '',
                    pageViewPrefix: 'Link:',
                    clickFn: function() {
                        window.open(item.linkHref, '_blank');
                    },
                    createThumbnail: function() {
                        return  new RC.media.LinkThumbnail(RC.apply(commonThumbnailConfig, {
                            href: item.linkHref
                        }));
                    }
                }
            };
            var itemConfig = typeConifg[itemType];
            var listItemIconClass = itemConfig.listItemIconClass || '';
            var listItemTypeText = itemConfig.listItemTypeText || '';
            var pageViewPrefix = itemConfig.pageViewPrefix || '';
            var clickFn = itemConfig.clickFn || function() {};
            var createThumbnail = itemConfig.createThumbnail || function() {};

            playerContainer.adopt(thumbContainer);

            var listItem = new Element('li', {
                'class': baseCss + '-item',
                'html': function() {
                    var html = [];
                    var itemText = RC.UI.Message('<span class="{0}-item-selection"></span><span class="{1}">{2}</span>', baseCss, listItemIconClass, listItemTypeText);
                    html.push(itemText, item.title);
                    return html.join('');

                }(),
                'events': {
                    mouseenter: function(e) {
                        e && e.stop();
                        clearTimeout(timeout);
                        var owner = this;
                        timeout = setTimeout(function() {
                            displayItem(item, owner, thumbContainer);
                        }, 250);
                    },
                    click: function(e) {

                        e.stop();
                        clickFn();
                        RC.getOmniLog().logPageView(pageViewPrefix + item.title, navigationMethod);
                    }
                }
            });

            itemsContainer.adopt(listItem);

            var thumb = createThumbnail();
            thumb.display(thumbContainer);
        }

        function displayItem(item, obj, thumbContainer) {
            itemsContainer && itemsContainer.getElements('li').removeClass(baseCss + '-item-selected');
            playerContainer && playerContainer.getElements('div.').removeClass(baseCss + '-player-item-selected');

            obj.addClass(baseCss + '-item-selected');
            thumbContainer.addClass(baseCss + '-player-item-selected');
        }

        itemsContainer.addEvent('mouseleave', function() {
            clearTimeout(timeout);
        });

        // simulate hover on first
        displayItem(items[0], itemsContainer.getElement('li.' + baseCss + '-item'),
            playerContainer.getElement('div.' + baseCss + '-player-item'));

        canvas.adopt(itemsContainer, playerContainer, shimContainer);

        return canvas;
    }
});

RC.reg('helpPanelHowToDo', RC.panel.HelpPanelHowToDo);

RC.namespace("RC.UI");

RC.UI.WebOptions = {

    USE_REGULAR_UI : 0,
    USE_FLASH_UI : 1,
    USE_PROTO_CUST : 2,
    USE_PROTO_CUST_FLASH_UI : 3

};

/**
 * The global Ajax interface that provides a simple way to make Ajax requests via web sockets protocol with maximum flexibility.
 * Since RC.Transport is a singleton, you can set common properties/events for it once and override them at the request function level only if necessary.
 *
 * @class
 * @name RC.Transport
 * @singleton
 * @interface
 */
RC.Transport = (function() {
    var isCust = false;

    var instance = {

        setIsCust : function(v)
        {
            isCust = v;
        },

        /**
         * Connects to web socket / renders swf object
         */
        connect : function(fn) {
            if (isCust) {
                RC.data.proxy.Socket.connect(fn);
            } else {
                if (RC.isFunc(fn)) {
                    fn();
                }
            }
        },

        /**
         * Call it if you want to close current connection
         */
        close : function() {
            if (isCust) {
                RC.data.proxy.Socket.close();
            }
        },

        /**
         * Sends command to server via web socket
         * @param params
         */
        send : function(params) {
            if (isCust) {

                var $do = new RC.data.AsyncContext();
                $do(function (cb) {
                    RC.Transport.connect(cb);
                });
                $do(function () {
                    RC.data.proxy.Socket.send(params);
                });

            } else {
                RC.Transport.sendHttp(params);
            }
        },

        sendHttp : function(params) {
            if (params.type == 'findSubscriber') {
                params.callback();
                return;
            }
            params.cmd = params.ns + "." + params.type;
            params.useWrapper = true;
            params.params = params.request;
            delete params.request;
            delete params.type;
            delete params.ns;
            (new RC.data.proxy.Ajax).send(params);
        },

        toStringArray : function (arr) {
            if (isCust) {
                var arr2 = RC.clone(arr);
                arr2.each(function(r, i) {
                    arr2[i] = r.toString();
                });
                return arr2;
            } else {
                return RC.Transport.toHttpStringArray(arr)
            }
        },

        toHttpStringArray : function(arr) {
            return JSON.encode(arr);
        }

    };

    return (instance);

})();

RC.Transport.utils = (function() {
    return {
        isRegularUI: function () {
            return RC.Config.flashUI === RC.UI.WebOptions.USE_REGULAR_UI;
        }  ,
        isFlashUI: function () {
            return RC.Config.flashUI === RC.UI.WebOptions.USE_FLASH_UI;
        },
        isProtoCust: function () {
            return RC.Config.flashUI === RC.UI.WebOptions.USE_PROTO_CUST;
        },
        isProtoCustFlashUI: function () {
            return RC.Config.flashUI === RC.UI.WebOptions.USE_PROTO_CUST_FLASH_UI;
        }
    };
})();

RC.ns("RC.media");

RC.media.YoutubeDeveloperKey = "AI39si6U2kGCLtgWEMnTWG0TaHU6PlVrXMs-JMdLMYQx6RWrzCTbugL_LWZW0cWKi_RySnxyHDu5b86Eht3PmW0qJIeQOjPVfA";

RC.media.YoutubeResponse = function(data){
    var rawData = data;

    this.getId = function(){
        return rawData["media$group"]["yt$videoid"]["$t"];
    };

    this.getTitle = function(){
        return rawData["media$group"]["media$title"]["$t"];
    };

    this.getDuration = function(){
        return rawData["media$group"]["yt$duration"]["seconds"];
    };

    this.getDurationInMinutes = function(){
        var seconds = this.getDuration();
        return Math.floor(seconds/60) + ':' + seconds % 60;
    };

    this.getViews = function(){
        return rawData["yt$statistics"] && rawData["yt$statistics"]["viewCount"];
    };

    this.getRawData = function(){
        return rawData;
    };
};

RC.media.YoutubeResponseList = function(config){
    var self = this;
    config = config || {};
    var response = config.response;
    var records = [];
    var rawData = [];
    var feed = false;


    this.getById = function(id){
        if (!id) return;

        var found = Array.filter(records, function(r){
            return r.getId() == id;
        });

        var result = found.pop();
        return result;
    };

    this.add = function(rawRecord){
        if (rawRecord instanceof RC.media.YoutubeResponse) {
            records.push(rawRecord);
        }
        else{
            r = new RC.media.YoutubeResponse(rawRecord);
            var id = r.getId();
            if (id && !self.getById(id)){
                records.push(r);
            }
        }
    };

    this.addBatch = function(records){
        $each(records, function (r) {
            self.add(r)
        });
    };

    this.getCount = function(){
        return records.length;
    };

    this.getRecords = function(){
        return records;
    };

    if (response) {
        if (response.entry) {
            rawData = response.entry;
            self.add(rawData);
        }
        else if (response.feed && response.feed.entry) {
            feed = true;
            rawData = response.feed.entry;
            this.addBatch(rawData);
        }
    }
};

(function () {

    var devKey = RC.media.YoutubeDeveloperKey;
    var RCmediaYoutubeRequest = function (config) {
        config = config || {};
        RCmediaYoutubeRequest.superclass.constructor.call(this, config);

        var self = this;

        var batchTimeout = 500;
        var batchThreshold = 50; //youtube max batch query size
        var maxAttemptsCount = 2;

        var cache = new RC.media.YoutubeResponseList();
        var queue = [];
        var timeoutId;

        function addToQueueEx(queueObject) {
            queueObject.attemptCount = queueObject.attemptCount || 0;
            queueObject.sendBySingleRequest = queueObject.sendBySingleRequest || false;

            queue.push(queueObject);

            if (cache.getById(queueObject.videoId)) {
                processedCached();
            }

            if (queue.length) {
                if (queue.length < batchThreshold) {
                    processDelayed();
                }
                else {
                    self.processNow();
                }
            }
        }

        this.addToQueue = function (videoId, callback) {
            addToQueueEx({
                    videoId:videoId,
                    // UIA-31804 Youtube batch query API always fails.
                    sendBySingleRequest: true,
                    callback:callback
                });
        };

        function processDelayed() {
            return timeoutId ? timeoutId : timeoutId = setTimeout(function(){self.processNow()}, batchTimeout);
        }

        this.processNow = function () {
            clearTimeout(timeoutId);
            timeoutId = null;

            processedCached();

            var queueToExecute = [];

            if (queue.length) {
                var firstElement = queue[0];

                if (!canBeBatched(firstElement)){
                    firstElement.attemptCount++;
                    queueToExecute.push(firstElement);
                    queue.splice(0,1);
                }
                else {
                    for (var i = 0; i <= batchThreshold && i<queue.length; i++) {
                        var r = queue[i];
                        r.attemptCount++;
                        if (canBeBatched(r)) {
                            queue.splice(i, 1);
                            queueToExecute.push(r);

                            i--; //fixing order after removing element
                        }
                    }
                }


                function afterRequestReceived(data, trySingleRequsetOnMissing){
                    var responseList = new RC.media.YoutubeResponseList({response: data});
                    processResponse(responseList, queueToExecute, trySingleRequsetOnMissing);
                    cache.addBatch(responseList.getRecords());

                    //if the queue is not empty - we should continue
                    processDelayed();
                }

                sendRequest(queueToExecute, afterRequestReceived);

            }

        };

        function processedCached(){
            var queueToExecute = [];
            var data;

            for (var i = 0; i<queue.length; i++) {
                var r = queue[i];
                if (data = cache.getById(r.videoId)){
                    queue.splice(i, 1);
                    queueToExecute.push(r);
                    i--;
                }
            }

            processResponse(cache, queueToExecute);
        }

        function canBeBatched(video) {
            var videoId = video.videoId;

            /*
             We retrieve videos through search query, where ids are separated by | (pipe)
             http://gdata.youtube.com/feeds/api/videos?q=h5jKcDH9s64|elzqvWXG1Y
             Unfortunately this solution does not work when the ID contains a dash/ hyphen "-".
             */
            var properVideoId = videoId && (videoId.indexOf('_') == -1 && videoId.indexOf('-') == -1);

            /*
             UIA-19546
             sendBySingleRequest can be used to retrieve info for videos,
             that by some reason were not processed in batch mode,
             for example, if this videos are not in search index of youtube
             */

            return properVideoId && !video.sendBySingleRequest;
        }

        function getUrl(videoId){
            var youtubeGdataUrl = 'https://gdata.youtube.com/feeds/api/videos';

            //every hour cache is forced to reload
            var antiCache = '&antiCache=' + (Math.floor(new Date().getTime() / (1000 * 60 * 60)));

            var params = 'v=2&alt=json-in-script&key=' + devKey + antiCache;

            var batch = RC.isArray(videoId) && videoId.length > 1;
            if (!batch && RC.isArray(videoId) && videoId.length) videoId = videoId[0];

            var query = ((batch)? '?q=' + videoId.join("|") + '&' :  '/' + videoId + '?')  + params;
            var url = youtubeGdataUrl + query;
            return url;
        }

        function sendRequest(queueToExecute, callback){
            var videoIdList = [];
            for(var i=0; i<queueToExecute.length; i++){
                var nextVideoId = queueToExecute[i].videoId;
                if (!Array.contains(videoIdList, nextVideoId)){
                    videoIdList.push(nextVideoId);
                }
            }

            var url = getUrl(videoIdList);

            var request = createRequest({
                url: url,
                timeout: 5000,
                onComplete: function (data) {
                    callback && callback(data, true);
                },
                onTimeout: function(){
                    callback && callback(null, false);
                }
            });

            request.send();
        }

        function createRequest(config){
            return new Request.JSONP(config);
        }

        function processResponse(youtubeResponseList, queueToExecute, trySingleRequsetOnMissing){
            queueToExecute.each(function(qRecord){
                var response = youtubeResponseList.getById(qRecord.videoId);
                if (response){
                    qRecord.callback && qRecord.callback(response);
                }
                else if (trySingleRequsetOnMissing){
                    if (qRecord.attemptCount < maxAttemptsCount) {
                        qRecord.sendBySingleRequest = true;
                        addToQueueEx(qRecord);
                    }
                }
            });
        }

        this.getCache = function(){
            return cache;
        };

    };

    RC.extend(RCmediaYoutubeRequest, RC.utils.Observable);

    RC.media.YoutubeRequest = new RCmediaYoutubeRequest();
}());

/**
 * @class
 * @name RC.media.Thumbnail
 * @extends RC.media.Element
 * Implements rendering of Thumbnail's html object
 *
 * @constructor
 * @param {Object} config The config object
 */
RC.ns("RC.media");
RC.media.Thumbnail = function(config)
{
    this.previewBackground = config.previewBackground || '#ffffff';
    this.title = config.title || '';
    this.linkText = config.linkText || '';
    this.img = config.img || '';
    this.imgText = config.imgText || this.title;
    this.href = config.href || '';
    this.duration = config.duration || '';
    this.views = config.views || '';

    this.defaultDimensions(config);

    RC.media.Thumbnail.superclass.constructor.call(this, config);

    this.canvas = null;

    this.events = {
        click: 'click'
    }

    this.addEvents(this.events.click);

    this.init();

}

RC.extend(RC.media.Thumbnail, RC.Element, {
    defaultDimensions : function(config){
        var dimensions = {};

        switch(config.size){
            default:
            case 'small':
                dimensions = {
                    previewClass: 'x-thumbnail-preview-small',
                    playButtonClass:'x-thumbnail-playButton-small x-thumbnail-playButton'
                };
                break;
            case 'medium':
                dimensions = {
                    previewClass: 'x-thumbnail-preview',
                    playButtonClass:'x-thumbnail-playButton'
                };
                break;
        }

        RC.apply(this, dimensions);
    },

    init : function()
    {
        var self = this;

        self.clickEvent = function(e){
            if (self.hasListener('click')) {
                self.fireListener('click', e);
            }
        };

        this.extraStyles = this.extraStyles ? this.extraStyles : {};
        this.extraStyles.display = this.visible ? 'block' : 'none';

        self.createCanvas();
        self.setPreviewBackground(self.previewBackground);
        self.setImg(self.img, self.title);
        self.setImgText(self.imgText);
        self.setDuration(self.duration);
        self.setPlayButton('', self.href, self.clickEvent);
        self.setTitle(self.title, self.href, self.clickEvent);
        self.setViews(self.views);
        self.setTextLink(self.linkText, self.href, self.clickEvent);

        if (!RC.isEmpty(this.extraStyle)) {
            self.canvas.set('style', self.canvas.get('style') + ';' + this.extraStyle);
        }

    },

    render: function(){
        return this.canvas;
    },

    setVisible: function(isVisible){
        this.canvas.setStyle('display', isVisible ? 'block' : 'none');
    },

    createCanvas: function(){
        var self = this;

        self.canvas = new Element('div', {
            'id'    : this.id,
            'class' : 'x-thumbnail ' + self.previewClass,
            'styles' : this.extraStyles
        });
    },

    setPreviewBackground: function(previewBackground){
        var self = this;
        if (!self.imgWrapper) {
            self.imgWrapper = new Element('div', {
                'class':'x-thumbnail-imgWrapper'
            });
            self.imgWrapper.inject(self.canvas);
        }
        self.imgWrapper.setStyle('background', previewBackground);
    },

    setImg:function (img, alt) {
        var self = this;
        var display = img ? "block" : "none";

        if (!self.imgPlaceholder) {
            self.imgPlaceholder = new Element('img', {
                'class':'x-thumbnail-img',
                'styles':{
                    'margin':'auto',
                    'vertical-align':'middle',
                    'width':'100%', //if we use one image for all sizes
                    'height':'auto'
                }
            });
            self.imgPlaceholder.inject(self.imgWrapper);
        }

        self.imgPlaceholder.set('src', img);
        self.imgPlaceholder.set('alt', alt);
        self.imgPlaceholder.setStyle('display', display);
    },

    setDuration: function(duration){
        var self = this;
        var display = duration ? "block" : "none";

        if (!self.durationPlaceholder) {
            self.durationPlaceholder = new Element('div', {
                'class':'x-thumbnail-duration'
            });
            self.durationPlaceholder.inject(self.imgWrapper);
        }

        if (!('set' in self.durationPlaceholder)) return;
        self.durationPlaceholder.set('text', duration || '');
        self.durationPlaceholder.setStyle('display', display);
    },

    setImgText: function(text){
        var self = this;
        if(!self.imgTextWrapper){
            self.imgTextWrapper = new Element('div',{
                'class':'x-thumbnail-imgTextWrapper'
            });
            
            self.imgTextWrapper.inject(self.imgWrapper);
        }
        self.imgTextWrapper.set('html',text);
    },
    
    setViews: function(views){
        var self = this;
        if (!self.viewsPlaceholder) {
            self.viewsPlaceholder = new Element('div', {
                'class':'x-thumbnail-views',
                'visibility': !RC.isEmpty(views)
            });

            self.viewsPlaceholder.inject(this.canvas);
        }
        if (!('set' in self.viewsPlaceholder)) return;
        self.viewsPlaceholder.set('text', views ? RC.UI.Message(RC.Lang.Common.VIEWS, views) : '');
    },

    setPlayButton: function(img /*set throw css now*/, href, onClick){
        var self = this;

        if (!self.playButtonPlaceholder) {
            self.playButtonPlaceholder = new Element('a', {
                'class':self.playButtonClass,
                'target':'_blank'
            });
            self.playButtonPlaceholder.inject(self.imgWrapper);
        }

        self.playButtonPlaceholder.set('href', href || '#');
        self.playButtonPlaceholder.addEvent('click', function(e){
            e.stop();
            onClick && onClick();
        });
    },

    setTitle: function(text, href, onClick){
        var self = this;
        if (!self.titlePlaceholder) {
            self.titlePlaceholder = new Element('a', {
                'class': 'x-thumbnail-text',
                'target': '_blank'
            });
            self.titlePlaceholder.inject(self.canvas);
        }

        self.titlePlaceholder.set('text', text || '');
        self.titlePlaceholder.set('href', href || '#');
        self.titlePlaceholder.addEvent('click', function(e){
            e.stop();
            onClick && onClick();
        });
    },

    setTextLink: function(text, href, onClick){
        var self = this;
        if (!self.linkTextPlaceholder) {
            self.linkTextPlaceholder = new Element('a', {
                'class': 'x-thumbnail-link',
                'target': '_blank'
            });
            self.linkTextPlaceholder.inject(self.canvas);
        }

        self.linkTextPlaceholder.set('text', text || '');
        self.linkTextPlaceholder.set('href', href || '#');
        self.linkTextPlaceholder.addEvent('click', function(e){
            e.stop();
            onClick && onClick();
        });
    },

    onClick: function(fn){
        this.addListener(this.events.click, fn);
    }
});

RC.reg('thumbnail', RC.media.Thumbnail);

/**
 * Created with IntelliJ IDEA.
 * User: denis.obydennykh
 * Date: 10/9/12
 * Time: 2:05 PM
 * To change this template use File | Settings | File Templates.
 */

/**
 * Implements rendering of VideoThumbnail's html object
 *
 * @class
 * @name RC.media.VideoThumbnail
 * @extends RC.media.Thumbnail
 * @constructor
 * @param {Object} config The config object
 */
RC.ns("RC.media");
RC.media.VideoThumbnail = function(config) {
    config.extraClass = config.extraClass || " ";
    config.extraClass += " x-thumbnail-video";
    config.linkText = RC.Lang.Common.WATCH_VIDEO;
    config.img = config.img ? config.img : 'https://i.ytimg.com/vi/' + config.videoId + '/hqdefault.jpg';
    config.href = "#";

    RC.media.VideoThumbnail.superclass.constructor.call(this, config);

    var self = this;

    this.windowWidth = this.windowWidth ? this.windowWidth : 640 + 26; //26 - size of window borders

    this.showVideo = function() {
        RC.utils.Video.openVideoWindow({
            videoId: config.videoId,
            title: config.title,
            width: self.windowWidth
        });
    };

    this.onClick(function() {
        RC.getOmniLog().logPageView('Video:' + config.title, config.navigationMethod);
        self.showVideo();
    });

    /**
     * @param {RC.media.YoutubeResponse} response
     */
    function processResponse(response){
        if(RC.isEmpty(self.duration)){
            self.setDuration(response.getDurationInMinutes())
        }
        self.setViews(response.getViews());
        self.fireListener('youtubeReady', response);
    }

    /*This verification was implemented in order to resolve case with redirect links(not YouTube links that redirect to YouTube video)*/
    if (config.videoId.indexOf('http') === -1) {
        RC.media.YoutubeRequest.addToQueue(config.videoId, processResponse);
    }
};

RC.extend(RC.media.VideoThumbnail, RC.media.Thumbnail);

RC.reg('videoThumbnail', RC.media.VideoThumbnail);

/**
 * Created with IntelliJ IDEA.
 * User: denis.obydennykh
 * Date: 10/9/12
 * Time: 2:05 PM
 * To change this template use File | Settings | File Templates.
 */

/**
 * Implements rendering of VideoPlayer's html object
 *
 * @class
 * @name RC.media.VideoPlayer
 * @extends RC.Element
 * @constructor
 * @param {Object} config The config object
 */
RC.ns("RC.media");
RC.media.VideoPlayer = function(config)
{
    RC.apply(this, this.defaultConfig());
    RC.apply(this, config);
    RC.media.VideoPlayer.superclass.constructor.call(this, config);

    var self = this;
    this.stopped = false;
    this.playerapiid = 'youtubePlayer' + RC.genId().replace('-', '');

    this.addListener('display', function(){
        self.injectFlashPlayer();
    });

};

RC.extend(RC.media.VideoPlayer, RC.Element, {
    defaultConfig: function(){
        return {
            width: '640',
            height: '360',
            autoplay : false
        }
    },

    getWidth: function(){
        return this.width;
    },

    render : function()
    {
        var self = this;

        this.extraStyles = this.extraStyles ? this.extraStyles : {};
        this.extraStyles.display = this.visible ? 'block' : 'none';
        this.extraStyles.width = this.width ? this.width : '200';


        var canvas = new Element('div', {
            'id'    : this.id,
            'class' : 'x-videoPlayer ' + (self.extraClass ? self.extraClass : ''),
            'styles' : this.extraStyles
        });
        if (!RC.isEmpty(this.extraStyle)) {
            canvas.set('style', canvas.get('style') + ';' + this.extraStyle);
        }

        this.canvas = canvas;

        return canvas;
    },

    setVisible: function(isVisible){
        this.canvas.setStyle('display', isVisible ? 'block' : 'none');
    },

    getYoutubePlayer: function(){
        return this.flashPlayer?this.flashPlayer:this.flashPlayer=$(this.playerapiid);
    },
    playVideo:function(){
        if (this.stopped) return;
        var yt = this.getYoutubePlayer();
        yt && yt.playVideo &&  yt.playVideo();
    },
    stopVideo: function(){
        this.stopped = true;
        var yt = this.getYoutubePlayer();
        yt && yt.stopVideo && yt.stopVideo();
    },
    injectFlashPlayer:function(){
        var self = this,
            swfUrl;

        /*This verification was implemented in order to resolve case with redirect links(not YouTube links that redirect to YouTube video)*/
        if (self.videoId.indexOf('http') !== -1) {
            swfUrl = self.videoId;
        } else {
            swfUrl = 'https://www.youtube.com/v/'+ this.videoId
            + '?autoplay=' + (this.autoplay ? 1:0)
            + '&version=' + RC.media.VideoPlayer.playerVersion
            + '&enablejsapi=1'
            + '&playerapiid=' + this.playerapiid
            + '&rel=0'; //do not show relative videos
        }

        swfobject.embedSWF(swfUrl, this.id, this.width, this.height, RC.media.VideoPlayer.flashVersion, null, null,  {
            allowScriptAccess: "always",
            allowfullscreen: true
        }, {
            id: this.playerapiid
        });
    }
});

RC.apply(RC.media.VideoPlayer,{
    playerVersion : '3',
    flashVersion: '10.1'
})
RC.reg('VideoPlayer', RC.media.VideoPlayer);

/**
 * Created with IntelliJ IDEA.
 * User: denis.obydennykh
 * Date: 10/9/12
 * Time: 2:05 PM
 * To change this template use File | Settings | File Templates.
 */

/**
 * Implements rendering of VideoPlayerWindow's html object
 *
 * @class
 * @name RC.media.VideoPlayerWindow
 * @extends RC.media.Thumbnail
 * @constructor
 * @param {Object} config The config object
 */
RC.ns("RC.media");
RC.media.VideoPlayerWindow = function (config) {

    var player = new RC.media.VideoPlayer({
        videoId:config.videoId,
        autoplay: false
    });

    config.items = [
        player
    ];

    config.width = config.width || player.getWidth();
    config.closable = true;

    var originalOnCloseFunction = config.onClose;
    config.onClose = function(){
        if(typeof originalOnCloseFunction == 'function') originalOnCloseFunction();
        player.stopVideo();
        player.destroy();
    };

    RC.media.VideoPlayerWindow.superclass.constructor.call(this, config);
};

RC.extend(RC.media.VideoPlayerWindow, RC.Window);

RC.reg('VideoPlayerWindow', RC.media.VideoPlayerWindow);

/**
 * Created with IntelliJ IDEA.
 * User: denis.obydennykh
 * Date: 10/9/12
 * Time: 2:09 PM
 * To change this template use File | Settings | File Templates.
 */

/**
 * @class
 * @name RC.media.VideoThumbnail
 * @extends RC.media.Thumbnail
 * Implements rendering of VideoThumbnail's html object
 *
 * @constructor
 * @param {Object} config The config object
 */
RC.ns("RC.media");
RC.media.PdfThumbnail = function(config)
{
    config.extraClass = config.extraClass || " ";
    config.extraClass += " x-thumbnail-pdf";
    config.linkText = RC.Lang.Common.DOWNLOAD_PDF;
    config.previewBackground = '#F4F3F3';

    RC.media.PdfThumbnail.superclass.constructor.call(this, config);
    
    this.onClick(function(){
    	RC.getOmniLog().logPageView('Pdf:' + config.title, config.navigationMethod);
        window.open(config.href, '_blank');
    })
}

RC.extend(RC.media.PdfThumbnail, RC.media.Thumbnail);

RC.reg('pdfThumbnail', RC.media.PdfThumbnail);

/**
 * Implements rendering of LinkThumbnail's html object
 *
 * @class
 * @name RC.media.LinkThumbnail
 * @extends RC.media.Thumbnail
 * @constructor
 * @param {Object} config The config object
 */
RC.ns("RC.media");
RC.media.LinkThumbnail = function(config) {
    config.extraClass = config.extraClass || " ";
    config.extraClass += " x-thumbnail-link";
    config.linkText = RC.Lang.Common.VIEW;

    RC.media.LinkThumbnail.superclass.constructor.call(this, config);

    this.onClick(function() {
        RC.getOmniLog().logPageView('Link:' + config.title, config.navigationMethod);
        window.open(config.href, '_blank');
    })
};

RC.extend(RC.media.LinkThumbnail, RC.media.Thumbnail);

RC.reg('linkThumbnail', RC.media.LinkThumbnail);

/*jslint */
/*global RC, Wrapper */

RC.namespace("RC.Config");

/**
 * @namespace
 * @name RC.Config
 */
RC.Config = (function () {
    'use strict';

    var config = {
        defaults: {
            "i18n": null,
            "contextPath": null,
            "resourcesPath": null, //@deprecated
            "mobileWrapperPath": null,
            "webSocketAddress": null,
            "webSocketPort": null,
            "webSocketPortSSL": null,
            "captchaUrl": null,
            "dateFormat": null,
            "phoneTypeAdditionalCompany": null,
            "omnitureEnable": null,
            "omnitureServiceWebAccount": null,
            "version": null,
            "legal": null,
            "maxFileSizeMegaBytes": null,
            "signupUrl": null,
            "helpLink": null,
            "feedbackLink": null,
            "displayName": null,
            "portSupportFax": null,
            "portSupportEmail": null,
            "portTollFreeSupportEmail": null,
            "smsSupportEmail": null,
            "displayNameFull": null,
            "headerAccountBlock": null,
            "tierName": null,
            "tierId": null,
            "extension": null,
            "extensionType": null,
            "isMailboxSystem": null,
            "sampleEmailToFaxAddress": null,
            "trialDaysLeft": null,
            "trialSize": null,
            "trialExpired": null,
            "accountServiceState": null,
            "isPaidTrial": null,
            "isFreeTrial": null,
            "isTrial": null,
            "planMonthsDuration": null,
            "billingPlanDuration": null,
            "planDaysDuration": null,
            "paymentType": null,
            "isInternationalDialingEnabled": null,
            "isAllowedInternationalEnabling": null,
            "mainNumber": null,
            "isMailboxIsAdmin": null,
            "isSingleMailbox": null,
            "supportNumber": null,
            "secondSupportNumber": null,
            "serviceNumber": null,
            "cancelSupportNumber": null,
            "secondCancelSupportNumber": null,
            "thirdCancelSupportNumberUS": null,
            "thirdCancelSupportNumberInt": null,
            "supportEmail": null,
            "showRingMe": null,
            "showRingOut": null,
            "showFaxOut": null,
            "showCallback": null,
            "isRegionalSettingsEditable": null,
            "isCallerIdEditable": null,
            "isSecurityNotSet": null,
            "isAgent": null,
            "isDNDAvailable": null,
            "isNotificationsAvailable": null,
            "isDialByNameAvailable": null,
            "isShowDirectoryListing": null,
            "isShowCompanyAddress": null,
            "isDialByNameOn": null,
            "isSetupCompleted": null,
            "isCallRecordingAvailable": null,
            "isAutoCallRecordingAvailable": null,
            "isBulkDownloadEnabled": null,
            "isAdvancedUser": null,
            "isOldUser": null,
            "isFaxTier": null,
            "isOfficeTier": null,
            "isSmsAvailable": null,
            "isUserBasedTier": null,
            "bDLLimitReached": null,
            "isUserExtension": null,
            "isMultiExtensionMode": null,
            "brandId": null,
            "loggedUserId": null,
            "loggedMailboxPin": null,
            "loggedMailboxId": null,
            "pinLength": null,
            "isSuspended": null,
            "isDedicatedFaxAllowed": null,
            "creditCardName": null,
            "ringTypes": null,
            "maxAdditionalNumbersLimit": null,
            "productionHomePage": null,
            "settingsPanelHeight": null,
            "countryName": null,
            "brandCountryId": null,
            "brandCountryName": null,
            "brandCountryCode": null,
            "brandDisplayName": null,
            "shortBrandName": null,
            "mailboxTimeZone": null,
            "transferSupportNumber": null,
            "portingFaxNumber": null,
            "portingEmailko": null,
            "brandName": null,
            "maxDLNumbers": null,
            "trimmedFirstName": null,
            "trimmedFullName": null,
            "connectPromptEditable": null,
            "oldCreditsLogicView": null,
            "isDialingPrompt": null,
            "isBLFEnabled": null,
            "intercomEnabled": null,
            "includedDigitalLinesPerExtension": null,
            "isExternalBilling": null,
            "availableMailboxTypes": null,
            "agentQueues": null,
            "isServiceRangeAvailable": null,
            "isSalesForceAppAvailable": null,
            "isZoomAppAvailable": null,
            "salesForceAppAdminGuide": null,
            "currencySymbol": null,
            "salesForceAppUserGuide": null,
            "salesForceAppDownloadAppUrl": null,
            "zendeskAppAdminGuide": null,
            "zendeskAppUserGuide": null,
            "zendeskAppDownloadAppUrl": null,
            "zendeskDatasheetUrl": null,
            "isZendeskAvailable": null,
            "nextPaymentDate": null,
            "serviceDate": null,
            "displayFCCInfo": null,
            "legalInfoPage": null,
            "tosInfoPage": null,
            "eulaInfoPage": null,
            "lngCode": null,
            "isAdminSession": null,
            "isAllowToApplyETC": null,
            "flashUI": null,
            "appearanceLogoURL": null,
            "appearanceLogoPath": null,
            "salesForceAppDownloadDatasheet": null,
            "phoneLeasingEnabled": null,
            "phoneRefurbishedEnabled" : null,
            "hasUserPhonesInLeasing" : null,
            "multilevelIVREnabled": null,
            "partnerBillingUI": null,
            "cloudFaxUrl": null,
            "freeSPDLEnabled": null,
            "salesSupportNumbers": null,
            "maxCompanyDigitalLines": null,
            "showSpartanBetaDownloadLink": null,
            "tierTargetBucket": null,
            "trustFaxBroadcast": null,
            "maxRecipientsNumber": null,
            "isAutoActivateNonUserExtension": null,
            "contactSupportURL" : null,
            "meetingsAppDownloadURL": null,
            "meetingsAppMacDownloadURL": null,
            "isContractTier" : null,
            "userLanguage": "en_US",
            "isPartnerBilling": null,
            "isEnterpriseUIBulkUploadEnabled": null,
            "simplifiedUI" : null,
            "isFaxAllowed": null,
            "hasMessagesAccess": null,
            "hasNonHipaaMessagesAccess" : null,
            "hipaaEnabledOnBrand": null,
            "autoPurchaseBlocked": null,
            "maxSimultaneousForwarding": null,
            "callingCreditLimitReached": null
        }
    };

    /**
     * @public
     * @function
     * @name RC.Config.load
     * @param {function} [callback]
     * @param {boolean} [skipLoader]
     * @param {string} [forceBrandId]
     * @return {void}
     */
    config.load = function (callback, skipLoader) {
        if (!skipLoader) {
            RC.Loader.show({});
        }
        Wrapper.Config.getParameters(
            RC.configuration.brandId,
            function (result) {
                RC.apply(config, result.configData, {});
                if (!skipLoader) {
                    RC.Loader.hide();
                }
                if (typeof callback === 'function') {
                    callback();
                }
            },
            function () {
                RC.Console.error('RC.Config.load(): Configuration data cannot be loaded.');
                if (!skipLoader) {
                    RC.Loader.hide();
                }
            },
            skipLoader
        );

    };

    /**
     * @public
     * @function
     * @name RC.Config.reload
     * @param {function} [callback]
     * @param {boolean} [skipLoader]
     * @return {void}
     */
    config.reload = function (callback, skipLoader) {
        config.load(callback, skipLoader);
    };

    return config;

}());


(function() {

    function isLandingPage() {
        var path = document.location.pathname;
        return (path.indexOf('overview.html') > 0 || path.indexOf('company/index.html') > 0);
    }

    window.isUseQuickLink = function() {
        var isFaxTier = RC.Config.isFaxTier,
            isUserType = RC.utils.Extension.isUserType(RC.Config.extensionType),
            isSingleMailbox = RC.Config.isSingleMailbox;

        return !isFaxTier && isUserType && !isSingleMailbox;
    };


    RC.Bootstrap = RC.extend(RC.utils.Observable, {
        constructor: function(config) {

            config = config || {};

            var dndClickable = config.dndClickable;

            var sysPopup = {
                showedPopups: [],
                show: function(fn){
                    var self = this;
                    fn.markAsShowed = function(str){
                        self.showedPopups.push(str || 'sys_popup');
                    };

                    return fn;
                }
            };

            config.loadWizards = RC.isDefined(config.loadWizards) ? config.loadWizards : true;
            config.loadTrackUtils = RC.isDefined(config.loadTrackUtils) ? config.loadTrackUtils : true;
            config.loadPageComponents = RC.isDefined(config.loadPageComponents) ? config.loadPageComponents : true;
            config.loadOnlyConfig = RC.isDefined(config.loadOnlyConfig) ? config.loadOnlyConfig : false;

            config.loadPageComponentMenu = RC.isDefined(config.loadPageComponentMenu) ? config.loadPageComponentMenu : true;
            config.loadPageComponentFCC = RC.isDefined(config.loadPageComponentFCC) ? config.loadPageComponentFCC : true;
            config.loadPageComponentDND = RC.isDefined(config.loadPageComponentDND) ? config.loadPageComponentDND : true;
            config.loadPageComponentNotifications = RC.isDefined(config.loadPageComponentNotifications) ? config.loadPageComponentNotifications : true;
            config.loadPageComponentFaxOut = RC.isDefined(config.loadPageComponentFaxOut) ? config.loadPageComponentFaxOut : true;
            config.loadPageComponentLogout = RC.isDefined(config.loadPageComponentLogout) ? config.loadPageComponentLogout : true;
            config.loadPageComponentExtension = RC.isDefined(config.loadPageComponentExtension) ? config.loadPageComponentExtension : true;

            config.loadPageComponentRingOut = RC.isDefined(config.loadPageComponentRingOut) ? config.loadPageComponentRingOut : true;

            config.loadPageComponentAppearance = RC.isDefined(config.loadPageComponentAppearance) ? config.loadPageComponentAppearance : true;
            config.loadPageComponentFooter = RC.isDefined(config.loadPageComponentFooter) ? config.loadPageComponentFooter : true;
            config.loadPageComponentSignupLink = RC.isDefined(config.loadPageComponentSignupLink) ? config.loadPageComponentSignupLink : true;
            config.loadPageComponentHelpLink = RC.isDefined(config.loadPageComponentHelpLink) ? config.loadPageComponentHelpLink : true;
            config.loadPageComponentFlashPlayer = RC.isDefined(config.loadPageComponentFlashPlayer) ? config.loadPageComponentFlashPlayer : true;

            if (config.loadOnlyConfig) {
                config.loadWizards = false;
                config.loadPageComponents = false;
                config.loadTrackUtils = true;
            }

            RC.Bootstrap.superclass.constructor.call(this, {});

            // global methods for backward compatibility
            window.showUpgradeServiceDialog = this.upgradeDialog;
            window.logout = this.logout;

            var self = this;
            var $do = new RC.data.AsyncContext();
            var payNowDiv = false;

            var notification = new RC.utils.Notification();

            $do(loadConfig); // After that action RC.Config existence is guaranteed

            $do.$if(function () {
                return !!config.setUIMode;
            })(setUImode);

            function isWebPhoneEnabled() {
                return RC.Config.isWebPhoneEnabled;
            }

            if (!config.isLoginPage) {
                $do.$if(isWebPhoneEnabled)(loadRequireJS);
                $do.$if(isWebPhoneEnabled)(setupPlatform);

                $do(loadEventBus, loadWidgetEngine);
            }

            $do(initDateCurrencyFormatters);

            if (config.loadTrackUtils) $do(loadTrackUtils);

            if (config.loadPageComponents) $do(loadPageComponents);

            if (config.loadWizards) {
                $do(sysPopup.show(openLanguageConfirm));
                $do(sysPopup.show(expressSetup));
                $do(sysPopup.show(transitionWizard));
                $do(sysPopup.show(payNow));
                $do(sysPopup.show(security));
                $do(sysPopup.show(upgrade));
                $do(sysPopup.show(e911registration));
                // SWT-1029
//                $do(sysPopup.show(changePassNumeric));
            }

            $do(routeRequest);

            $do.$if(isLandingPage)(showAnnouncementPopups);

            if (config.loadPageComponentFlashPlayer) $do(validateFlashPlayer);

            self.addDisposableListener(self.events.completed);
            $do(completed);
            $do.$if(function () {
                return !!config.enableSessionTimeout;
            })(initSessionTimeoutTimer);

            function setUImode(cb) {
                var additionalMenuContent =
                    '<div id="btnFaxOut-placeholder" class="x-header-hidden"></div>' +
                    '<div id="btnRingOut-placeholder" class="x-header-hidden"></div>' +
                    '<div id="btnFcc-placeholder" class="x-header-hidden"></div>';

                if (RC.Config.userSeparationUIEnabled) {
                    $('mainPageOuterWrap').addClass('separated-ui');

                    $$('#main-menu .additional-menu-container').set('html', additionalMenuContent);

                    $('headerControls').innerHTML = [
                        '<div id="uiModeSwitcher" class="x-header-hidden"></div>',

                        '<div id="headerDND" class="x-header-hidden"></div>',
                        '<div id="headerExt"></div>',

                            '<div id="headerHelp">'
                            + '<a class="GetHelp header-arrow" title="Launch help site and contact Support. Control Feature Tips.">'
                            + RC.Lang.Common.HELP
                            + '</a>'
                            + '</div>',

                        RC.Config.isPartnerSSOLogin ? '' : '<div id="headerDelimiter"> | </div>',
                        '<div id="headerLogout"></div>',
                        '<div id="headerAppearance" class="x-header-hidden"></div>'
                    ].join('');
                } else {
                    $$('#mainTableTD .additional-menu-container').set('html', additionalMenuContent);

                    $('headerControls').innerHTML = [
                        '<div id="headerExt"></div>',
                        '<div id="headerLogout"></div>',
                        '<div id="headerHelp">\
                            <a class="GetHelp header-arrow" title="Launch help site and contact Support. Control Feature Tips.">Get Help</a>\
                        </div>',
                        '<div id="headerNotification" class="x-header-hidden"></div>',
                        '<div id="headerDND" class="x-header-hidden"></div>',
                        '<div id="headerAppearance" class="x-header-hidden"></div>'
                    ].join('');
                }

                cb();
            }

            function showAnnouncementPopups(cb){
                if (sysPopup.showedPopups.length) { // sys popups are showed, do not show announcements
                    cb();
                } else {
                    RC.ComponentMgr.load('inproductMessageUtils.js', function() {
                        RC.UI.InProductMessageUtils.show(cb);
                    });
                }
            }

            function loadRequireJS(cb) {
                RC.ComponentMgr.load('../bower_components/requirejs/require.js', function() {
                    RC.ComponentMgr.load('widgets/requireConfig.js', function() {
                        RC.Console.log('RC.Bootstrap: Loaded RequireJS', requirejs.s.contexts._.config);
                        cb();
                    }, true);
                }, true);
            }

            function loadEventBus(cb) {
                RC.ComponentMgr.load('eventBus.js', cb);
            }

            function loadWidgetEngine(cb) {
                RC.ComponentMgr.load('widgets.js', cb);
            }

            function loadConfig(cb) {
                RC.Console.log('RC.Bootstrap: loadConfig()');
                RC.Config.load(function() {
                    RC.Config.brandDisplayName = RC.Lang.Common.SERVICE_PLAN_ID[RC.Config.brandId] || RC.Config.brandDisplayName;
                    RC.Config.shortBrandName = RC.Lang.Common.SHORT_SERVICE_PLAN_ID[RC.Config.brandId] || RC.Config.shortBrandName;
                    RC.Config.displayName = RC.Config.brandDisplayName;
                    RC.Config.creditCardName = RC.Lang.Common.CREDIT_CARD_NAME || RC.Config.creditCardName;


                    //INT-1823 Remove this hack after server side translation will be ready
                    if (RC.Config.salesRepresentativeNumber) {
                        RC.Config.salesRepresentativeNumber = RC.Config.salesRepresentativeNumber.replace(/and/,  RC.Lang.Common.AND_WORD);
                    }
                    if (RC.Config.salesSupportNumbers) {
                        RC.Config.salesSupportNumbers = RC.Config.salesSupportNumbers.replace(/and/,  RC.Lang.Common.AND_WORD);
                    }
                    cb();
                });
            }

            function setupPlatform(cb) {
                RC.Console.log('RC.Bootstrap: setupPlatform()');

                require(['RCSDK'], function(RCSDK) {
                    window.RCSDK = RCSDK || {disabled: true};

                    if (window.RCSDK.disabled) {
                        cb();
                        return false;
                    }

                    RC.Console.log('RC.Bootstrap: Loaded RCSDK version:', RCSDK.version);

                    RCSDK.core.Log.disableAll();
                    RCSDK.core.Log.logDebug = false;

                    var platform = RCSDK.core.Platform.getInstance(),
                        visibility = new RCSDK.core.PageVisibility();

                    platform.server = '/mobile';
                    platform.apiKey = '';
                    platform.forceAuthentication();

                    platform.on([platform.events.accessViolation], function(e) {

                        //if (window.location.href.indexOf('/login/') == -1) self.logout();

                    });

                    platform.on([platform.events.logoutSuccess, platform.events.logoutError], function(e) {

                        //RC.changeLocation('/?s=' + RC.Config.brandId);

                    });

                    /*
                     visibility.on(visibility.events.change, function (visible) {
                     if (visible) platform.isAuthorized();
                     });
                     */

                    cb();

                });

            }

            function initDateCurrencyFormatters(cb) {
                RC.Console.log('RC.Bootstrap: initDateCurrencyFormatters()');
                RC.ComponentMgr.load('common/i18n.js', function() {
                    RC.Common.i18n.configure();
                    cb();
                });
            }

            function loadTrackUtils(cb) {

                RC.Console.log('RC.Bootstrap: loadTrackUtils()');

                RC.ComponentMgr.load('tools/track/trackUtil' + (RC.Config.omnitureEnable ? '' : '_api') + '.js', function() {

                    RC.Transport.setIsCust(RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST ||
                        RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST_FLASH_UI);

                    var isSecure = !(Cookie.read("USE_NON_SECURE_SOCKET") == 1);

                    RC.data.proxy.Socket.host = RC.Config.webSocketAddress;
                    RC.data.proxy.Socket.port = isSecure ? RC.Config.webSocketPortSSL : RC.Config.webSocketPort;
                    RC.data.proxy.Socket.secure = isSecure;

                    cb();

                });

            }

            function openLanguageConfirm(cb){
                //Only show for TELUS end user or none TELUS brand

                var isEndUser = (!RC.Config.partnerSSOUserType || RC.Config.partnerSSOUserType === 'cu') && !RC.Config.isAdminSession;
                if(!isEndUser) {
                    cb();
                    return false;
                }

                var config = RC.Config,
                    currentLocale = RC.utils.Lang.getLocaleFromCookie() ,
                    userLocale = config.userLanguage;

                if(currentLocale && userLocale !== currentLocale ) {
                    showChangeLocaleDlg();
                }else {
                    cb();
                }

                function showChangeLocaleDlg() {
                    new RC.Msg.confirmEx({
                            html: RC.Lang.Common.CONFIRM_LANGUAGE_DIALOG_CONTENT,
                            width: 470,
                            closable: true,
                            title: RC.Lang.Common.ALERT
                        },
                        function(selection){
                            if(selection == 'no'){
                                cancel()
                            }else{
                                changeToLocale()
                            }
                        },
                        RC.Lang.Common.LANGUAGES_SHORT[currentLocale],
                        RC.Lang.Common.LANGUAGES_SHORT[userLocale]
                    );

                    return false;
                }

                function changeToLocale() {
                    var mailBoxId = RC.Config.loggedMailboxId;

                    Wrapper.send("extensions.setRegionalSettings",
                        {
                            mid: mailBoxId,
                            companyLevel: false,
                            textLanguage: currentLocale
                        }, function() {
                            document.location.reload();
                        }, function() {});
                }

                function cancel() {
                    RC.utils.Lang.setLocaleInCookie(userLocale);
                    document.location.reload();
                }
            }

            function expressSetup(cb) {
                var thisFn = arguments.callee;
                RC.Console.log('RC.Bootstrap: expressSetup()');

                RC.ComponentMgr.load('expressSetup.js', function(){
                    var es = new RC.UI.ExpressSetup();

                    es.onSkip(function(){
                        cb();
                    });

                    es.onDone(function(){
                        cb();
                    });

                    es.onReady(function(){
                        thisFn.markAsShowed('express_setup');
                    });

                });

            }

            function changePassNumeric(cb) {
                var thisFn = arguments.callee;
                RC.Console.log('RC.Bootstrap: changePassNumeric()');

                Wrapper.Extensions.hasAlphaNumericPassword(config.mailboxId, function (response) {
                    if (!response.result) {
                        RC.ComponentMgr.load('changePassNumeric.js', function () {
                            var cpn = new RC.UI.ChangePassNumeric();
                            thisFn.markAsShowed('change_pass_numeric');
                            cpn.onDone(function(){
                                cb();
                            });
                        });
                    } else {
                        cb();
                    }
                });
            }

            function transitionWizard(cb) {
                var thisFn = arguments.callee;

                RC.Console.log('RC.Bootstrap: transitionWizard()');

                function isItNotFirstEntry() {
                    return (Cookie.read('RC.UI.Wizard.Transitions'));
                }

                if (!isItNotFirstEntry() && RC.Config.isOldUser && !RC.Config.isAdminSession) {

                    RC.Loader.show({});

                    if (RC.Config.isExternalBilling){

                        RC.Loader.hide();
                        cb();

                    } else {

                        Wrapper.Extensions.getMailboxTransitioningWizardState(function(response) {

                            RC.Loader.hide();

                            if (response.result != 'Completed') {

                                if (RC.Config.isFaxTier) {

                                    RC.ComponentMgr.load('wizards/transitions/faxTransition.js', function() {
                                        var obj = new RC.UI.Wizard.Transitions.FaxTransition();
                                        thisFn.markAsShowed('fax_transition');
                                        obj.addListener('close', cb);
                                    });

                                } else if (!RC.Config.isExternalBilling && !RC.Config.isFaxTier && RC.utils.Extension.isUserType(RC.Config.extensionType)) { //TODO Mobile/Office detection

                                    RC.ComponentMgr.load('wizards/transitions/officeMobileTransition.js', function() {
                                        var obj = new RC.UI.Wizard.Transitions.OfficeMobileTransition();
                                        thisFn.markAsShowed('office_transition');
                                        obj.addListener('close', cb);
                                    });

                                } else cb();

                            } else cb();

                        });
                    }

                } else cb();

                Cookie.write('RC.UI.Wizard.Transitions', 1, {duration: 0.1});

            }

            function payNow(cb) {
                var thisFn = arguments.callee;
                RC.Console.log('RC.UI.Bootstrap: payNow()');

                var isAdmin = RC.Config.isMailboxSystem || RC.Config.isMailboxIsAdmin;
                var isBrandBT = RC.Config.brandId == 7710;
                var isBrandATT = RC.Config.brandId == 3420;

                if (isLandingPage() && !RC.Config.isExternalBilling && isAdmin === true) {
                    (new RC.Ajax).send({
                        cmd: 'billing.getPayNowInfo',
                        useWrapper: true,
                        onSuccess: function (response) {
                            RC.ComponentMgr.load('system/payNow.js', function () {
                                var transactionsLimitReached = response.info.transactionsLimitReached;
                                var showAutoPurchaseBlocked = RC.Config.autoPurchaseBlocked && RC.Config.isMailboxIsAdmin;

                                if (!isBrandBT) {
                                    RC.UI.System.PayNow.showStatusBarWarning(response.info.customerSupportNumber, showAutoPurchaseBlocked, transactionsLimitReached, false);
                                }

                                var isMonthlyBillingFailed = response.info.monthlyBillingFailed;
                                if (isMonthlyBillingFailed && !isBrandATT) {
                                    var cmp = new RC.UI.System.PayNow(response.info);
                                    var win = new RC.Window(cmp.getPanel());
                                    win.show();
                                    thisFn.markAsShowed('pay_now');
                                    win.addListener('close', cb);
                                } else cb();

                            });

                        }
                    });
                } else {
                    if (isBrandATT && RC.Config.callingCreditLimitReached && isAdmin === true) {
                        RC.ComponentMgr.load('system/payNow.js', function () {
                             RC.UI.System.PayNow.showStatusBarWarning(0, false, false, true);
                        });
                    }
                    cb();
                }

            }

            function security(cb) {
                var thisFn = arguments.callee;
                RC.Console.log('RC.Bootstrap: security()');

                if (isLandingPage() && RC.Config.isSetupCompleted && RC.Config.isSecurityNotSet) {

                    RC.ComponentMgr.load('settings/security.js', function() {

                        var cmp = new RC.UI.Settings.Security({
                            mailboxId: RC.Config.loggedMailboxId,
                            isOverview: true
                        });
                        cmp.onReady(function(){
                            var win = cmp.show();
                            thisFn.markAsShowed('security');
                            win.addListener('close', cb);
                        });

                    });

                } else cb();

            }

            function upgrade(cb) {
                var thisFn = arguments.callee;
                RC.Console.log('RC.Bootstrap: upgrade()');

                function only7DaysLeft() {
                    return RC.Config.trialDaysLeft <= 7;
                }

                function trialExpired() {
                    //todo may be need >= ? or RC.Config.isTrial?
                    return RC.Config.trialDaysLeft < 0;
                }

                if ((RC.Config.isFreeTrial || RC.Config.isPaidTrial) && !Cookie.read("isItNotFirstEntry") && !RC.Config.isExternalBilling && RC.Config.isMailboxIsAdmin && (only7DaysLeft() || trialExpired())) {
                    thisFn.markAsShowed('upgrade');
                    self.upgradeDialog({
                        onSuccess: cb
                    });

                } else cb();

                Cookie.write("isItNotFirstEntry", true, {path: '/'});

            }

            function validateFlashPlayer(cb) {
                var mobile = (/iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i.test(navigator.userAgent.toLowerCase()));
                if (RC.Config.loggedMailboxId && !Cookie.read("flashPlayerCheckPerformed") && !mobile) {
                    RC.utils.Flash.validateFlashVersion();
                    Cookie.write("flashPlayerCheckPerformed", true, {path: '/', duration: 0});
                }

                cb();
            }

            function e911registration(cb) {
                var thisFn = arguments.callee;
                RC.Console.log('RC.Bootstrap: e911registration()');

                if (isLandingPage() && !RC.Config.isAdminSession) {

                    RC.ComponentMgr.load("wizards/e911registration.js", function() {
                        var cmp = new RC.UI.Wizard.E911Registration();
                        cmp.onDone(cb);

                        cmp.onShow(function(){
                            thisFn.markAsShowed('e911_registration');
                        });

                        cmp.onCancel(cb);
                        cmp.onSkip(cb);
                    });

                } else cb();

            }

            function routeRequest(cb) {

                RC.Console.log('RC.Bootstrap: routeRequest()');

                if (payNowDiv) RC.panel.Manager.display(payNowDiv);

                // Here we have loaded the app, explicitly calling router
                RC.Router.createSinglePage(function () {});

                RC.Router.run();

                cb();

            }

            function initSessionTimeoutTimer(){
                RC.ComponentMgr.batchLoad(["system/sessionTimer.js","countdownPopup.js"], function(){

                    var timeout = RC.Config.timeoutValue;
                    //15 minut for admin session ignoring account level settings
                    if (RC.Config.isAdminSession === true) {
                        timeout = 15;
                    }
                    RC.UI.System.Timeout.sessionTimer = new RC.UI.System.Timeout.SessionTimerManager({
                        dom: document,
                        timeoutValue: timeout
                    });

                    //if TELUS or BAA or AdminSession ==> remove autologin cookies
                    RC.UI.System.Timeout.correctResetAutoLogin();

                    if (RC.UI.System.Timeout.canStartTimer()) {
                        RC.UI.System.Timeout.sessionTimer.start();
                    }
                });
            }

            function revealElement(el) {
                if (!el) return;
                el.removeClass('x-header-hidden');
            }

            function loadPageComponents(callback) {

                RC.Console.log('RC.Bootstrap: pageComponents()');

                function getSwitcher(cb) {
                    var div = $('main-menu-wrapper');
                    if (!div) return cb();

                    RC.ComponentMgr.load("system/menu.js", function() {
                        RC.ComponentMgr.load('system/switchUI.js', function () {
                            var switcher = new RC.UI.Switcher({
                                containerId: 'uiModeSwitcher'
                            });

                            switcher.build(div);
                            revealElement(div);
                            cb();
                        });
                    });
                }

                function getMenu(cb) {
                    var div = $('main-menu-wrapper');
                    if (!div) return cb();

                    RC.ComponentMgr.load("system/menu.js", function() {
                        (new RC.UI.Menu.MenuClass({})).build().display('main-menu-wrapper');
                        revealElement(div);
                        cb();
                    });
                }

                function getFooter(cb) {
                    var div = $('legal');
                    if (!div) return cb();

                    RC.ComponentMgr.load('system/footer.js', function() {

                        new RC.UI.System.Footer().createLegal(RC.Lang.Common.LEGAL, {
                            legalInfoPage: RC.Config.legalInfoPage,
                            tosInfoPage: RC.Config.tosInfoPage,
                            eulaInfoPage: RC.Config.eulaInfoPage,
                            termOfUseInfoPage: RC.Config.termOfUseInfoPage
                        }, 'legal');

                        cb();
                    });
                }

                function foldIcon(canvas) {
                    if (RC.Config.userSeparationUIEnabled) {
                        canvas.title = canvas.innerHTML;
                        canvas.innerHTML = '';
                    }

                    return canvas;
                }

                function getFCC(cb) {
                    var div = $('btnFcc-placeholder');
                    if (!div) return cb();

                    RC.ComponentMgr.load('fcc/fcc.js', function() {
                        var fcc = new RC.UI.Fcc();

                        foldIcon(fcc.getCanvas()).inject(div);
                        revealElement(div);

                        cb();
                    });

                }

                function getAppearance() {

                    var div = document.getElement('#headerAppearance');
                    var url = RC.Config.appearanceLogoURL;
                    var src = RC.Config.appearanceLogoPath;

                    if (!div) return;

                    if (!url) {
                        div.set('html', '<img src="' + RC.getSkinnedRCLibXImageUrl('img/dot.gif') + '" alt="">');
                    } else {
                        div.set('html', '<a href="' + url + '" target="blank"><img src="' + RC.getSkinnedRCLibXImageUrl('img/dot.gif') + '" alt=""></a>');
                    }

                    if (src) {
                        div.setStyles({visibility: 'hidden'});
                        revealElement(div);
                        var img = div.getElement('img');

                        function onReady() {

                            var size = img.getSize();

                            img.setStyle(size.x / size.y > 136 / 34 ? 'width' : 'height', '100%');
                            size = img.getSize();
                            div.setStyles({width: size.x, height: size.y});
                            div.setStyles({visibility: 'visible'});
                        }

                        img.addEvent('load', onReady);
                        img.set('src', src);

                        if (!RC.isEmpty(img.get('complete'))) {
                            img.fireEvent('load');
                        }

                    }

                }

                function getHelpLink() {

                    var helperLink = $('headerHelp');

                    if (helperLink != null) {
                        var hasFeatureTip = false;
                        var helpLink = helperLink.getElement('.GetHelp');
                        helpLink.innerHTML = RC.Lang.Common.GETHELP_NAME;
                        if (!RC.Config.isFaxTier && RC.Config.isUserExtension) {
                            hasFeatureTip = true;
                            helpLink.setAttribute('title', RC.Lang.Common.GETHELP_TITLE);
                        } else {
                            hasFeatureTip = false;
                            helpLink.removeAttribute('title');
                        }
                        RC.UI.HelperMenuPicker.render({link: helperLink, plainLink: !hasFeatureTip});
                    }

                }

                function getSignupLink() {
                    var link = $('login-signup-link');
                    if (link != null) {
                        link.href = RC.Config.signupUrl;
                    }
                }

                function getExtension() {
                    var div = $('headerExt');
                    if(!div) {
                        return;
                    }

                    if (!RC.Config.userSeparationUIEnabled) {
                        if (RC.Config.isSingleMailbox == true || RC.Config.isFaxTier == true) {
                            div.innerHTML = RC.UI.Message(RC.Lang.Common.WELCOME_WITHOUT_EXT, RC.Config.trimmedFirstName, RC.Config.extension);
                        } else {
                            div.innerHTML = RC.UI.Message(RC.Lang.Common.WELCOME_WITH_EXT, RC.Config.trimmedFirstName, RC.Config.extension, RC.Config.loggedMailboxPin);
                        }
                    } else {
                        if (RC.Config.isSingleMailbox == true || RC.Config.isFaxTier == true) {
                            div.innerHTML = RC.UI.Message(RC.Lang.Common.SIMPLE_WELCOME_WITHOUT_EXT, RC.Config.trimmedFirstName, RC.Config.extension);
                        } else {
                            div.innerHTML = RC.UI.Message(RC.Lang.Common.SIMPLE_WELCOME_WITH_EXT, RC.Config.trimmedFirstName, RC.Config.extension, RC.Config.loggedMailboxPin);
                        }
                    }
                }

                function getLoginOut() {
                    var div = $('headerLogout');
                    if(!div) return;

                    if(!RC.Config.isPartnerSSOLogin || !RC.isEmpty(RC.Config.partnerSSOBackUrl)) {
                        var extraClassSSOLogin = 'back-to-my-account' + (RC.Config.isAdminSession ? ' x-hidden' : '');
                        var logoutClass = !RC.Config.isPartnerSSOLogin ? 'LogOut header-arrow': extraClassSSOLogin;
                        new Element('a', {
                            'href': '#',
                            'html': RC.Lang.Common.LOGOUT,
                            'class': logoutClass,
                            'events': {
                                'click': function (e) {
                                    e.stop();
                                    self.logout();
                                }
                            }
                        }).inject(div);

                        RC.Config.isPartnerSSOLogin && div.addClass('header-SSOBackToMyAccount');
                    }
                }

                function getDND() {

                    var div = $('headerDND');
                    if (!div) return;

                    new Element('span', {
                        id: 'btnDND',
                        html: '',
                        title: RC.Lang.Common.DND_TIP
                    }).inject(div, 'top');

                    var dndStatusPicker = new RC.utils.DNDStatusPicker({
                        id: 'dndComponent',
                        containerId: 'btnDND',
                        width: 180,
                        clickable: dndClickable,
                        isUserSeparatedUI: RC.Config.userSeparationUIEnabled
                    });

                    dndStatusPicker.render();
                    revealElement(div);

                }

                function getNotifications() {
                    return false;

                    var div = $('headerNotification');
                    if (!div) return;

                    new Element('span', {
                        id: 'btnNotification',
                        html: '',
                        title: RC.Lang.Common.DESKTOP_NOTIFICATIONS_TITLE
                    }).inject(div, 'top');

                    if(notification.isSupported()) {
                        notification.renderButton({
                            id: 'notificationComponent',
                            containerId: 'btnNotification'
                        });
                        revealElement(div);
                    }
                }

                function getFaxOut() {

                    var div = $('btnFaxOut-placeholder');
                    if (!div) return;

                    var link = foldIcon(new Element('a', {
                        id: 'btnFaxOut',
                        html: RC.Lang.Common.FAX_OUT
                    })).inject(div);

                    $('btnFaxOut').addEvent('click', function(e) {
                        e.stop();
                        RC.Loader.show({});
                        RC.ComponentMgr.load('cloudFax/cloudFax.js', function() {
                            var faxOut = new RC.UI.CloudFax();
                            faxOut.onReady(function() {
                                var win = faxOut.getWindow();
                                win.show();
                                RC.Loader.hide();
                            });
                        });
                    });
                    revealElement(div);

                }


                function getOldRingout(cb) {
                    RC.RingOutModule = {
                        windowOpened: false,
                        ready: false,
                        loaded: false,
                        showRingOut: function (options) {
                            if (RC.RingOutModule.ringOut == undefined) {
                                RC.RingOutModule.ringOut = new RC.UI.RingOut();
                                RC.RingOutModule.ringOut.onReady(function () {
                                    RC.Loader.hide();
                                    init();
                                });
                                RC.RingOutModule.ringOut.onClose(function () {
                                    RC.RingOutModule.windowOpened = false;
                                });
                            } else {
                                RC.Loader.hide();
                                init();
                            }

                            function init() {
                                if (!RC.RingOutModule.windowOpened) {
                                    RC.RingOutModule.window = RC.RingOutModule.ringOut.getWindow();
                                    RC.RingOutModule.window.show();
                                    RC.RingOutModule.windowOpened = true;
                                }
                                RC.RingOutModule.ringOut.fillData(options);
                            }

                            RC.getOmniLog().logPageView("RingOut");
                        }
                    };

                    var div = $('btnRingOut-placeholder');
                    if (!div) return;

                    var link = foldIcon(new Element('a', {
                        id: 'btnRingOut',
                        html: RC.Lang.Common.RING_OUT
                    })).inject(div);

                    $('btnRingOut').addEvent('click', function(e) {
                        e.stop();
                        openROdialog({});
                    });
                    revealElement(div);

                    if (RC.Config.mainNumber !== undefined) {
                        RC.ComponentMgr.load('ringOut.js', function () {
                            RC.RingOutModule.ready = true;
                        });
                        cb();
                    } else {
                        cb();
                    }

                }

                function getRingOut(permissions, cb) {
                    RC.RingOutWidget = {
                        widget: undefined,
                        win: undefined,
                        visible: false,
                        show: function(options) {
                            if(this.widget) {
                                if(!this.visible) {
                                    this.widget.update();
                                }
                                if(options.number) {
                                    this.widget.setTargetNumber(options.number);
                                }
                                RC.RingOutWidget.win.displayWin(true, true, true);
                                this.widget.start();
                                this.visible = true;
                            }
                        },
                        hide: function() {
                            $("ringOutWindow").style.display = 'none';
                            this.visible = false;
                        }
                    };

                    var widgetConfig = {
                        id: 'webPhone',
                        browserSupport: (function() {
                            var val = false;
                            if (Browser.name === 'chrome' || (Browser.name === 'firefox' && Browser.version > 31)) {
                                val = true;
                            }
                            return val;
                        }()),
                        eventBus: RC.EventBus,
                        isInternationalCallingAllowed: RC.Config.isInternationalDialingEnabled && permissions.internationalEnabled,
                        domBuilder: {
                            build: function(element) {

                                switch(element.name) {
                                    case "incomingCallWindow":
                                        var div = document.createElement('div');
                                        div.innerHTML = element.html;
                                        document.body.appendChild(div);
                                        break;
                                    case "webRTCIndicator":
                                        var roButton = $("btnRingOut");
                                        roButton.innerHTML += element.html;
                                        break;
                                }

                            }
                        }
                    };

                    var div = $('btnRingOut-placeholder');
                    if (!div) return;

                    var link = foldIcon(new Element('a', {
                        id: 'btnRingOut',
                        html: RC.Lang.Common.RING_OUT
                    })).inject(div);

                    $('btnRingOut').addEvent('click', function(e) {
                        e.stop();
                        if (RC.RingOutWidget.win) {
                            RC.Console.log('RingOut widget shown');
                            RC.RingOutWidget.show({});
                        }

                    });

                    revealElement(div);

                    RC.EventBus.subscribe('webPhone-incomingCall', function(params) {
                        if (RC.RingOutWidget.win) {
                            RC.RingOutWidget.win.setTitle(RC.Lang.Common.INCOMING_CALL);
                            RC.RingOutWidget.show({});
                        }
                        notification.show({
                            uid: params.uid,
                            title: RC.Lang.Common.INCOMING_CALL,
                            body: (params.contact.name !== undefined)
                                ? (truncate(params.contact.name, 25) + "\n" + params.contact.number)
                                : (params.contact.number),
                            icon: RC.getSkinnedRCLibXImageUrl('img/common/RC-icon-notif.png')
                        });
                    });

                    RC.EventBus.subscribe('webPhone-callStarted', resetRingoutTitle);
                    RC.EventBus.subscribe('webPhone-callEnded', resetRingoutTitle);
                    RC.EventBus.subscribe('ringOut-modeSwitched', resetRingoutTitle);

                    RC.EventBus.subscribe('webPhone-callStarted', hideNotification);
                    RC.EventBus.subscribe('webPhone-callEnded', hideNotification);

                    function hideNotification(params) {
                        if (params && params.uid) {
                            notification.hide(params.uid);
                        }
                    }

                    function resetRingoutTitle() {
                        var win = RC.RingOutWidget.win;
                        var widget = RC.RingOutWidget.widget;

                        if (!win || !widget) {
                            return;
                        }
                        win.setTitle(widget.isWebPhoneModeOn() ? RC.Lang.Common.WEB_PHONE : RC.Lang.Common.RING_OUT);
                    }

                    RC.Widgets.load("ringOut", widgetConfig, function (widget) {

                        RC.Console.log('RingOut widget loaded');

                        RC.RingOutWidget.widget = widget;

                        RC.RingOutWidget.win = new RC.Window({
                            id: 'ringOutWindow',
                            width: 250,
                            modal: false,
                            draggable: true,
                            extraBodyStyle: 'padding: 0',
                            title: RC.Lang.Common.RING_OUT,
                            closable: true,
                            items: [
                                {
                                    xtype: 'div',
                                    html: widget.getView()
                                }
                            ],
                            buttons: [
                            ],
                            listeners: {
                                'show': function () {
                                },
                                'render': function () {
                                },
                                'destroy': function () {
                                }
                            },
                            onClose: function () {

                                /*if (widget.mode == 'WebPhone') { // TOdO: use a constant instead a direct value 
                                    var inProgress = widget.controller.callController.callController.checkProgressState();
                                    console.log(inProgress);
                                }*/
                                

                                RC.RingOutWidget.hide();
                                widget.reset();
                                return false;
                            }
                        });

                        RC.RingOutWidget.win.show();
                        RC.RingOutWidget.win.displayWin(false, true, true);

                        widget.eventBus.subscribe('webPhone-unsupported', function() {

                            var browserName = Browser.name;
                            if (browserName == 'ie') {
                                browserName = 'Internet Explorer';
                            } else {
                                browserName = browserName.charAt(0).toUpperCase() + browserName.slice(1);
                            }

                            var msg = RC.UI.Message(RC.Lang.Common.WEB_PHONE_UNSUPPORTED, [browserName, Browser.version].join(' '));
                            RC.Msg.alert(RC.Lang.Common.ALERT, msg, null, true);
                        });

                        widget.eventBus.subscribe('webPhone-userMediaRequestDenied', function() {
                            RC.Msg.alert(RC.Lang.Common.ALERT, RC.Lang.Common.WEB_PHONE_USER_MEDIA_DENIED, null, true);
                        });

                        var storage = (function() {
                            function dummy() {}
                            return {
                                setItem: function(name, val) {
                                    window.localStorage ? window.localStorage.setItem(name, JSON.stringify(val)) : dummy();
                                },
                                getItem: function(name) {
                                    var val;
                                    val = window.localStorage ? window.localStorage.getItem(name) : null;
                                    return JSON.parse(val);
                                }
                            };
                        }())

                        var ringoutSettings = storage.getItem('ringoutSettings') || {},
                            mid = RC.Config.loggedMailboxId;

                        widget.setMode(ringoutSettings[mid] && ringoutSettings[mid].mode, true);

                        widget.eventBus.subscribe('ringOut-modeSwitched', function(mode) {
                            if (!ringoutSettings[mid]) {
                                ringoutSettings[mid] = {};
                            }
                            ringoutSettings[mid].mode = mode;
                            storage.setItem('ringoutSettings', ringoutSettings);
                        });

                        //widget.setMode(Cookie.read('ringOut-mode'));

                        /**/

                        // TODO: REFACTOR RINGOUT LOADING!
                        var mid = RC.Config.loggedMailboxId;
                        (new RC.Ajax).send(
                            {
                                cmd: 'extensions.getCallerIdSettings',
                                useWrapper: true,
                                params: { mid: mid },
                                onSuccess: function(response) {

                                    var cid = response.callerIdsFormatted.Conference;
                                    if (cid === null) {
                                        cid = (response.callerIds.Conference === 'clidBlocked')
                                            ? '[blocked]'
                                            : response.mailboxCallerIds.mainNumber.number;
                                    }

                                    widget.callerId = cid;
                                },
                                onError: function() {

                                }
                            });



                    }, function() {

                    }, {
                        brand: RC.Config.brandId
                    });


                    RC.EventBus.subscribe('ringOut-showFullCallLog', function() {
                        var cl = document.querySelectorAll(".x-menu-item.x-follow-link[href='/settings/calls.html']");
                        if(cl.length > 0) {
                            cl[0].click();
                        }
                    });


                    cb();


                }


                //TODO remove
                RC.Config.isNotificationsAvailable = true;

                // Sync components
                if (config.loadPageComponentDND && RC.Config.isDNDAvailable) getDND();
                if (config.loadPageComponentNotifications && RC.Config.isNotificationsAvailable) getNotifications();
                if (config.loadPageComponentFaxOut && RC.Config.showFaxOut) getFaxOut();
                if (config.loadPageComponentAppearance) getAppearance();
                if (config.loadPageComponentSignupLink) getSignupLink();
                if (config.loadPageComponentHelpLink) getHelpLink();
                if (config.loadPageComponentLogout) getLoginOut();
                if (config.loadPageComponentExtension) getExtension();

                // Async components
                var $Q = new RC.data.AsyncContext();

                if (config.loadPageComponentMenu) {
                    if (RC.Config.userSeparationUIEnabled) {
                        $Q(getSwitcher);
                    } else {
                        $Q(getMenu);
                    }
                }

                if (config.loadPageComponentRingOut && RC.Config.showRingOut) {
                    if (RC.Config.isWebPhoneEnabled && !RCSDK.disabled) {
                        $Q(function(cb) {
                            Wrapper.Extensions.getExtensionPermissions({
                                serialize: function() {return {};}
                            }, function(res) {
                                getRingOut(res.permissions, cb);
                            });
                        });
                    } else {
                        $Q(getOldRingout);
                    }
                }

                if (config.loadPageComponentFooter) $Q(getFooter);
                if (config.loadPageComponentFCC && RC.Config.displayFCCInfo) $Q(getFCC);

                $Q(function() {
                    callback();
                })
            }

            function completed(cb){
                self.fireListener(self.events.completed);
                cb();
            }

        },
        upgradeDialog: function(conf) {

            conf = conf || {};
            if (RC && RC.Wizard) {
                var win = new RC.Wizard({id: 'wizard'}).getUpgradeServiceWindow(conf);
                win.show();
                win.addListener('close', function() {
                    conf.onSuccess && conf.onSuccess();
                });
            } else {
                RC.changeLocation("/settings/billing.html");
            }

        },
        logout: function() {
            var partnerSSOBackUrl = RC.Config.isPartnerSSOLogin && RC.utils.Common.getTelusLocaleLink(RC.Config.partnerSSOBackUrl);
            RC.changeLocation(partnerSSOBackUrl || '/login/logout.html');
        },
        onCompleted: function (callback) {
            this.addListener(this.events.completed, callback);
        },
        events: {
            'completed': 'completed'
        }
    });

})();


function openROdialog(callDataObj) {
    if(RC.RingOutModule) {
        //Old RingOut
        RC.Loader.show({
            handler: function() {
                RC.RingOutModule.showRingOut(callDataObj);
            }
        });
    } else {
        RC.RingOutWidget.show({number: callDataObj.cid});
    }
}


function openFOdialog(callDataObj) {
    RC.Loader.show({
        handler: function() {
            RC.ComponentMgr.load('cloudFax/cloudFax.js', function() {
                var faxOut = new RC.UI.CloudFax();
                faxOut.onReady(function() {
                    var win = faxOut.getWindow();
                    win.show();
                    faxOut.fillData(callDataObj);
                    RC.Loader.hide();
                });
            }, '', true);
        }
    });
}

function sendToPrintFix(w) {
    w.document.write('Loading...');
}

function sendToPrint(node, beforePrintCallback, additionalCsses) {
    // to do check node
    var cl = node.cloneNode(true);
    cl.style.left = '0px';
    cl.style.top = '0px';
    var p = document.createElement('DIV');
    p.appendChild(cl);

    additionalCsses = additionalCsses || []; // additionalCsses accepts both string and array
    var cssArray = ['desktop/elements'].include(additionalCsses).flatten();
    var version = (RC.Config.version ? "?v=" + RC.Config.version : '');
    var rclibCssLink = RC.UI.Message('<link href="/RCLibX/css/refresh-{0}.css{1}" type="text/css" rel="stylesheet" />', RC.configuration.brandId, version);

    cssArray = cssArray.map(
        function(item) {
            item = RC.ComponentMgr.getBrandedComponentUrl(item + '.css');
            return RC.UI.Message('<link href="' + '../../../{0}{1}" type="text/css" rel="stylesheet" />', item, version);
        }
    );
    cssArray.unshift(rclibCssLink);
    var cssLinks = cssArray.join('');

    var mootoolsLink = '<script type="text/javascript" src="/RCLibX/js/mootools.js' + version + '" ></' + 'script>';
    var winContent = RC.UI.Message('<!DOCTYPE html><html><head>{0}{1}</head><body>{2}</body></html>', cssLinks, mootoolsLink, p.innerHTML);
    var win = window.open('javascript:opener.sendToPrintFix(window);', '_blank', '');
    win.document.open();
    win.document.write(winContent);
    win.document.close();
    var flg = true;
    if (RC.isFunc(beforePrintCallback)) flg = beforePrintCallback(win.document, win);
    if (flg != false) win.print();
}


var msgTypeVoice = 1;
var msgTypeFax = 2;
var msgTypeText = 3;
var msgTypeGreeting = 5;

var previewPanel = null;
var timer_id, starter_timer_id = null;

function previewOpen(msgid, type, ev, g_type, g_default, g_url, playAudio, faxErrorCode) {
    if (type == msgTypeGreeting && !playerAvailable())
        return;
    var eventCopy = {};
    for (var i in ev) {
        eventCopy[i] = ev[i];
    }
    starter_timer_id = setTimeout(function() {
        previewPanel = new PreviewPanel(msgid, type, eventCopy, g_type, g_default, g_url, playAudio, faxErrorCode);
        if (previewPanel != null) previewPanel.loadDocument();
    }, 500);
}

function formatDateTime(receivedDate) {
    var date = RC.utils.Date.toUtc(receivedDate);
    return RC.utils.Date.formatMidDate(date, true) + ' ' + RC.utils.Date.formatTime(date);
}

function previewClose() {
    clearTimeout(starter_timer_id);
    if (previewPanel != null) {
        if ((previewPanel.getMsgType() == msgTypeVoice ||
            previewPanel.getMsgType() == msgTypeGreeting)) {
            if (RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST) {
                try {
                    RC.data.proxy.Socket.stop();
                }
                catch (e) {
                    //connection wasn't established
                }
            } else {
                playerAvailable() && RC.getCmp('MessagePlayer').stop();
            }
        }
        destroyDiv();
    }
}

function playerAvailable() {
    if (RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST) {
        return true;
    } else {
        var messagePlayer = RC.getCmp('MessagePlayer');
        return messagePlayer && messagePlayer.getPlayer();
    }
}

function moveDiv(ev) {
    if (previewPanel != null && previewPanel.getDiv() != null) {
        var cursor = getDivPosition(ev);
        previewPanel.getDiv().style.left = cursor.x + 12;
        previewPanel.getDiv().style.top = cursor.y + 2;
    }
}

function destroyDiv() {
    if (previewPanel != null) {
        var d = document.getElementById("PreviewWin");
        if (d != null)
            document.body.removeChild(d);
        if (timer_id != null)
            window.clearInterval(timer_id);
        previewPanel = null;
    }
}

function getDivPosition(ev) {
    ev = ev || window.event;
    var cursor = {x: 0, y: 0};
    if (ev.pageX || ev.pageY) {
        cursor.x = ev.pageX;
        cursor.y = ev.pageY;
    } else {
        cursor.x = ev.clientX +
            (document.documentElement.scrollLeft ||
                document.body.scrollLeft) -
            document.documentElement.clientLeft;
        cursor.y = ev.clientY +
            (document.documentElement.scrollTop ||
                document.body.scrollTop) -
            document.documentElement.clientTop;
    }
    return cursor;
}

function PreviewPanel(msgid, type, ev, g_type, g_default, g_url, playAudio, faxErrorCode) {
    this._msgid = msgid;
    this._msgtype = type;
    this._msginfo = null;
    this._greettype = g_type;
    this._greetdef = g_default;
    this._greeturl = g_url;
    this._extFile = null;
    this._div = null;
    this._playAudio = playAudio != undefined ? playAudio : true;
    this._faxErrCode = faxErrorCode;

    var self = this;

    this.create = function() {
        this._div = new Element('div', {
            id: 'PreviewWin',
            html: '<img src="' + RC.getSkinnedRCLibXImageUrl('img/panel/loader.gif') + '" alt="" />',
            'class': 'x-recording-preview-window',
            styles: {
                'width': (this._msgtype == msgTypeGreeting ? 230 : 210),
                'z-index': RC.Window.zIndex + 1
            }
        });

        var cursor = getDivPosition(ev);
        this._div.setStyles({
            'left': cursor.x + 12,
            'top': cursor.y + 2
        });
        document.onmousemove = moveDiv;
        document.onclick = previewClose;
        this._div.inject(document.body);
    };

    this.loadDocument = function() {
        var self = this;
        var $do = new RC.data.AsyncContext();
        $do(connect);
        $do(send);

        function connect(cb) {
            RC.Transport.connect(cb);
        }

        function send() {
            RC.Transport.send({
                type: 'getMessageInfo',
                ns: 'messages',
                request: {
                    messageId: self._msgid,
                    type: self._msgtype
                },
                onSuccess: self.onSuccess,
                onError: self.onError
            });
        }
    };

    this.onSuccess = function(result) {
        var renderingFailed = -9;
        if (!result) {
            if (self._div != null)
                self._div.innerHTML = RC.Lang.Common.CANNOT_OPEN_MESSAGE;
            return;
        } else if (result.lengthInBytes == 0) {
            console.info(self._faxErrCode)
            if (self._faxErrCode == renderingFailed) {
                self._div.innerHTML = RC.Lang.Common.CANNOT_RENDER_MESSAGE;
            } else {
                self._div.innerHTML = RC.Lang.Common.CANNOT_OPEN_MESSAGE ;
            }
            return;
        }

        switch(self.getMsgType()) {

            case msgTypeVoice:
                self._msginfo = result;
                self.playMessage();
                break;
            case msgTypeFax:
                if (self._div != null) {
                    if (RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST) {
                        self._greeturl = "data:image/png;base64," + result.subject;
                    }
                    self._div.set('text', '');
                    new Element('div', {
                        'align': 'center',
                        'html': '<img src="' + self._greeturl + '" alt="" border="0" width="140" />',
                        'styles': {
                            'margin': 0,
                            'padding': 0
                        }
                    }).inject(self._div);
                }
                break;
            case msgTypeText:
                self._msginfo = result;
                self.showTextMessage();
                break;
            case msgTypeGreeting:
                self._msginfo = result;
                self.playGreeting();
                break;
        }
    };

    this.onError = function() {
        if (self._div != null)
            self._div.innerHTML = RC.Lang.Common.CANNOT_OPEN_MESSAGE;
    };

    this.showTextMessage = function() {
        var strHtml = "";

        if (this._msginfo != null) {
            strHtml += this._msginfo['subject'] + "<br>";
            if (this._msginfo['name'] != "") {
                strHtml += RC.UI.Message(RC.Lang.Common.SHOW_TEXT_MESSAGE_FROM, this._msginfo['name']);
            }
            strHtml += RC.UI.Message(RC.Lang.Common.SHOW_TEXT_MESSAGE_TEXT,
                formatDateTime(this._msginfo['receivedDate']),
                this._msginfo['length'],
                this._msginfo['type']
            );
            if (this._msginfo['mtext']) {
                strHtml += "<br>" + this._msginfo['mtext'];
            }

            if (this._div != null)
                this._div.innerHTML = strHtml;
        }
    };

    this.playMessage = function() {
        var strHtml = "";

        if (this._msginfo != null) {

            var playAudio = this._playAudio && playerAvailable() && previewPanel != null;

            if (playAudio) {
                strHtml = RC.Lang.Common.PLAY_MESSAGE_PLAYING;
            }

            strHtml += RC.UI.Message(RC.Lang.Common.PLAY_MESSAGE_TEXT,
                this._msginfo['from'],
                this._msginfo['name'] ? RC.UI.Message(RC.Lang.Common.PLAY_MESSAGE_NAME, this._msginfo['name']) : '',
                formatDateTime(this._msginfo['receivedDate']),
                this._msginfo['length']
            );
            if (this._div != null)
                this._div.innerHTML = strHtml;

            if (playAudio) this.playAudio();
        }
    };

    this.playGreeting = function() {
        if (this._msginfo != null) {
            var strHtml = RC.UI.Message(RC.Lang.Common.PLAY_GREETING_TEXT,
                this._msginfo['type'],
                this._msginfo['name'],
                this._msginfo['length']
            );
            if (this._div != null)
                this._div.innerHTML = strHtml;

            this.playAudio();
        }
    };

    this.playAudio = function() {
        if (timer_id != null)
            window.clearInterval(timer_id);
        timer_id = window.setInterval(this.startPlaying, 500);
    };

    this.startPlaying = function() {
        if (timer_id != null)
            window.clearInterval(timer_id);
        if (previewPanel != null && previewPanel._msginfo != null) {
            if (RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST) {
                RC.data.proxy.Socket.play(previewPanel._msgid, RC.Config.loggedMailboxId, previewPanel._msginfo['realExtension']);
            } else {
                playerAvailable() && RC.getCmp('MessagePlayer').openFile(previewPanel._greeturl + '&download=1&file=.wav', true);
            }
        }
    };

    this.stopPlaying = function() {
        clearTimeout(starter_timer_id);
        if (playerAvailable()) {
            if (RC.Config.flashUI == RC.UI.WebOptions.USE_PROTO_CUST) {
                RC.data.proxy.Socket.stop();
            } else {
                playerAvailable() && RC.getCmp('MessagePlayer').stop();
            }
        }
        destroyDiv();
    };

    this.getMsgType = function() {
        return this._msgtype;
    };

    this.getDiv = function() {
        return this._div;
    };

    this.create();
}


/*!
 * Merchant e-Solutions Javascript Tokenization API
 * http://www.merchante-solutions.com
 *
 * V1.0 11/06/2012
 * Copyright 2012 Merchant e-Solutions
 */
var Mes = {
	mod10: function (e) {
        var t, n, r, i, s, o;
        r = !0, i = 0, n = (e + "").split("").reverse();
        for (s = 0, o = n.length; s < o; s++) {
            t = n[s], t = parseInt(t, 10);
            if (r = !r) t *= 2;
            t > 9 && (t -= 9), i += t
        }
        return i % 10 === 0
    },
	tokenize: function(cc, exp, cb, url) {
		var cors = Mes.getCORS(cb, url);

		// Validate CORS compatibility
		if (!cors)
			Mes.complete({'code': 1, 'text': RC.Lang.Common.MES_ERROR.UNSUPPORTED_BROWSER }, cb);
		// Validate Card num with LUHN
		else if(!Mes.valCc(cc))
			Mes.complete({'code': 2, 'text': RC.Lang.Common.MES_ERROR.INVALID_CARD_NUMBER }, cb);
		// Validate expiry date
		else if(!Mes.valExpiry(exp))
			Mes.complete({'code': 3, 'text': RC.Lang.Common.MES_ERROR.INVALID_EXPIRY_DATE }, cb);
		else {
			// CORS Error Handler
			cors.onerror = function() {
				Mes.complete({'code': 6, 'text': RC.Lang.Common.MES_ERROR.TRANSMISSION_ERROR }, cb);
			};
			// CORS Finish Handler
			cors.onload = function() {
				// Validate HTTP Status code (only works with XMLHttpRequest, XDomainRequest goes straight to the error handler when status isn't 200)
				if(typeof cors.status != "undefined" && cors.status !== 200)
					Mes.complete({'code': 5, 'text': RC.UI.Message(RC.Lang.Common.MES_ERROR.HTTP_ERROR, cors.status)}, cb)
				else {
					var json = Mes.parseJSON(cors.responseText);
					// Validate for gateway errors
					if(json['error_code'] != "000")
						Mes.complete({'code': 4, 'text': RC.Lang.Common.MES_ERROR.GATEWAY_ERROR, 'gateway_text': json['auth_response_text'], 'gateway_error': json['error_code'] }, cb);
					else
						Mes.complete({'code': 0, 'text': RC.Lang.Common.MES_ERROR.SUCCESS, 'token': json['transaction_id'] }, cb);
				}
			};
			// Send request
			cors.send("transaction_type=T&card_number="+cc+"&card_exp_date="+exp+"&resp_encoding=json");
		}
	},
	valCc: function(cc) {
		return Mes.mod10(cc) && cc.length != 0;
	},
	valExpiry: function(exp) {
		return exp.length == 4;
	},
	parseJSON: function(json) {
		var result;
		// Last resort for browsers which don't support the JSON object.
		if(typeof JSON !== 'object')
			result = eval("(function(){return "+json+";})()");
		// Prefer in-browser parse, or jQuery, if present.
		else
			result = JSON && JSON.parse(json) || $.parseJSON(json);
		return result;
	},
	getCORS: function(cb, url) {
		// CORS not supported by default.
		var cors = null;
        url = url || "https://api.merchante-solutions.com/mes-api/tridentApi";

		// IE6 reports XmlHttpRequest as undefined, IE7 unfortunatly reports as an object.
		if(typeof XMLHttpRequest != "undefined") {
			cors = new XMLHttpRequest();

			// Prefer XMLHttpRequest (Chrome/Firefox/Opera/Safari/IE10).
			if ("withCredentials" in cors) {
				cors.open("POST", url, true);
				cors.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
				cors.setRequestHeader("x-requested-with", "XMLHttpRequest");
			}
			// Fallback; attempt XDomainRequest (for IE8,9).
			else if (typeof XDomainRequest != "undefined") {
				cors = new XDomainRequest();
				cors.onprogress = function() { };
				cors.ontimeout = function() { };

				// Handle the exception XDomainRequest will throw when opening a request across scheme (SSL to non-SSL or vice versa).
				try {
					cors.open("POST", url);
				}
				catch(e) {
					Mes.complete({'code': 7, 'text': e.message }, cb)
					throw e; // Rethrow to terminate execution
				}
			}
			// CORS Unsupported (IE7).
			else
				cors = null;
		}
		return cors;
	},
	complete: function(rsp, cb) {
		return typeof cb == "function" ? cb(rsp) : void 0;
	}
}

